

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#B1A58E">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="这篇文章全面介绍了C++编程语言的核心概念和高级特性，涵盖了从基础数据类型到复杂内存管理和多线程编程的各个方面。以下是主要内容的简要总结：  1. **C++编译与链接**：详细说明了如何使用g++编译器编译C++代码，包括如何包含头文件、链接库文件以及编译过程的各个阶段。  2. **基本数据类型**：介绍了C++的内置数据类型（如整型、字符型、浮点型、布尔型）和复合类型（如数组、结构体、类、指">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp基础">
<meta property="og:url" content="http://example.com/2025/05/20/cpp/cpp/index.html">
<meta property="og:site_name" content="Xun&#39;s Blog">
<meta property="og:description" content="这篇文章全面介绍了C++编程语言的核心概念和高级特性，涵盖了从基础数据类型到复杂内存管理和多线程编程的各个方面。以下是主要内容的简要总结：  1. **C++编译与链接**：详细说明了如何使用g++编译器编译C++代码，包括如何包含头文件、链接库文件以及编译过程的各个阶段。  2. **基本数据类型**：介绍了C++的内置数据类型（如整型、字符型、浮点型、布尔型）和复合类型（如数组、结构体、类、指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-225032343.7&rm=3">
<meta property="article:published_time" content="2025-05-20T12:00:00.000Z">
<meta property="article:modified_time" content="2025-06-17T15:40:57.858Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-225032343.7&rm=3">
  
  
  
  <title>cpp基础 - Xun&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GEluhFhlvVVyi1wC9RzB0vSk-MdYXbMMI","app_key":"9ng4wvU8n0568liU440awYcT","server_url":"https://proxy.bytewaver.top/proxy/geluhfhl.api.lncldglobal.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/pink-small.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">cpp基础</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-20 20:00" pubdate>
          2025年5月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          38k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          315 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">cpp基础</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p><strong>GPT摘要</strong></p>
<p>这篇文章全面介绍了C++编程语言的核心概念和高级特性，涵盖了从基础数据类型到复杂内存管理和多线程编程的各个方面。以下是主要内容的简要总结：  1. <strong>C++编译与链接</strong>：详细说明了如何使用g++编译器编译C++代码，包括如何包含头文件、链接库文件以及编译过程的各个阶段。  2. <strong>基本数据类型</strong>：介绍了C++的内置数据类型（如整型、字符型、浮点型、布尔型）和复合类型（如数组、结构体、类、指针、引用）。  3. <strong>指针与内存管理</strong>：讨论了指针的使用、内存布局（包括栈、堆、全局&#x2F;静态存储区等）、指针的运算以及常见的内存管理问题。  4. <strong>变量作用域与内存模型</strong>：解释了变量的不同作用域（如全局、局部、命名空间、类作用域）以及内存的不同存储区。  5. <strong>头文件与源文件</strong>：讲解了头文件的作用、如何避免头文件重定义问题，以及如何正确使用内联函数和外部变量。  6. <strong>右值引用与移动语义</strong>：介绍了C++11引入的右值引用和移动语义，如何通过这些特性优化资源管理和减少不必要的拷贝。  7. <strong>异常处理</strong>：讨论了异常处理的基本机制和最佳实践，包括try-catch块、异常类型和标准异常类。  8. <strong>智能指针</strong>：介绍了unique_ptr、shared_ptr和weak_ptr的使用，如何通过智能指针来管理动态内存。  9. <strong>容器与迭代器</strong>：详细介绍了STL容器（如vector、array、set、map等）和迭代器的使用，包括如何遍历和操作容器中的元素。  10. <strong>字符串与正则表达式</strong>：讲解了C++字符串的操作、流的使用以及正则表达式的基本应用。  11. <strong>文件与网络</strong>：介绍了文件流的使用（如读写文件）、网络编程的基础知识以及套接字的使用。  12. <strong>多线程与异步编程</strong>：讨论了C++11引入的多线程支持，包括线程、互斥量、条件变量和异步编程的基本概念。  13. <strong>高级主题</strong>：涵盖了lambda表达式、bind函数、函数对象（仿函数）和std::function的使用，如何通过这些特性来实现更灵活和高效的代码。  这篇文章为C++程序员提供了一个全面的参考，帮助读者从基础概念到高级特性全面掌握C++编程语言。</p>
</blockquote>
<p>g++ src&#x2F;main.cpp src&#x2F;test.cpp -I.&#x2F;include -o program</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ main.cpp -o program \<br>  -I/opt/boost/include \  <span class="hljs-comment"># 告诉编译器去哪里找头文件  </span><br>  -L/opt/boost/lib \      <span class="hljs-comment"># 告诉链接器去哪里找库文件</span><br>  -lboost_filesystem      <span class="hljs-comment"># 告诉链接器要链接哪个库</span><br><br>选项    核心作用    阶段    示例<br>-I    指定头文件搜索路径    预处理/编译    -Iinclude or CPLUS_INCLUDE_PATH<br>-L    指定库文件搜索路径    链接阶段    -L/opt/boost/lib or LIBRARY_PATH<br>-l    指定需要链接的库名称    链接阶段    -lboost_filesystem 不能省略<br><br><br>g++ -E main.cpp -I/opt/boost/include -o main.i<br>g++ -S main.i -o main.s<br>g++ -c main.s -o main.o<br>g++ main.o -L/opt/boost/lib -lboost_filesystem -o program<br></code></pre></td></tr></table></figure>

<p>&#x2F;opt&#x2F;homebrew&#x2F;  指向&#x2F;opt&#x2F;homebrew&#x2F;Cellar&#x2F; 下</p>
<table>
<thead>
<tr>
<th>软件包类型</th>
<th>示例</th>
<th>lib 目录链接</th>
<th>include 目录链接</th>
<th>bin 目录链接</th>
</tr>
</thead>
<tbody><tr>
<td>库</td>
<td>boost, openssl</td>
<td>✅</td>
<td>✅</td>
<td>❌ 或 少量</td>
</tr>
<tr>
<td>命令行工具</td>
<td>wget, curl</td>
<td>❌ 或 少量</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>编程语言</td>
<td>python, node</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>数据库</td>
<td>mysql, postgresql</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><h5 id="1-内置类型（基本类型）"><a href="#1-内置类型（基本类型）" class="headerlink" title="1. 内置类型（基本类型）"></a>1. 内置类型（基本类型）</h5><p>内置类型是C++语言自带的基本数据类型，主要包括以下几种：</p>
<ul>
<li>整型（Integer Types）<ul>
<li><code>int</code>：标准整型，通常为4字节。</li>
<li><code>short</code>：短整型，通常为2字节。</li>
<li><code>long</code>：长整型，通常为4或8字节（取决于平台）。</li>
<li><code>long long</code>：更长的整型，通常为8字节。</li>
<li><code>unsigned</code>：无符号整型，不支持负数。</li>
<li><code>unsigned short</code>、<code>unsigned long</code>、<code>unsigned long long</code>：对应的无符号版本。</li>
</ul>
</li>
<li>字符型（Character Types）<ul>
<li><code>char</code>：字符型，通常为1字节。</li>
<li><code>wchar_t</code>：宽字符型，通常为2或4字节（用于表示Unicode字符）。</li>
<li><code>char16_t</code>、<code>char32_t</code>：用于表示UTF-16和UTF-32编码的字符。</li>
</ul>
</li>
<li>浮点型（Floating Point Types）<ul>
<li><code>float</code>：单精度浮点型，通常为4字节。</li>
<li><code>double</code>：双精度浮点型，通常为8字节。</li>
<li><code>long double</code>：扩展精度浮点型，通常为8字节或16字节（取决于平台）。</li>
</ul>
</li>
<li>布尔型（Boolean Type）<ul>
<li><code>bool</code>：布尔型，表示真（true）或假（false）。</li>
</ul>
</li>
</ul>
<h5 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2. 复合类型"></a>2. 复合类型</h5><p>复合类型是由内置类型或其他复合类型组合而成的类型，主要包括以下几种：</p>
<ul>
<li>数组（Array）<ul>
<li>一组相同类型的数据元素，可以通过索引访问。</li>
</ul>
</li>
<li>结构体（Struct）<ul>
<li>一种用户定义的数据类型，可以包含不同类型的数据成员。</li>
</ul>
</li>
<li>联合体（Union）<ul>
<li>与结构体类似，但所有成员共享同一内存位置，只有一个成员可以在任何给定时间存储值。</li>
</ul>
</li>
<li>枚举（Enum）<ul>
<li>一种用户定义的类型，用于定义一组命名的整型常量。</li>
</ul>
</li>
<li>类（Class）<ul>
<li>C++的面向对象编程特性，允许定义包含数据和成员函数的复杂数据类型。</li>
</ul>
</li>
<li>指针（Pointer）<ul>
<li>指向其他类型的内存地址，可以用来动态分配内存和实现复杂的数据结构。</li>
</ul>
</li>
<li>引用（Reference）<ul>
<li>对现有变量的别名，提供了对变量的另一种访问方式。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">var_func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//整形，4字节</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//ll整形, 8字节</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> lla = <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">//长整型， 4 字节</span><br>    <span class="hljs-type">long</span> la = <span class="hljs-number">1024</span>;<br>    <span class="hljs-comment">//短整型,2 字节</span><br>    <span class="hljs-type">short</span> sa = <span class="hljs-number">200</span>;<br>    <span class="hljs-comment">//带符号字符型,</span><br>    <span class="hljs-comment">//字符型使用时最好指示带符号还是不带符号</span><br>    <span class="hljs-comment">//因为在不同的机器上不指明char符号可能会有问题</span><br>    <span class="hljs-type">signed</span> <span class="hljs-type">char</span> sc = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">//无符号字符型</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uc = <span class="hljs-string">&#x27;m&#x27;</span>;<br>    <span class="hljs-comment">//bool类型</span><br>    <span class="hljs-type">bool</span> bt = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义和声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//只声明a   它在其他地方定义。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a;  <br><br><br><span class="hljs-comment">// 变量定义 会分配内存空间</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 定义并初始化变量 &#x27;a&#x27;</span><br><span class="hljs-type">float</span> b = <span class="hljs-number">20.5</span>; <span class="hljs-comment">// 定义并初始化变量 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>

<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><ul>
<li><strong>32位系统</strong>：所有类型的指针都是 <strong>4字节</strong></li>
<li><strong>64位系统</strong>：所有类型的指针都是 <strong>8字节</strong></li>
<li>指针+1 的偏移量 &#x3D; sizeof(指针指向的类型)</li>
<li><code>*(ptr+x) = ptr[x]</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//访问对象</span><br><span class="hljs-type">int</span> ival = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">//p_int存放着ival的地址，或者说p_int是指向变量ival的指针</span><br><span class="hljs-type">int</span> * p_int = &amp;ival;<br><br><span class="hljs-comment">// 取值 由符号*得到指针p所指向的对象，输出42</span><br>std::cout &lt;&lt; *p_int ;<br><br><span class="hljs-comment">// 赋值</span><br>*p_int = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对指针的引用： int *&amp; b = a; 和引用一样的作用，修改b影响a</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">poinref_func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-comment">// p是一个指针</span><br>    <span class="hljs-type">int</span> *p;<br>    <span class="hljs-comment">// r 是一个对p的引用</span><br>    <span class="hljs-type">int</span> *&amp;r = p;<br>    <span class="hljs-comment">// 令r指向了一个指针p</span><br>    <span class="hljs-comment">//给r赋值为&amp;i,就是p指向了i</span><br>    r = &amp;i;<br>    <span class="hljs-comment">//解引用r得到i,也就是p指向的对象，将i的值修改为0</span><br>    *r = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 空指针  可以用if判断</span><br><span class="hljs-type">int</span> * empty_pointer2 = nullptr;  <span class="hljs-comment">// c98写法   =0</span><br><br><br><span class="hljs-comment">// 万能指针</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">void</span>* ptr = &amp;num;<br><span class="hljs-comment">// 使用前需要类型转换</span><br>*(<span class="hljs-type">double</span> *)ptr<br><span class="hljs-type">int</span>* intPtr = static_cast&lt;<span class="hljs-type">int</span>*&gt;(ptr);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *intPtr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出10</span><br><br><br><span class="hljs-comment">// 数组指针</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *ptr_arr = arr;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ptr_arr is : &quot;</span> &lt;&lt; ptr_arr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-type">int</span> firstElement = *ptr_arr;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;firstElement is &quot;</span> &lt;&lt; firstElement &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 递增指针 递增的大小取决于指针指向了谁</span><br>++ptr_arr; <span class="hljs-comment">// ptr 现在指向 arr[1]  int会大4</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ptr_arr is : &quot;</span> &lt;&lt; ptr_arr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><br>p[x] = *(p + x);<br>&amp;(p[x]) = &amp;(*(p + x)) = p + x;<br><br><br><span class="hljs-comment">// 取地址</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;;<br><span class="hljs-comment">// 地址值相同，但类型不同：</span><br><span class="hljs-type">char</span>* p1 = arr;          <span class="hljs-comment">// 指向 arr[0]，类型是 char*</span><br><span class="hljs-type">char</span> (*p2)[<span class="hljs-number">5</span>] = &amp;arr;    <span class="hljs-comment">// 指向整个数组，类型是 char (*)[5]</span><br><span class="hljs-comment">// 验证指针运算差异：</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-type">void</span>*)(arr + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 地址 +1 字节</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-type">void</span>*)(&amp;arr + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 地址 +5 字节</span><br></code></pre></td></tr></table></figure>

<ol>
<li>支持加减操作</li>
<li>解引用时不能是空指针</li>
<li>解引用时读取的字节数量，以及++的偏移量取决于指向的数据所占的空间</li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol>
<li><strong>全局作用域</strong>：在函数外部声明的变量具有全局作用域。它们可以在程序的任何地方被访问，但通常建议在需要时才使用全局变量，因为它们可能导致代码难以理解和维护。</li>
<li><strong>局部作用域</strong>：在函数内部、代码块（如<code>if</code>语句、<code>for</code>循环等）内部声明的变量具有局部作用域。它们只能在声明它们的代码块内被访问。一旦离开该代码块，这些变量就不再可见。</li>
<li><strong>命名空间作用域</strong>：在命名空间中声明的变量（实际上是实体，如变量、函数等）具有命名空间作用域。它们只能在相应的命名空间内被直接访问，但可以通过使用命名空间的名称作为前缀来从外部访问。 <code>std</code> </li>
<li><strong>类作用域</strong>：在类内部声明的成员变量和成员函数具有类作用域。成员变量和成员函数可以通过类的对象来访问，或者在某些情况下（如静态成员）可以通过类名直接访问。</li>
<li><strong>块作用域</strong>：这是局部作用域的一个特例，指的是由大括号<code>&#123;&#125;</code>包围的代码块内部声明的变量。这些变量只能在该代码块内被访问。 <strong>并发编程中</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 全局作用域 (Global scope)</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 命名空间作用域 (Namespace scope)</span><br><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-type">int</span> namespaceVar = <span class="hljs-number">200</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNamespaceVar</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Namespace variable: &quot;</span> &lt;&lt; namespaceVar &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 类作用域 (Class scope)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类成员变量 (Class member variable)</span><br>    <span class="hljs-type">int</span> classVar = <span class="hljs-number">300</span>;<br><br>    <span class="hljs-comment">// 静态类成员 (Static class member)</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticClassVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printClassVars</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 局部作用域 (Local scope)</span><br>        <span class="hljs-type">int</span> localVar = <span class="hljs-number">400</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Class variable: &quot;</span> &lt;&lt; classVar &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Global variable inside class: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员</span><br><span class="hljs-type">int</span> MyClass::staticClassVar = <span class="hljs-number">500</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 使用命名空间变量</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Namespace variable: &quot;</span> &lt;&lt; MyNamespace::namespaceVar &lt;&lt; endl;<br>    MyNamespace::<span class="hljs-built_in">printNamespaceVar</span>();<br><br>    <span class="hljs-comment">// 块作用域 (Block scope)</span><br>    &#123;<br>        <span class="hljs-type">int</span> blockVar = <span class="hljs-number">600</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Block variable: &quot;</span> &lt;&lt; blockVar &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// blockVar 在这里不可访问</span><br><br>    <span class="hljs-comment">// 创建类实例</span><br>    MyClass obj;<br>    obj.<span class="hljs-built_in">printClassVars</span>();<br><br>    <span class="hljs-comment">// 访问静态类成员</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Static class variable: &quot;</span> &lt;&lt; MyClass::staticClassVar &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 局部作用域示例</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// i 是循环作用域的变量</span><br>        <span class="hljs-type">int</span> loopVar = <span class="hljs-number">700</span>;  <span class="hljs-comment">// loopVar 只在循环内有效</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Loop variable: &quot;</span> &lt;&lt; loopVar &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// loopVar 在这里不可访问</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h4><ol>
<li>代码区（Code Segment&#x2F;Text Segment）：<ul>
<li>存储程序执行代码（即机器指令）的内存区域。这部分内存是共享的，只读的，且在程序执行期间不会改变。</li>
<li>举例说明：当你编译一个C++程序时，所有的函数定义、控制结构等都会被转换成机器指令，并存储在代码区。</li>
</ul>
</li>
<li>全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）：<ul>
<li>存储全局变量和静态变量的内存区域。这些变量在程序的<strong>整个运行期间</strong>都存在，但它们的可见性和生命周期取决于声明它们的作用域。</li>
<li>举例说明：全局变量（在函数外部声明的变量）和静态变量（使用<code>static</code>关键字声明的变量，无论是在函数内部还是外部）都会存储在这个区域。</li>
</ul>
</li>
<li>栈区（Stack Segment）：<ul>
<li>存储局部变量、函数参数、返回地址等的内存区域。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用和自动变量。</li>
<li>举例说明：在函数内部声明的变量（不包括静态变量）通常存储在栈上。当函数被调用时，其参数和局部变量会被推入栈中；当函数返回时，这些变量会从栈中弹出，其占用的内存也随之释放。</li>
</ul>
</li>
<li>堆区（Heap Segment）：<ul>
<li>由程序员通过动态内存分配函数（如<code>new</code>和<code>malloc</code>）分配的内存区域。堆区的内存分配和释放是手动的，因此程序员需要负责管理内存，以避免内存泄漏或野指针等问题。</li>
<li>举例说明：当你使用<code>new</code>操作符在C++中动态分配一个对象或数组时，分配的内存就来自堆区。同样，使用<code>delete</code>操作符可以释放堆区中的内存。</li>
</ul>
</li>
<li>常量区（Constant Area）：<ul>
<li>存储常量（如字符串常量、const修饰的全局变量等）的内存区域。这部分内存也是只读的，且通常在程序执行期间不会改变。</li>
<li>举例说明：在C++中，使用双引号括起来的字符串字面量通常存储在常量区。此外，使用<code>const</code>关键字声明的全局变量，如果其值在编译时就已确定，也可能存储在常量区。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">// 用于strlen</span></span><br><br><span class="hljs-comment">// 全局变量，存储在全局/静态存储区</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 静态变量，也存储在全局/静态存储区，但仅在其声明的文件或函数内部可见</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量，存储在栈区</span><br>    <span class="hljs-type">int</span> localVar = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 静态局部变量，虽然声明在函数内部，但存储在全局/静态存储区，且只在第一次调用时初始化</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticLocalVar = <span class="hljs-number">40</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside func:&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;localVar = &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;staticLocalVar = &quot;</span> &lt;&lt; staticLocalVar &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 尝试通过动态内存分配在堆区分配内存</span><br>    <span class="hljs-type">int</span>* heapVar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">50</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;heapVar = &quot;</span> &lt;&lt; *heapVar &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 释放堆区内存（重要：实际使用中不要忘记释放不再使用的堆内存）</span><br>    <span class="hljs-keyword">delete</span> heapVar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 访问全局变量</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main:&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;globalVar = &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;staticVar = &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl; <span class="hljs-comment">// 注意：staticVar在外部不可见（除非在同一个文件中或通过特殊方式）</span><br><br>    <span class="hljs-comment">// 调用函数，展示栈区和堆区的使用</span><br>    <span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-comment">// 字符串常量通常存储在常量区，但直接访问其内存地址并不是标准C++的做法</span><br>    <span class="hljs-comment">// 这里我们仅通过指针来展示其存在</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* strConst = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    <span class="hljs-comment">// 注意：不要尝试修改strConst指向的内容，因为它是只读的</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;strConst = &quot;</span> &lt;&lt; strConst &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 尝试获取字符串常量的长度（这不会修改常量区的内容）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Length of strConst = &quot;</span> &lt;&lt; <span class="hljs-built_in">strlen</span>(strConst) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h4><p>C++程序的编译过程是一个相对复杂但有序的过程，它涉及将高级语言（C++）代码转换为机器可以执行的低级指令。在这个过程中，通常会生成几个中间文件，包括<code>.i</code>（预处理文件）、<code>.s</code>（汇编文件）和<code>.o</code>（目标文件或对象文件）。下面是这个过程的详细解释：</p>
<ol>
<li><strong>预处理（Preprocessing）</strong></li>
</ol>
<ul>
<li><strong>输入</strong>：C++源代码文件（通常以<code>.cpp</code>或<code>.cxx</code>为后缀）。</li>
<li><strong>处理</strong>：预处理器（通常是<code>cpp</code>）读取源代码文件，并对其进行宏展开、条件编译、文件包含（<code>#include</code>）等处理。</li>
<li><strong>输出</strong>：生成预处理后的文件，通常具有<code>.i</code>后缀（尽管这个步骤可能不是所有编译器都会自动生成<code>.i</code>文件，或者可能需要特定的编译器选项来生成）。</li>
</ul>
<ol start="2">
<li><strong>编译（Compilation）</strong></li>
</ol>
<ul>
<li><strong>输入</strong>：预处理后的文件（如果有的话，否则直接是源代码文件）。</li>
<li><strong>处理</strong>：编译器（如<code>g++</code>、<code>clang++</code>等）将预处理后的文件或源代码文件转换为汇编语言代码。这个步骤是编译过程的核心，它执行<strong>词法分析、语法分析、语义分析、中间代码生成、代码优化</strong>等任务。</li>
<li><strong>输出</strong>：生成汇编文件，通常具有<code>.s</code>或<code>.asm</code>后缀。</li>
</ul>
<ol start="3">
<li><strong>汇编（Assembly）</strong></li>
</ol>
<ul>
<li><strong>输入</strong>：汇编文件。</li>
<li><strong>处理</strong>：汇编器（如<code>as</code>、<code>gas</code>等）将汇编语言代码转换为机器语言指令（即目标代码），但这些指令仍然是针对特定架构的，并且尚未被链接成可执行文件。</li>
<li><strong>输出</strong>：生成目标文件（或对象文件），通常具有<code>.o</code>、<code>.obj</code>或<code>.out</code>后缀。</li>
</ul>
<ol start="4">
<li><strong>链接（Linking）</strong></li>
</ol>
<ul>
<li><strong>输入</strong>：一个或多个目标文件，以及可能需要的库文件（如C++标准库）。</li>
<li><strong>处理</strong>：链接器（如<code>ld</code>、<code>lld</code>等）将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用（即函数和变量的调用），并将它们链接到正确的地址。</li>
<li><strong>输出</strong>：生成可执行文件（在Unix-like系统中通常是<code>.out</code>、<code>.exe</code>或没有特定后缀，在Windows系统中是<code>.exe</code>）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分步编译</span><br>g++ -E hello.cpp -o hello.i    <span class="hljs-comment"># 预处理</span><br>g++ -S hello.i -o hello.s      <span class="hljs-comment"># 编译为汇编</span><br>g++ -c hello.s -o hello.o      <span class="hljs-comment"># 汇编为目标文件</span><br>g++ hello.o -o hello           <span class="hljs-comment"># 链接生成可执行文件</span><br><br><span class="hljs-comment"># 一步完成</span><br>g++ hello.cpp -o hello<br></code></pre></td></tr></table></figure>

<p>在编译C++程序时，编译器会首先处理源文件（.cpp 文件）。对于源文件中的每个 <code>#include</code> 指令，编译器都会查找并包含相应的头文件（.h 或 .hpp 文件）。然后，编译器将处理源文件中的所有实现代码，并将它们与从头文件中获取的声明进行匹配。</p>
<h4 id="头文件和源文件"><a href="#头文件和源文件" class="headerlink" title="头文件和源文件"></a>头文件和源文件</h4><p>头文件（.h 或 .hpp）</p>
<p>头文件主要用于<strong>声明</strong>（declarations），包括：</p>
<ul>
<li>类（class）的声明</li>
<li>函数（functions）的原型（prototypes）</li>
<li>模板（templates）的声明</li>
<li>宏定义（#define）</li>
<li>外部变量（extern variables）的声明</li>
<li>内联函数（inline functions）</li>
</ul>
<p>头文件通常包含预处理指令如 <code>#ifndef</code>、<code>#define</code> 和 <code>#endif</code>，这些指令用于防止头文件被重复包含（也称为“头文件保护”或“包含卫士”）。</p>
<p><strong>示例头文件（example.h）</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXAMPLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_H</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 构造函数声明</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 成员函数声明</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>源文件（.cpp）</p>
<p>源文件包含实际的代码实现，即函数体、类的成员函数的实现等。源文件通常包括必要的头文件，以便编译器知道它们正在使用的函数、类等是如何声明的。</p>
<p><strong>示例源文件（example.cpp）</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;example.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>MyClass::<span class="hljs-built_in">MyClass</span>() &#123;<br>    <span class="hljs-comment">// 构造函数实现</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass::myFunction!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>头文件应该只包含<strong>声明</strong>，源文件应该包含实现。</li>
<li>使用头文件保护来避免头文件被重复包含。</li>
<li>在大型项目中，合理组织头文件和源文件可以提高项目的可维护性和可扩展性。</li>
<li>在编译时，确保所有的源文件都被编译，并且所有的头文件都被正确包含。</li>
<li>Header Guard: <code>#pragma once</code> 和 宏定义（如 <code>#ifndef, #define, #endif</code>）都是用来防止头文件在一个文件中被重复包含的机制，但它们在工作方式和使用场景上存在一些区别。  预处理阶段</li>
</ul>
<p><strong>重定义问题</strong>：</p>
<p>头文件中如果定义了变量，会导致重定义，程序编译并未产生问题,但是链接产生问题了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DAY05_EXTERN_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DAY05_EXTERN_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">int</span> global_age = <span class="hljs-number">10</span>;<br>std::string global_name = <span class="hljs-string">&quot;llfc&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//DAY05_EXTERN_GLOBAL_H</span></span><br></code></pre></td></tr></table></figure>

<p>正确做法，头文件只声明不定义，声明放到cpp中。 头文件可能被包含多次但cpp只会被包含一次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HEADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HEADER_H</span><br><br><span class="hljs-comment">// 正确：使用extern声明</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> global_counter;  <span class="hljs-comment">// 只是声明，不是定义</span><br><br><span class="hljs-comment">// 正确：使用inline定义，inline函数可以在多个编译单元中定义，链接器合并</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_counter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> global_counter;<br>&#125;<br><span class="hljs-comment">// 编译时的简化过程（对象文件中）:普通函数使用的&quot;强符号&quot;(strong symbol)</span><br><span class="hljs-comment">// file1.o - 包含add()的弱符号定义 </span><br><span class="hljs-comment">// file2.o - 包含add()的弱符号定义</span><br><span class="hljs-comment">// 最终可执行文件 - 只保留一个add()的定义</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header.h&quot;</span></span><br><br><span class="hljs-comment">// 正确：在源文件中定义</span><br><span class="hljs-type">int</span> global_counter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 实际的定义</span><br></code></pre></td></tr></table></figure>

<h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><p>内联展开：示编译器将函数调用处直接替换为函数体代码，而不是生成函数调用指令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用内联函数</span><br><span class="hljs-type">int</span> result = <span class="hljs-built_in">max</span>(x, y);  <br><span class="hljs-comment">// 编译器可能将上面这行展开为: int result = (x &gt; y) ? x : y;</span><br></code></pre></td></tr></table></figure>

<p>头文件重定义问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UTILITIES_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UTILITIES_H</span><br><br><span class="hljs-comment">// 使用inline避免多重定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, message);<br>&#125;<br><br><span class="hljs-comment">// C++17后，可以直接在头文件中使用inline变量:</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159265358979323846</span>;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> std::string APP_NAME = <span class="hljs-string">&quot;MyApplication&quot;</span>;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 甚至可以是非常量变量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>底层指针实现</p>
<ol>
<li>必须初始化</li>
<li>绑定后不能修改</li>
<li>不能空引用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">// b是a的引用</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: a = 100, b = 100</span><br><br>    b = <span class="hljs-number">200</span>; <span class="hljs-comment">// 更改b的值也会更改a的值</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: a = 200, b = 200</span><br><br><br>    <span class="hljs-comment">// int c = 300;</span><br>    <span class="hljs-comment">// 表示修改b的值为c的值  而不是把b作为c的引用</span><br>    <span class="hljs-comment">// b = c; </span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>主要用户函数穿参和返回值，更快</li>
<li>使用const，防止引用修改了原对象</li>
<li>底层使用指针实现，但引用更加安全直观</li>
</ol>
<h5 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h5><p>在C++中，左值（<code>lvalue</code>）和右值（<code>rvalue</code>）是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。</p>
<ol>
<li>左值通常指的是具有持久状态的对象，它们有明确的内存地址，可以被多次赋值。</li>
<li>右值通常是临时的、没有持久状态的值，它们通常没有内存地址，或者其内存地址在表达式结束后就变得无效。</li>
</ol>
<p><strong>C++11</strong>引入了右值引用（<code>rvalue reference</code>），用<code>T&amp;&amp;</code>表示，作为对左值引用（<code>lvalue reference</code>，用<code>T&amp;</code>表示）的补充。这一特性极大地增强了C++的表达能力，特别是在资源管理和性能方面。</p>
<p><strong>左值引用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a; <span class="hljs-comment">// b是a的左值引用</span><br></code></pre></td></tr></table></figure>

<p><strong>右值引用</strong>：引用一个右值（临时的）。用于函数参数（实现移动语义）和返回值（允许链式调用等）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&amp;&amp; c = <span class="hljs-number">20</span>; <span class="hljs-comment">// c是整数字面量20的右值引用（但这种情况不常见，通常用于函数参数或返回值）</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>); <span class="hljs-comment">// 返回的临时字符串是一个右值</span><br>&#125;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;&amp;d = foo(); <span class="hljs-comment">// d是foo()返回的临时字符串的右值引用</span><br></code></pre></td></tr></table></figure>

<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 必须初始化</span><br></code></pre></td></tr></table></figure>

<p>编译器可能会对const进行优化，放到只读区域</p>
<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到<code>bufSize</code>的地方，然后用512替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">在头文件中<br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 错误：可能导致多重定义</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> constVar = <span class="hljs-number">20</span>;    <span class="hljs-comment">// const变量可以在头文件中定义 对于每一个分别的文件中，都会有独立副本</span><br></code></pre></td></tr></table></figure>

<h5 id="reference-to-const"><a href="#reference-to-const" class="headerlink" title="reference to const"></a>reference to const</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> i5 = <span class="hljs-number">1024</span><br><br><span class="hljs-comment">//用常量引用绑定常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = ci;<br><br><span class="hljs-comment">//允许将const int&amp; 绑定到一个普通的int对象上</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r5 = i5;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r6 = <span class="hljs-number">1024</span>;<br><br>但不允许使用非<span class="hljs-type">const</span>引用绑定<span class="hljs-type">const</span>变量<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误用法，类型不匹配</span><br><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> &amp; rd = dval;<br><br><span class="hljs-comment">//编译通过</span><br><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; ri = dval;<br></code></pre></td></tr></table></figure>

<h5 id="point"><a href="#point" class="headerlink" title="point"></a>point</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 指向常量的指针  (pointer to constant)  保护数据不被修改 Low-level const</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pconst_func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//指向常量的指针</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br>    <span class="hljs-comment">//不可以用普通指针指向常量</span><br>    <span class="hljs-comment">// double *ptr = π</span><br>    <span class="hljs-comment">//用常量指针指向常量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> *cptr = π<br>    <span class="hljs-comment">//不能给*cptr赋值因为cptr指向的是常量</span><br>    <span class="hljs-comment">// *cptr = 42;</span><br>    <span class="hljs-comment">//指向常量的指针指向非常量  但也不能修改   单向保护</span><br>    <span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br>    cptr = &amp;dval;<br>&#125;<br><br><span class="hljs-comment">// 常量指针(constant pointer) 保指针始终指向同一个地址  ＊放在const关键字之前 指向的地址初始化后不可修改  Top-level const</span><br><span class="hljs-type">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// curErr将一直指向errNumb</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> curErr = &amp;errNumb;<br></code></pre></td></tr></table></figure>



<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><ul>
<li>普通值  Buffer a;</li>
<li>指针值  Buffer *p &#x3D; new Buffer();</li>
</ul>
<p>普通值在传递 赋值时有很大的不同，引入了运算符重载、拷贝构造、引用、右值引用</p>
<p>为什么不直接全用指针，和java一样？ 没有内存回收机制</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612.png" srcset="/img/loading.gif" lazyload alt="image-20250519102222191"></p>
<ul>
<li><p>是否有持久的内存地址，取地址操作</p>
</li>
<li><p>只能作为赋值语句右值的值（const只能但算左值）</p>
</li>
<li><p>函数返回值？ 只有全局变量的引用是左值</p>
</li>
<li><p>纯右值</p>
<ul>
<li><p>临时对象、字面量、算术表达式</p>
</li>
<li><pre><code class="cpp">int x = 5;           // 5 是纯右值
int y = x + 2;       // x + 2 是纯右值
std::string(&quot;abc&quot;)   // 构造出来的临时对象是纯右值
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 将亡值<br><br>  - 即将“被移动”的对象的值。它有**标识性**（表示某个特定对象），但可以被移动或资源窃取。有地址<br><br>  - ```cpp<br>    std::string&amp;&amp; str = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// std::move(s) 是将亡值</span><br>    std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">front</span>();       <span class="hljs-comment">// 返回的是将亡值</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>将亡值</p>
<ul>
<li>我希望有一个对象用完之后不要了<ul>
<li>直接传参？调用了拷贝构造 白复制了 浪费资源。</li>
<li>const &amp;，可以延长右值，但内部值不能操作了。此外函数不知道传入的是右值还是左值</li>
<li>普通引用&amp;，无法传入右值</li>
</ul>
</li>
<li>引入移动语义。显式move实现所有权转交、函数临时返回、表达式<ul>
<li>用谁来接受这个将亡值？右值引用</li>
<li>move其实就是<code>static_cast&lt;std::string&amp;&amp;&gt;(s)</code>强转右值引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在矩阵相加中，如何通过充分利用将亡值与移动语义，减少资源的申请</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp">www.bilibili.com/video/BV15v411g7Ma<br>cpp17 + 禁用rvo<br>M r = a + b  +  c<br>       tmpab + c<br>  <br><span class="hljs-comment">// 传统加法：两个 const 引用，返回一个新矩阵（纯右值）</span><br>  <span class="hljs-keyword">friend</span> Matrix <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Matrix &amp;a, <span class="hljs-type">const</span> Matrix &amp;b) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;operator+(const&amp;, const&amp;)\n&quot;</span>);<br>      <span class="hljs-keyword">if</span> (a.row != b.row || a.col != b.col) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Size mismatch&quot;</span>);<br>      <span class="hljs-function">Matrix <span class="hljs-title">res</span><span class="hljs-params">(a.row, a.col)</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.row; ++i)<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a.col; ++j)<br>              res.data[i][j] = a.data[i][j] + b.data[i][j];<br>      <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回纯右值</span><br>  &#125;<br>每加法 一次构造 + 一次返回值拷贝<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp; mat)<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp; mat)<br>  <br><br>优化<span class="hljs-number">1</span> 添加移动构造，编译器会优先使用移动，减少了一次拷贝开销<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br>  <br><br>优化<span class="hljs-number">2</span> 充分利用tmpab的空间,使用右值引用窃取临时变量资源<br>    <span class="hljs-comment">// 利用右值引用加法</span><br>    <span class="hljs-keyword">friend</span> Matrix <span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; a, <span class="hljs-type">const</span> Matrix&amp; b) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;operator+(Matrix&amp;&amp;, const&amp;)\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a.row != b.row || a.col != b.col) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Size mismatch&quot;</span>);<br>        Matrix res = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// 资源转移窃取</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.row; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; res.col; ++j)<br>                res.data[i][j] += b.data[i][j];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br>    <span class="hljs-keyword">operator</span>+(Matrix&amp;&amp;, <span class="hljs-type">const</span>&amp;)<br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat) <span class="hljs-comment">// 拷贝变成了移动</span><br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br><br>此外如果调用std::<span class="hljs-built_in">move</span>(a) + b + c，结果的地址会和a一致，也就是窃取了a的资源<br></code></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="类型推动和别名"><a href="#类型推动和别名" class="headerlink" title="类型推动和别名"></a>类型推动和别名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ulong;<br><br><span class="hljs-comment">// c++11</span><br>using <span class="hljs-type">int64_t</span> = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure>

<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算求和</span><br><span class="hljs-type">int</span> age1 = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> age2 = <span class="hljs-number">35</span>;<br><span class="hljs-keyword">auto</span> age_add = age1+age2;<br></code></pre></td></tr></table></figure>

<p>auto一般会忽略掉顶层<code>const</code>，同时底层<code>const</code>则会保留下来，比如当初始值是一个指向常量的指针时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br>    <span class="hljs-comment">// a是一个整数，类型是r所引用的类型</span><br>    <span class="hljs-keyword">auto</span> a = r;<br>    <span class="hljs-comment">// cr是一个常量引用，ci是int类型的常量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br>    <span class="hljs-comment">// b是一个整数，ci顶层const被忽略了</span><br>    <span class="hljs-keyword">auto</span> b = ci;<br>    <span class="hljs-comment">// c是一个整数，cr是ci的别名，ci本身是一个顶层const</span><br>    <span class="hljs-keyword">auto</span> c = cr;<br>    <span class="hljs-comment">// d 是一个整型指针，i是整型</span><br>    <span class="hljs-keyword">auto</span> d = &amp;i;<br>    <span class="hljs-comment">// e是一个指向整数常量的指针，对常量对象取地址是一种底层const</span><br>    <span class="hljs-keyword">auto</span> e = &amp;ci;<br>&#125;<br><br><span class="hljs-comment">//顶层const可显示指定,f是一个const int类型</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<br></code></pre></td></tr></table></figure>

<h5 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h5><p>用于在编译时推导表达式的类型。但不和auto一样需要赋值</p>
<ul>
<li>单个标识符：保持原类型</li>
<li>加括号的标识符的左值：变为引用类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">decltype(expression) variable;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br>decltype(x) y = <span class="hljs-number">100</span>;     <span class="hljs-comment">// y的类型是int</span><br>decltype(x + y) sum;     <span class="hljs-comment">// sum的类型是int</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">会包含变量的顶层<span class="hljs-type">const</span>，以及引用<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci, *p = &amp;i;<br><span class="hljs-comment">//x是const int类型</span><br>decltype(ci) x = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//y是一个const int&amp;类型，y绑定到x    必须初始化</span><br>decltype(cj) y = x;<br><br><br>decltype(*p)  <span class="hljs-comment">// *p可以理解为i的引用，所以decltype(*p)上int&amp; 必须初始化</span><br></code></pre></td></tr></table></figure>

<h5 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;</span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; <br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;<span class="hljs-title function_">decltype</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(f)(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...))</span>&gt; &#123;<br>    using RetType = decltype(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(f)(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<br>    <span class="hljs-keyword">if</span> (stop_.load())<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;RetType&gt;&#123;&#125;;<br>    <span class="hljs-keyword">auto</span> task = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::packaged_task&lt;RetType()&gt;&gt;(<br>            <span class="hljs-built_in">std</span>::bind(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(f), <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;RetType&gt; ret = task-&gt;get_future();<br>    &#123;<br>        <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">cv_mt</span><span class="hljs-params">(cv_mt_)</span>;<br>        tasks_.emplace([task] &#123; (*task)(); &#125;);<br>    &#125;<br>    cv_lock_.notify_one();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="聚合初始化"><a href="#聚合初始化" class="headerlink" title="聚合初始化"></a>聚合初始化</h4><ol>
<li>数组</li>
<li>符合以下条件的类:<ul>
<li>没有用户声明的构造函数</li>
<li>没有私有或保护的非静态数据成员</li>
<li>没有虚函数</li>
<li>没有基类</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 数组的聚合初始化</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 结构体的聚合初始化</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br>Point p = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;<br><br><br><span class="hljs-comment">// c++11 以下两种写法等价</span><br>Person p1 = &#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>&#125;;<br>Person p2&#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inner</span> &#123;</span><br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Outer</span> &#123;</span><br>    Inner in;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><span class="hljs-comment">// 嵌套聚合初始化</span><br>Outer obj = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, <span class="hljs-number">3</span>&#125;;<br><br><br>stl<br><span class="hljs-comment">// 初始化 vector</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化 array</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化 set</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化 map</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span>&gt; m = &#123;<br>    &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">3</span>&#125;<br>&#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StructName</span> &#123;</span><br>    <span class="hljs-comment">// 成员变量</span><br>    dataType1 member1;<br>    dataType2 member2;<br>    <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> counter;      <span class="hljs-comment">// 仅声明</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 合法：静态常量整型可以在类内初始化  不能取地址，除非额外定义了</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;        <span class="hljs-comment">// C++17支持</span><br><br>&#125;;<br><br><span class="hljs-comment">// 在类外定义并初始化</span><br><span class="hljs-type">int</span> MyClass::counter = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-comment">// Overload the &lt;&lt; operator for Point</span><br>ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; point) &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; point.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Point p1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;; <span class="hljs-comment">// 使用初始化列表</span><br>    Point p3 = &#123; .y = <span class="hljs-number">50</span>, .x = <span class="hljs-number">60</span> &#125;; <span class="hljs-comment">// 使用指定成员初始化，顺序可以不同</span><br>    Point p4;<br>    p4.x = <span class="hljs-number">70</span>; <span class="hljs-comment">// 先初始化x</span><br>    p4.y = <span class="hljs-number">80</span>; <span class="hljs-comment">// 再初始化y</span><br><br>    Point arrPoints[<span class="hljs-number">3</span>] = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; &#125;; <span class="hljs-comment">// 数组初始化</span><br><br>    Point * p5 = new Point; <span class="hljs-comment">// 动态分配内存</span><br><br>    p5-&gt;x = <span class="hljs-number">90</span>; <span class="hljs-comment">// 使用指针访问成员</span><br>    p5-&gt;y = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt; p5 &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt; *p5 &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt; p5-&gt;x &lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;hello &quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义命名空间</span><br>namespace Math &#123;<br>    <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用命名空间中的成员</span><br>Math::PI;         <span class="hljs-comment">// 使用作用域解析运算符</span><br>Math::add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 调用命名空间中的函数</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 方法1：使用整个命名空间</span><br>using namespace Math;<br>PI;  <span class="hljs-comment">// 可以直接使用，不需要Math::</span><br><br><span class="hljs-comment">// 方法2：只使用特定成员</span><br>using Math::PI;<br>PI;  <span class="hljs-comment">// 只导入 PI</span><br><br>对于<span class="hljs-built_in">std</span>同理<br>using <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>;<br>using <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>避免在头文件、全局作用域中使用 <code>using namespace</code></li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;Hello, C-strings!&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">str</span><span class="hljs-params">(cstr)</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = str.c_str();<br></code></pre></td></tr></table></figure>

<h5 id="c风格的"><a href="#c风格的" class="headerlink" title="c风格的"></a>c风格的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> greeting[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> city[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;Beijing&quot;</span>; <span class="hljs-comment">// \0后面有额外空间</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 包含垃圾值</span><br>    <span class="hljs-type">char</span> cstr[] = <span class="hljs-string">&quot;Hello, World!&quot;</span>; <span class="hljs-comment">// 结尾会自动有一个&#x27;\0&#x27;</span><br><br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(cstr);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; cstr[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; cstr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>  <span class="hljs-comment">// 拷贝</span><br>  <span class="hljs-type">char</span> dest[<span class="hljs-number">50</span>];<br>  <span class="hljs-built_in">strcpy</span>(dest, src);<br><br><br>  <span class="hljs-type">char</span> ca[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;P&#x27;</span>,<span class="hljs-string">&#x27;P&#x27;</span>&#125;; <span class="hljs-comment">//有风险，因为ca没有以\0结束，所以strlen可能访问越界</span><br><br>    <span class="hljs-built_in">strcat</span>(p1,p2)    将p2附加到p1之后，返回p1<br>    <span class="hljs-title function_">strcmp</span><span class="hljs-params">(p1,p2)</span>    比较p1和p2的是否相等，如果相等返回0，如果p1&gt;p2返回一个正值，如果p1&lt;p2返回一个负值<br><br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str1;              <span class="hljs-comment">// 空字符串</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;Hello&quot;</span>;    <span class="hljs-comment">// 使用字符串字面量初始化</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str3&#123;<span class="hljs-string">&quot;World&quot;</span>&#125;;     <span class="hljs-comment">// 统一初始化语法</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">str4</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span>;      <span class="hljs-comment">// 创建包含5个&#x27;a&#x27;的字符串：&quot;aaaaa&quot;</span><br><br>str.length();     <span class="hljs-comment">// 获取长度  同.size();</span><br>str.empty();      <span class="hljs-comment">// 判断是否为空</span><br>str.clear();      <span class="hljs-comment">// 清空字符串</span><br><br>str[<span class="hljs-number">0</span>];           <span class="hljs-comment">// 使用下标访问: &#x27;H&#x27;</span><br>str.at(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 使用at()访问（带边界检查）: &#x27;H&#x27; 会抛出越界异常</span><br>str.front();      <span class="hljs-comment">// 首字符: &#x27;H&#x27;</span><br>str.back();       <span class="hljs-comment">// 末字符: &#x27;o&#x27;</span><br><br>str += <span class="hljs-string">&quot; World&quot;</span>;              <span class="hljs-comment">// 追加字符串</span><br>str.append(<span class="hljs-string">&quot; Again&quot;</span>);         <span class="hljs-comment">// 追加</span><br>str.push_back(<span class="hljs-string">&#x27;!&#x27;</span>);          <span class="hljs-comment">// 追加单个字符</span><br>str.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; my&quot;</span>);        <span class="hljs-comment">// 在指定位置插入</span><br>str.erase(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);             <span class="hljs-comment">// 删除从位置5开始的3个字符</span><br>str.replace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Hi&quot;</span>);     <span class="hljs-comment">// 替换从位置0开始的5个字符为&quot;Hi&quot;</span><br><br><br>str.find(<span class="hljs-string">&quot;World&quot;</span>);           <span class="hljs-comment">// 查找子串，返回首次出现位置</span><br>str.rfind(<span class="hljs-string">&quot;o&quot;</span>);             <span class="hljs-comment">// 从右向左查找</span><br>str.find_first_of(<span class="hljs-string">&quot;aeiou&quot;</span>); <span class="hljs-comment">// 查找第一个元音字母</span><br>str.find_last_of(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找最后一个元音字母</span><br></code></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-built_in">std</span>::transform(str.begin(), str.end(), str.begin(), <br>                   [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">toupper</span>(c); &#125;);<br><br><br><span class="hljs-comment">// Method 2: Using range-based for loop with iterator</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = str.begin(); it != str.end(); ++it) &#123;<br>      *it = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">tolower</span>(*it);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>字符串转其它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 转字符串 std::to_string()</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str1 = <span class="hljs-built_in">std</span>::to_string(num);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str2 = <span class="hljs-built_in">std</span>::to_string(pi);<br><br><br><span class="hljs-comment">// 字符串转数字  C++11</span><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">std</span>::stoi(numStr);<br><span class="hljs-type">double</span> pi = <span class="hljs-built_in">std</span>::stod(piStr);<br></code></pre></td></tr></table></figure>

<p>字符串流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br>字符串到流<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> ss;<br>ss &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-number">3.14</span>;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = ss.str();<br><br><br>流到字符串<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data = <span class="hljs-string">&quot;123 45.67 Hello&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> <span class="hljs-title function_">ss</span><span class="hljs-params">(data)</span>;<br><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> c;<br><br>ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br></code></pre></td></tr></table></figure>

<p>正则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-built_in">std</span>::regex <span class="hljs-title function_">pattern</span><span class="hljs-params">(<span class="hljs-string">R&quot;(\b\w&#123;5&#125;\b)&quot;</span>)</span>; <span class="hljs-comment">// 匹配所有5个字母的单词</span><br><br><span class="hljs-built_in">std</span>::sregex_iterator <span class="hljs-title function_">it</span><span class="hljs-params">(text.begin(), text.end(), pattern)</span>;<br></code></pre></td></tr></table></figure>

<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 不同的初始化方式</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec1;                        <span class="hljs-comment">// 空向量</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">vec2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>;                     <span class="hljs-comment">// 5个元素，初始值为0</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">vec3</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span>;                  <span class="hljs-comment">// 5个元素，初始值为1</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec4 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;     <span class="hljs-comment">// 列表初始化</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">vec5</span><span class="hljs-params">(vec4)</span>;                  <span class="hljs-comment">// 拷贝构造</span><br><br><br><span class="hljs-comment">// 创建 M x N 的矩阵</span><br><span class="hljs-type">int</span> M = <span class="hljs-number">3</span>, N = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; matrix(M, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N));<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; grid3 = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>    &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>&#125;;  <span class="hljs-comment">// 直接初始化3x3矩阵</span><br><br><br><span class="hljs-comment">// 添加元素</span><br>vec.push_back(<span class="hljs-number">4</span>);           <span class="hljs-comment">// 在末尾添加元素</span><br>vec.emplace_back(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 在末尾构造元素（更高效）</span><br>vec.insert(vec.begin(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 在指定位置插入元素</span><br><br><span class="hljs-comment">// 删除元素</span><br>vec.pop_back();            <span class="hljs-comment">// 删除末尾元素</span><br>vec.erase(vec.begin());    <span class="hljs-comment">// 删除指定位置元素</span><br>vec.clear();               <span class="hljs-comment">// 清空所有元素</span><br><br><span class="hljs-comment">// 访问元素</span><br><span class="hljs-type">int</span> first = vec[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 下标访问（不检查边界）</span><br><span class="hljs-type">int</span> first_safe = vec.at(<span class="hljs-number">0</span>);<span class="hljs-comment">// 带边界检查的访问</span><br><span class="hljs-type">int</span> last = vec.back();     <span class="hljs-comment">// 访问最后一个元素</span><br><span class="hljs-type">int</span> first2 = vec.front();  <span class="hljs-comment">// 访问第一个元素</span><br><br><br>vec.size();      <span class="hljs-comment">// 当前元素个数</span><br>vec.capacity();  <span class="hljs-comment">// 当前分配的存储空间大小</span><br>vec.empty();     <span class="hljs-comment">// 检查是否为空</span><br>vec.reserve(<span class="hljs-number">10</span>); <span class="hljs-comment">// 预分配空间</span><br>vec.resize(<span class="hljs-number">5</span>);   <span class="hljs-comment">// 改变大小</span><br>vec.shrink_to_fit(); <span class="hljs-comment">// 释放多余内存</span><br><br><br><br><span class="hljs-comment">// 遍历元素</span><br><span class="hljs-comment">// 1. 范围for循环（推荐）  使用引用加速 而const保证不修改</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; element : vec) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// 2. 迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.begin(); it != vec.end(); ++it) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// 3. 索引</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vec.size(); ++i) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::iterator it2;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;::const_iterator it3; <span class="hljs-comment">// 常量</span><br><br><br>v.begin(); <span class="hljs-comment">// const 容器会返回const_iterator</span><br>v.cbegin(); <span class="hljs-comment">// 都会返回const_iterator</span><br><br><br><span class="hljs-comment">// 解引用运算符</span><br>*iter          <span class="hljs-comment">// 访问元素</span><br>iter-&gt;member   <span class="hljs-comment">// 访问成员(如果有)</span><br><br><span class="hljs-comment">// 自增运算</span><br>++iter        <span class="hljs-comment">// 前缀自增,移动到下一个元素</span><br>iter++        <span class="hljs-comment">// 后缀自增</span><br><br><span class="hljs-comment">// 比较运算 </span><br>iter1 == iter2 <span class="hljs-comment">// 判断两个迭代器是否指向相同位置</span><br>iter1 != iter2 <span class="hljs-comment">// 判断两个迭代器是否指向不同位置</span><br></code></pre></td></tr></table></figure>

<p>迭代器失效：在遍历的时候修改内容，会导致原来的迭代器失效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正确的方式  使用返回值更新迭代器</span><br>it = container.erase(it);  <span class="hljs-comment">// 返回删除元素的下一个元素的迭代器</span><br><br><br><span class="hljs-comment">// 在循环中正确使用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = container.begin(); it != container.end();) &#123;<br>    <span class="hljs-keyword">if</span> (某个条件) &#123;<br>        it = container.erase(it);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ++it;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 声明定长数组  p[i] = *(p+i)</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">5</span>];                     <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// 完全初始化</span><br><span class="hljs-type">int</span> arr3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;           <span class="hljs-comment">// 部分初始化，剩余元素为0</span><br><span class="hljs-type">int</span> arr4[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;         <span class="hljs-comment">// 自动推导大小</span><br><br>不可以用<span class="hljs-built_in">vector</span>初始化数组<br>数组 -&gt; <span class="hljs-built_in">vector</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">ivec</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::begin(int_arr), <span class="hljs-built_in">std</span>::end(int_arr))</span>;<br><br><br><span class="hljs-type">constexpr</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sz = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 访问</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>); ++i)&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// c11 提供快速位置获取</span><br><span class="hljs-type">int</span> * beg = <span class="hljs-built_in">std</span>::begin(ia);<br><span class="hljs-type">int</span> * end = <span class="hljs-built_in">std</span>::end(ia);  <span class="hljs-comment">// == ia + sz</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = beg; it != end; ++it)&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>多维<br><span class="hljs-comment">// 二维数组   函数传参以及表达式运算时会退化成int (*)[4]</span><br><span class="hljs-type">int</span> matrix[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 以下所有表达式都是等价的，都访问值7</span><br><span class="hljs-type">int</span> value1 = a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];           <span class="hljs-comment">// 普通数组访问</span><br><span class="hljs-type">int</span> value2 = *(*(a + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>);   <span class="hljs-comment">// 完全展开的指针访问</span><br><span class="hljs-type">int</span> value3 = *(a[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>);       <span class="hljs-comment">// 混合形式</span><br><span class="hljs-type">int</span> value4 = *((<span class="hljs-type">int</span>*)a + <span class="hljs-number">6</span>);    <span class="hljs-comment">// 将二维数组当作一维数组访问</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; ++p)&#123; <span class="hljs-comment">// ia+i等价于 &amp;(ia[i])</span><br>    <span class="hljs-comment">//q指向4个整数的数组的首元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q = *p; q != *p + <span class="hljs-number">4</span>; ++q)&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>固定大小，编译时确定</li>
<li>连续内存空间</li>
<li>栈上分配</li>
<li>不能改变大小</li>
<li>快速索引访问</li>
</ul>
<h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 动态分配</span><br><span class="hljs-type">int</span>* arr = new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 使用完后需要释放</span><br>delete[] arr;<br><br><span class="hljs-comment">// 动态分配并初始化（C++11）</span><br><span class="hljs-type">int</span>* arr = new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><br><br><span class="hljs-comment">// 动态二维数组</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">3</span>, n = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 分配行指针</span><br><span class="hljs-type">int</span>** arr = new <span class="hljs-type">int</span>*[m];<br><span class="hljs-comment">// 分配每一行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    arr[i] = new <span class="hljs-type">int</span>[n];<br>&#125;<br><br><span class="hljs-comment">// 释放内存</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    delete[] arr[i];<br>&#125;<br>delete[] arr;<br></code></pre></td></tr></table></figure>

<ul>
<li>运行时确定大小</li>
<li>堆上分配</li>
<li>需要手动管理内存</li>
<li>使用指针访问</li>
</ul>
<p>数组的指针和引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;<br><span class="hljs-comment">//arrRef 引用一个含有10个整数的数组</span><br><span class="hljs-type">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<br></code></pre></td></tr></table></figure>

<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> &#123;</span><br>public:<br>    <span class="hljs-type">double</span> real, imag;<br><br>    Complex operator+(<span class="hljs-type">const</span> Complex &amp;c) &#123;<br>        Complex temp;<br>        temp.real = real + c.real;<br>        temp.imag = imag + c.imag;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> &#123;</span><br>public:<br>    <span class="hljs-type">double</span> real, imag;<br>    friend Complex operator-(<span class="hljs-type">const</span> Complex &amp;c1, <span class="hljs-type">const</span> Complex &amp;c2);<br><br>    <span class="hljs-comment">// 重载 &lt;&lt; 运算符（作为友元函数）</span><br>    friend ostream&amp; operator&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Complex &amp;c);<br>&#125;;<br><br>Complex operator-(<span class="hljs-type">const</span> Complex &amp;c1, <span class="hljs-type">const</span> Complex &amp;c2) &#123;<br>    Complex temp;<br>    temp.real = c1.real + c2.real;<br>    temp.imag = c1.imag + c2.imag;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br>ostream&amp; operator&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Complex &amp;c) &#123;<br>    out &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// multiply.h:</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MULTIPLY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MULTIPLY_H</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// multiply.cpp:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;multiply.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;multiply.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> result = multiply(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;4 * 6 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>g++ main.cpp multiply.cpp -o program<br></code></pre></td></tr></table></figure>

<p>传参：</p>
<ul>
<li><strong>传值调用</strong>：适用于不需要修改原始数据且数据量较小的情况。  拷贝构造函数</li>
<li><strong>传引用调用</strong>：适用于需要修改原始数据或传递大型数据结构以提高效率。</li>
<li><strong>传指针调用</strong>：类似传引用调用，但更灵活，可用于传递<code>nullptr</code>或指向动态分配的内存。</li>
</ul>
<p>返回值：</p>
<ul>
<li>基本数据类型</li>
<li>引用类型<code>int&amp; getReference(int&amp; value); int&amp; ref = getReference(x); </code></li>
<li>指针类型 <code>int* createNumber()</code></li>
<li>对象  优先移动语义，其次拷贝构造函数 现代编译器通过返回值优化（RVO）减少对象拷贝，提高效率</li>
</ul>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// Regular function</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Declaring a function pointer</span><br>    <span class="hljs-type">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br>    <span class="hljs-comment">// Assigning function address to pointer</span><br>    func_ptr = add;  <span class="hljs-comment">// 取地址可以省略</span><br><br>    <span class="hljs-comment">// Calling function through pointer</span><br>    <span class="hljs-type">int</span> result = func_ptr(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 解引用可以省略</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// typedef for Cleaner </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*Operation)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br>Operation op = add;<br><br><br><span class="hljs-comment">// 结合lambda</span><br><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>) = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br></code></pre></td></tr></table></figure>

<h5 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h5><p>Lambda 表达式在编译器生成的代码中会被转换为一个<strong>匿名类</strong>，该类包含以下关键部分：</p>
<ul>
<li><strong>捕获的变量</strong>：以值捕获的变量会成为该类的成员变量（例如 <code>std::shared_ptr</code> 会作为成员变量存储）。</li>
<li>**重载的 <code>operator()</code>**：即 lambda 的函数体逻辑。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">[capture clause](parameters) -&gt; return_type &#123; body &#125;<br><br><br><span class="hljs-type">int</span> multiplier = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> multiply = [multiplier](<span class="hljs-type">int</span> x) <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> x * multiplier; &#125;;<br><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">std</span>::for_each(nums.begin(), nums.end(), <br>    [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br><br><br><span class="hljs-comment">// 使用Lambda表达式计算总和  引用捕获</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">std</span>::for_each(numbers.begin(), numbers.end(), [&amp;sum](<span class="hljs-type">int</span> x) &#123;<br>    sum += x;<br>&#125;);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; callback)</span> &#123;<br>    callback(<span class="hljs-number">42</span>);<br>&#125;<br><span class="hljs-comment">// Usage</span><br>process([](<span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x; &#125;);<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>值捕获 (<code>[=]</code>)</strong>: 捕获所有外部变量的副本。 <strong>拷贝构造函数</strong></li>
<li><strong>引用捕获 (<code>[&amp;]</code>)</strong>: 捕获所有外部变量的引用。</li>
<li><strong>混合捕获</strong>: 指定部分变量按值捕获，部分按引用捕获，如 <code>[=, &amp;var]</code> 或 <code>[&amp;, var]</code>。</li>
<li><strong>无捕获 (<code>[]</code>)</strong>: 不捕获任何外部变量。</li>
</ol>
<p>使用lambda捕获结合智能指针，可以实现生命周期延续，防止引用捕获时外部对象已经被销毁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> </span>&#123;<br>    <span class="hljs-type">static</span> std::mutex mtx;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;3. Inside function, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 参数值传递 计数再+1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1. ptr created, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-comment">// 值捕获 ptr：触发拷贝构造，引用计数 +1</span><br>    <span class="hljs-keyword">auto</span> lambda = [ptr]() &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;3. Inside lambda, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>()));<br>    &#125;;<br><br>    <span class="hljs-comment">// 复制到 bind 对象内部 引用计数 +1</span><br>    <span class="hljs-keyword">auto</span> boundFunc = std::<span class="hljs-built_in">bind</span>(printValue, ptr);<br><br><br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;2. After lambda capture, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 3</span><br><br>    <span class="hljs-built_in">boundFunc</span>();<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([lambda]() &#123;  <span class="hljs-comment">// 拷贝 lambda，其内部的 ptr 被拷贝，引用计数 +1</span></span></span><br><span class="hljs-params"><span class="hljs-function">        lambda();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;4. end = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 2</span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当定义 lambda 时，编译器实际上创建了一个匿名类（闭包类型）的实例，捕获的变量 add_ptr 确实相当于闭包类型的成员变量，调用lambda时就是<strong>访问成员</strong>变量，值不会增加</li>
<li>lambda被复制（例如传递给线程），add_ptr作为其成员也会被复制，从而增加引用计数。</li>
<li>bind 也会创建一个函数对象，并以元组形式存储所有参数的副本 所以计数+1，同时调用函数时会<strong>传参</strong>再次拷贝，额外在+1</li>
</ul>
<h5 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h5><p><strong>仿函数（Functors）</strong>，又称<strong>函数对象（Function Objects）</strong>，是在C++中重载了 <code>operator()</code> 的类或结构体实例。使得对象能像函数一样被调用，类似于<code>__call__</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义一个仿函数类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Adder</span> &#123;</span><br>    <span class="hljs-type">int</span> to_add;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    Adder(<span class="hljs-type">int</span> value) : to_add(value) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载()运算符</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x + to_add;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Adder <span class="hljs-title function_">add5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>; <span class="hljs-comment">// 创建一个添加5的仿函数</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;10 + 5 = &quot;</span> &lt;&lt; add5(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: 10 + 5 = 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 结合模版 实现通用代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 通用比较仿函数</span><br>template &lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Compare</span> &#123;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a &lt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>&#125;;<br><br>    <span class="hljs-comment">// 使用仿函数进行排序</span><br>    <span class="hljs-built_in">std</span>::sort(numbers.begin(), numbers.end(), Compare&lt;<span class="hljs-type">int</span>&gt;());<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;排序后的数字: &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : numbers) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 5 8 9</span><br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>许多标准库算法可以接受仿函数作为参数    <code>auto it = std::find_if(numbers.begin(), numbers.end(), greaterThan10);</code></p>
<h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5><p><code>std::function</code> 是 C++11 引入的通用可调用对象包装器，允许以统一的方式处理多种可调用对象。</p>
<p><code>std::function&lt;int(int, int)&gt; func; // 接受两个int，返回int的可调用对象</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 函数对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Multiply</span> &#123;</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 封装普通函数</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func1 = add;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Add: &quot;</span> &lt;&lt; func1(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: Add: 7</span><br><br>    <span class="hljs-comment">// 封装Lambda表达式</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func2 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Subtract: &quot;</span> &lt;&lt; func2(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: Subtract: 6</span><br><br>    <span class="hljs-comment">// 封装函数对象</span><br>    Multiply multiply;<br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func3 = multiply;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Multiply: &quot;</span> &lt;&lt; func3(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: Multiply: 12</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p><code>std::bind</code>的主要作用是生成一个新的可调用对象，通过预先绑定某些参数，或者调整参数顺序，使得调用时更加方便。它支持普通函数、成员函数、函数对象等，并且可以使用占位符来灵活处理参数的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; msg, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 绑定消息为&quot;Hello&quot;，生成新的函数对象，只需要传递次数</span><br>    <span class="hljs-keyword">auto</span> sayHello = <span class="hljs-built_in">std</span>::bind(display, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-built_in">std</span>::placeholders::_1);<br><br>    sayHello(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    输出:</span><br><span class="hljs-comment">    Hello</span><br><span class="hljs-comment">    Hello</span><br><span class="hljs-comment">    Hello</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 绑定次数为2，生成新的函数对象，只需要传递消息</span><br>    <span class="hljs-keyword">auto</span> sayTwice = <span class="hljs-built_in">std</span>::bind(display, <span class="hljs-built_in">std</span>::placeholders::_1, <span class="hljs-number">2</span>);<br>    sayTwice(<span class="hljs-string">&quot;Hi&quot;</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    输出:</span><br><span class="hljs-comment">    Hi</span><br><span class="hljs-comment">    Hi</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bind_result</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    F func;  <span class="hljs-comment">// 存储目标函数</span><br>    std::tuple&lt;Args...&gt; bound_args;  <span class="hljs-comment">// 以元组形式存储所有参数的副本</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bind_result</span>(F f, Args... args) <br>        : <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">bound_args</span>(std::<span class="hljs-built_in">move</span>(args)...) &#123;&#125;<br><br>    <span class="hljs-comment">// 调用运算符，允许对象作为函数使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... CallArgs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(CallArgs&amp;&amp;... call_args)</span> </span>&#123;<br>        <span class="hljs-comment">// 将存储的参数传递给目标函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">invoke_with_args</span>(<br>            std::index_sequence_for&lt;Args...&gt;&#123;&#125;, <br>            std::forward&lt;CallArgs&gt;(call_args)...<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数，用于展开存储的参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>... Is, <span class="hljs-keyword">typename</span>... CallArgs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">invoke_with_args</span><span class="hljs-params">(std::index_sequence&lt;Is...&gt;, CallArgs&amp;&amp;... call_args)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">get</span>&lt;Is&gt;(bound_args)...);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">可调用对象类型</th>
<th align="left">状态携带</th>
<th align="left">性能</th>
<th align="left">灵活性</th>
<th align="left">典型场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">普通函数</td>
<td align="left">否</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">简单逻辑</td>
</tr>
<tr>
<td align="left">函数指针</td>
<td align="left">否</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">回调机制</td>
</tr>
<tr>
<td align="left">Lambda 表达式</td>
<td align="left">是</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">内联匿名逻辑</td>
</tr>
<tr>
<td align="left">仿函数（函数对象）</td>
<td align="left">是</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">需复用的状态逻辑</td>
</tr>
<tr>
<td align="left"><code>std::function</code></td>
<td align="left">是</td>
<td align="left">中</td>
<td align="left">高</td>
<td align="left">统一管理多种可调用对象</td>
</tr>
<tr>
<td align="left">成员函数指针</td>
<td align="left">否</td>
<td align="left">高</td>
<td align="left">中</td>
<td align="left">面向对象回调</td>
</tr>
<tr>
<td align="left"><code>std::bind</code></td>
<td align="left">是</td>
<td align="left">中</td>
<td align="left">高</td>
<td align="left">参数适配、延迟绑定</td>
</tr>
</tbody></table>
<ul>
<li><strong>简单回调：</strong> 使用函数指针或Lambda表达式。</li>
<li><strong>需要携带状态或更复杂逻辑：</strong> 使用Lambda表达式或仿函数（Functors）。</li>
<li><strong>接口要求 <code>std::function</code>：</strong> 使用 <code>std::function</code>，不过要注意可能的性能开销。</li>
<li><strong>参数预绑定：</strong> 使用 <code>std::bind</code>，但在现代C++中，许多情况下Lambda表达式能达到相同效果且更直观。</li>
</ul>
<h5 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// Network event types</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NetworkEvent</span> &#123;</span><br>    CONNECT,<br>    DISCONNECT,<br>    DATA_RECEIVED,<br>    ERROR<br>&#125;;<br><br><span class="hljs-comment">// Event data structure</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EventData</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> clientId;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data;<br>    <span class="hljs-type">int</span> errorCode;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkEventHandler</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// Register callback for specific event</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">registerHandler</span><span class="hljs-params">(NetworkEvent event, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> EventData&amp;)&gt; handler)</span> &#123;<br>        eventHandlers[event] = handler;<br>    &#125;<br><br>    <span class="hljs-comment">// Simulate event occurring</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(NetworkEvent event, <span class="hljs-type">const</span> EventData&amp; data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (eventHandlers.find(event) != eventHandlers.end()) &#123;<br>            eventHandlers[event](data);<br>        &#125;<br>    &#125;<br><br>private:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;NetworkEvent, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> EventData&amp;)&gt;&gt; eventHandlers;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    NetworkEventHandler handler;<br><br>    <span class="hljs-comment">// Register handlers for different events</span><br>    handler.registerHandler(NetworkEvent::CONNECT, <br>        [](<span class="hljs-type">const</span> EventData&amp; data) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Client &quot;</span> &lt;&lt; data.clientId &lt;&lt; <span class="hljs-string">&quot; connected&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    );<br><br>    handler.registerHandler(NetworkEvent::DATA_RECEIVED, <br>        [](<span class="hljs-type">const</span> EventData&amp; data) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Received data from &quot;</span> &lt;&lt; data.clientId &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; data.data &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    );<br><br>    handler.registerHandler(NetworkEvent::ERROR, <br>        [](<span class="hljs-type">const</span> EventData&amp; data) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Error from &quot;</span> &lt;&lt; data.clientId &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; data.errorCode &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// Simulate some network events</span><br>    handler.handleEvent(NetworkEvent::CONNECT, &#123;<span class="hljs-string">&quot;client123&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>&#125;);<br>    handler.handleEvent(NetworkEvent::DATA_RECEIVED, &#123;<span class="hljs-string">&quot;client123&quot;</span>, <span class="hljs-string">&quot;Hello Server!&quot;</span>, <span class="hljs-number">0</span>&#125;);<br>    handler.handleEvent(NetworkEvent::ERROR, &#123;<span class="hljs-string">&quot;client123&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">404</span>&#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><strong>封装（Encapsulation）</strong>：将数据和操作数据的代码绑定在一起，保护数据不被外界直接访问。</li>
<li><strong>抽象（Abstraction）</strong>：通过类定义抽象出具有共同特性的对象，提高代码的可重用性和可维护性。</li>
<li><strong>继承（Inheritance）和多态（Polymorphism）</strong>：实现代码的复用与动态绑定。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// 公有成员</span><br>protected:<br>    <span class="hljs-comment">// 受保护成员  成员函数 &amp; 友元函数 &amp; 派生类</span><br>private:<br>    <span class="hljs-comment">// 私有成员  成员函数 &amp; 友元函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造顺序：</p>
<ol>
<li><p>自动调用父类默认构造函数  （或者在子类初始化列表中主动调用）</p>
</li>
<li><p>成员变量构造（按声明顺序）  如果想要有参构造，需要在初始化列表中</p>
<ol>
<li>初始化列表初始化   -&gt;  默认构造函数初始化</li>
</ol>
</li>
<li><p>当前类构造函数</p>
</li>
</ol>
<p>析构顺序（与构造相反）：</p>
<ol>
<li>当前类析构函数</li>
<li>成员变量析构</li>
<li>父类析构函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoveExample</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// 构造函数  实现了有参后，会删除默认的无参</span><br>    MoveExample(<span class="hljs-type">int</span> size) : size_(size), data_(new <span class="hljs-type">int</span>[size]) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Constructor called.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数   </span><br>      <span class="hljs-comment">// 默认拷贝构造会逐个拷贝 指针是浅拷贝； 如果有const、引用、不可拷贝类型则不会生成默认的</span><br>    MoveExample(<span class="hljs-type">const</span> MoveExample&amp; other) : size_(other.size_), data_(new <span class="hljs-type">int</span>[other.size_]) &#123;<br>        <span class="hljs-built_in">std</span>::copy(other.data_, other.data_ + size_, data_);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Copy constructor called.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    MoveExample(MoveExample&amp;&amp; other) noexcept : size_(other.size_), data_(other.data_) &#123;<br>        other.size_ = <span class="hljs-number">0</span>;<br>        other.data_ = nullptr;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Move constructor called.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值运算符</span><br>    MoveExample&amp; operator=(<span class="hljs-type">const</span> MoveExample&amp; other) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Copy assignment operator called.\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> (this == &amp;other)<br>            <span class="hljs-keyword">return</span> *this;<br><br>        delete[] data_;<br>        size_ = other.size_;<br>        data_ = new <span class="hljs-type">int</span>[size_];<br>        <span class="hljs-built_in">std</span>::copy(other.data_, other.data_ + size_, data_);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MoveExample&amp; operator=(MoveExample&amp;&amp; other) noexcept &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Move assignment operator called.\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> (this == &amp;other)<br>            <span class="hljs-keyword">return</span> *this;<br><br>        delete[] data_;<br>        size_ = other.size_;<br>        data_ = other.data_;<br><br>        other.size_ = <span class="hljs-number">0</span>;<br>        other.data_ = nullptr;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MoveExample() &#123;<br>        delete[] data_;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Destructor called.\n&quot;</span>;<br>    &#125;<br><br>private:<br>    <span class="hljs-type">int</span> size_;<br>    <span class="hljs-type">int</span>* data_;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Example ex1;               <span class="hljs-comment">// 调用默认构造函数</span><br>    Example <span class="hljs-title function_">ex2</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span>;           <span class="hljs-comment">// 调用参数化构造函数</span><br>    Example ex3 = ex2;         <span class="hljs-comment">// 调用拷贝构造函数 等价于 Example ex3(ex2);</span><br>    ex3 = ex2;                  <span class="hljs-comment">// 调用拷贝赋值运算符</span><br><br>    <span class="hljs-comment">// 临时右值</span><br>      MoveExample ex3 = MoveExample(<span class="hljs-number">200</span>);   <span class="hljs-comment">// Constructor + Move Constructor；如果启动rvo会只有Constructor </span><br>  <span class="hljs-comment">// 等价于 MoveExample ex3( MoveExample(200));</span><br>  <br>      ex4 = MoveExample(<span class="hljs-number">400</span>);   <span class="hljs-comment">// Move Assignment</span><br><br>      <span class="hljs-comment">// 显式移动</span><br>    MoveExample <span class="hljs-title function_">obj2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(obj1))</span>;<br>    MoveExample obj2 = <span class="hljs-built_in">std</span>::move(obj1);    <span class="hljs-comment">// 移动构造</span><br>    obj2 = <span class="hljs-built_in">std</span>::move(obj1);                <span class="hljs-comment">// 移动赋值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>浅拷贝：int * 直接拷贝值 <code>data = other.data</code><ul>
<li>如果释放多次资源，就会报错</li>
</ul>
</li>
<li>深拷贝：int * 重新new空间 并设置值相同. <code>data = new int(*other.data)</code></li>
</ul>
<h5 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h5><p>资源所有权的交换</p>
<ul>
<li><code>MoveExample&amp; operator=(MoveExample&amp;&amp; other)</code></li>
<li><code>MoveExample(MoveExample&amp;&amp; other) noexcept</code></li>
</ul>
<h5 id="MyString"><a href="#MyString" class="headerlink" title="MyString"></a>MyString</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span>&#123;</span><br><br>private:<br>    <span class="hljs-comment">// size and data</span><br>    <span class="hljs-type">size_t</span> size_;<br>    <span class="hljs-type">char</span>* data_;<br><br>public:<br><br>    MyString():size_(<span class="hljs-number">0</span>), data_(new <span class="hljs-type">char</span>[<span class="hljs-number">1</span>])&#123;<br>    &#125;<br><br>    MyString(<span class="hljs-type">char</span> * c):size_(<span class="hljs-built_in">strlen</span>(c)), data_(new <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(c)+<span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-built_in">strcpy</span>(data_, c);<br>    &#125;<br><br>    MyString(<span class="hljs-type">const</span> MyString &amp; s2)&#123;<br>        this-&gt;size_ = s2.getSize();<br>        this-&gt;data_ = new <span class="hljs-type">char</span>[this -&gt; size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data_, s2.getData());<br>    &#125;<br><br>    MyString&amp; operator=(<span class="hljs-type">const</span> MyString&amp; s2)&#123;<br>        this-&gt;size_ = s2.getSize();<br><br>        delete[] this-&gt;data_;<br><br>        this-&gt;data_ = new <span class="hljs-type">char</span>[this-&gt;size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(this-&gt;data_, s2.getData());<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    MyString operator+(<span class="hljs-type">const</span> MyString&amp; s2)&#123;<br>        MyString result;<br>        result.size_ = this-&gt;size_ + s2.getSize();<br>        result.data_ = new <span class="hljs-type">char</span>[result.size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(result.data_, this-&gt;data_);<br>        <span class="hljs-built_in">strcat</span>(result.data_, s2.getData());<br><br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;&amp;result&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// MyString&amp; operator+(const MyString&amp; s2)&#123;</span><br>    <span class="hljs-comment">//     size_ = this-&gt;size_ + s2.getSize();</span><br>    <span class="hljs-comment">//     char* tmp = new char[size_ + 1];</span><br>    <span class="hljs-comment">//     strcpy(tmp, this-&gt;data_);</span><br>    <span class="hljs-comment">//     strcat(tmp, s2.getData());</span><br><br>    <span class="hljs-comment">//     delete[] data_;</span><br>    <span class="hljs-comment">//     data_ = tmp;</span><br><br>    <span class="hljs-comment">//     // std::cout&lt;&lt;&amp;result&lt;&lt;std::endl;</span><br><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br><br><br>    MyString(MyString &amp;&amp; s2) noexcept&#123;<br>        this-&gt;size_ = s2.getSize();<br>        this-&gt;data_ = s2.getData();<br>        s2.size_ = <span class="hljs-number">0</span>;<br>        s2.data_ = nullptr;<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;move con&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    MyString&amp; operator=(MyString&amp;&amp; s2)&#123;<br>        this-&gt;size_ = s2.getSize();<br><br>        delete[] this-&gt;data_;<br><br>        this-&gt;data_ = s2.getData();<br>        this-&gt;size_ = s2.getSize();<br>        s2.setData(nullptr);<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;move asi&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    ~MyString()&#123;<br>        delete[] data_;<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;deconstruct&quot;</span> &lt;&lt; <span class="hljs-string">&quot;~MyString(&quot;</span> &lt;&lt; this &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">size_t</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> size_;<br>    &#125;<br><br>    <span class="hljs-type">char</span>* <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> data_;<br>    &#125;<br><br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(<span class="hljs-type">char</span>* newData)</span> &#123;<br>        data_ = newData;<br>    &#125;<br><br><br>    friend <span class="hljs-built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp; os, <span class="hljs-type">const</span> MyString&amp; s);<br><br>&#125;;<br><br><span class="hljs-built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp; os, <span class="hljs-type">const</span> MyString&amp; s)&#123;<br>    os &lt;&lt; s.data_;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="RVO"><a href="#RVO" class="headerlink" title="RVO"></a>RVO</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">MyClass <span class="hljs-title function_">createObject</span><span class="hljs-params">()</span> &#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj;   <br>&#125;<br>MyClass obj2 = createObject();<br><br><br>-fno-elide-constructors<br><br><span class="hljs-comment">// 无优化  还额外创建了一个临时变量；obj-&gt;tmp-&gt;obj2</span><br><span class="hljs-comment">// MyClass constructor  // obj 构造</span><br><span class="hljs-comment">// MyClass copy constructor // 返回值临时对象构造</span><br><span class="hljs-comment">// MyClass destructor       // obj 析构</span><br><span class="hljs-comment">// MyClass copy constructor // obj2 构造</span><br><span class="hljs-comment">// MyClass destructor       // 临时对象析构</span><br><span class="hljs-comment">// MyClass destructor      // obj2 对象析构</span><br><br><br><span class="hljs-comment">// 优化后 直接构造在返回值位置 只构造一次  二者地址相同</span><br><span class="hljs-comment">// MyClass constructor</span><br><span class="hljs-comment">// MyClass destructor</span><br><br><br><span class="hljs-comment">// 内存高地址</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// |                  |</span><br><span class="hljs-comment">// | 主函数栈帧       |</span><br><span class="hljs-comment">// | (result变量)     |</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// | 返回值临时对象   | &lt;- Copy Constructor在这里创建对象</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// | createObject     |</span><br><span class="hljs-comment">// | 函数栈帧        |</span><br><span class="hljs-comment">// | (obj1, obj2)    |</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// |                  |</span><br><span class="hljs-comment">// 内存低地址</span><br></code></pre></td></tr></table></figure>

<ul>
<li>忽略优化的情况下-fno-elide-constructors出现上面的情况</li>
<li>cpp17后，强制不再先构造一个中间临时</li>
</ul>
<h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>访问控制</strong>：也就是min(原权限，继承权限)</p>
<ul>
<li>公有继承（public inheritance）<ul>
<li>基类的 <code>public</code> 成员在派生类中保持 <code>public</code>。</li>
<li>基类的 <code>protected</code> 成员在派生类中保持 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员在派生类中不可访问。</li>
</ul>
</li>
<li>保护继承（protected inheritance）<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>protected</code>。</li>
</ul>
</li>
<li>私有继承（private inheritance）<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>
</ul>
</li>
</ul>
<p><strong>调用顺序：</strong></p>
<ol>
<li><p>基类的 <strong>默认构造函数</strong> 首先被调用，除非派生类在初始化列表中显式调用其他基类构造函数。</p>
</li>
<li><p>派生类的成员按照声明顺序被构造。</p>
</li>
<li><p>派生类的构造函数体被执行。</p>
</li>
<li><p>派生类先析构。再子类</p>
</li>
</ol>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>实现多态：</p>
<ul>
<li>通过对象直接调用函数时，表现与非虚函数相同，直接调用子类</li>
<li>通过<strong>基类指针&#x2F;引用</strong>调用函数时，会调用实际子类的函数实现，从而实现多态</li>
<li>当把一个子类对象直接赋值给父类对象（不是指针或引用）时，发生<strong>对象切片</strong> 派生类特性丢失 变成调用父类了，同样<code>vector&lt;Base&gt;</code>也会</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>public:<br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> public Base &#123;<br>public:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> override &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; base)</span> &#123;<br>    base.show(); <span class="hljs-comment">// 动态绑定，根据实际对象类型调用对应的show()</span><br>&#125;<br><br><br><br><span class="hljs-comment">// 子类中，还可以调用父类的，用于扩展父类行为而非完全替换它、装饰器模式</span><br>Shape::draw();  <span class="hljs-comment">// 调用父类的draw方法</span><br></code></pre></td></tr></table></figure>

<h6 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a><strong>虚函数原理</strong></h6><ul>
<li><p>每个包含虚函数的类都有一个**虚函数表 (vtable)**，类对象通过 <strong>vptr</strong> 指向这个表的地址</p>
</li>
<li><p>表中存储着虚函数的地址。编译时创建</p>
</li>
<li><p>Sizeof(a) 会显示这个对象所占用空间，如果有虚函数需要多8个字节vptr，如果还有一个int结合内存对齐需要16</p>
</li>
<li><pre><code class="hljs">+---------------+
|     vptr      | -----&gt; +-----------------+
+---------------+        | 虚函数表(vtable) |
|   成员变量1    |        +-----------------+
+---------------+        | virtualFunc1()  |
|   成员变量2    |        +-----------------+
+---------------+        | virtualFunc2()  |
                         +-----------------+
                         | virtualFunc3()  |
                         +-----------------+
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><br>```c<br>typedef void<span class="hljs-comment">(*Fun)(void*)</span><span class="hljs-punctuation">;</span><br><br>Base* ptr = <span class="hljs-keyword">new</span> Derived()<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">// 获取vptr，ptr是一个地址，内容还是一个地址 所以转换为：指向指针void* 的地址。这个指针代表着虚函数表的起始地址</span><br>void* vptr = *(void**)ptr<span class="hljs-punctuation">;</span><br><span class="hljs-comment">// 获取虚函数表中f1的地址（在虚函数表中的偏移为0）  long long代表取这个地址中8位的数据，long long*等价于void**</span><br>Fun f = (Fun)<span class="hljs-comment">(*(long long*)</span>vptr)<span class="hljs-punctuation">;</span><br><span class="hljs-comment">// 调用f1</span><br>f(ptr)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure>

// 获取虚函数表中f2的地址（在虚函数表中的偏移为+8个字节）
Fun f2 = (Fun)(*((long long*)vptr + 1));
// 调用f1
f2(ptr);

当然vptr是指向函数(void*)的指针，也可以用
void** vptr = *(void***)ptr;
Fun f = (Fun)(*vptr);   // (Fun)(vptr[0]);

// 取出变量
std::cout&lt;&lt; *(int*)((void**)ptr + 1) &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- 当虚函数重写后，f地址不同，否则是相同的；普通的函数不需要vptr，函数放到代码段固定地址，编译时就确定函数地址，少一个查表过程相对更高效<br><br><br><br>包含**纯虚函数**的类为**抽象基类**，不能被初始化<br><br>```c<br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pureVirtualFunction</span>()</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printm</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h6 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a><strong>虚析构</strong></h6><p>避免当我们通过基类指针删除一个派生类对象时，派生类的资源没有被正确释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>public:<br>    Base() &#123; <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base constructor\n&quot;</span>; <br>    &#125;<br>    <span class="hljs-comment">// 情况1：普通析构函数</span><br>    <span class="hljs-comment">// ~Base() &#123; </span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; &quot;Base destructor\n&quot;; </span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 情况2：虚析构函数</span><br>    virtual ~Base() &#123; <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base destructor\n&quot;</span>; <br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> public Base &#123;<br>private:<br>    <span class="hljs-type">int</span>* data;<br>public:<br>    Derived() : data(new <span class="hljs-type">int</span>(<span class="hljs-number">100</span>)) &#123; <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Derived constructor\n&quot;</span>; <br>    &#125;<br>    ~Derived() &#123; <br>        delete data;  <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Derived destructor\n&quot;</span>; <br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Base* ptr = new Derived();<br>    delete ptr;  <span class="hljs-comment">// 如果Base析构函数不是virtual，这里只会调用Base的析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h6><ul>
<li>虚继承主要用于解决菱形继承中的数据重复问题</li>
<li>在无虚继承的情况下，<code>Convertible</code> 类将拥有两份 <code>Device</code> 的成员变量，这会导致二义性问题。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-comment">// 不使用虚继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> :</span> public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span> :</span> public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D1</span> :</span> public B1, public C1 &#123;&#125;;<br><br><span class="hljs-comment">// 使用虚继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> :</span> virtual public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C2</span> :</span> virtual public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D2</span> :</span> public B2, public C2 &#123;&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    D1 d1;  <span class="hljs-comment">// 菱形继承</span><br>    <span class="hljs-comment">// d1.data;        // 错误：数据模糊</span><br>    d1.B1::data = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 必须指定路径</span><br>    d1.C1::data = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 两份数据</span><br><br>    D2 d2;  <span class="hljs-comment">// 虚继承</span><br>    d2.data = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 正确：只有一份数据</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h5><ul>
<li><p>delete <code>DefaultClass(const DefaultClass &amp;) = delete; </code>  单例下删除一些函数，或者防止资源复制</p>
</li>
<li><p>移动构造和拷贝构造：性能更高，直接转移空间而不是复制资源，适用于临时对象</p>
</li>
<li><p>初始化列表作用：提高性能、常量成员和引用必须、避免先构造再赋值减少开销</p>
</li>
<li><p>析构函数作用：主线程等待子循环、资源释放</p>
</li>
<li><p>RAII：构造函数获取资源，析构函数释放资源，确保资源不会泄漏</p>
<ul>
<li><pre><code class="c">void unsafeFunction() &#123;
    mtx.lock();
    std::cout &lt;&lt; &quot;Thread is working...&quot; &lt;&lt; std::endl;
    // 如果这里有异常，mutex 将无法解锁，导致死锁
    mtx.unlock();
&#125;

void safeFunction() &#123;
    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 自动加锁
    std::cout &lt;&lt; &quot;Thread is working...&quot; &lt;&lt; std::endl;
&#125;  // 作用域结束，自动解锁
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 自定义guard</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockGuard</span> &#123;<br><span class="hljs-keyword">private</span>:<br><br>    std::mutex&amp; mtx;  <span class="hljs-comment">// 引用外部互斥锁</span><br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LockGuard</span><span class="hljs-params">(std::mutex&amp; m)</span> : mtx(m) &#123;</span><br>        mtx.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// 构造函数加锁</span><br>    &#125;<br>    <br>    ~<span class="hljs-built_in">LockGuard</span>() &#123;<br>        mtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 析构函数解锁</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 禁止拷贝和赋值，防止多个 LockGuard 实例管理同一把锁</span><br>    <span class="hljs-built_in">LockGuard</span>(<span class="hljs-type">const</span> LockGuard&amp;) = <span class="hljs-keyword">delete</span>;<br>    LockGuard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LockGuard&amp;) = <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-operator">-</span> 静态成员在程序开始时初始化，结束时析构<br>  <br>  ```c<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-keyword">static</span> <span class="hljs-type">MyClass</span> instance;<br>      <span class="hljs-type">MyClass</span>() &#123; cout <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;构造<span class="hljs-subst">\n</span>&quot;</span>; &#125;<br>      <span class="hljs-operator">~</span><span class="hljs-type">MyClass</span>() &#123; cout <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;析构<span class="hljs-subst">\n</span>&quot;</span>; &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 放在类外面的 cpp中</span><br>  <span class="hljs-type">MyClass</span> <span class="hljs-type">MyClass</span>::instance; <span class="hljs-comment">// 静态成员变量定义</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>C++ 提供了多种内存管理方式，包括传统的 C 风格的 <code>malloc</code> 和 <code>free</code>，以及 C++ 专用的 <code>new</code> 和 <code>delete</code>。</p>
<p>在 C++ 程序中，内存主要分为以下几个区域：</p>
<ul>
<li><p><strong>栈（Stack）</strong>：自动管理内存，存储局部变量和函数调用信息。内存分配和释放速度快，但空间有限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;      <span class="hljs-comment">// x存储在栈上</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;    <span class="hljs-comment">// c存储在栈上</span><br>&#125; <span class="hljs-comment">// 函数结束时，x和c自动释放</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>堆（Heap）</strong>：手动管理内存，用于动态分配内存。内存分配和释放由程序员控制，灵活但易出错（如内存泄漏、悬挂指针）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 内存在堆上分配</span><br><span class="hljs-comment">// 使用p指向的内存...</span><br>delete p;                <span class="hljs-comment">// 必须手动释放内存，否则会造成内存泄漏</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>全局&#x2F;静态区（<code>Data/BSS Segment</code>）</strong>：存储全局变量和静态变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 全局变量存储在全局区</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar = <span class="hljs-number">5</span>; <span class="hljs-comment">// 静态变量存储在静态区</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc&#x2F;free"></a>malloc&#x2F;free</h5><ul>
<li><strong>类型转换</strong>：<code>malloc</code> 返回 <code>void*</code>，需要显式转换为所需类型的指针。</li>
<li><strong>初始化</strong>：<code>malloc</code> 分配的内存未初始化，内容不确定。</li>
<li><strong>释放对应性</strong>：由 <code>malloc</code> 分配的内存必须使用 <code>free</code> 释放，避免使用 <code>delete</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// 包含 malloc 和 free</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 分配一个整数的内存</span><br>    <span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (p == nullptr) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    *p = <span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(p);<br><br><br>    <span class="hljs-comment">// 分配一个数组的内存  [ 记录的大小（20） | 你可以用的20字节 ]</span><br>    p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="new-delete"><a href="#new-delete" class="headerlink" title="new&#x2F;delete"></a>new&#x2F;delete</h5><ul>
<li><strong>类型安全</strong>：<code>new</code> 返回正确类型的指针，免去了强制类型转换。</li>
<li><strong>构造&#x2F;析构</strong>：<code>new</code> 和 <code>delete</code> 自动调用构造函数和析构函数。</li>
<li><strong>异常处理</strong>：在分配失败时，<code>new</code> 默认抛出 <code>std::bad_alloc</code> 异常，而 <code>malloc</code> 返回 <code>nullptr</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Type* ptr = new Type(parameters);<br>Type* <span class="hljs-built_in">array</span> = new Type[size];<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br>public:<br>    MyClass(<span class="hljs-type">int</span> val) : value(val) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~MyClass() &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Destructor called for value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    MyClass* obj = new MyClass(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    delete obj; <span class="hljs-comment">// 调用析构函数并释放内存</span><br><br><br>    <span class="hljs-type">int</span>* arr = new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 分配5个整数  对类会调用默认构造函数</span><br>    delete[] arr; <span class="hljs-comment">// 释放数组内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>可能的内存布局:<span class="hljs-type">size_t</span>用于delete[]<br>+----------------+------------------------------------------------------------+<br>| 长度信息(<span class="hljs-type">size_t</span>) | 对象<span class="hljs-number">1</span> | 对象<span class="hljs-number">2</span> | 对象<span class="hljs-number">3</span> | ... | 对象n |<br>+----------------+------------------------------------------------------------+<br>^                 ^<br>|                 |<br>内部指针           返回给用户的指针<br></code></pre></td></tr></table></figure>

<p>可以通过 <code>nothrow</code> 参数防止 <code>new</code> 抛出异常，改为返回 <code>nullptr</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = new(<span class="hljs-built_in">std</span>::nothrow) <span class="hljs-type">int</span>;<br><span class="hljs-keyword">if</span> (p == nullptr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;malloc failed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>特性</th>
<th>malloc&#x2F;free</th>
<th>new&#x2F;delete</th>
</tr>
</thead>
<tbody><tr>
<td>类型安全</td>
<td>需要显式类型转换</td>
<td>自动类型转换，无需显式转换</td>
</tr>
<tr>
<td>构造&#x2F;析构函数</td>
<td><strong>不调用</strong>对象的构造&#x2F;析构函数</td>
<td>调用对象的构造&#x2F;析构函数</td>
</tr>
<tr>
<td>返回值</td>
<td><code>void*</code>，需要转换为目标类型</td>
<td>返回目标类型指针，类型安全</td>
</tr>
<tr>
<td>错误处理</td>
<td>分配失败返回 <code>nullptr</code></td>
<td>分配失败抛出 <code>std::bad_alloc</code> 异常</td>
</tr>
<tr>
<td>多态行为</td>
<td>无</td>
<td>支持多态，通过虚函数正确调用析构函数</td>
</tr>
<tr>
<td>内存分配与释放对应性</td>
<td>必须使用 <code>free</code> 释放由 <code>malloc</code> 分配的内存</td>
<td>必须使用 <code>delete</code> 释放由 <code>new</code> 分配的内存</td>
</tr>
</tbody></table>
<p>重新分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 重新分配为 5 个整数</span><br><span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(arr, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (temp == nullptr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Realloc failed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">free</span>(arr); <span class="hljs-comment">// 释放原内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>arr = temp;<br></code></pre></td></tr></table></figure>



<h5 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h5><ul>
<li><code>operator new[]</code> 是一个<strong>内存分配函数</strong>，用于为<strong>动态数组</strong>分配内存。类似于malloc。需要结合placement new使用</li>
<li>::表示这是调用<strong>全局作用域中的版本</strong>，避免调用类中重载的 <code>operator new[]</code>。</li>
<li><code>::operator new[]</code> 是一种<strong>低层级、无构造行为的内存分配方式</strong>，适用于对内存管理和性能有<strong>精细要求的场景</strong>，比如容器实现、内存池、自定义 allocator 等，实现延时构造以及适配无默认构造函数。</li>
<li>new T 底层会调用operator new + 执行构造函数，delete T底层析构+::operator delete</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* mem = ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">sizeof</span>(MyClass) * <span class="hljs-number">10</span>);  <span class="hljs-comment">// 只分配内存</span><br>MyClass* p = <span class="hljs-built_in">static_cast</span>&lt;MyClass*&gt;(mem);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">new</span> (p + i) <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// placement new 构造对象</span><br>&#125;<br><br><span class="hljs-comment">// later: 手动析构并释放</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    (p + i)-&gt;~<span class="hljs-built_in">MyClass</span>();<br>&#125;<br>::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](mem);<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作</th>
<th>分配内存</th>
<th>调用构造</th>
<th>调用析构</th>
<th>释放内存</th>
</tr>
</thead>
<tbody><tr>
<td><code>new T</code></td>
<td>✅</td>
<td>✅</td>
<td>（配合 <code>delete</code>）</td>
<td>（配合 <code>delete</code>）</td>
</tr>
<tr>
<td>delete</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>::operator new</code></td>
<td>✅</td>
<td></td>
<td></td>
<td>（配合 <code>delete</code>）</td>
</tr>
<tr>
<td><code>new (ptr) T</code><br /> (placement new)</td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>obj-&gt;~T()</code></td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td><code>::operator delete</code></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
</tr>
</tbody></table>
<h5 id="动态数组-1"><a href="#动态数组-1" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> &#123;</span><br>public:<br>    DynamicArray()<br>        : capacity(<span class="hljs-number">2</span>), size(<span class="hljs-number">0</span>), data((<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (data == nullptr) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>    &#125;<br><br>    ~DynamicArray() &#123;<br>        <span class="hljs-built_in">free</span>(data);<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            resize(capacity * <span class="hljs-number">2</span>);<br>        &#125;<br>        data[size++] = value;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            throw <span class="hljs-built_in">std</span>::out_of_range(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> size; &#125;<br><br>private:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> new_capacity)</span> &#123;<br>        <span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(data, new_capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (temp == nullptr) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>        data = temp;<br>        capacity = new_capacity;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> capacity;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-type">int</span>* data;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    try &#123;<br>        DynamicArray arr;<br>        arr.add(<span class="hljs-number">10</span>);<br>        arr.add(<span class="hljs-number">20</span>);<br>        arr.add(<span class="hljs-number">30</span>); <span class="hljs-comment">// 触发扩展</span><br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Dynamic Array Contents:&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.getSize(); ++i) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; arr.get(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    catch (<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::bad_alloc&amp; e) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    catch (<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::out_of_range&amp; e) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Array access error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h5><p>提前new了空间，这个空间被当作student还是别的类使用都不关pool，pool只负责提供相应大小的空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPool</span> &#123;</span><br>public:<br>    MemoryPool(<span class="hljs-type">size_t</span> objectSize, <span class="hljs-type">size_t</span> poolSize)<br>        : objSize(objectSize), totalSize(poolSize), pool((<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(objectSize * poolSize)) &#123;<br>        <span class="hljs-keyword">if</span> (pool == nullptr) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>        <span class="hljs-comment">// 初始化 free list</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; ++i) &#123;<br>            freeList.push(pool + i * objectSize);<br>        &#125;<br>    &#125;<br><br>    ~MemoryPool() &#123;<br>        <span class="hljs-built_in">free</span>(pool);<br>    &#125;<br><br>    <span class="hljs-type">void</span>* <span class="hljs-title function_">allocate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (freeList.empty()) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>        <span class="hljs-type">void</span>* ptr = freeList.top();<br>        freeList.pop();<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>        freeList.push((<span class="hljs-type">char</span>*)ptr);<br>    &#125;<br><br>private:<br>    <span class="hljs-type">size_t</span> objSize;<br>    <span class="hljs-type">size_t</span> totalSize;<br>    <span class="hljs-type">char</span>* pool;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">void</span>*&gt; freeList;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br>public:<br>    MyClass(<span class="hljs-type">int</span> val) : value(val) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~MyClass() &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    try &#123;<br>        <span class="hljs-comment">// 创建一个能容纳 3 个 MyClass 对象的内存池</span><br>        MemoryPool <span class="hljs-title function_">pool</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(MyClass), <span class="hljs-number">3</span>)</span>;<br><br>        <span class="hljs-comment">// 分配对象内存</span><br>        <span class="hljs-type">void</span>* mem1 = pool.allocate();<br>        <span class="hljs-type">void</span>* mem2 = pool.allocate();<br><br>        <span class="hljs-comment">// 使用“定位 new”构造对象</span><br>        MyClass* obj1 = new(mem1) MyClass(<span class="hljs-number">100</span>);<br>        MyClass* obj2 = new(mem2) MyClass(<span class="hljs-number">200</span>);<br><br>        <span class="hljs-comment">// 使用对象</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;obj1 value: &quot;</span> &lt;&lt; obj1-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;obj2 value: &quot;</span> &lt;&lt; obj2-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>        <span class="hljs-comment">// 显式调用析构函数</span><br>        obj1-&gt;~MyClass();<br>        obj2-&gt;~MyClass();<br><br>        <span class="hljs-comment">// 释放内存</span><br>        pool.deallocate(mem1);<br>        pool.deallocate(mem2);<br><br>    &#125;<br>    catch (<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::bad_alloc&amp; e) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Memory pool allocation error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><h5 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h5><p><strong>栈展开</strong>：当异常被抛出时，程序会沿着函数调用栈回溯，查找能够处理该异常的catch块。在这个过程中，所有途经函数中已构造的局部对象都会被正确析构，从而释放资源和执行清理操作。<strong>但new的对象，delete并不会执行</strong>。</p>
<ul>
<li>在C++中，函数内部创建的局部对象的生命周期绑定到其作用域（即花括号<code>&#123;&#125;</code>限定的代码块）</li>
<li>当离开作用域时，局部对象会自动析构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">()</span> &#123;<br>    Resource <span class="hljs-title function_">r3</span><span class="hljs-params">(<span class="hljs-string">&quot;in function3&quot;</span>)</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Function 3 begins throwing exception&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    throw <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Exception from function3&quot;</span>);<br>    <span class="hljs-comment">// This line won&#x27;t execute， but ～Resource()  will execute</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Function 3 ends&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>后面的智能指针的原理其实还是依靠<strong>指针对象栈展开时，自动调用析构函数</strong>实现资源的释放</p>
<p>RAII通过将资源管理与对象生命周期绑定，提供了一种高效、安全的资源管理方式，能够在大多数情况下替代<code>try-catch-finally</code>结构</p>
<h5 id="new问题"><a href="#new问题" class="headerlink" title="new问题"></a>new问题</h5><ul>
<li><p>忘记释放内存导致的内存泄漏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">functionWithLeak</span><span class="hljs-params">()</span> &#123;<br>    MyClass* ptr = new MyClass(); <span class="hljs-comment">// 分配内存</span><br><br>    <span class="hljs-comment">// 某些操作...</span><br><br>    <span class="hljs-keyword">if</span> (someCondition) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 在这里返回，忘记释放内存</span><br>    &#125;<br><br>    <span class="hljs-comment">// 更多操作...</span><br><br>    delete ptr; <span class="hljs-comment">// 如果提前返回，永远不会执行到这一行</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">functionNoLeak</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;(); <span class="hljs-comment">// 分配内存  提高效率和异常安全性</span><br><br>    <span class="hljs-comment">// 某些操作...</span><br><br>    <span class="hljs-keyword">if</span> (someCondition) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 即使在这里返回，智能指针也会自动释放内存</span><br>    &#125;<br><br>    <span class="hljs-comment">// 更多操作...</span><br><br>    <span class="hljs-comment">// 不需要手动delete，智能指针离开作用域时自动释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>重复释放内存导致的未定义行为， 或<strong>悬挂指针</strong>指向已经释放的内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">processData</span><span class="hljs-params">(MyClass* ptr, <span class="hljs-type">bool</span> takeOwnership)</span> &#123;<br>    <span class="hljs-comment">// 使用ptr...</span><br><br>    <span class="hljs-keyword">if</span> (takeOwnership) &#123;<br>        delete ptr; <span class="hljs-comment">// 只有在需要负责释放时才delete</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> &#123;<br>    MyClass* ptr = new MyClass();<br>    processData(ptr, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 调用者保留所有权</span><br><br>    <span class="hljs-comment">// 其他操作...</span><br><br>    delete ptr; <span class="hljs-comment">// 调用者必须记得删除</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种模式容易导致混淆：谁应该删除指针？可能导致重复释放（double delete）或者忘记释放。</p>
<p>智能指针通过明确的所有权语义解决了这个问题：</p>
<ul>
<li><code>unique_ptr</code>：表示独占所有权，清楚地表明谁负责资源</li>
<li><code>shared_ptr</code>：表示共享所有权，当所有共享者都不再需要该资源时自动释放</li>
<li><code>weak_ptr</code>：表示无所有权的观察者，不影响资源的生命周期</li>
</ul>
</li>
<li><p>异常发生时确保资源正确释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">functionWithLeakOnException</span><span class="hljs-params">()</span> &#123;<br>    MyClass* ptr = new MyClass();<br><br>    <span class="hljs-comment">// 某些可能抛出异常的操作...</span><br>    riskyOperation(); <span class="hljs-comment">// 如果这里抛出异常，后面的delete不会执行</span><br><br>    delete ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">functionSafeWithException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;();<br><br>    <span class="hljs-comment">// 某些可能抛出异常的操作...</span><br>    riskyOperation(); <span class="hljs-comment">// 即使抛出异常，智能指针的析构函数仍会被调用</span><br><br>    <span class="hljs-comment">// 无需手动delete</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>任何时候只有一个对象含有所有权，一次没有拷贝只有移动</p>
<p>管理mutex、thread、singleton、boost::asiio iocontext</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个 unique_ptr</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Test&gt; <span class="hljs-title function_">ptr1</span><span class="hljs-params">(new Test(<span class="hljs-number">100</span>))</span>;<br>    ptr1-&gt;show();<br><br>    <span class="hljs-comment">// 使用 make_unique（C++14 引入）</span><br>    <span class="hljs-keyword">auto</span> ptr2 = <span class="hljs-built_in">std</span>::make_unique&lt;Test&gt;(<span class="hljs-number">200</span>);<br>    ptr2-&gt;show();<br><br>    <span class="hljs-comment">// 移动 unique_ptr</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Test&gt; ptr3 = <span class="hljs-built_in">std</span>::move(ptr1);<br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ptr3-&gt;show();<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>template&lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUniquePtr</span> &#123;</span><br>private:<br>    T* ptr;<br><br>public:<br>    <span class="hljs-comment">// 构造函数</span><br>    explicit <span class="hljs-title function_">MyUniquePtr</span><span class="hljs-params">(T* p = nullptr)</span> : <span class="hljs-title function_">ptr</span><span class="hljs-params">(p)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MyUniquePtr() &#123;<br>        <span class="hljs-keyword">if</span> (ptr) &#123;<br>            delete ptr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝</span><br>    MyUniquePtr(<span class="hljs-type">const</span> MyUniquePtr&amp;) = delete;<br>    MyUniquePtr&amp; operator=(<span class="hljs-type">const</span> MyUniquePtr&amp;) = delete;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    MyUniquePtr(MyUniquePtr&amp;&amp; other) noexcept : ptr(other.ptr) &#123;<br>        other.ptr = nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MyUniquePtr&amp; operator=(MyUniquePtr&amp;&amp; other) noexcept &#123;<br>        <span class="hljs-keyword">if</span> (this != &amp;other) &#123;<br>            delete ptr;<br>            ptr = other.ptr;<br>            other.ptr = nullptr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 访问操作</span><br>    T&amp; operator*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125;<br>    T* operator-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T* <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br><br>    <span class="hljs-comment">// 放弃所有权</span><br>    T* <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        T* temp = ptr;<br>        ptr = nullptr;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br>    <span class="hljs-comment">// 重置指针</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(T* p = nullptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ptr != p) &#123;<br>            delete ptr;<br>            ptr = p;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    explicit operator <span class="hljs-title function_">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr != nullptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Student&gt; <span class="hljs-title function_">stdPtr</span><span class="hljs-params">(new Student())</span>;<br><span class="hljs-keyword">auto</span> stdPtr2 = <span class="hljs-built_in">std</span>::make_shared&lt;Student&gt;();<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>template&lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySharedPtr</span> &#123;</span><br>private:<br>    T* ptr;<br>    <span class="hljs-type">size_t</span>* ref_count;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">decrease_ref</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (ptr &amp;&amp; ref_count) &#123;<br>            (*ref_count)--;<br>            <span class="hljs-keyword">if</span> (*ref_count == <span class="hljs-number">0</span>) &#123;<br>                delete ptr;<br>                delete ref_count;<br>                ptr = nullptr;<br>                ref_count = nullptr;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>public:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    MySharedPtr() : ptr(nullptr), ref_count(nullptr) &#123;&#125;<br><br>    <span class="hljs-comment">// 接收原始指针的构造函数</span><br>    explicit <span class="hljs-title function_">MySharedPtr</span><span class="hljs-params">(T* p)</span> : <span class="hljs-title function_">ptr</span><span class="hljs-params">(p)</span>, <span class="hljs-title function_">ref_count</span><span class="hljs-params">(nullptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            ref_count = new <span class="hljs-type">size_t</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    MySharedPtr(<span class="hljs-type">const</span> MySharedPtr&amp; other) : ptr(other.ptr), ref_count(other.ref_count) &#123;<br>        <span class="hljs-keyword">if</span> (ref_count) &#123;<br>            (*ref_count)++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值运算符</span><br>    MySharedPtr&amp; operator=(<span class="hljs-type">const</span> MySharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (this != &amp;other) &#123;<br>            decrease_ref();<br><br>            ptr = other.ptr;<br>            ref_count = other.ref_count;<br><br>            <span class="hljs-keyword">if</span> (ref_count) &#123;<br>                (*ref_count)++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    MySharedPtr(MySharedPtr&amp;&amp; other) noexcept : ptr(other.ptr), ref_count(other.ref_count) &#123;<br>        other.ptr = nullptr;<br>        other.ref_count = nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MySharedPtr&amp; operator=(MySharedPtr&amp;&amp; other) noexcept &#123;<br>        <span class="hljs-keyword">if</span> (this != &amp;other) &#123;<br>            decrease_ref();<br><br>            ptr = other.ptr;<br>            ref_count = other.ref_count;<br><br>            other.ptr = nullptr;<br>            other.ref_count = nullptr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MySharedPtr() &#123;<br>        decrease_ref();<br>    &#125;<br><br>    <span class="hljs-comment">// 访问操作</span><br>    T&amp; operator*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125;<br>    T* operator-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T* <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br><br>    <span class="hljs-comment">// 获取引用计数</span><br>    <span class="hljs-type">size_t</span> <span class="hljs-title function_">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>        <span class="hljs-keyword">return</span> (ref_count ? *ref_count : <span class="hljs-number">0</span>); <br>    &#125;<br><br>    <span class="hljs-comment">// 重置指针</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(T* p = nullptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ptr != p) &#123;<br>            decrease_ref();<br><br>            ptr = p;<br>            <span class="hljs-keyword">if</span> (p) &#123;<br>                ref_count = new <span class="hljs-type">size_t</span>(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ref_count = nullptr;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    explicit operator <span class="hljs-title function_">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr != nullptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// MyUniquePtr 示例</span><br>    &#123;<br>        <span class="hljs-function">MyUniquePtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;up1: &quot;</span> &lt;&lt; *up1 &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 移动所有权</span><br>        MyUniquePtr&lt;<span class="hljs-type">int</span>&gt; up2 = std::<span class="hljs-built_in">move</span>(up1);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;up2: &quot;</span> &lt;&lt; *up2 &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// up1 现在不拥有任何资源</span><br>        <span class="hljs-keyword">if</span> (!up1) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;up1 is now empty&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125; <span class="hljs-comment">// up2 自动释放资源</span><br><br>    <span class="hljs-comment">// MySharedPtr 示例</span><br>    &#123;<br>        <span class="hljs-function">MySharedPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">100</span>))</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 count: &quot;</span> &lt;&lt; sp<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        &#123;<br>            MySharedPtr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;After copy, sp1 count: &quot;</span> &lt;&lt; sp<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;<br>        &#125; <span class="hljs-comment">// sp2 析构，计数减一</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;After inner scope, sp1 count: &quot;</span> &lt;&lt; sp<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-comment">// sp1 析构，资源被释放</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><ul>
<li><strong>非拥有所有权</strong>：不增加引用计数。</li>
<li><strong>可从 <code>shared_ptr</code> 生成</strong>：通过 <code>std::weak_ptr</code> 可以访问 <code>shared_ptr</code> 管理的对象。</li>
<li><strong>避免循环引用</strong>：适用于双向关联或观察者模式。</li>
</ul>
<p>在存在双向关联（如父子关系）时，使用多个 <code>shared_ptr</code> 可能导致循环引用，导致内存泄漏。此时，可以使用 <code>weak_ptr</code> 来打破循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; b_ptr;<br><br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A 构造函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A 析构函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::weak_ptr&lt;A&gt; a_ptr; <span class="hljs-comment">// 改用 weak_ptr，不增加引用计数</span><br><br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B 构造函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B 析构函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>        std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>        a-&gt;b_ptr = b;<br>        b-&gt;a_ptr = a; <span class="hljs-comment">// weak_ptr 不会增加引用计数</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a 的引用计数: &quot;</span> &lt;&lt; a.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;b 的引用计数: &quot;</span> &lt;&lt; b.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-comment">// 离开作用域</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main 函数结束&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 现在会看到析构函数被调用</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h5><p>有时，默认的 <code>delete</code> 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileDeleter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE* fp)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (fp) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Closing file.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-built_in">fclose</span>(fp);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;FILE&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), FileDeleter())</span></span>;<br>        <span class="hljs-keyword">if</span> (filePtr) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-comment">// 使用 filePtr 进行文件操作</span><br>            <span class="hljs-built_in">fprintf</span>(filePtr.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-comment">// 自动关闭文件</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><table>
<thead>
<tr>
<th>分类</th>
<th>容器类型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序列容器</strong></td>
<td><code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></td>
</tr>
<tr>
<td><strong>关联容器</strong></td>
<td><code>set</code>&#x2F;<code>multiset</code>、<code>map</code>&#x2F;<code>multimap </code> 红黑树</td>
</tr>
<tr>
<td><strong>无序关联容器</strong></td>
<td><code>unordered_set</code>&#x2F;<code>unordered_multiset</code>、<code>unordered_map</code>&#x2F;<code>unordered_multimap</code>  哈希表</td>
</tr>
<tr>
<td><strong>容器适配器</strong></td>
<td><code>stack</code>、<code>queue</code>、<code>priority_queue</code></td>
</tr>
</tbody></table>
<h5 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h5><p>内部使用动态数组，可随机访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个空的整数vector</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; numbers;<br><br><span class="hljs-comment">// 向vector末尾添加元素</span><br>numbers.push_back(<span class="hljs-number">10</span>);<br>numbers[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = numbers.begin(); it != numbers.end(); ++it) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>numbers.pop_back();<br></code></pre></td></tr></table></figure>

<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>多个不连续的固定大小缓冲区，可随机访问，并且中间插入相较于vector效率更好</p>
<ul>
<li>频繁头尾插入</li>
<li>随机访问</li>
<li>较少的中间插入操作</li>
</ul>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><ul>
<li>固定大小数组的封装，大小在编译时确定</li>
<li>性能与原生数组相当</li>
<li>提供边界检查和额外安全特性</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 随机访问</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第三个元素: &quot;</span> &lt;&lt; arr[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 边界检查访问</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第四个元素: &quot;</span> &lt;&lt; arr.at(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;所有元素: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : arr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>

<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>内部使用双向链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 在开头和结尾添加元素</span><br>lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">// 在中间插入元素</span><br><span class="hljs-keyword">auto</span> it = lst.<span class="hljs-built_in">begin</span>();<br>std::<span class="hljs-built_in">advance</span>(it, <span class="hljs-number">3</span>); <span class="hljs-comment">// 移动到第四个位置</span><br>lst.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">99</span>);<br><br><span class="hljs-comment">// 遍历列表</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;所有元素: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : lst) &#123;<br>    std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-built_in">front</span>(), <span class="hljs-built_in">back</span>()<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h5 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h5><ul>
<li><strong>查找操作</strong><ul>
<li><code>find()</code>：查找指定值的迭代器   <code>x.find(name) != x.end()</code></li>
<li><code>count()</code>：统计指定值的元素个数</li>
<li><code>empty()、size()</code>: 容器元素数量</li>
<li><code>equal_range()</code>：返回等于指定值的元素范围</li>
</ul>
</li>
<li><strong>修改操作</strong><ul>
<li><code>insert()</code>：插入元素</li>
<li><code>erase()</code>：删除元素</li>
<li><code>clear()</code>：清空</li>
</ul>
</li>
<li><strong>有序容器</strong><ul>
<li><code>lower_bound()</code>：返回不小于k的第一个元素</li>
<li><code>upper_bound()</code>：返回大于k的第一个元素</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 5只会被存储一次</span><br>s.insert(<span class="hljs-number">6</span>);<br><br><span class="hljs-keyword">if</span> (s.find(<span class="hljs-number">3</span>) != s.end())<br></code></pre></td></tr></table></figure>

<h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p>stack</p>
<ul>
<li><code>push()</code>：压栈</li>
<li><code>pop()</code>：出栈</li>
<li><code>top()</code>：访问栈顶元素</li>
<li><code>emplace()</code>：原地构造并压栈</li>
</ul>
<p>queue</p>
<ul>
<li><code>push()</code>：入队</li>
<li><code>pop()</code>：出队</li>
<li><code>front()</code>：访问队首元素</li>
<li><code>back()</code>：访问队尾元素</li>
<li><code>emplace()</code>：原地构造并入队</li>
</ul>
<p>priority_queue</p>
<ul>
<li><code>push()</code>：入队</li>
<li><code>pop()</code>：出队（移除最高优先级元素）</li>
<li><code>top()</code>：访问最高优先级元素</li>
<li><code>emplace()</code>：原地构造并入队</li>
</ul>
<h5 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h5><p>为容器提供内存分配和释放的机制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleAllocator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <br>    <span class="hljs-built_in">SimpleAllocator</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-built_in">SimpleAllocator</span>(<span class="hljs-type">const</span> SimpleAllocator&lt;U&gt;&amp;) &#123;&#125;<br>    <br>    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">max_size</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(std::<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(T)))) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Allocated &quot;</span> &lt;&lt; <span class="hljs-function">n * <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;&lt; &quot; bytes\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* p, std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">free</span>(p);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Deallocated &quot;</span> &lt;&lt; <span class="hljs-function">n * <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;&lt; &quot; bytes\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">max_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">size_t</span>(<span class="hljs-number">-1</span>) / <span class="hljs-built_in">sizeof</span>(T);<br>    &#125;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* p, Args&amp;&amp;... args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span>(p) <span class="hljs-built_in">U</span>(std::forward&lt;Args&gt;(args)...);<br>    &#125;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* p)</span> </span>&#123;<br>        p-&gt;~<span class="hljs-built_in">U</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 比较运算符，使分配器可以比较</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> SimpleAllocator&lt;T&gt;&amp;, <span class="hljs-type">const</span> SimpleAllocator&lt;U&gt;&amp;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> SimpleAllocator&lt;T&gt;&amp;, <span class="hljs-type">const</span> SimpleAllocator&lt;U&gt;&amp;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义分配器的vector</span><br>    std::vector&lt;<span class="hljs-type">int</span>, SimpleAllocator&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        vec.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="手写list"><a href="#手写list" class="headerlink" title="手写list"></a>手写list</h5><p>需要实现Iterator类，并且list中的一些插入删除操作都基于iterator实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span> &#123;</span><br>private:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        T data;<br>        Node* next;<br>        Node* prev;<br><br>        Node(<span class="hljs-type">const</span> T&amp; value) : data(value), next(nullptr), prev(nullptr) &#123;&#125;<br>    &#125;;<br><br>    Node* head;<br>    Node* tail;<br>    <span class="hljs-type">size_t</span> _size;<br><br>public:<br>    <span class="hljs-comment">// 迭代器实现</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iterator</span> &#123;</span><br>    public:<br>        using iterator_category = <span class="hljs-built_in">std</span>::bidirectional_iterator_tag;<br>        using value_type = T;<br>        using difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-type">ptrdiff_t</span>;<br>        using pointer = T*;<br>        using reference = T&amp;;<br><br>    private:<br>        Node* current;<br><br>    public:<br>        <span class="hljs-comment">// 构造函数</span><br>        iterator(Node* ptr = nullptr) : current(ptr) &#123;&#125;<br><br>        <span class="hljs-comment">// 解引用操作符</span><br>        reference operator*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> current-&gt;data; &#125;<br>        pointer operator-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> &amp;(current-&gt;data); &#125;<br><br>        <span class="hljs-comment">// 递增操作符</span><br>        iterator&amp; operator++() &#123;<br>            current = current-&gt;next;<br>            <span class="hljs-keyword">return</span> *this;<br>        &#125;<br><br>        iterator operator++(<span class="hljs-type">int</span>) &#123;<br>            iterator temp = *this;<br>            current = current-&gt;next;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 递减操作符</span><br>        iterator&amp; operator--() &#123;<br>            current = current-&gt;prev;<br>            <span class="hljs-keyword">return</span> *this;<br>        &#125;<br><br>        iterator operator--(<span class="hljs-type">int</span>) &#123;<br>            iterator temp = *this;<br>            current = current-&gt;prev;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 比较操作符</span><br>        <span class="hljs-type">bool</span> operator==(<span class="hljs-type">const</span> iterator&amp; other) <span class="hljs-type">const</span> &#123; <br>            <span class="hljs-keyword">return</span> current == other.current; <br>        &#125;<br><br>        <span class="hljs-type">bool</span> operator!=(<span class="hljs-type">const</span> iterator&amp; other) <span class="hljs-type">const</span> &#123; <br>            <span class="hljs-keyword">return</span> current != other.current; <br>        &#125;<br><br>        <span class="hljs-comment">// 友元声明，让MyList可以访问迭代器的私有成员</span><br>        friend <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>;</span><br>    &#125;;<br><br>    <span class="hljs-comment">// const迭代器实现（类似上面的iterator，但返回const引用和指针）</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">const_iterator</span> &#123;</span><br>        <span class="hljs-comment">// 类似实现但返回const T&amp;和const T*</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 构造函数和析构函数</span><br>    MyList() : head(nullptr), tail(nullptr), _size(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建哨兵节点（sentinel）简化迭代器实现</span><br>        head = new Node(T());<br>        tail = new Node(T());<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br><br>    ~MyList() &#123;<br>        clear();<br>        delete head;<br>        delete tail;<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代器方法</span><br>    iterator <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> iterator(head-&gt;next); &#125;<br>    iterator <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> iterator(tail); &#125;<br>    const_iterator <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> const_iterator(head-&gt;next); &#125;<br>    const_iterator <span class="hljs-title function_">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> const_iterator(tail); &#125;<br><br>    <span class="hljs-comment">// 其他方法（push_back, push_front, clear等）</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 插入元素到迭代器位置之前</span><br>  iterator <span class="hljs-title function_">insert</span><span class="hljs-params">(iterator pos, <span class="hljs-type">const</span> T&amp; value)</span> &#123;<br>      Node&lt;T&gt;* current = pos.node_ptr;<br>      Node&lt;T&gt;* new_node = new Node&lt;T&gt;(value);<br><br>      Node&lt;T&gt;* prev_node = current-&gt;prev;<br><br>      new_node-&gt;next = current;<br>      new_node-&gt;prev = prev_node;<br><br>      prev_node-&gt;next = new_node;<br>      current-&gt;prev = new_node;<br><br>      <span class="hljs-keyword">return</span> iterator(new_node);<br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="手写deque"><a href="#手写deque" class="headerlink" title="手写deque"></a>手写deque</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-04-15-144449407.png" srcset="/img/loading.gif" lazyload alt="image-20250415144404330"></p>
<p>这里简单实现，只实现一个头尾插入删除的vector</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deque</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* buffer;               <span class="hljs-comment">// 内部缓冲区</span><br>    <span class="hljs-type">size_t</span> capacity;         <span class="hljs-comment">// 缓冲区容量</span><br>    <span class="hljs-type">size_t</span> front_idx;        <span class="hljs-comment">// 头部索引</span><br>    <span class="hljs-type">size_t</span> back_idx;         <span class="hljs-comment">// 尾部索引</span><br>    <span class="hljs-type">size_t</span> count;            <span class="hljs-comment">// 当前元素数量</span><br><br>  <span class="hljs-built_in">resize</span>();<br>  <span class="hljs-built_in">push_front</span>();<br>  <span class="hljs-built_in">push_back</span>();<br>&#125;<br><br><span class="hljs-comment">// 代码</span><br></code></pre></td></tr></table></figure>

<h5 id="BST实现map"><a href="#BST实现map" class="headerlink" title="BST实现map"></a>BST实现map</h5><p><a target="_blank" rel="noopener" href="https://gitbookcpp.llfc.club/sections/cpp/base/cppbase28.html">https://gitbookcpp.llfc.club/sections/cpp/base/cppbase28.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// For std::pair</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    std::pair&lt;Key, T&gt; data;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode* parent;<br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value, TreeNode* parentNode = <span class="hljs-literal">nullptr</span>)<br>        : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_pair</span>(key, value)), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">parent</span>(parentNode) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyMap</span>() : <span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    ~<span class="hljs-built_in">MyMap</span>() &#123; <span class="hljs-built_in">clear</span>(root); &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝构造和赋值</span><br>    <span class="hljs-built_in">MyMap</span>(<span class="hljs-type">const</span> MyMap&amp;) = <span class="hljs-keyword">delete</span>;<br>    MyMap&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyMap&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 插入或更新键值对</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>&lt;Key, T&gt;(key, value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        TreeNode&lt;Key, T&gt;* current = root;<br>        TreeNode&lt;Key, T&gt;* parent = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            parent = current;<br>            <span class="hljs-keyword">if</span> (key &lt; current-&gt;data.first) &#123;<br>                current = current-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; current-&gt;data.first) &#123;<br>                current = current-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 键已存在，更新值</span><br>                current-&gt;data.second = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (key &lt; parent-&gt;data.first) &#123;<br>            parent-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>&lt;Key, T&gt;(key, value, parent);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>&lt;Key, T&gt;(key, value, parent);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找元素，返回指向节点的指针</span><br>    <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span> </span>&#123;<br>        TreeNode&lt;Key, T&gt;* current = root;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (key &lt; current-&gt;data.first) &#123;<br>                current = current-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; current-&gt;data.first) &#123;<br>                current = current-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> </span>&#123;<br>        TreeNode&lt;Key, T&gt;* node = <span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到要删除的节点</span><br><br>        <span class="hljs-comment">// 节点有两个子节点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 找到中序后继</span><br>            TreeNode&lt;Key, T&gt;* successor = <span class="hljs-built_in">minimum</span>(node-&gt;right);<br>            node-&gt;data = successor-&gt;data; <span class="hljs-comment">// 替换数据</span><br>            node = successor; <span class="hljs-comment">// 将要删除的节点指向后继节点</span><br>        &#125;<br><br>        <span class="hljs-comment">// 节点有一个或没有子节点</span><br>        TreeNode&lt;Key, T&gt;* child = (node-&gt;left) ? node-&gt;left : node-&gt;right;<br>        <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">nullptr</span>) &#123;<br>            child-&gt;parent = node-&gt;parent;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node-&gt;parent == <span class="hljs-literal">nullptr</span>) &#123;<br>            root = child;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>            node-&gt;parent-&gt;left = child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;parent-&gt;right = child;<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 清空所有节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">clear</span>(root);<br>        root = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取迭代器</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Iterator</span>(TreeNode&lt;Key, T&gt;* node = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">current</span>(node) &#123;&#125;<br><br>        std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current-&gt;data;<br>        &#125;<br><br>        std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;(current-&gt;data);<br>        &#125;<br><br>        <span class="hljs-comment">// 前置递增</span><br>        Iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            current = <span class="hljs-built_in">successor</span>(current);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 后置递增</span><br>        Iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            Iterator temp = *<span class="hljs-keyword">this</span>;<br>            current = <span class="hljs-built_in">successor</span>(current);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current == other.current;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current != other.current;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        TreeNode&lt;Key, T&gt;* current;<br><br>        <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">minimum</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                node = node-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">successor</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">minimum</span>(node-&gt;right);<br>            &#125;<br><br>            TreeNode&lt;Key, T&gt;* p = node-&gt;parent;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; node == p-&gt;right) &#123;<br>                node = p;<br>                p = p-&gt;parent;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-built_in">minimum</span>(root));<br>    &#125;<br><br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    TreeNode&lt;Key, T&gt;* root;<br><br>    <span class="hljs-comment">// 删除树中的所有节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">clear</span>(node-&gt;left);<br>        <span class="hljs-built_in">clear</span>(node-&gt;right);<br>        <span class="hljs-keyword">delete</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到最小的节点</span><br>    <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">minimum</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到最大的节点</span><br>    <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">maximum</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="AVL实现map"><a href="#AVL实现map" class="headerlink" title="AVL实现map"></a>AVL实现map</h5><p>左右子树高度差不超过1</p>
<p>右旋：左左情况：y为+2 且 x为+1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    y                             x<br>   / \                           / \<br>  x   T3            ==&gt;          z   y<br> / \                               / \<br>z   T2                            T2  T3<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br>AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-built_in">rightRotate</span>(AVLNode&lt;KeyType, ValueType&gt;* y) &#123;<br>    AVLNode&lt;KeyType, ValueType&gt;* x = y-&gt;left;<br>    AVLNode&lt;KeyType, ValueType&gt;* T2 = x-&gt;right;<br><br>    <span class="hljs-comment">// 执行旋转</span><br>    x-&gt;right = y;<br>    y-&gt;left = T2;<br><br>    <span class="hljs-comment">// 更新高度</span><br>    y-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(y-&gt;left), <span class="hljs-built_in">getHeight</span>(y-&gt;right)) + <span class="hljs-number">1</span>;<br>    x-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(x-&gt;left), <span class="hljs-built_in">getHeight</span>(x-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 返回新的根</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>左旋：右右情况：A为-2 且 B为-1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    A                           B<br>   / \                         / \<br>  T1  B          ==&gt;          A   C<br>     / \                     / \ <br>    T2  C                   T1 T2 <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br>AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-built_in">leftRotate</span>(AVLNode&lt;KeyType, ValueType&gt;* x) &#123;<br>    AVLNode&lt;KeyType, ValueType&gt;* y = x-&gt;right;<br>    AVLNode&lt;KeyType, ValueType&gt;* T2 = y-&gt;left;<br><br>    <span class="hljs-comment">// 执行旋转</span><br>    y-&gt;left = x;<br>    x-&gt;right = T2;<br><br>    <span class="hljs-comment">// 更新高度</span><br>    x-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(x-&gt;left), <span class="hljs-built_in">getHeight</span>(x-&gt;right)) + <span class="hljs-number">1</span>;<br>    y-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(y-&gt;left), <span class="hljs-built_in">getHeight</span>(y-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 返回新的根</span><br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>左-右(LR)型：A+2 且  B -1；B进行<strong>左旋</strong> 后 A<strong>右旋</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    A                  A                  C<br>   / \                / \                / \<br>  B   T4     =&gt;     C   T4     =&gt;      B   A<br> / \                / \                / \ / \<br>T1  C              B   T3            T1 T2 T3 T4<br>   / \            / \<br>  T2  T3        T1  T2<br></code></pre></td></tr></table></figure>

<p>右-左(LR)型：A-2 且 B +1 ；B进行<strong>右旋</strong> 后 A<strong>左旋</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  A                  A                  C<br> / <span class="hljs-string">\</span>                / <span class="hljs-string">\</span>                / <span class="hljs-string">\</span><br>T1  B      =&gt;     T1  C      =&gt;      A   B<br>   / <span class="hljs-string">\</span>                / <span class="hljs-string">\</span>            / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br>  C   T4            T2   B         T1 T2 T3 T4<br> / <span class="hljs-string">\</span>                    / <span class="hljs-string">\</span><br>T2  T3                 T3  T4<br></code></pre></td></tr></table></figure>

<h6 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-function">AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-title">insertNode</span><span class="hljs-params">(AVLNode&lt;KeyType, ValueType&gt;* node, <span class="hljs-type">const</span> KeyType&amp; key, <span class="hljs-type">const</span> ValueType&amp; value)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 执行标准的BST插入</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">AVLNode</span>&lt;KeyType, ValueType&gt;(key, value);<br><br>    <span class="hljs-keyword">if</span> (key &lt; node-&gt;key)<br>        node-&gt;left = <span class="hljs-built_in">insertNode</span>(node-&gt;left, key, value);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; node-&gt;key)<br>        node-&gt;right = <span class="hljs-built_in">insertNode</span>(node-&gt;right, key, value);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果键已经存在，更新其值</span><br>        node-&gt;value = value;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 更新节点高度</span><br>    node-&gt;height = <span class="hljs-number">1</span> + std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(node-&gt;left), <span class="hljs-built_in">getHeight</span>(node-&gt;right));<br><br>    <span class="hljs-comment">// 3. 获取平衡因子</span><br>    <span class="hljs-type">int</span> balance = <span class="hljs-built_in">getBalance</span>(node);<br><br>    <span class="hljs-comment">// 4. 根据平衡因子进行旋转</span><br><br>    <span class="hljs-comment">// 左左情况  这里可以使用getBalance(node-&gt;left) 但更低效</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br><br>    <span class="hljs-comment">// 右右情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br><br>    <span class="hljs-comment">// 左右情况</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;<br>        node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-comment">// 右左情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;<br>        node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-function">AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-title">deleteNode</span><span class="hljs-params">(AVLNode&lt;KeyType, ValueType&gt;* root, <span class="hljs-type">const</span> KeyType&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 执行标准的BST删除</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-keyword">if</span> (key &lt; root-&gt;key)<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key)<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 节点有一个或没有子节点</span><br>        <span class="hljs-keyword">if</span> ((root-&gt;left == <span class="hljs-literal">nullptr</span>) || (root-&gt;right == <span class="hljs-literal">nullptr</span>)) &#123;<br>            AVLNode&lt;KeyType, ValueType&gt;* temp = root-&gt;left ? root-&gt;left : root-&gt;right;<br><br>            <span class="hljs-comment">// 没有子节点</span><br>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">nullptr</span>) &#123;<br>                temp = root;<br>                root = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 一个子节点</span><br>                *root = *temp; <span class="hljs-comment">// 复制内容  可以避免改父的指针</span><br><br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 节点有两个子节点，获取中序后继</span><br>            AVLNode&lt;KeyType, ValueType&gt;* temp = <span class="hljs-built_in">getMinValueNode</span>(root-&gt;right);<br>            <span class="hljs-comment">// 复制中序后继的内容到此节点</span><br>            root-&gt;key = temp-&gt;key;<br>            root-&gt;value = temp-&gt;value;<br>            <span class="hljs-comment">// 删除中序后继</span><br>            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, temp-&gt;key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果树只有一个节点</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 2. 更新节点高度</span><br>    root-&gt;height = <span class="hljs-number">1</span> + std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(root-&gt;left), <span class="hljs-built_in">getHeight</span>(root-&gt;right));<br><br>    <span class="hljs-comment">// 3. 获取平衡因子</span><br>    <span class="hljs-type">int</span> balance = <span class="hljs-built_in">getBalance</span>(root);<br><br>    <span class="hljs-comment">// 4. 根据平衡因子进行旋转</span><br><br>    <span class="hljs-comment">// 左左情况</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;left) &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(root);<br><br>    <span class="hljs-comment">// 左右情况</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;left) &lt; <span class="hljs-number">0</span>) &#123;<br>        root-&gt;left = <span class="hljs-built_in">leftRotate</span>(root-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(root);<br>    &#125;<br><br>    <span class="hljs-comment">// 右右情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;right) &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(root);<br><br>    <span class="hljs-comment">// 右左情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;right) &gt; <span class="hljs-number">0</span>) &#123;<br>        root-&gt;right = <span class="hljs-built_in">rightRotate</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(root);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="手写unorderedmap"><a href="#手写unorderedmap" class="headerlink" title="手写unorderedmap"></a>手写unorderedmap</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18bwPe4EfG">https://www.bilibili.com/video/BV18bwPe4EfG</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_map&lt;KeyType, ValueType, Hash = std::hash&lt;KeyType&gt;, KeyEqual = std::equal_to&lt;KeyType&gt;, Allocator = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> KeyType, ValueType&gt;&gt;&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>KeyType</strong>：键的类型，需要支持哈希运算和相等比较。</li>
<li><strong>ValueType</strong>：值的类型。</li>
<li><strong>Hash</strong>：哈希函数，默认为 <code>std::hash&lt;KeyType&gt;</code>。</li>
<li><strong>KeyEqual</strong>：键相等的比较函数，默认为 <code>std::equal_to&lt;KeyType&gt;</code>。使用类的operator&#x3D;&#x3D;</li>
<li><strong>Allocator</strong>：内存分配器，默认为 <code>std::allocator</code>。</li>
</ul>
<p>自定义类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">// 自定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载相等运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> name == other.name &amp;&amp; age == other.age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 自定义哈希函数对象(等价于Java的hashCode)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonHash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 组合哈希值的一种简单方法</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(p.name) ^ std::<span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(p.age);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 自定义相等比较函数对象(等价于Java的equals)，使用operator==实现</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p1, <span class="hljs-type">const</span> Person&amp; p2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 直接调用Person类的operator==</span><br>        <span class="hljs-keyword">return</span> p1 == p2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在unordered_map模板参数中指定哈希和相等函数对象</span><br>    std::unordered_map&lt;Person, std::string, PersonHash, PersonEqual&gt; personMap;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)</span></span>;  <span class="hljs-comment">// 与p1相同</span><br><br>    personMap[p1] = <span class="hljs-string">&quot;工程师&quot;</span>;<br>    personMap[p2] = <span class="hljs-string">&quot;设计师&quot;</span>;<br><br>    <span class="hljs-comment">// 由于p3和p1相等，这将打印&quot;工程师&quot;</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p3的职业: &quot;</span> &lt;&lt; personMap[p3] &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// For std::pair</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">// For std::hash</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span> <span class="hljs-comment">// For iterator_traits</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// For exceptions</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// HashNode 结构定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashNode</span> &#123;<br>    std::pair&lt;<span class="hljs-type">const</span> Key, T&gt; data;<br>    HashNode* next;<br><br>    <span class="hljs-built_in">HashNode</span>(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value)<br>        : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_pair</span>(key, value)), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// MyHashMap 类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;<br><span class="hljs-keyword">class</span> MyHashMap &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 迭代器类前向声明</span><br>    <span class="hljs-keyword">class</span> Iterator;<br><br>    <span class="hljs-comment">// 类型定义</span><br>    <span class="hljs-keyword">using</span> key_type = Key;<br>    <span class="hljs-keyword">using</span> mapped_type = T;<br>    <span class="hljs-keyword">using</span> value_type = std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;;<br>    <span class="hljs-keyword">using</span> size_type = <span class="hljs-type">size_t</span>;<br><br>    <span class="hljs-comment">// 构造函数及析构函数</span><br>    <span class="hljs-built_in">MyHashMap</span>(size_type initial_capacity = <span class="hljs-number">16</span>, <span class="hljs-type">double</span> max_load_factor = <span class="hljs-number">0.75</span>);<br>    ~<span class="hljs-built_in">MyHashMap</span>();<br><br>    <span class="hljs-comment">// 禁止拷贝构造和赋值</span><br>    <span class="hljs-built_in">MyHashMap</span>(<span class="hljs-type">const</span> MyHashMap&amp;) = <span class="hljs-keyword">delete</span>;<br>    MyHashMap&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyHashMap&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 基本操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value)</span></span>;<br>    <span class="hljs-function">T* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span></span>;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 迭代器操作</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 迭代器类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 迭代器别名</span><br>        <span class="hljs-keyword">using</span> iterator_category = std::forward_iterator_tag;<br>        <span class="hljs-keyword">using</span> value_type = std::pair&lt;Key, T&gt;;<br>        <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>        <span class="hljs-keyword">using</span> pointer = value_type*;<br>        <span class="hljs-keyword">using</span> reference = value_type&amp;;<br><br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node);<br><br>        <span class="hljs-comment">// 解引用操作符</span><br>        reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;<br>        pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>;<br><br>        <span class="hljs-comment">// 递增操作符</span><br>        Iterator&amp; <span class="hljs-keyword">operator</span>++();<br>        Iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);<br><br>        <span class="hljs-comment">// 比较操作符</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span>;<br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        MyHashMap* map_;<br>        size_type bucket_index_;<br>        HashNode&lt;Key, T&gt;* current_node_;<br><br>        <span class="hljs-comment">// 移动到下一个有效节点</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">()</span></span>;<br>    &#125;;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;<br>    size_type bucket_count_;<br>    size_type element_count_;<br>    <span class="hljs-type">double</span> max_load_factor_;<br>    Hash hash_func_;<br><br>    <span class="hljs-comment">// 辅助函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">MyHashMap</span>(size_type initial_capacity, <span class="hljs-type">double</span> max_load_factor)<br>    : <span class="hljs-built_in">bucket_count_</span>(initial_capacity),<br>      <span class="hljs-built_in">element_count_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">max_load_factor_</span>(max_load_factor),<br>      <span class="hljs-built_in">hash_func_</span>(<span class="hljs-built_in">Hash</span>()) &#123;<br>    buckets_.<span class="hljs-built_in">resize</span>(bucket_count_, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>MyHashMap&lt;Key, T, Hash&gt;::~<span class="hljs-built_in">MyHashMap</span>() &#123;<br>    <span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-comment">// 插入函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value) &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            node-&gt;data.second = value; <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = node-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 键不存在，插入新节点到链表头部</span><br>    HashNode&lt;Key, T&gt;* new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashNode</span>&lt;Key, T&gt;(key, value);<br>    new_node-&gt;next = buckets_[index];<br>    buckets_[index] = new_node;<br>    ++element_count_;<br><br>    <span class="hljs-comment">// 检查负载因子，可能需要扩容</span><br>    <span class="hljs-type">double</span> load_factor = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(element_count_) / bucket_count_;<br>    <span class="hljs-keyword">if</span> (load_factor &gt; max_load_factor_) &#123;<br>        <span class="hljs-built_in">rehash</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找函数（非常量版本）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>T* MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            <span class="hljs-keyword">return</span> &amp;(node-&gt;data.second);<br>        &#125;<br>        node = node-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 查找函数（常量版本）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">const</span> T* MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> Key&amp; key) <span class="hljs-type">const</span> &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            <span class="hljs-keyword">return</span> &amp;(node-&gt;data.second);<br>        &#125;<br>        node = node-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">erase</span>(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    HashNode&lt;Key, T&gt;* prev = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">nullptr</span>) &#123;<br>                buckets_[index] = node-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev-&gt;next = node-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> node;<br>            --element_count_;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        prev = node;<br>        node = node-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 未找到键</span><br>&#125;<br><br><span class="hljs-comment">// 清空函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">clear</span>() &#123;<br>    <span class="hljs-keyword">for</span> (size_type i = <span class="hljs-number">0</span>; i &lt; bucket_count_; ++i) &#123;<br>        HashNode&lt;Key, T&gt;* node = buckets_[i];<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            HashNode&lt;Key, T&gt;* temp = node;<br>            node = node-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        buckets_[i] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    element_count_ = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 动态扩容函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">rehash</span>() &#123;<br>    size_type new_bucket_count = bucket_count_ * <span class="hljs-number">2</span>;<br>    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; <span class="hljs-built_in">new_buckets</span>(new_bucket_count, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// 重新分配所有元素</span><br>    <span class="hljs-keyword">for</span> (size_type i = <span class="hljs-number">0</span>; i &lt; bucket_count_; ++i) &#123;<br>        HashNode&lt;Key, T&gt;* node = buckets_[i];<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            HashNode&lt;Key, T&gt;* next_node = node-&gt;next;<br>            size_type new_index = <span class="hljs-built_in">hash_func_</span>(node-&gt;data.first) % new_bucket_count;<br><br>            <span class="hljs-comment">// 插入到新桶的头部</span><br>            node-&gt;next = new_buckets[new_index];<br>            new_buckets[new_index] = node;<br><br>            node = next_node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 替换旧桶</span><br>    buckets_ = std::<span class="hljs-built_in">move</span>(new_buckets);<br>    bucket_count_ = new_bucket_count;<br>&#125;<br><br><span class="hljs-comment">// begin() 函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator<br>MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">begin</span>() &#123;<br>    <span class="hljs-keyword">for</span> (size_type i = <span class="hljs-number">0</span>; i &lt; bucket_count_; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (buckets_[i] != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-keyword">this</span>, i, buckets_[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">end</span>();<br>&#125;<br><br><span class="hljs-comment">// end() 函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator<br>MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">end</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-keyword">this</span>, bucket_count_, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// Iterator 构造函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node)<br>    : <span class="hljs-built_in">map_</span>(map), <span class="hljs-built_in">bucket_index_</span>(bucket_index), <span class="hljs-built_in">current_node_</span>(node) &#123;&#125;<br><br><span class="hljs-comment">// 解引用操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::reference<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (current_node_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Iterator out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> current_node_-&gt;data;<br>&#125;<br><br><span class="hljs-comment">// 成员访问操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointer<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (current_node_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Iterator out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;(current_node_-&gt;data);<br>&#125;<br><br><span class="hljs-comment">// 前置递增操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>++() &#123;<br>    <span class="hljs-built_in">advance</span>();<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 后置递增操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>    Iterator temp = *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-built_in">advance</span>();<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">// 比较操作符==</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> map_ == other.map_ &amp;&amp;<br>           bucket_index_ == other.bucket_index_ &amp;&amp;<br>           current_node_ == other.current_node_;<br>&#125;<br><br><span class="hljs-comment">// 比较操作符!=</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<br>&#125;<br><br><span class="hljs-comment">// advance 函数：移动到下一个有效节点</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-built_in">advance</span>() &#123;<br>   <span class="hljs-keyword">if</span>(current_node_ != <span class="hljs-literal">nullptr</span>)&#123;<br>         current_node_ = current_node_-&gt;next;<br>    &#125;<br>   <span class="hljs-keyword">while</span>(current_node_ == <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(bucket_index_ <span class="hljs-number">+1</span>  &lt; map_-&gt;bucket_count_)&#123;<br>                   ++bucket_index_;<br>                   current_node_ = map_-&gt;buckets_[bucket_index_];<br>          &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket_index_ <span class="hljs-number">+1</span>  == map_-&gt;bucket_count_)&#123;<br>                   ++bucket_index_;<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><p>模版函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">functionName</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><br><span class="hljs-comment">// 多类型模板函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T a, U b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">maxValue</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">maxValue</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>) &lt;&lt; std::endl;         <span class="hljs-comment">// int 类型</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">maxValue</span>(<span class="hljs-number">3.14</span>, <span class="hljs-number">2.72</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// double 类型</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">maxValue</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;    <span class="hljs-comment">// char 类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 或者用 template &lt;class T&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T value) : <span class="hljs-built_in">data</span>(value) &#123;&#125;<br>    <span class="hljs-function">T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123; data = value; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="模版参数"><a href="#模版参数" class="headerlink" title="模版参数"></a>模版参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">类型参数用于表示任意类型，在模板实例化时被具体的类型替代。<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data;<br>&#125;;<br><br><br>非类型参数允许模板接受非类型的值，如整数、指针或引用。C+<span class="hljs-number">+17</span> 支持更多非类型参数类型，如 <span class="hljs-keyword">auto</span>。<br>非类型参数必须是编译期常量。<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data[N];<br>&#125;;<br><br><br>模板模板参数<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerPrinter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&lt;T, std::allocator&lt;T&gt;&gt;&amp; container)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : container)<br>            std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><br>    ContainerPrinter&lt;std::vector, <span class="hljs-type">int</span>&gt; vecPrinter;<br>    vecPrinter.<span class="hljs-built_in">print</span>(vec); <span class="hljs-comment">// 输出：1 2 3 4 5 </span><br><br>    ContainerPrinter&lt;std::list, <span class="hljs-type">int</span>&gt; listPrinter;<br>    listPrinter.<span class="hljs-built_in">print</span>(lst); <span class="hljs-comment">// 输出：10 20 30 </span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="全特化偏特化"><a href="#全特化偏特化" class="headerlink" title="全特化偏特化"></a>全特化偏特化</h5><ul>
<li>全特化：提供了模板的一个所有参数的特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。</li>
<li>偏特化：允许模板对部分参数进行特定类型的处理。<strong>函数模版不支持</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原始模板（Primary template）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;原始模板&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 全特化 - 为&lt;int, double&gt;提供特殊实现</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;全特化版本: &lt;int, double&gt;&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 偏特化 - 为第二个参数是int的情况提供特殊实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T, <span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;偏特化版本: &lt;T, int&gt;, T = &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 偏特化 - 为两个参数类型相同的情况提供特殊实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T, T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;偏特化版本: &lt;T, T&gt;, T = &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="变参模版"><a href="#变参模版" class="headerlink" title="变参模版"></a>变参模版</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(T first, Args... args)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>

<p>递归展开</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基本情况（递归终止条件）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 递归展开参数包</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T first, Args... rest)</span> </span>&#123;<br>    std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 处理第一个参数</span><br>    <span class="hljs-built_in">print</span>(rest...);             <span class="hljs-comment">// 递归处理剩余参数</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// 输出: 1 2.5 hello c</span><br></code></pre></td></tr></table></figure>

<p>折叠表达式 cpp17</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一元折叠 - 求和</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (... + args);  <span class="hljs-comment">// (((arg1 + arg2) + arg3) + ...)</span><br>&#125;<br><br><span class="hljs-comment">// 二元折叠 - 打印</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;  <span class="hljs-comment">// 链式输出</span><br>&#125;<br><br><span class="hljs-comment">// 带初始值的折叠</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printWithComma</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    ((std::cout &lt;&lt; args &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>), ...);  <span class="hljs-comment">// 每个参数后面加逗号</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>一元右折叠</strong>：<code>(pack op ...)</code></li>
<li><strong>一元左折叠</strong>：<code>(... op pack)</code></li>
<li><strong>二元右折叠</strong>：<code>(pack op ... op init)</code></li>
<li><strong>二元左折叠</strong>：<code>(init op ... op pack)</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 一元右折叠</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum1</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ...);  <span class="hljs-comment">// 等价于 a1 + (a2 + (... + aN))</span><br>&#125;<br><br><span class="hljs-comment">// 一元左折叠</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum2</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (... + args);  <span class="hljs-comment">// 等价于 ((a1 + a2) + ...) + aN</span><br>&#125;<br><br><span class="hljs-comment">// 二元右折叠（带初始值）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum3</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ... + <span class="hljs-number">0</span>);  <span class="hljs-comment">// 即使参数包为空也能工作</span><br>&#125;<br><br><span class="hljs-comment">// 二元左折叠（带初始值）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum4</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + args);  <span class="hljs-comment">// 即使参数包为空也能工作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum1(1, 2, 3, 4, 5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum2(1, 2, 3, 4, 5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum3() = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum3</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 空参数包，结果为 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum4() = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum4</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 空参数包，结果为 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h4><p>Substitution Failure Is Not An Error</p>
<ul>
<li><strong>函数重载选择</strong>：根据参数类型的不同选择不同的函数实现。</li>
<li><strong>类型特性检测</strong>：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。</li>
<li><strong>条件编译</strong>：根据模板参数的特性决定是否编译某些代码段。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-type">enable_if_t</span>&lt;condition&gt;` 来替代 std::enable_if&lt;condition&gt;::type<br><br><br>当T满足条件时 → 表达式变为<span class="hljs-type">void</span>（或者enable_if第二个模板参数指定的类型）<br>当T不满足条件时 → 表达式无效，导致模板替换失败，编译器不会报错，而是简单地丢弃该重载。  替换失败不是错误<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 使用std::enable_if实现SFINAE</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <br>          <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">enable_if_t</span>&lt;std::is_integral&lt;T&gt;::value&gt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">process</span>(T value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理整数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>          <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">enable_if_t</span>&lt;std::is_floating_point&lt;T&gt;::value&gt;,<br>          <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-comment">// 额外参数避免签名冲突</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">process</span>(T value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理浮点数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 选择整数版本</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 选择浮点数版本</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果没有</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 运行时判断类型</span><br>    <span class="hljs-keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;处理整数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::is_floating_point&lt;T&gt;::value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;处理浮点数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;未知类型&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 主模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Enable = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> MyClass &#123;<br>    <span class="hljs-comment">// 默认实现</span><br>&#125;;<br><br><span class="hljs-comment">// 特化版本（当T满足某条件时）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T, <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt; &#123;<br>    <span class="hljs-comment">// 针对整数类型的特殊实现</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h4><p>需求：</p>
<ol>
<li>对于普通类型，使用通用的打印格式。</li>
<li>对于指针类型，打印指针地址或指向的值。</li>
<li>对于<code>std::string</code>类型，使用专门的格式。</li>
<li>支持可变数量的参数，通过折叠表达式实现参数的逐一打印。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Enable = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> Logger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-built_in">log</span>(<span class="hljs-type">const</span> T&amp; message) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;T, <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; message)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging integer: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;std::string&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging string: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logOne</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; message)</span></span>&#123;<br>    Logger&lt;T&gt;::<span class="hljs-built_in">log</span>(message);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAll</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... args)</span></span>&#123;<br><br>    (<span class="hljs-built_in">logOne</span>(args), ...);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAllC</span><span class="hljs-params">(T first, <span class="hljs-type">const</span> Args&amp;... args)</span></span>&#123;<br>    <span class="hljs-built_in">logOne</span>(first);<br>    <span class="hljs-built_in">logAll</span>(args...);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h4><p><strong>定义</strong><br> 模板元编程是利用 C++ 模板机制，在编译阶段执行“算法”或“计算”，最终在生成的二进制中只留下结果，不留任何运行时开销的编程手段。</p>
<p><strong>本质</strong></p>
<ul>
<li><strong>类型计算</strong>：通过类型递归、偏特化来在编译期对类型进行判断、转换、组合。</li>
<li><strong>值计算</strong>：通过整型非类型模板参数，利用编译器对常量表达式求值来进行数值计算。</li>
</ul>
<p><strong>与运行时多态的对比</strong></p>
<ul>
<li><strong>静态多态</strong>（模板）在编译期“展平”成具体代码，可获得极致优化；</li>
<li><strong>动态多态</strong>（虚函数）则要靠 vtable 在运行时分派。</li>
</ul>
<p><strong>递归 + 偏特化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 计算阶乘：Factorial&lt;N&gt;::value 在编译期算出 N!</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N<span class="hljs-number">-1</span>&gt;::value;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-built_in">static_assert</span>(Factorial&lt;<span class="hljs-number">5</span>&gt;::value == <span class="hljs-number">120</span>, <span class="hljs-string">&quot;&quot;</span>);  <br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">当编译器遇到Factorial&lt;<span class="hljs-number">5</span>&gt;::value时，会触发一系列模板实例化：<br><br><br><span class="hljs-comment">// 主模板应用于N=5</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">5</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">5</span> * Factorial&lt;<span class="hljs-number">4</span>&gt;::value;<br>&#125;;<br><br><span class="hljs-comment">// 递归实例化N=4,3,2,1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">4</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">4</span> * Factorial&lt;<span class="hljs-number">3</span>&gt;::value; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">3</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">3</span> * Factorial&lt;<span class="hljs-number">2</span>&gt;::value; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">2</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">2</span> * Factorial&lt;<span class="hljs-number">1</span>&gt;::value; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">1</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span> * Factorial&lt;<span class="hljs-number">0</span>&gt;::value; &#125;;<br><br><span class="hljs-comment">// 特化模板终止递归</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>; &#125;;<br></code></pre></td></tr></table></figure>

<p><strong>类型计算：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 检测是否可以对T类型进行加法操作</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">struct</span> is_addable : std::false_type &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_addable</span>&lt;T, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">void</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;() + std::<span class="hljs-built_in">declval</span>&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">static_assert</span>(is_addable&lt;<span class="hljs-type">int</span>&gt;::value, <span class="hljs-string">&quot;int should be addable&quot;</span>);<br><span class="hljs-built_in">static_assert</span>(!is_addable&lt;<span class="hljs-type">void</span>*&gt;::value, <span class="hljs-string">&quot;void* should not be addable&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>变参模板</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基本递归模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span>... Ns&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>;<br><br><span class="hljs-comment">// 递归终止</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>&lt;&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 递归定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N, <span class="hljs-type">int</span>... Ns&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>&lt;N, Ns...&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N + Sum&lt;Ns...&gt;::value;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = Sum&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&gt;::value; <span class="hljs-comment">// 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Type Lists</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义类型列表</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeList</span> &#123;&#125;;<br><br><span class="hljs-comment">// 获取类型列表中第N个类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> List, std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeAt</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, <span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = Head;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail, std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> TypeAt&lt;TypeList&lt;Tail...&gt;, N - <span class="hljs-number">1</span>&gt;::type;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">using</span> list = TypeList&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;;<br><span class="hljs-keyword">using</span> third_type = TypeAt&lt;list, <span class="hljs-number">2</span>&gt;::type; <span class="hljs-comment">// char</span><br></code></pre></td></tr></table></figure>

<h4 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h4><p><strong>左值（lvalue）</strong>和<strong>右值（rvalue）</strong>是C++中用于描述表达式值类别的重要概念。</p>
<ul>
<li>左值（lvalue）：<ul>
<li>表示具有持久存储的对象。</li>
<li>可以出现在赋值语句的左侧。</li>
<li>可以被取地址（即，可以使用<code>&amp;</code>运算符）。</li>
<li>示例：变量名、引用等。</li>
</ul>
</li>
<li>右值（rvalue）：<ul>
<li>表示临时对象或没有持久存储的值。</li>
<li>通常出现在赋值语句的右侧。</li>
<li>不能被取地址。</li>
<li>示例：字面量、临时对象、表达式结果等。</li>
</ul>
</li>
</ul>
<p>C++11进一步细化了右值的分类：</p>
<ul>
<li><strong>纯右值（prvalues）</strong>：表示临时对象或字面量，如<code>42</code>、<code>3.14</code>。</li>
<li><strong>将亡值（xvalues，expiring values）</strong>：表示即将被移动的对象，如<code>std::move</code>的结果。</li>
</ul>
<p>C++标准库提供了几个类型特性（type traits）用于判断表达式的值类别：</p>
<ul>
<li><code>std::is_lvalue_reference&lt;T&gt;</code>：判断类型<code>T</code>是否为左值引用。</li>
<li><code>std::is_rvalue_reference&lt;T&gt;</code>：判断类型<code>T</code>是否为右值引用。</li>
<li><code>std::is_lvalue&lt;T&gt;</code>（C++20起）：判断表达式是否为左值。</li>
<li><code>std::is_rvalue&lt;T&gt;</code>（C++20起）：判断表达式是否为右值。</li>
</ul>
<h4 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp;)</span> </span>&#123; <br>    <span class="hljs-comment">// 将分析 T 的类型和 T&amp;&amp; 折叠后的类型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>对左值 以及 左值引用 以及右值引用(命名的右值引用被视为左值)：T 推导为左值引用类型</li>
<li>对右值 以及 move()：T 推导为非引用类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 值类别基础：左值与右值<br>让我们从最基本的概念开始：<br><br>左值(lvalue)：可以取地址、有名字的表达式<br><br>例如：变量、数组元素、返回引用的函数<br>特点：通常可以出现在赋值号(=)左边<br>右值(rvalue)：不能取地址、没有名字的临时表达式<br><br>例如：字面常量(<span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello&quot;</span>)、临时对象、返回非引用的函数结果<br>特点：只能出现在赋值号(=)右边<br>C++<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;        <span class="hljs-comment">// x 是左值</span><br><span class="hljs-type">int</span> y = x + <span class="hljs-number">20</span>;    <span class="hljs-comment">// (x + 20) 是右值</span><br><span class="hljs-type">int</span>&amp; ref = x;      <span class="hljs-comment">// 左值引用必须绑定到左值</span><br><span class="hljs-comment">// int&amp; ref2 = 42; // 错误：左值引用不能绑定到右值</span><br><span class="hljs-number">2.</span> 引用类型基础<br>C++有两种基本引用：<br><br>左值引用(T&amp;)：只能绑定到左值<br>右值引用(T&amp;&amp;)：主要用于绑定右值（C+<span class="hljs-number">+11</span>引入）<br>C++<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-comment">// a 是左值</span><br><span class="hljs-type">int</span>&amp; lref = a;     <span class="hljs-comment">// 正确：左值引用绑定到左值</span><br><span class="hljs-comment">// int&amp; badref = 20; // 错误：左值引用不能绑定到右值</span><br><br><span class="hljs-type">int</span>&amp;&amp; rref = <span class="hljs-number">30</span>;   <span class="hljs-comment">// 正确：右值引用绑定到右值</span><br><span class="hljs-comment">// int&amp;&amp; badrref = a; // 错误：右值引用不能绑定到左值</span><br>特殊情况：<span class="hljs-type">const</span> 左值引用可以绑定到右值：<br><br>C++<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 正确：const左值引用可以绑定到右值</span><br><span class="hljs-number">3.</span> 函数参数中的引用<br>C++<br><span class="hljs-comment">// 接收左值的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理左值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    x += <span class="hljs-number">1</span>;  <span class="hljs-comment">// 可以修改原始值</span><br>&#125;<br><br><span class="hljs-comment">// 接收右值的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理右值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 可能会移动资源，而不是复制</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">processLValue</span>(a);     <span class="hljs-comment">// 正确：a是左值</span><br>    <span class="hljs-comment">// processLValue(42); // 错误：42是右值，不能绑定到左值引用参数</span><br><br>    <span class="hljs-comment">// processRValue(a);  // 错误：a是左值，不能绑定到右值引用参数</span><br>    <span class="hljs-built_in">processRValue</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// 正确：42是右值</span><br>&#125;<br><span class="hljs-number">4.</span> 重要观察：命名的右值引用是左值！<br>这是理解后面内容的关键点：<br><br>C++<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>&amp;&amp; rref = <span class="hljs-number">42</span>;  <span class="hljs-comment">// rref的类型是int&amp;&amp;（右值引用）</span><br><br>    <span class="hljs-comment">// 但是rref本身是左值，因为它有名字！</span><br>    <span class="hljs-type">int</span>&amp; lref = rref;  <span class="hljs-comment">// 正确：可以将左值引用绑定到rref</span><br><br>    <span class="hljs-built_in">processLValue</span>(rref);  <span class="hljs-comment">// 正确：rref是左值</span><br>    <span class="hljs-comment">// processRValue(rref);  // 错误：不能将左值传给右值引用参数</span><br>&#125;<br>核心理解：引用变量的类型与它的值类别是不同的概念！<br><br>rref的类型是<span class="hljs-type">int</span>&amp;&amp;（右值引用类型）<br>但rref的值类别是左值（因为它有名字）<br><span class="hljs-number">5.</span> 模板与通用引用<br>当在模板参数中使用T&amp;&amp;时，它不一定是右值引用，而是一种特殊的<span class="hljs-string">&quot;通用引用&quot;</span>：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;  <span class="hljs-comment">// 这里的T&amp;&amp;不一定是右值引用</span><br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(x);    <span class="hljs-comment">// 用左值调用：T推导为int&amp;，param类型为int&amp;</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 用右值调用：T推导为int，param类型为int&amp;&amp;</span><br>&#125;<br><span class="hljs-number">6.</span> 模板类型推导规则<br>当使用通用引用T&amp;&amp;时，类型推导遵循以下规则：<br><br>传入左值，T被推导为左值引用：T = X&amp;<br>传入右值，T被推导为非引用类型：T = X<br>C++<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">printType</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;T的类型: &quot;</span>;<br>    <span class="hljs-built_in">printType</span>&lt;T&gt;();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;param的类型: &quot;</span>;<br>    <span class="hljs-built_in">printType</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">f</span>(a);   <span class="hljs-comment">// 传入左值: T = int&amp;, param类型 = int&amp;</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 传入右值: T = int, param类型 = int&amp;&amp;</span><br>&#125;<br><span class="hljs-number">7.</span> 引用折叠规则<br>C++有四条引用折叠规则，当涉及到引用的引用时：<br><br>T&amp; &amp; → T&amp; (左值引用的左值引用 = 左值引用)<br>T&amp; &amp;&amp; → T&amp; (左值引用的右值引用 = 左值引用)<br>T&amp;&amp; &amp; → T&amp; (右值引用的左值引用 = 左值引用)<br>T&amp;&amp; &amp;&amp; → T&amp;&amp; (右值引用的右值引用 = 右值引用)<br>简单来说：只要有一个是左值引用(&amp;)，结果就是左值引用；只有当两个都是右值引用(&amp;&amp;)时，结果才是右值引用。<br><br><span class="hljs-number">8.</span> 引用折叠与通用引用结合<br>当我们结合模板类型推导和引用折叠规则，以下情况发生：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">wrapper</span>(x);   <span class="hljs-comment">// 左值情况</span><br>左值调用流程：<br><br>x是左值，所以T被推导为<span class="hljs-type">int</span>&amp;<br>参数类型变为<span class="hljs-type">int</span>&amp; &amp;&amp;<br>引用折叠：<span class="hljs-type">int</span>&amp; &amp;&amp; → <span class="hljs-type">int</span>&amp;<br>最终param类型为<span class="hljs-type">int</span>&amp;（左值引用）<br>C++<br><span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 右值情况</span><br>右值调用流程：<br><br><span class="hljs-number">42</span>是右值，所以T被推导为<span class="hljs-type">int</span><br>参数类型变为<span class="hljs-type">int</span>&amp;&amp;<br>无需折叠，保持为<span class="hljs-type">int</span>&amp;&amp;<br>最终param类型为<span class="hljs-type">int</span>&amp;&amp;（右值引用）<br><span class="hljs-number">9.</span> 问题：参数转发<br>考虑一个包装函数，它需要将参数传递给另一个函数：<br><br>C++<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;左值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;右值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(param);  <span class="hljs-comment">// 问题在这里！</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(a);    <span class="hljs-comment">// 期望调用process(int&amp;)</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 期望调用process(int&amp;&amp;)</span><br>&#125;<br>关键问题：即使<span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>)中的param类型是<span class="hljs-type">int</span>&amp;&amp;，但由于param有名字，它在函数体内是左值！所以<span class="hljs-built_in">process</span>(param)总是调用左值版本。<br><br><span class="hljs-number">10.</span> std::forward 的作用<br>std::forward解决了上述问题，它可以在必要时（当原始参数是右值时）将参数转换回右值：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(param));  <span class="hljs-comment">// 保持参数的原始值类别</span><br>&#125;<br>std::forward的简化原理：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);<br>&#125;<br>当T是<span class="hljs-type">int</span>&amp;（传入左值）时，T&amp;&amp;折叠为<span class="hljs-type">int</span>&amp;，不改变值类别。 当T是<span class="hljs-type">int</span>（传入右值）时，T&amp;&amp;保持为<span class="hljs-type">int</span>&amp;&amp;，将左值arg转换回右值引用。<br></code></pre></td></tr></table></figure>

<p>参数转发:当我们编写通用的模板函数（如工厂、封装器）时，通常想把参数“原样”传递给另一个函数或构造器，而不改变它的值类别（左值&#x2F;右值）和 cv 限定（const&#x2F;volatile）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;左值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;右值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(param);  <span class="hljs-comment">// 问题在这里！</span><br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(param));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(a);    <span class="hljs-comment">// 期望调用process(int&amp;)</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 期望调用process(int&amp;&amp;)</span><br>&#125;<br><span class="hljs-comment">// 即使wrapper(42)中的param类型是int&amp;&amp;，但由于param有名字，它在函数体内是左值！所以process(param)总是调用左值版本。</span><br></code></pre></td></tr></table></figure>



<p>vector中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-type">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">emplace_back</span>(Args&amp;&amp;... args) &#123;<br>    <span class="hljs-built_in">checkSize</span>();  <span class="hljs-comment">// 扩容（如果需要）</span><br>    <span class="hljs-keyword">new</span> (data_ + size_) <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...);  <span class="hljs-comment">// 原地构造</span><br>    ++size_;<br>&#125;<br><br><br>Vector&lt;Foo&gt; v;<br>Foo a;<br>v.<span class="hljs-built_in">emplace_back</span>(a);           <span class="hljs-comment">// 应该调用 copy ctor</span><br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Foo</span>(<span class="hljs-number">42</span>));     <span class="hljs-comment">// 应该调用 move ctor</span><br></code></pre></td></tr></table></figure>



<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><h5 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h5><p>Meyer’s Singleton </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++11 及以上版本线程安全</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局访问点</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// C++11 保证了局部静态变量的线程安全初始化</span><br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>(静态成员变量)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 静态实例成员</span><br>    <span class="hljs-type">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在类外定义和初始化静态成员</span><br>Singleton Singleton::instance;<br></code></pre></td></tr></table></figure>

<h5 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//懒汉式指针</span><br><span class="hljs-comment">//即使创建指针类型也存在问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglePointer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SinglePointer</span>()<br>    &#123;<br>    &#125;<br>    <span class="hljs-built_in">SinglePointer</span>(<span class="hljs-type">const</span> SinglePointer &amp;) = <span class="hljs-keyword">delete</span>;<br>    SinglePointer &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SinglePointer &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SinglePointer *<span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        s_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s_mutex.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SinglePointer</span>();<br>        s_mutex.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> SinglePointer *single;<br>    <span class="hljs-type">static</span> mutex s_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>问题：2、3可能调换，导致其他线程使用了为完全初始化的对象</p>
<ol>
<li>calloc 开辟空间</li>
<li>调用构造函数</li>
<li>将构造好的对象赋值给single</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglePointer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">SinglePointer</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">SinglePointer</span>(<span class="hljs-type">const</span> SinglePointer&amp;) = <span class="hljs-keyword">delete</span>;<br>    SinglePointer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SinglePointer&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 获取单例实例</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> SinglePointer* <span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 使用内存序语义的原子操作进行第一次检查</span><br>        SinglePointer* tmp = instance.<span class="hljs-built_in">load</span>(std::memory_order_acquire);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 使用RAII锁管理，确保异常情况下也能释放锁</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_mutex)</span></span>;<br><br>            <span class="hljs-comment">// 再次检查，避免另一个线程已经创建了实例</span><br>            tmp = instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SinglePointer</span>();<br><br>                <span class="hljs-comment">// 使用内存序语义存储指针，确保其他线程能看到完全初始化的对象</span><br>                instance.<span class="hljs-built_in">store</span>(tmp, std::memory_order_release);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 提供清理单例实例的方法（可选）</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DestroyInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_mutex)</span></span>;<br>        SinglePointer* tmp = instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (tmp != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> tmp;<br>            instance.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数（如果需要在销毁时执行清理操作）</span><br>    ~<span class="hljs-built_in">SinglePointer</span>() <br>    &#123;<br>        <span class="hljs-comment">// 清理资源的代码</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 使用原子类型确保线程安全的指针访问</span><br>    <span class="hljs-type">static</span> std::atomic&lt;SinglePointer*&gt; instance;<br>    <span class="hljs-type">static</span> std::mutex s_mutex;<br>&#125;;<br><br><span class="hljs-comment">// 静态成员初始化</span><br>std::atomic&lt;SinglePointer*&gt; SinglePointer::instance&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>std::mutex SinglePointer::s_mutex;<br></code></pre></td></tr></table></figure>

<h5 id="once-flag"><a href="#once-flag" class="headerlink" title="once_flag"></a><strong>once_flag</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-type">static</span> std::once_flag flag;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        std::<span class="hljs-built_in">call_once</span>(flag, createInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroyInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> instance;<br>        instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// cpp中初始化静态成员</span><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::once_flag Singleton::flag;<br></code></pre></td></tr></table></figure>

<p>但不能保证destroyInstance被调用，因此可以使用shared_ptr优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; instance;<br>    <span class="hljs-type">static</span> std::once_flag flag;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        instance = std::<span class="hljs-built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>());<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        std::<span class="hljs-built_in">call_once</span>(flag, createInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 不再需要destroyInstance方法，shared_ptr会自动管理内存</span><br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员</span><br>std::shared_ptr&lt;Singleton&gt; Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::once_flag Singleton::flag;<br></code></pre></td></tr></table></figure>

<h5 id="通用模版"><a href="#通用模版" class="headerlink" title="通用模版"></a>通用模版</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TempClass</span> &#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;;<br><span class="hljs-comment">//CRTP</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealClass</span>: <span class="hljs-keyword">public</span> TempClass&lt;RealClass&gt;&#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; _instance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> std::once_flag s_flag;<br>        std::<span class="hljs-built_in">call_once</span>(s_flag, [&amp;]() &#123;<br>            _instance = <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T);<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; _instance.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//通过继承方式实现网络模块单例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleNet</span> : <span class="hljs-keyword">public</span> Singleton&lt;SingleNet&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;SingleNet&gt;; <span class="hljs-comment">// Singleton里面有new操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleNet</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">SingleNet</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;SingleNet destruct &quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><ol>
<li><p><strong>Reactor模式</strong>:</p>
<ul>
<li>先接收”可以进行IO”的通知</li>
<li>应用程序自己执行实际的IO操作(read&#x2F;write)</li>
<li>处理结果来自自己执行的IO操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 等待事件通知（哪些fd准备好了）</span><br><span class="hljs-type">int</span> ready_fds = <span class="hljs-built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">// 处理就绪的文件描述符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ready_fds; i++) &#123;<br>    <span class="hljs-type">int</span> fd = events[i].data.fd;<br><br>    <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<br>        <span class="hljs-comment">// 通知：数据可读了</span><br>        <span class="hljs-comment">// 但我们必须自己执行读取操作</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> bytes_read = <span class="hljs-built_in">read</span>(fd, buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br><br>        <span class="hljs-keyword">if</span> (bytes_read &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 处理读取到的数据</span><br>            <span class="hljs-built_in">process_data</span>(fd, buffer, bytes_read);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;<br>        <span class="hljs-comment">// 通知：可以写数据了</span><br>        <span class="hljs-comment">// 但我们必须自己执行写入操作</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* response = <span class="hljs-built_in">get_response</span>(fd);<br>        <span class="hljs-built_in">write</span>(fd, response, <span class="hljs-built_in">strlen</span>(response));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Proactor模式</strong>:</p>
<ul>
<li>先发起异步IO请求</li>
<li>等待”IO已完成”的通知</li>
<li>处理结果来自系统已经完成的IO操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 发起异步读取操作</span><br>socket-&gt;<span class="hljs-built_in">async_read_some</span>(<br>    boost::asio::<span class="hljs-built_in">buffer</span>(*buffer),<br>    [<span class="hljs-keyword">this</span>, socket, buffer](<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::<span class="hljs-type">size_t</span> bytes_transferred) &#123;<br>        <span class="hljs-keyword">if</span> (!error) &#123;<br>            <span class="hljs-comment">// 读取操作已完成，直接处理数据</span><br>            <span class="hljs-comment">// 不需要自己调用read函数</span><br>            <span class="hljs-built_in">process_data</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), bytes_transferred);<br><br>            <span class="hljs-comment">// 发送响应</span><br>            <span class="hljs-built_in">start_write</span>(socket, <span class="hljs-string">&quot;Response&quot;</span>);<br><br>            <span class="hljs-comment">// 继续读取</span><br>            <span class="hljs-built_in">start_read</span>(socket);<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>操作系统底层io模型存在差异，如何实现Asio中Proactor风格的API？</p>
<ul>
<li><strong>Windows</strong>：Windows操作系统从早期就提供了真正的异步I&#x2F;O机制(IOCP)，天然支持Proactor模式</li>
<li><strong>Unix&#x2F;Linux</strong>：传统上依赖于I&#x2F;O多路复用机制(select&#x2F;poll&#x2F;epoll)，这些本质上是Reactor模式，Asio巧妙地使用底层的Reactor机制(epoll&#x2F;kqueue)<strong>模拟出</strong>Proactor行为</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">用户代码                     Asio库内部                     操作系统<br>    |                           |                             |<br>    |--<span class="hljs-built_in">async_read</span>()-----------&gt;|                             |<br>    |                           |--注册读事件到epoll---------&gt;|<br>    |                           |                             |<br>    |                           |&lt;--通知<span class="hljs-string">&quot;可读&quot;</span>----------------|<br>    |                           |                             |<br>    |                           |--执行实际<span class="hljs-built_in">read</span>()系统调用----&gt;|<br>    |                           |&lt;--返回数据------------------|<br>    |                           |                             |<br>    |&lt;--调用完成回调函数--------|                             |<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Asio在Linux上的简化工作原理</span><br><br><span class="hljs-comment">// 1. 用户发起异步读取请求</span><br>socket.<span class="hljs-built_in">async_read_some</span>(buffer, [](error_code ec, <span class="hljs-type">size_t</span> bytes_transferred) &#123;<br>    <span class="hljs-comment">// 5. 用户回调在数据已读取后执行</span><br>    <span class="hljs-built_in">process_data</span>(buffer, bytes_transferred);<br>&#125;);<br><br><span class="hljs-comment">// 2. Asio内部实现（对用户不可见）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">internal_register_read</span><span class="hljs-params">(socket_type sock, buffer_type&amp; buffer, callback_type&amp; callback)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个操作描述符</span><br>    op_state* state = <span class="hljs-keyword">new</span> op_state&#123;sock, buffer, callback&#125;;<br><br>    <span class="hljs-comment">// 注册到epoll，告诉系统&quot;当这个socket可读时通知我&quot;</span><br>    <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock, &amp;event);<br><br>    <span class="hljs-comment">// 保存状态以便之后处理</span><br>    operations_[sock] = state;<br>&#125;<br><br><span class="hljs-comment">// 3. Asio内部事件循环（在io_context::run中）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">io_context::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 等待epoll事件（这是Reactor风格的I/O事件等待）</span><br>        <span class="hljs-built_in">epoll_wait</span>(epoll_fd, events, max_events, timeout);<br><br>        <span class="hljs-keyword">for</span> (each ready_event) &#123;<br>            socket_type sock = ready_event.data.fd;<br>            op_state* state = operations_[sock];<br><br>            <span class="hljs-keyword">if</span> (ready_event.events &amp; EPOLLIN) &#123;<br>                <span class="hljs-comment">// 4. 事件发生时，Asio自己执行读取操作（这是关键部分）</span><br>                <span class="hljs-type">int</span> bytes = <span class="hljs-built_in">read</span>(sock, state-&gt;buffer, state-&gt;buffer_size);<br><br>                <span class="hljs-comment">// 读取完成后，安排调用用户的回调函数</span><br>                <span class="hljs-built_in">post_completion</span>(state-&gt;callback, error_code&#123;&#125;, bytes);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-1.png" srcset="/img/loading.gif" lazyload alt="image-20250426200128683"></p>
<p><code>socket.write_some()</code></p>
<ul>
<li><strong>部分写入操作</strong>：一次尝试写入尽可能多的数据</li>
<li><strong>返回值</strong>：返回实际写入的字节数(可能小于缓冲区大小)</li>
<li><strong>完成条件</strong>：<strong>操作系统缓冲区</strong>部分填满即可返回</li>
</ul>
<p><code>asio::write()</code></p>
<ul>
<li><strong>完整写入操作</strong>：保证写入整个缓冲区的所有数据</li>
<li><strong>内部实现</strong>：可能会进行多次<code>write_some()</code>调用</li>
<li><strong>返回值</strong>：返回总写入字节数(通常等于传入缓冲区大小)</li>
<li><strong>完成条件</strong>：所有数据都写入完毕才会返回</li>
</ul>
<p><code>socket.read_some()</code></p>
<ul>
<li><strong>部分读取操作</strong>：只要有任何数据可用就返回</li>
<li><strong>读取行为</strong>：读取部分数据（最多填充提供的缓冲区大小）</li>
<li><strong>返回值</strong>：返回实际读取的字节数</li>
<li><strong>错误处理</strong>：使用传入的[error](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;Applications&#x2F;Visual Studio Code.app&#x2F;Contents&#x2F;Resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html)参数报告错误，不抛出异常</li>
<li><strong>阻塞行为</strong>：有数据就立即返回，即使只读到一个字节&#96;</li>
</ul>
<p><code>asio::read()</code></p>
<ul>
<li><strong>完整读取操作</strong>：尝试填满整个缓冲区（代码中的buffer）</li>
<li><strong>读取行为</strong>：会进行多次底层读取，直到缓冲区填满</li>
<li><strong>返回值</strong>：返回读取的总字节数（通常等于缓冲区大小）</li>
<li><strong>错误处理</strong>：默认情况下会抛出异常</li>
<li><strong>阻塞行为</strong>：会一直阻塞直到缓冲区填满、到达文件末尾或发生错误</li>
</ul>
<h4 id="同步客户端服务器"><a href="#同步客户端服务器" class="headerlink" title="同步客户端服务器"></a>同步客户端服务器</h4><h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><p>同步的读写，并且完全单线程处理</p>
<ul>
<li>客户端之间会相互阻塞，并且如果客户端不发送也会阻塞</li>
<li>如果开辟子线程分别处理客户端，会消耗资源</li>
<li>发送接收为应答模式，不能实现全双工通讯</li>
<li>粘包问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">io_context: Asio的核心，所有I/O操作都需要它</span><br><span class="hljs-comment">endpoint: 表示网络地址(IP+端口)的抽象</span><br><span class="hljs-comment">acceptor: 服务器用来接受新连接的组件</span><br><span class="hljs-comment">resolver: 用于域名解析为IP地址</span><br><span class="hljs-comment">socket: 表示网络连接的抽象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1. An instance of &#x27;io_service&#x27; class is required by</span><br>            <span class="hljs-comment">// socket constructor. </span><br>    asio::io_context  ios;<br><br>    <span class="hljs-comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span><br>    <span class="hljs-comment">// a TCP protocol with IPv4 as underlying protocol.</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3. Instantiating an active TCP socket object.</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Used to store information about error that happens</span><br>    <span class="hljs-comment">// while opening the socket.</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 4. Opening the socket.</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Failed to open the socket.</span><br>        std::cout<br>            &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// TCP客户端示例，连接服务器并发送/接收消息</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_client</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br>        <span class="hljs-comment">// 解析主机名和端口</span><br>        asio::ip::<span class="hljs-function">tcp::resolver <span class="hljs-title">resolver</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::ip::tcp::resolver::results_type endpoints = <br>            resolver.<span class="hljs-built_in">resolve</span>(host, std::<span class="hljs-built_in">to_string</span>(port));<br><br>        <span class="hljs-comment">// 创建socket并连接到服务器</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::<span class="hljs-built_in">connect</span>(socket, endpoints);<br><br>        <span class="hljs-comment">// socket.connect(endpoints);</span><br><br>        <span class="hljs-comment">// 发送消息</span><br>        asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(message));<br><br>        <span class="hljs-comment">// 接收响应</span><br>        std::array&lt;<span class="hljs-type">char</span>, 1024&gt; recv_buffer;<br>        <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(recv_buffer));<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;接收到: &quot;</span>;<br>        std::cout.<span class="hljs-built_in">write</span>(recv_buffer.<span class="hljs-built_in">data</span>(), length);<br>        std::cout &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// TCP服务器示例，接受连接并处理客户端请求</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_server</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br><br>        <span class="hljs-comment">// 创建接收器监听新连接</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(io_context, </span></span><br><span class="hljs-params"><span class="hljs-function">            asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))</span></span>;<br><br>        <span class="hljs-comment">// 方式二: 分步操作</span><br>        <span class="hljs-comment">// asio::ip::tcp::endpoint ep(asio::ip::tcp::v4(), port);</span><br>        <span class="hljs-comment">// asio::ip::tcp::acceptor acceptor2(io_context, ep.protocol());</span><br>        <span class="hljs-comment">// // 需要后续显式调用 bind 和 listen</span><br>        <span class="hljs-comment">// acceptor2.bind(ep);</span><br>        <span class="hljs-comment">// acceptor2.listen();</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;服务器启动，监听端口 &quot;</span> &lt;&lt; port &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 为新连接创建socket</span><br>            asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br><br>            <span class="hljs-comment">// 等待连接</span><br>            acceptor.<span class="hljs-built_in">accept</span>(socket);<br><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;接受来自 &quot;</span> &lt;&lt; socket.<span class="hljs-built_in">remote_endpoint</span>() &lt;&lt; <span class="hljs-string">&quot; 的连接&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 读取客户端数据</span><br>            std::array&lt;<span class="hljs-type">char</span>, 1024&gt; buffer;<br>            boost::system::error_code error;<br><br>            <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(buffer), error);<br><br>            <span class="hljs-keyword">if</span> (!error) &#123;<br>                <span class="hljs-comment">// 处理请求</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;收到: &quot;</span>;<br>                std::cout.<span class="hljs-built_in">write</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                std::cout &lt;&lt; std::endl;<br><br>                <span class="hljs-comment">// 发送响应</span><br>                std::string response = <span class="hljs-string">&quot;服务器回应: &quot;</span>;<br>                response.<span class="hljs-built_in">append</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(response));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;用法: &quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; socket      - 测试socket创建&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; server 端口  - 启动TCP服务器&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; client 主机 端口 消息 - 运行TCP客户端&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::string mode = argv[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;socket&quot;</span>) &#123;<br>        <span class="hljs-comment">// 测试socket创建</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Socket创建成功!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;server&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 运行服务器</span><br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_server</span>(port);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;client&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">// 运行客户端</span><br>        std::string host = argv[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">3</span>]);<br>        std::string message = argv[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_client</span>(host, port, message);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无效的参数!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="多线程处理连接"><a href="#多线程处理连接" class="headerlink" title="多线程处理连接"></a>多线程处理连接</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 全局线程管理集合</span><br>std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;<br>std::mutex thread_set_mutex;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1. An instance of &#x27;io_service&#x27; class is required by</span><br>            <span class="hljs-comment">// socket constructor. </span><br>    asio::io_context  ios;<br><br>    <span class="hljs-comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span><br>    <span class="hljs-comment">// a TCP protocol with IPv4 as underlying protocol.</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3. Instantiating an active TCP socket object.</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Used to store information about error that happens</span><br>    <span class="hljs-comment">// while opening the socket.</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 4. Opening the socket.</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Failed to open the socket.</span><br>        std::cout<br>            &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// TCP客户端示例，连接服务器并发送/接收消息</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_client</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br>        <span class="hljs-comment">// 解析主机名和端口</span><br>        asio::ip::<span class="hljs-function">tcp::resolver <span class="hljs-title">resolver</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::ip::tcp::resolver::results_type endpoints = <br>            resolver.<span class="hljs-built_in">resolve</span>(host, std::<span class="hljs-built_in">to_string</span>(port));<br><br>        <span class="hljs-comment">// 创建socket并连接到服务器</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::<span class="hljs-built_in">connect</span>(socket, endpoints);<br><br>        <span class="hljs-comment">// 发送消息</span><br>        asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(message));<br><br>        <span class="hljs-comment">// 接收响应</span><br>        std::array&lt;<span class="hljs-type">char</span>, 1024&gt; recv_buffer;<br>        <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(recv_buffer));<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;接收到: &quot;</span>;<br>        std::cout.<span class="hljs-built_in">write</span>(recv_buffer.<span class="hljs-built_in">data</span>(), length);<br>        std::cout &lt;&lt; std::endl;<br><br><br>        <span class="hljs-comment">// asio::write(socket, asio::buffer(message));</span><br><br>        <span class="hljs-comment">// // 接收响应</span><br>        <span class="hljs-comment">// length = socket.read_some(asio::buffer(recv_buffer));</span><br><br>        <span class="hljs-comment">// std::cout &lt;&lt; &quot;接收到: &quot;;</span><br>        <span class="hljs-comment">// std::cout.write(recv_buffer.data(), length);</span><br>        <span class="hljs-comment">// std::cout &lt;&lt; std::endl;</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理客户端会话的函数 - 将在独立线程中运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_client</span><span class="hljs-params">(asio::ip::tcp::socket socket)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;线程启动 - 处理来自 &quot;</span> &lt;&lt; socket.<span class="hljs-built_in">remote_endpoint</span>() &lt;&lt; <span class="hljs-string">&quot; 的连接&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">for</span>(;;)&#123;<br>            <span class="hljs-comment">// 读取客户端数据</span><br>            std::array&lt;<span class="hljs-type">char</span>, 1024&gt; buffer;<br>            boost::system::error_code error;<br>            <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(buffer), error);<br><br>            <span class="hljs-keyword">if</span> (!error) &#123;<br>                <span class="hljs-comment">// 处理请求</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;收到: &quot;</span>;<br>                std::cout.<span class="hljs-built_in">write</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                std::cout &lt;&lt; std::endl;<br><br>                <span class="hljs-comment">// 发送响应</span><br>                std::string response = <span class="hljs-string">&quot;服务器回应: &quot;</span>;<br>                response.<span class="hljs-built_in">append</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(response));<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (error == boost::asio::error::eof) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error) &#123;<br>                <span class="hljs-keyword">throw</span> boost::system::<span class="hljs-built_in">system_error</span>(error);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;会话处理异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 修改后的TCP服务器，使用多线程处理连接</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_server</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br>        <span class="hljs-comment">// 创建接收器监听新连接</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(io_context, </span></span><br><span class="hljs-params"><span class="hljs-function">            asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))</span></span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;服务器启动，监听端口 &quot;</span> &lt;&lt; port &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 为新连接创建socket  </span><br>            asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br><br>            <span class="hljs-comment">// 等待连接</span><br>            acceptor.<span class="hljs-built_in">accept</span>(socket);<br><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;接受来自 &quot;</span> &lt;&lt; socket.<span class="hljs-built_in">remote_endpoint</span>() &lt;&lt; <span class="hljs-string">&quot; 的连接&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 创建新线程处理这个连接 </span><br>            <span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;(handle_client, std::<span class="hljs-built_in">move</span>(socket));<br><br>            <span class="hljs-comment">// 将线程添加到管理集合中 防止作用域结束线程销毁</span><br>            <span class="hljs-comment">// &#123;</span><br>            <span class="hljs-comment">//     std::lock_guard&lt;std::mutex&gt; lock(thread_set_mutex);</span><br>            <span class="hljs-comment">//     thread_set.insert(t);</span><br>            <span class="hljs-comment">// &#125;</span><br>            thread_set.<span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 清理所有线程</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(thread_set_mutex)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : thread_set) &#123;<br>            <span class="hljs-keyword">if</span> (t-&gt;<span class="hljs-built_in">joinable</span>()) &#123;<br>                t-&gt;<span class="hljs-built_in">join</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;用法: &quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; socket      - 测试socket创建&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; server 端口  - 启动TCP服务器&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; client 主机 端口 消息 - 运行TCP客户端&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::string mode = argv[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;socket&quot;</span>) &#123;<br>        <span class="hljs-comment">// 测试socket创建</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Socket创建成功!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;server&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 运行服务器</span><br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_server</span>(port);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;client&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">// 运行客户端</span><br>        std::string host = argv[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">3</span>]);<br>        std::string message = argv[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_client</span>(host, port, message);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无效的参数!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="异步写API"><a href="#异步写API" class="headerlink" title="异步写API"></a>异步写API</h4><h5 id="base"><a href="#base" class="headerlink" title="base"></a>base</h5><p>node：管理数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最大报文接收大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RECVSIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MsgNode</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> total_len): _total_len(total_len), _cur_len(<span class="hljs-number">0</span>)&#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>        <span class="hljs-built_in">memcpy</span>(_msg, msg, total_len);<br>    &#125;<br><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>    &#125;<br><br>    ~<span class="hljs-built_in">MsgNode</span>()&#123;<br>        <span class="hljs-keyword">delete</span>[]_msg;<br>    &#125;<br>    <span class="hljs-comment">//消息首地址</span><br>    <span class="hljs-type">char</span>* _msg;<br>    <span class="hljs-comment">//总长度</span><br>    <span class="hljs-type">int</span> _total_len;<br>    <span class="hljs-comment">//当前长度</span><br>    <span class="hljs-type">int</span> _cur_len;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">      std::shared_ptr&lt;MsgNode&gt;)</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>      std::shared_ptr&lt;MsgNode&gt; _send_node;<br>      std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>  &#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br><br><span class="hljs-comment">// 因为WriteCallBackErr函数为三个参数且为成员函数，而async_write_some需要的回调函数为两个参数，所以我们通过bind将三个参数转换为两个参数的普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, </span></span><br><span class="hljs-params"><span class="hljs-function">    std::<span class="hljs-type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len <br>        &lt; msg_node-&gt;_total_len) &#123;<br>        _send_node-&gt;_cur_len += bytes_transferred;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,<br>            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题：连续发送两个 <code>WriteToSocketErr(&quot;Hello World!&quot;); </code>可能出现”HelloHello World! World!” </p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>引入队列，以及_send_pending，每次只会有一个线程进行发送<code>（_send_pending=true）</code>，并在发送完成后处理队列中剩余的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    <span class="hljs-type">bool</span> _send_pending;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf), std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec,  std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//取出队首元素即当前未发送完数据</span><br>    <span class="hljs-keyword">auto</span> &amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>    send_data-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//数据未发送完， 则继续发送</span><br>    <span class="hljs-keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len-send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p>write替代write_some简化实现，每次回调中肯定发送完了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不能与async_write_some混合使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不考虑粘包情况， 先用固定的字节接收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//没读完继续读</span><br>    <span class="hljs-keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;<br>        _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len,<br>            _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>receive简化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>读取async_read_some更快，写入直接wirte更方便</p>
<h4 id="异步回调实现"><a href="#异步回调实现" class="headerlink" title="异步回调实现"></a>异步回调实现</h4><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>处理客户端消息收发的会话类，一个session对应一个客户端，封装了socket以及数据buffer: _data</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc):_socket(ioc)&#123;<br>    &#125;<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">Socket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _socket;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    tcp::socket _socket;<br>    <span class="hljs-keyword">enum</span> &#123;max_length = <span class="hljs-number">1024</span>&#125;;<br>    <span class="hljs-type">char</span> _data[max_length];<br>&#125;;<br><br><span class="hljs-number">1</span>   _data用来接收客户端传递的数据 <br><span class="hljs-number">2</span>   _socket为单独处理客户端读写的socket。 <br><span class="hljs-number">3</span>   handle_read和handle_write分别为读回调函数和写回调函数。<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始开始读</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2)<br>    );<br>&#125;<br><br><span class="hljs-comment">// 读回调：会写相同数据到peer，同时写完后触发写回调handle_write</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transfered), <br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写回调：打印读读数据，并继续等待读取  打乒乓球模式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">// 写完后继续读取新数据</span><br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>                placeholders::_2)<br>        );<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Write error: &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="server"><a href="#server" class="headerlink" title="server"></a>server</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_accept</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    boost::asio::io_context&amp; _ioc;<br>    tcp::acceptor _acceptor;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Server::<span class="hljs-built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port) :_ioc(ioc),<br>_acceptor(ioc, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)) &#123;<br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    Session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Session</span>(_ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br><br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>二次析构：如果同时注册了客户端的读和写回调，然后客户端断开请求，这时候可能会导致同时进入到delete this;导致重复回收资源。<strong>解决：智能指针+伪闭包实现</strong><ul>
<li>目前是乒乓球模式，并不会同时注册读写事件，所以不会出错，实际应用是全双工的</li>
</ul>
</li>
<li>未处理粘包，序列化，以及逻辑和收发线程解耦等问题</li>
<li>未做到完全的收发分离(全双工逻辑)</li>
</ul>
<p>client代码和之前同步的一致</p>
<h5 id="智能指针优化"><a href="#智能指针优化" class="headerlink" title="智能指针优化"></a>智能指针优化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用指针指针代替new    </span><br><span class="hljs-comment">// Session* new_session = new Session(_ioc);</span><br>shared_ptr&lt;Session&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;Session&gt;(_ioc);<br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>    std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br><br><br>bind后计数++<br>shared_ptr传递给所有回调函数，实现生命周期自动管理。<br><br><br><br>  如何从自身成员函数内部获取指向自己的 std::shared_ptr？<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>: <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Session&gt;<br>&#123;<br>    <span class="hljs-comment">// 现在可以调用 shared_from_this() 了</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="队列优化-05"><a href="#队列优化-05" class="headerlink" title="队列优化-05"></a>队列优化-05</h5><p>希望服务器一直监听写事件；此外多次发送是有序的。</p>
<p>server端发送添加一个队列，放到session中，代表对每一个客户端的发送队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br>  std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>  std::mutex _send_lock;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>服务器端的数据发送，抽象出一个send函数，将数据加入到发送队列中，并通过判断是否有其他线程正在工作来决定自己是否执行send</li>
<li>服务端接受到数据后，调用send，并重新回到监听读事件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> max_length)</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>    _send_que.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><br>    <span class="hljs-keyword">if</span>(_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length), <br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Server received data: &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        <span class="hljs-comment">// boost::asio::async_write(_socket, boost::asio::buffer(_data, bytes_transfered), </span><br>        <span class="hljs-comment">//     std::bind(&amp;Session::handle_write, this, placeholders::_1, session));</span><br><br>        <span class="hljs-comment">// 服务器接受到之后，不是打乒乓球回传，而是使用队列发送，并且重新监听写回调</span><br>        <span class="hljs-built_in">Send</span>(_data, bytes_transfered);<br><br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2, <span class="hljs-built_in">shared_from_this</span>())<br>        );<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Read error: &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">// 写完后继续读取新数据</span><br>        <span class="hljs-comment">// memset(_data, 0, max_length);</span><br>        <span class="hljs-comment">// _socket.async_read_some(boost::asio::buffer(_data, max_length),</span><br>        <span class="hljs-comment">//     std::bind(&amp;Session::handle_read, this, placeholders::_1,</span><br>        <span class="hljs-comment">//         placeholders::_2, session)</span><br>        <span class="hljs-comment">// );</span><br><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>        _send_que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!_send_que.<span class="hljs-built_in">empty</span>())&#123;<br>            boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_send_que.<span class="hljs-built_in">front</span>()-&gt;_data, _send_que.<span class="hljs-built_in">front</span>()-&gt;_max_len), <br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Write error: &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="粘包TLV-06"><a href="#粘包TLV-06" class="headerlink" title="粘包TLV-06"></a>粘包TLV-06</h4><p>记录下包的长度，使得TCP层的数据流可以被正确的解析</p>
<h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p>简单实现：使用指定长度的read先读取长度，再根据长度读取内容，需要额外添加以下存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前在解析头 还是 体</span><br><span class="hljs-type">bool</span> _b_head_parse;<br><br><span class="hljs-comment">// 当前收到的消息结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br><br><span class="hljs-comment">// 当前收到的头部结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br></code></pre></td></tr></table></figure>

<p>还能更加简化，使用lambda嵌套lambda</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read_fix</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">200</span>));<br>        <span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br>            _b_head_parse = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-type">short</span> data_len;<br>            <span class="hljs-built_in">memcpy</span>(&amp;data_len, _data, HEAD_LENGTH);<br><br>            _recv_msg_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br><br>            boost::asio::<span class="hljs-built_in">async_read</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, data_len),<br>                std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read_fix, <span class="hljs-keyword">this</span>, placeholders::_1,<br>                    placeholders::_2, <span class="hljs-built_in">shared_from_this</span>())<br>            );<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            _b_head_parse = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data, _data, _recv_msg_node-&gt;_total_len);<br>            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            std::cout&lt;&lt; <span class="hljs-string">&quot;recieve msg: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;<br><br>            <span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br>            boost::asio::<span class="hljs-built_in">async_read</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, HEAD_LENGTH),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read_fix, <span class="hljs-keyword">this</span>, placeholders::_1,<br>                placeholders::_2, <span class="hljs-built_in">shared_from_this</span>())<br>        );<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="read-some"><a href="#read-some" class="headerlink" title="read_some"></a>read_some</h5><p>复杂实现：使用read_some函数，需要每次将读出来的数据_data组装到合适的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">2000</span>));<br>        <span class="hljs-comment">//已经移动的字符数</span><br>        <span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 核心是将接收的数据buffer: _data放入到合适的位置</span><br>        <span class="hljs-keyword">while</span> (bytes_transferred&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 正在接收头部？</span><br>            <span class="hljs-comment">//     头部还没完成，复制数据后return</span><br>            <span class="hljs-comment">//     头部完成还有剩余，复制头部数据后，continue</span><br><br>            <span class="hljs-comment">// 接收数据部分</span><br>            <span class="hljs-comment">//     接收不够，复制数据后return</span><br>            <span class="hljs-comment">//     接收超出，复制数据、回发报文、处理剩下的</span><br><br>            <span class="hljs-keyword">if</span>(!_b_head_parse)&#123;<br>                <span class="hljs-keyword">if</span>(bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH)&#123;<br>                    <span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>                    _recv_head_node-&gt;_cur_len += bytes_transferred;<br>                    copy_len += bytes_transferred;<br>                    bytes_transferred -= bytes_transferred;<br>                    <span class="hljs-keyword">continue</span> ;<br>                &#125;<br><br>                <span class="hljs-comment">// head and body</span><br>                <span class="hljs-type">short</span> left_head = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;<br>                <span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, left_head);<br>                copy_len += left_head;<br>                bytes_transferred -= left_head;<br><br>                <span class="hljs-type">short</span> data_len;<br>                <span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br>                std::cout&lt;&lt; <span class="hljs-string">&quot;recieve data len: &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;<br><br>                _recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br>                _recv_msg_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br>                _b_head_parse = <span class="hljs-literal">true</span>;<br><br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(bytes_transferred + _recv_msg_node-&gt;_cur_len &lt; _recv_msg_node-&gt;_total_len)&#123;<br>                    <span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>                    _recv_msg_node-&gt;_cur_len += bytes_transferred;<br>                    copy_len += bytes_transferred;<br>                    bytes_transferred -= bytes_transferred;<br>                    <span class="hljs-keyword">continue</span> ;<br>                &#125;<br><br>                <span class="hljs-type">short</span> left_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br>                <span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, left_msg);<br>                bytes_transferred -= left_msg;<br>                copy_len += left_msg;<br>                _recv_msg_node-&gt;_cur_len += left_msg;<br><br>                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                std::cout&lt;&lt; <span class="hljs-string">&quot;recieve msg: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;<br><br>                <span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br>                _b_head_parse = <span class="hljs-literal">false</span>;<br><br>            &#125;<br>        &#125;<br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length), <br>                        std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>,  placeholders::_1, placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同理客户端也要做一定的修改，额外添加长度并且收发分离</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">thread <span class="hljs-title">send_thread</span><span class="hljs-params">([&amp;socket] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">for</span>(;;)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">10</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> * message = <span class="hljs-string">&quot;Hello from client!&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">char</span> send_data[MAX_LENGTH];</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">short</span> msg_len = strlen(message);</span></span><br><span class="hljs-params"><span class="hljs-function">                memcpy(send_data, &amp;msg_len, HEAD_LENGTH);</span></span><br><span class="hljs-params"><span class="hljs-function">                memcpy(send_data + HEAD_LENGTH, message, msg_len);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                boost::asio::write(socket, boost::asio::buffer(send_data, msg_len + HEAD_LENGTH));</span></span><br><span class="hljs-params"><span class="hljs-function">                cout &lt;&lt; <span class="hljs-string">&quot;Message sent: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br><br>        <span class="hljs-function">thread <span class="hljs-title">recv_thread</span><span class="hljs-params">([&amp;socket] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">for</span> (;;) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-comment">// 接收回显</span></span></span><br><span class="hljs-params"><span class="hljs-function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">2</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">char</span> reply_head[HEAD_LENGTH];</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">size_t</span> reply_length = boost::asio::read(socket, boost::asio::buffer(reply_head, HEAD_LENGTH));</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">short</span> reply_len;</span></span><br><span class="hljs-params"><span class="hljs-function">                memcpy(&amp;reply_len, &amp;reply_head, HEAD_LENGTH);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">char</span> msg[MAX_LENGTH] = &#123;<span class="hljs-number">0</span>&#125;;</span></span><br><span class="hljs-params"><span class="hljs-function">                reply_length = boost::asio::read(socket, boost::asio::buffer(msg, reply_len));</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                cout &lt;&lt; <span class="hljs-string">&quot;Server replied: &quot;</span> &lt;&lt; string(msg, reply_length) &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="字节序和序列化"><a href="#字节序和序列化" class="headerlink" title="字节序和序列化"></a>字节序和序列化</h4><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>多字节数据在内存中的存储顺序。</p>
<ul>
<li><strong>大端序（Big-Endian）</strong>：高位字节存储在低地址</li>
<li><strong>小端序（Little-Endian）</strong>：低位字节存储在低地址</li>
</ul>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">0x12345678<br>大端序存储<br>内存地址： 0x1000  0x1001  0x1002  0x1003<br>内存内容：  <span class="hljs-number"> 12 </span>    <span class="hljs-number"> 34 </span>    <span class="hljs-number"> 56 </span>    <span class="hljs-number"> 78 </span>  <br><br>小端<br>内存地址： 0x1000  0x1001  0x1002  0x1003<br>内存内容：  <span class="hljs-number"> 78 </span>    <span class="hljs-number"> 56 </span>    <span class="hljs-number"> 34 </span>    <span class="hljs-number"> 12 </span>  <br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 当前系统为小端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当前系统为大端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>长度信息，发送接收统一<strong>本地序-&gt;网络序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len=boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br><br><br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span> * msg, <span class="hljs-type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="hljs-number">0</span>)&#123;<br>    _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len<span class="hljs-number">+1</span>]();<br>    <span class="hljs-comment">//转为网络字节序</span><br>    <span class="hljs-type">int</span> max_len_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(max_len);<br>    <span class="hljs-built_in">memcpy</span>(_data, &amp;max_len_host, HEAD_LENGTH);<br>    <span class="hljs-built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len);<br>    _data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h5><p>Protocol Buffers（简称 Protobuf）是一种轻便高效的序列化数据结构的协议，由 Google 开发。它可以用于将结构化数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域。 我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install protobuf<br><br>protoc --cpp_out=. message.proto<br><br>clang++ -std=c++17 main.cpp message.pb.cc -I/opt/homebrew/include -L/opt/homebrew/lib \<br>  -lprotobuf -labsl_base -labsl_log_internal_check_op -labsl_log_internal_message \<br>  -labsl_log_internal_log_sink_set -o main<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">syntax</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;proto3&quot;</span><span class="hljs-comment">;</span><br>package tutorial<span class="hljs-comment">;</span><br><br>message Person &#123;<br>  string name <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  int32 id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>  string email <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;message.pb.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    tutorial::Person person;<br>    person.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;John Doe&quot;</span>);<br>    person.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">123</span>);<br>    person.<span class="hljs-built_in">set_email</span>(<span class="hljs-string">&quot;john@example.com&quot;</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Person: &quot;</span> &lt;&lt; person.<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 序列化为字符串</span><br>    std::string serialized_str;<br>    person.<span class="hljs-built_in">SerializeToString</span>(&amp;serialized_str);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;序列化后大小: &quot;</span> &lt;&lt; serialized_str.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 反序列化</span><br>    tutorial::Person deserialized_person;<br>    <span class="hljs-keyword">if</span> (deserialized_person.<span class="hljs-built_in">ParseFromString</span>(serialized_str)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;反序列化成功!&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;反序列化后的 Person: &quot;</span> &lt;&lt; deserialized_person.<span class="hljs-built_in">name</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot;, ID: &quot;</span> &lt;&lt; deserialized_person.<span class="hljs-built_in">id</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot;, Email: &quot;</span> &lt;&lt; deserialized_person.<span class="hljs-built_in">email</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;反序列化失败!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="json"><a href="#json" class="headerlink" title="json"></a>json</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/json.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> json = boost::json;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    json::object obj;<br>    obj[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span>;<br>    obj[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">30</span>;<br>    obj[<span class="hljs-string">&quot;skills&quot;</span>] = json::array&#123;<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;JSON&quot;</span>&#125;;<br><br>    <span class="hljs-comment">// 序列化</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;序列化输出: &quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; obj &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 转换为字符串用于反序列化</span><br>    std::string json_str = json::<span class="hljs-built_in">serialize</span>(obj);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n字符串形式: &quot;</span> &lt;&lt; json_str &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 反序列化</span><br>    json::value parsed = json::<span class="hljs-built_in">parse</span>(json_str);<br><br>    <span class="hljs-comment">// 访问反序列化后的数据</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n反序列化后访问数据: &quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; parsed.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-built_in">as_string</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;年龄: &quot;</span> &lt;&lt; parsed.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-built_in">as_int64</span>() &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;技能: &quot;</span>;<br>    json::array skills = parsed.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;skills&quot;</span>).<span class="hljs-built_in">as_array</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; skills.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        std::cout &lt;&lt; skills[i].<span class="hljs-built_in">as_string</span>();<br>        <span class="hljs-keyword">if</span> (i &lt; skills.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="逻辑层-08"><a href="#逻辑层-08" class="headerlink" title="逻辑层-08"></a>逻辑层-08</h4><p>目前所有的逻辑只有一个线程处理，无法充分利用多线程</p>
<ul>
<li>之前的逻辑层和asio回调在一个线程中顺序处理，一个socket时间长可能会影响其他socket消息的处理。</li>
<li>现在业务处理放到一个队列中，由逻辑层消费者线程处理<ul>
<li>逻辑层在接收到用户的消息后，处理具体的业务，如查询数据库</li>
</ul>
</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-2.png" srcset="/img/loading.gif" lazyload alt="image-20250428095058092"></p>
<p><strong>解决方案</strong>：再抽象一层，handle_read读取出用户请求后加入事件就绪队列，逻辑层额外单线程或多线程处理这个队列。redis类似就是这种设计</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-05-16-152244743.png" srcset="/img/loading.gif" lazyload alt="image-20250428095336148"></p>
<p>数据包格式改造：tlv格式，增加id字段作为type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">short</span> _cur_len;<br>    <span class="hljs-type">short</span> _total_len;<br>    <span class="hljs-type">short</span> _msg_id;<br>    <span class="hljs-type">char</span>* _data;<br></code></pre></td></tr></table></figure>



<h5 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h5><p>本质上是一个生产者消费者模型，asio是生产者，而逻辑线程是消费者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionExample</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::mutex _mutex;                <span class="hljs-comment">// 互斥锁</span><br>    std::condition_variable _consume; <span class="hljs-comment">// 条件变量</span><br>    <span class="hljs-type">bool</span> cond = <span class="hljs-literal">false</span>;                <span class="hljs-comment">// 这里可以是任何条件表达式</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waitForCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建唯一锁，用于自动管理互斥锁</span><br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <br>        <span class="hljs-comment">// 使用while循环检查条件，防止虚假唤醒</span><br>        <span class="hljs-keyword">while</span> (!cond) &#123;<br>            <span class="hljs-comment">// 释放锁并等待，当被通知时重新获取锁</span><br>            _consume.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <br>        <span class="hljs-built_in">assert</span>(cond);  <span class="hljs-comment">// 此时条件肯定满足</span><br>        <br>        <span class="hljs-comment">// 条件满足后的处理逻辑</span><br>        <br>        <span class="hljs-comment">// 作用域结束时自动释放互斥锁</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signalCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建唯一锁</span><br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <br>        <span class="hljs-comment">// 更新条件</span><br>        cond = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 或其他使条件成立的逻辑</span><br>        <br>        <span class="hljs-comment">// 通知所有等待的线程</span><br>        _consume.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 相当于notifyAll</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">wait(lock) 内部执行</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">&#123;</span><br><span class="hljs-attribute">  1. 将当前线程加入条件变量的等待队列</span><br><span class="hljs-attribute">  2. 原子地释放互斥锁</span><br><span class="hljs-attribute">  3. 将线程置于睡眠状态</span><br><span class="hljs-attribute">  4. 被唤醒后重新获取互斥锁</span><br><span class="hljs-attribute">  5. 返回到调用点</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">notify操作的执行流程</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">notify_one()</span><span class="hljs-punctuation">:</span> <span class="hljs-string">从等待队列中选择一个线程唤醒</span><br>  <span class="hljs-attribute">notify_all()</span><span class="hljs-punctuation">:</span> <span class="hljs-string">唤醒等待队列中的所有线程</span><br>  <span class="hljs-attribute">被唤醒的线程会竞争获取互斥锁，只有获得锁后才能继续执行</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">等待与唤醒机制</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">Linux</span><span class="hljs-punctuation">:</span> <span class="hljs-string">使用futex系统调用(fast userspace mutex)</span><br>  <span class="hljs-attribute">Windows</span><span class="hljs-punctuation">:</span> <span class="hljs-string">使用WaitForSingleObject和条件变量API</span><br>  现代实现大多使用futex避免不必要的内核态切换<br></code></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">notify时的锁管理<br>C++<br>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>    cond = <span class="hljs-literal">true</span>;<br>&#125;  <span class="hljs-comment">// 先释放锁</span><br>_cv.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 再通知</span><br>效率考量:<br>  持有锁时通知会导致被唤醒线程立即阻塞在锁获取上<br>  先释放锁再通知可以减少线程切换开销<br>执行顺序:<br>先改变条件	再发出通知的顺序是关键<br>先通知后改变条件会导致竞态条件<br></code></pre></td></tr></table></figure>



<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span>  function&lt;<span class="hljs-type">void</span>(F&lt;CSession&gt;, <span class="hljs-type">short</span> msg_id, string msg_data)&gt; FunCallBack;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicSystem</span>:<span class="hljs-keyword">public</span> Singleton&lt;LogicSystem&gt;&#123;<br><br>  <br><span class="hljs-keyword">private</span>:<br>  	<span class="hljs-comment">// 生产者消费者中的并发控制</span><br>  	std::mutex _mutex;<br>    std::condition_variable _consume;<br><br>    <span class="hljs-comment">// 消费队列</span><br>    std::queue&lt;shared_ptr&lt;LogicNode&gt;&gt; _msg_queue;<br><br>    <span class="hljs-comment">// 回调函数  根据id 决定不同的回调函数</span><br>    std::map&lt;<span class="hljs-type">short</span>, FunCallBack&gt; _fun_callbacks;<br>    <br>    std::thread _thread;  	<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// #include &lt;thread&gt;</span><br><span class="hljs-comment">// #include &lt;memory&gt;</span><br><span class="hljs-comment">// #include &lt;functional&gt;</span><br><span class="hljs-comment">// #include &lt;boost/asio.hpp&gt;</span><br><span class="hljs-comment">// #include &quot;const.h&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MsgNode.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;session.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Singleton.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LogicSystem.h&quot;</span></span><br><br><br>LogicSystem::<span class="hljs-built_in">LogicSystem</span>():_b_stop(<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-built_in">RegisterCallBacks</span>();<br>    _thread = std::<span class="hljs-built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="hljs-keyword">this</span>);<br>&#125;<br><br>LogicSystem::~<span class="hljs-built_in">LogicSystem</span>()&#123;<br>    _b_stop = <span class="hljs-literal">true</span>;<br>    _consume.<span class="hljs-built_in">notify_one</span>();<br>    _thread.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::PostMsgToQue</span><span class="hljs-params">(std::shared_ptr &lt;LogicNode&gt; msg)</span></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>    _msg_queue.<span class="hljs-built_in">push</span>(msg);<br><br>    <span class="hljs-comment">// 这里是不管三七二十一都通知，也可以是转为非空时 进行通知，其他时间不通知</span><br>    <span class="hljs-comment">// 通知前可以先主动释放锁unique_lk.unlock(); 但也可以默认退出作用域自动释放</span><br>    _consume.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::DealOneMsg</span><span class="hljs-params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> it = _fun_callbacks.<span class="hljs-built_in">find</span>(msg-&gt;_recvnode-&gt;_msg_id);<br>    <span class="hljs-keyword">if</span>(it != _fun_callbacks.<span class="hljs-built_in">end</span>())&#123;<br>        it-&gt;<span class="hljs-built_in">second</span>(msg-&gt;_session, msg-&gt;_recvnode-&gt;_msg_id, <br>            std::<span class="hljs-built_in">string</span>(msg-&gt;_recvnode-&gt;_data, msg-&gt;_recvnode-&gt;_total_len));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::DealMsg</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br><br>        <span class="hljs-keyword">while</span>(_msg_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; !_b_stop)&#123;<br>            _consume.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(_b_stop)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;LogicSystem is stop, process the left&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">while</span>(!_msg_queue.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">auto</span> msg = _msg_queue.<span class="hljs-built_in">front</span>();<br>                _msg_queue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">DealOneMsg</span>(msg);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> msg = _msg_queue.<span class="hljs-built_in">front</span>();<br>        _msg_queue.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-comment">// 提前unlock，防止处理线程一直拿着锁！！！</span><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-built_in">DealOneMsg</span>(msg);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::RegisterCallBacks</span><span class="hljs-params">()</span></span>&#123;<br>    _fun_callbacks[MSG_IDS::MSG_HELLO_WORLD] = <br>        <span class="hljs-built_in">bind</span>(&amp;LogicSystem::HelloWordCallBack, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::HelloWordCallBack</span><span class="hljs-params">(shared_ptr&lt;Session&gt; session, <span class="hljs-type">short</span> msg_id, string msg_data)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World call back! &quot;</span> &lt;&lt; msg_data &lt;&lt; std::endl;<br><br>    this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10000</span>));<br><br>    <span class="hljs-type">char</span>* non_const_msg_data = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(msg_data.<span class="hljs-built_in">c_str</span>());<br>    session-&gt;<span class="hljs-built_in">Send</span>(non_const_msg_data, msg_data.<span class="hljs-built_in">length</span>(), MSG_IDS::MSG_HELLO_WORLD);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h5><p>利用signal_set 定义了一系列信号合集，并且绑定了一个匿名函数，匿名函数捕获了io_context的引用，并且函数中设置了停止操作，也就是说当捕获到SIGINT,SIGTERM等信号时，会调用<code>io_context.stop</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span> <span class="hljs-comment">// For SIGINT and SIGTERM</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        boost::asio::io_context  io_context;<br>        boost::<span class="hljs-function">asio::signal_set <span class="hljs-title">signals</span><span class="hljs-params">(io_context, SIGINT, SIGTERM)</span></span>;<br>        signals.<span class="hljs-built_in">async_wait</span>([&amp;io_context](<span class="hljs-keyword">auto</span>, <span class="hljs-keyword">auto</span>) &#123;<br>            io_context.<span class="hljs-built_in">stop</span>();<br>            &#125;);<br>        <span class="hljs-function">CServer <span class="hljs-title">s</span><span class="hljs-params">(io_context, <span class="hljs-number">10086</span>)</span></span>;<br>        io_context.<span class="hljs-built_in">run</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="多线程ioc-09"><a href="#多线程ioc-09" class="headerlink" title="多线程ioc-09"></a>多线程ioc-09</h4><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/reactor.html">https://xiaolincoding.com/os/8_network_system/reactor.html</a></p>
<ul>
<li>图中业务处理是串联的，实际上业务我们已经交给了业务线程</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-3.png" srcset="/img/loading.gif" lazyload alt="image-20250508213456352"></p>
<p>之前是解耦了io和业务处理，现在将io进一步解耦并扩展</p>
<h5 id="多ioc-多线程"><a href="#多ioc-多线程" class="headerlink" title="多ioc+多线程"></a>多ioc+多线程</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-4.png" srcset="/img/loading.gif" lazyload alt="image-20250508172344229"></p>
<p>运行多个io_context在不同的线程中，主线程还是一个io_context用于处理客户端接收连接，客户端的读写请求用pool中的某一个io_context处理。实现在io层面多线程，并且接受客户端请求和处理客户端读写分开。</p>
<ul>
<li>之前：一个io_context负责服务器socket接受新客户端，同时负责所有客户端socket读写</li>
<li>现在：io_context只负责接受新客户端，接收到的客户端由pool中的ioc负责读写<ul>
<li>同一个客户端，绑定的始终是<strong>同一个</strong>pool中的ioc</li>
<li>每一个ioc可以理解为创建了一个独立的epoll，并有一个线程处理</li>
<li>一个主线程做 listen&#x2F;accept，N 个 I&#x2F;O 线程各自跑自己的 EventLoop（每个对应一个 epoll 实例），accept 分发新连接给不同子 loop。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsioIOServicePool</span>: <span class="hljs-keyword">public</span> Singleton&lt;AsioIOServicePool&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;AsioIOServicePool&gt;;<br><br><br>    <span class="hljs-keyword">using</span> WorkGuard = boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;;<br>    <span class="hljs-keyword">using</span> WorkGuardPtr = std::unique_ptr&lt;WorkGuard&gt;;<br><br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">AsioIOServicePool</span>();<br><br>    boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">GetIOService</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">AsioIOServicePool</span>(std::<span class="hljs-type">size_t</span> size = std::thread::<span class="hljs-built_in">hardware_concurrency</span>());<br><br>    std::vector&lt;boost::asio::io_context&gt; _io_contexts;<br>		<br>  	<span class="hljs-comment">// 防止没有注册事件的ioc直接结束了</span><br>    std::vector&lt;WorkGuardPtr&gt; _works;<br>    std::vector&lt;std::thread&gt; _threads;<br>    std::<span class="hljs-type">size_t</span>   _nextIOService;<br>&#125;;<br>AsioIOServicePool::<span class="hljs-built_in">AsioIOServicePool</span>(std::<span class="hljs-type">size_t</span> size):_io_contexts(size), _works(size), _nextIOService(<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        _works[i] = std::<span class="hljs-built_in">make_unique</span>&lt;WorkGuard&gt;(boost::asio::<span class="hljs-built_in">make_work_guard</span>(_io_contexts[i]));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        _threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>, i]()&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;IOService thread &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; started.&quot;</span> &lt;&lt; std::endl;<br>            _io_contexts[i].<span class="hljs-built_in">run</span>();<br>        &#125;);<br>    &#125;<br>&#125;<br>boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">AsioIOServicePool::GetIOService</span><span class="hljs-params">()</span></span>&#123;<br>    _nextIOService = (_nextIOService + <span class="hljs-number">1</span>) % _io_contexts.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">return</span> _io_contexts[_nextIOService];<br>&#125;<br><br><br><span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(ioc, port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Session* new_session = new Session(_ioc);</span><br>    <span class="hljs-keyword">auto</span>&amp; ioc = AsioIOServicePool::<span class="hljs-built_in">getInstance</span>()-&gt;<span class="hljs-built_in">GetIOService</span>();<br>    shared_ptr&lt;Session&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;Session&gt;(ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-05-16-203252837.png" srcset="/img/loading.gif" lazyload alt="image-20250508213523316"></p>
<h6 id="对比tomcat"><a href="#对比tomcat" class="headerlink" title="对比tomcat"></a>对比tomcat</h6><table>
<thead>
<tr>
<th>Layer</th>
<th>Your Asio Server</th>
<th>Tomcat NIO Connector</th>
</tr>
</thead>
<tbody><tr>
<td>接收连接<br />监听 socket 上的 IO<br />处理请求</td>
<td>main_ioc+<br />AsioIOServicePool+<br />LogicSystem</td>
<td>Acceptor（接收线程+ <br />Poller（Selector 轮询线程+<br /> Worker（请求处理线程池）</td>
</tr>
<tr>
<td><strong>Accept</strong></td>
<td>1 acceptor on <code>main io_context</code></td>
<td>1 (or configurable) acceptor threads</td>
</tr>
<tr>
<td><strong>I&#x2F;O Reactors</strong></td>
<td>N <code>io_context</code> threads</td>
<td>1 (by default) NIO selector thread</td>
</tr>
<tr>
<td><strong>I&#x2F;O → Business Handoff</strong></td>
<td><code>LogicSystem::PostMsgToQue</code> → separate queue</td>
<td>selector thread hands to a servlet thread pool</td>
</tr>
<tr>
<td><strong>Business Threads</strong></td>
<td>1 (or more if you extend) <code>LogicSystem</code> thread(s)</td>
<td>configurable <code>maxThreads</code> executor (200+)</td>
</tr>
</tbody></table>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss">      ┌────────────────────────┐<br>      │   <span class="hljs-selector-tag">Main</span> Thread (Acceptor)│<br>      │   - async_accept       │<br>      └────────────┬───────────┘<br>                   ↓<br>┌────────────────────────────────────┐<br>│         AsioIOServicePool          │<br>│   (like Poller / Selector pool)    │<br>└────────────┬────────────┬──────────┘<br>             ↓            ↓<br>      ┌────────────┐ ┌────────────┐<br>      │ Session N  │ │ Session M  │ ...<br>      └────┬───────┘ └────┬───────┘<br>           ↓              ↓<br>     │PostMsgToQue│ │PostMsgToQue│<br>           ↓              ↓<br>   ┌─────────────────────────────────┐<br>   │       LogicSystem (Worker)      │<br>   │     单线程 → 改为线程池优化        │<br>   └─────────────────────────────────┘<br></code></pre></td></tr></table></figure>



<h5 id="单ioc-多线程run"><a href="#单ioc-多线程run" class="headerlink" title="单ioc+多线程run"></a>单ioc+多线程run</h5><p>直接同一个ioc，但多个线程中执行run</p>
<ul>
<li>只有一个内核事件队列，也就是epoll实例</li>
<li>多个线程同时调用ioc.run，也就是<code>epoll_wait</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadNum; ++i) &#123;<br>    _threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]() &#123;<br>        _service.<span class="hljs-built_in">run</span>();<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-5.png" srcset="/img/loading.gif" lazyload alt="image-20250508210545803"></p>
<ul>
<li>可以多个线程执行回调函数</li>
<li>存在问题，可能多个线程同时处理同一个用户socket，导致并发以及处理顺序问题（同时调用回调）</li>
<li>引入一个strand，实现维护一个队列：<strong>保证所有通过同一个 <code>strand</code> 提交的 handler，永远不会并行执行</strong>，它们会“排队”并由某个线程一个接一个地执行。</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-6.png" srcset="/img/loading.gif" lazyload alt="image-20250508210243102"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在 Session 里声明：</span><br>boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; _strand;<br><br><span class="hljs-comment">// 构造函数里初始化：</span><br><span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc)<br>  : _socket(ioc), _strand(ioc.<span class="hljs-built_in">get_executor</span>()) &#123; ... &#125;<br><br><span class="hljs-comment">// async 调用时包装到 strand：</span><br>boost::asio::<span class="hljs-built_in">async_read</span>(_socket, buf,<br>  boost::asio::<span class="hljs-built_in">bind_executor</span>(_strand,<br>    std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read_fix, <span class="hljs-built_in">shared_from_this</span>(), ...))<br>);<br><br></code></pre></td></tr></table></figure>

<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-7.png" srcset="/img/loading.gif" lazyload alt="image-20250508213440635"></p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul>
<li><strong>轻量级</strong>： 协程运行在用户态，不需要操作系统提供线程上下文切换支持，因此比线程更加轻量级。</li>
<li><strong>非抢占式</strong>： 协程的切换是由程序员显式控制的（通常通过 <code>yield</code> 或 <code>await</code>），而非由操作系统抢占。</li>
<li><strong>单线程并发</strong>： 协程虽然可以实现并发，但它们是在单线程内完成的，没有真正的并行。</li>
<li><strong>状态保存</strong>： 协程可以在中途暂停并保存当前执行状态，稍后恢复并继续执行。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>协程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>调度方式</td>
<td>主动让出控制权（协作式）</td>
<td>由操作系统内核调度（抢占式）</td>
</tr>
<tr>
<td>开销</td>
<td>轻量级，创建和上下文切换很快</td>
<td>较重，需要系统资源进行调度</td>
</tr>
<tr>
<td>并发能力</td>
<td>单线程中的并发</td>
<td>多线程并发，支持多核并行</td>
</tr>
<tr>
<td>共享数据安全性</td>
<td>不需要同步机制（单线程）</td>
<td>需要锁等同步机制</td>
</tr>
</tbody></table>
<h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>HTTP 请求头:</p>
<ul>
<li><strong>Request-line</strong>：包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</li>
<li><strong>Host</strong>：指定被请求资源的主机名或IP地址和端口号。</li>
<li><strong>Accept</strong>：指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text&#x2F;plain, text&#x2F;html。</li>
<li><strong>User-Agent</strong>：客户端使用的浏览器类型和版本号，供服务器统计用户代理信息。</li>
<li><strong>Cookie</strong>：如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</li>
<li><strong>Connection</strong>：表示是否需要持久连接（keep-alive）。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html, application/xhtml+xml, */*<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>sessionid=abcdefg1234567<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure>

<p>HTTP 响应头:</p>
<ul>
<li><strong>Status-line</strong>：包含协议版本、状态码和状态消息。</li>
<li><strong>Content-Type</strong>：响应体的MIME类型。</li>
<li><strong>Content-Length</strong>：响应体的字节数。</li>
<li><strong>Set-Cookie</strong>：服务器向客户端发送cookie信息时使用该字段。</li>
<li><strong>Server</strong>：服务器类型和版本号。</li>
<li><strong>Connection</strong>：表示是否需要保持长连接（keep-alive）。</li>
</ul>
<p>在实际的HTTP报文头中，还可以包含其他可选字段。 如下是一个http响应头的示例</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content</span>-Type: text/html; charset=UTF-<span class="hljs-number">8</span><br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">1024</span><br><span class="hljs-attribute">Set</span>-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/<br><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">32</span> (Unix) mod_ssl/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">32</span> OpenSSL/<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>e-fips mod_bwlimited/<span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Connection</span>: keep-alive<br></code></pre></td></tr></table></figure>



<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(hello_function)</span></span>; <span class="hljs-comment">// 创建线程</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside scope&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 没有调用t.join()或t.detach()</span><br>    &#125; <span class="hljs-comment">// t离开作用域 - 程序在这里终止</span><br><br>    <span class="hljs-comment">// 这行永远不会执行</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Outside scope&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>




                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/cpp/" class="category-chain-item">cpp</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cpp/" class="print-no-link">#cpp</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/21/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F4/" title="从零开始实现秒杀系统（四）：系统优化篇">
                        <span class="hidden-mobile">从零开始实现秒杀系统（四）：系统优化篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comment.bytewaver.top/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10,"reaction":true},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
