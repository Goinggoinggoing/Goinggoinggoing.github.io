<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cpp基础</title>
    <link href="/2025/05/20/cpp/cpp/"/>
    <url>/2025/05/20/cpp/cpp/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>以下是对提供的C++相关内容的简洁摘要：  —</p></blockquote><p>g++ src&#x2F;main.cpp src&#x2F;test.cpp -I.&#x2F;include -o program</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ main.cpp -o program \<br>  -I/opt/boost/include \  <span class="hljs-comment"># 告诉编译器去哪里找头文件  </span><br>  -L/opt/boost/lib \      <span class="hljs-comment"># 告诉链接器去哪里找库文件</span><br>  -lboost_filesystem      <span class="hljs-comment"># 告诉链接器要链接哪个库</span><br><br>选项    核心作用    阶段    示例<br>-I    指定头文件搜索路径    预处理/编译    -Iinclude or CPLUS_INCLUDE_PATH<br>-L    指定库文件搜索路径    链接阶段    -L/opt/boost/lib or LIBRARY_PATH<br>-l    指定需要链接的库名称    链接阶段    -lboost_filesystem 不能省略<br><br><br>g++ -E main.cpp -I/opt/boost/include -o main.i<br>g++ -S main.i -o main.s<br>g++ -c main.s -o main.o<br>g++ main.o -L/opt/boost/lib -lboost_filesystem -o program<br></code></pre></td></tr></table></figure><p>&#x2F;opt&#x2F;homebrew&#x2F;  指向&#x2F;opt&#x2F;homebrew&#x2F;Cellar&#x2F; 下</p><table><thead><tr><th>软件包类型</th><th>示例</th><th>lib 目录链接</th><th>include 目录链接</th><th>bin 目录链接</th></tr></thead><tbody><tr><td>库</td><td>boost, openssl</td><td>✅</td><td>✅</td><td>❌ 或 少量</td></tr><tr><td>命令行工具</td><td>wget, curl</td><td>❌ 或 少量</td><td>❌</td><td>✅</td></tr><tr><td>编程语言</td><td>python, node</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>数据库</td><td>mysql, postgresql</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><h5 id="1-内置类型（基本类型）"><a href="#1-内置类型（基本类型）" class="headerlink" title="1. 内置类型（基本类型）"></a>1. 内置类型（基本类型）</h5><p>内置类型是C++语言自带的基本数据类型，主要包括以下几种：</p><ul><li>整型（Integer Types）<ul><li><code>int</code>：标准整型，通常为4字节。</li><li><code>short</code>：短整型，通常为2字节。</li><li><code>long</code>：长整型，通常为4或8字节（取决于平台）。</li><li><code>long long</code>：更长的整型，通常为8字节。</li><li><code>unsigned</code>：无符号整型，不支持负数。</li><li><code>unsigned short</code>、<code>unsigned long</code>、<code>unsigned long long</code>：对应的无符号版本。</li></ul></li><li>字符型（Character Types）<ul><li><code>char</code>：字符型，通常为1字节。</li><li><code>wchar_t</code>：宽字符型，通常为2或4字节（用于表示Unicode字符）。</li><li><code>char16_t</code>、<code>char32_t</code>：用于表示UTF-16和UTF-32编码的字符。</li></ul></li><li>浮点型（Floating Point Types）<ul><li><code>float</code>：单精度浮点型，通常为4字节。</li><li><code>double</code>：双精度浮点型，通常为8字节。</li><li><code>long double</code>：扩展精度浮点型，通常为8字节或16字节（取决于平台）。</li></ul></li><li>布尔型（Boolean Type）<ul><li><code>bool</code>：布尔型，表示真（true）或假（false）。</li></ul></li></ul><h5 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2. 复合类型"></a>2. 复合类型</h5><p>复合类型是由内置类型或其他复合类型组合而成的类型，主要包括以下几种：</p><ul><li>数组（Array）<ul><li>一组相同类型的数据元素，可以通过索引访问。</li></ul></li><li>结构体（Struct）<ul><li>一种用户定义的数据类型，可以包含不同类型的数据成员。</li></ul></li><li>联合体（Union）<ul><li>与结构体类似，但所有成员共享同一内存位置，只有一个成员可以在任何给定时间存储值。</li></ul></li><li>枚举（Enum）<ul><li>一种用户定义的类型，用于定义一组命名的整型常量。</li></ul></li><li>类（Class）<ul><li>C++的面向对象编程特性，允许定义包含数据和成员函数的复杂数据类型。</li></ul></li><li>指针（Pointer）<ul><li>指向其他类型的内存地址，可以用来动态分配内存和实现复杂的数据结构。</li></ul></li><li>引用（Reference）<ul><li>对现有变量的别名，提供了对变量的另一种访问方式。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">var_func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//整形，4字节</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//ll整形, 8字节</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> lla = <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">//长整型， 4 字节</span><br>    <span class="hljs-type">long</span> la = <span class="hljs-number">1024</span>;<br>    <span class="hljs-comment">//短整型,2 字节</span><br>    <span class="hljs-type">short</span> sa = <span class="hljs-number">200</span>;<br>    <span class="hljs-comment">//带符号字符型,</span><br>    <span class="hljs-comment">//字符型使用时最好指示带符号还是不带符号</span><br>    <span class="hljs-comment">//因为在不同的机器上不指明char符号可能会有问题</span><br>    <span class="hljs-type">signed</span> <span class="hljs-type">char</span> sc = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">//无符号字符型</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uc = <span class="hljs-string">&#x27;m&#x27;</span>;<br>    <span class="hljs-comment">//bool类型</span><br>    <span class="hljs-type">bool</span> bt = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义和声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//只声明a   它在其他地方定义。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a;  <br><br><br><span class="hljs-comment">// 变量定义 会分配内存空间</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 定义并初始化变量 &#x27;a&#x27;</span><br><span class="hljs-type">float</span> b = <span class="hljs-number">20.5</span>; <span class="hljs-comment">// 定义并初始化变量 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><ul><li><strong>32位系统</strong>：所有类型的指针都是 <strong>4字节</strong></li><li><strong>64位系统</strong>：所有类型的指针都是 <strong>8字节</strong></li><li>指针+1 的偏移量 &#x3D; sizeof(指针指向的类型)</li><li><code>*(ptr+x) = ptr[x]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//访问对象</span><br><span class="hljs-type">int</span> ival = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">//p_int存放着ival的地址，或者说p_int是指向变量ival的指针</span><br><span class="hljs-type">int</span> * p_int = &amp;ival;<br><br><span class="hljs-comment">// 取值 由符号*得到指针p所指向的对象，输出42</span><br>std::cout &lt;&lt; *p_int ;<br><br><span class="hljs-comment">// 赋值</span><br>*p_int = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对指针的引用： int *&amp; b = a; 和引用一样的作用，修改b影响a</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">poinref_func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-comment">// p是一个指针</span><br>    <span class="hljs-type">int</span> *p;<br>    <span class="hljs-comment">// r 是一个对p的引用</span><br>    <span class="hljs-type">int</span> *&amp;r = p;<br>    <span class="hljs-comment">// 令r指向了一个指针p</span><br>    <span class="hljs-comment">//给r赋值为&amp;i,就是p指向了i</span><br>    r = &amp;i;<br>    <span class="hljs-comment">//解引用r得到i,也就是p指向的对象，将i的值修改为0</span><br>    *r = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 空指针  可以用if判断</span><br><span class="hljs-type">int</span> * empty_pointer2 = nullptr;  <span class="hljs-comment">// c98写法   =0</span><br><br><br><span class="hljs-comment">// 万能指针</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">void</span>* ptr = &amp;num;<br><span class="hljs-comment">// 使用前需要类型转换</span><br>*(<span class="hljs-type">double</span> *)ptr<br><span class="hljs-type">int</span>* intPtr = static_cast&lt;<span class="hljs-type">int</span>*&gt;(ptr);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *intPtr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出10</span><br><br><br><span class="hljs-comment">// 数组指针</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *ptr_arr = arr;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ptr_arr is : &quot;</span> &lt;&lt; ptr_arr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-type">int</span> firstElement = *ptr_arr;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;firstElement is &quot;</span> &lt;&lt; firstElement &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 递增指针 递增的大小取决于指针指向了谁</span><br>++ptr_arr; <span class="hljs-comment">// ptr 现在指向 arr[1]  int会大4</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ptr_arr is : &quot;</span> &lt;&lt; ptr_arr &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><br>p[x] = *(p + x);<br>&amp;(p[x]) = &amp;(*(p + x)) = p + x;<br><br><br><span class="hljs-comment">// 取地址</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;;<br><span class="hljs-comment">// 地址值相同，但类型不同：</span><br><span class="hljs-type">char</span>* p1 = arr;          <span class="hljs-comment">// 指向 arr[0]，类型是 char*</span><br><span class="hljs-type">char</span> (*p2)[<span class="hljs-number">5</span>] = &amp;arr;    <span class="hljs-comment">// 指向整个数组，类型是 char (*)[5]</span><br><span class="hljs-comment">// 验证指针运算差异：</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-type">void</span>*)(arr + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 地址 +1 字节</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-type">void</span>*)(&amp;arr + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 地址 +5 字节</span><br></code></pre></td></tr></table></figure><ol><li>支持加减操作</li><li>解引用时不能是空指针</li><li>解引用时读取的字节数量，以及++的偏移量取决于指向的数据所占的空间</li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol><li><strong>全局作用域</strong>：在函数外部声明的变量具有全局作用域。它们可以在程序的任何地方被访问，但通常建议在需要时才使用全局变量，因为它们可能导致代码难以理解和维护。</li><li><strong>局部作用域</strong>：在函数内部、代码块（如<code>if</code>语句、<code>for</code>循环等）内部声明的变量具有局部作用域。它们只能在声明它们的代码块内被访问。一旦离开该代码块，这些变量就不再可见。</li><li><strong>命名空间作用域</strong>：在命名空间中声明的变量（实际上是实体，如变量、函数等）具有命名空间作用域。它们只能在相应的命名空间内被直接访问，但可以通过使用命名空间的名称作为前缀来从外部访问。 <code>std</code> </li><li><strong>类作用域</strong>：在类内部声明的成员变量和成员函数具有类作用域。成员变量和成员函数可以通过类的对象来访问，或者在某些情况下（如静态成员）可以通过类名直接访问。</li><li><strong>块作用域</strong>：这是局部作用域的一个特例，指的是由大括号<code>&#123;&#125;</code>包围的代码块内部声明的变量。这些变量只能在该代码块内被访问。 <strong>并发编程中</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 全局作用域 (Global scope)</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 命名空间作用域 (Namespace scope)</span><br><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-type">int</span> namespaceVar = <span class="hljs-number">200</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNamespaceVar</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Namespace variable: &quot;</span> &lt;&lt; namespaceVar &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 类作用域 (Class scope)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类成员变量 (Class member variable)</span><br>    <span class="hljs-type">int</span> classVar = <span class="hljs-number">300</span>;<br><br>    <span class="hljs-comment">// 静态类成员 (Static class member)</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticClassVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printClassVars</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 局部作用域 (Local scope)</span><br>        <span class="hljs-type">int</span> localVar = <span class="hljs-number">400</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Class variable: &quot;</span> &lt;&lt; classVar &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Global variable inside class: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员</span><br><span class="hljs-type">int</span> MyClass::staticClassVar = <span class="hljs-number">500</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 使用命名空间变量</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Namespace variable: &quot;</span> &lt;&lt; MyNamespace::namespaceVar &lt;&lt; endl;<br>    MyNamespace::<span class="hljs-built_in">printNamespaceVar</span>();<br><br>    <span class="hljs-comment">// 块作用域 (Block scope)</span><br>    &#123;<br>        <span class="hljs-type">int</span> blockVar = <span class="hljs-number">600</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Block variable: &quot;</span> &lt;&lt; blockVar &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// blockVar 在这里不可访问</span><br><br>    <span class="hljs-comment">// 创建类实例</span><br>    MyClass obj;<br>    obj.<span class="hljs-built_in">printClassVars</span>();<br><br>    <span class="hljs-comment">// 访问静态类成员</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Static class variable: &quot;</span> &lt;&lt; MyClass::staticClassVar &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 局部作用域示例</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// i 是循环作用域的变量</span><br>        <span class="hljs-type">int</span> loopVar = <span class="hljs-number">700</span>;  <span class="hljs-comment">// loopVar 只在循环内有效</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Loop variable: &quot;</span> &lt;&lt; loopVar &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// loopVar 在这里不可访问</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h4><ol><li>代码区（Code Segment&#x2F;Text Segment）：<ul><li>存储程序执行代码（即机器指令）的内存区域。这部分内存是共享的，只读的，且在程序执行期间不会改变。</li><li>举例说明：当你编译一个C++程序时，所有的函数定义、控制结构等都会被转换成机器指令，并存储在代码区。</li></ul></li><li>全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）：<ul><li>存储全局变量和静态变量的内存区域。这些变量在程序的<strong>整个运行期间</strong>都存在，但它们的可见性和生命周期取决于声明它们的作用域。</li><li>举例说明：全局变量（在函数外部声明的变量）和静态变量（使用<code>static</code>关键字声明的变量，无论是在函数内部还是外部）都会存储在这个区域。</li></ul></li><li>栈区（Stack Segment）：<ul><li>存储局部变量、函数参数、返回地址等的内存区域。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用和自动变量。</li><li>举例说明：在函数内部声明的变量（不包括静态变量）通常存储在栈上。当函数被调用时，其参数和局部变量会被推入栈中；当函数返回时，这些变量会从栈中弹出，其占用的内存也随之释放。</li></ul></li><li>堆区（Heap Segment）：<ul><li>由程序员通过动态内存分配函数（如<code>new</code>和<code>malloc</code>）分配的内存区域。堆区的内存分配和释放是手动的，因此程序员需要负责管理内存，以避免内存泄漏或野指针等问题。</li><li>举例说明：当你使用<code>new</code>操作符在C++中动态分配一个对象或数组时，分配的内存就来自堆区。同样，使用<code>delete</code>操作符可以释放堆区中的内存。</li></ul></li><li>常量区（Constant Area）：<ul><li>存储常量（如字符串常量、const修饰的全局变量等）的内存区域。这部分内存也是只读的，且通常在程序执行期间不会改变。</li><li>举例说明：在C++中，使用双引号括起来的字符串字面量通常存储在常量区。此外，使用<code>const</code>关键字声明的全局变量，如果其值在编译时就已确定，也可能存储在常量区。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">// 用于strlen</span></span><br><br><span class="hljs-comment">// 全局变量，存储在全局/静态存储区</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 静态变量，也存储在全局/静态存储区，但仅在其声明的文件或函数内部可见</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量，存储在栈区</span><br>    <span class="hljs-type">int</span> localVar = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 静态局部变量，虽然声明在函数内部，但存储在全局/静态存储区，且只在第一次调用时初始化</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticLocalVar = <span class="hljs-number">40</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside func:&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;localVar = &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;staticLocalVar = &quot;</span> &lt;&lt; staticLocalVar &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 尝试通过动态内存分配在堆区分配内存</span><br>    <span class="hljs-type">int</span>* heapVar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">50</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;heapVar = &quot;</span> &lt;&lt; *heapVar &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 释放堆区内存（重要：实际使用中不要忘记释放不再使用的堆内存）</span><br>    <span class="hljs-keyword">delete</span> heapVar;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 访问全局变量</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main:&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;globalVar = &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;staticVar = &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl; <span class="hljs-comment">// 注意：staticVar在外部不可见（除非在同一个文件中或通过特殊方式）</span><br><br>    <span class="hljs-comment">// 调用函数，展示栈区和堆区的使用</span><br>    <span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-comment">// 字符串常量通常存储在常量区，但直接访问其内存地址并不是标准C++的做法</span><br>    <span class="hljs-comment">// 这里我们仅通过指针来展示其存在</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* strConst = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    <span class="hljs-comment">// 注意：不要尝试修改strConst指向的内容，因为它是只读的</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;strConst = &quot;</span> &lt;&lt; strConst &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 尝试获取字符串常量的长度（这不会修改常量区的内容）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Length of strConst = &quot;</span> &lt;&lt; <span class="hljs-built_in">strlen</span>(strConst) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h4><p>C++程序的编译过程是一个相对复杂但有序的过程，它涉及将高级语言（C++）代码转换为机器可以执行的低级指令。在这个过程中，通常会生成几个中间文件，包括<code>.i</code>（预处理文件）、<code>.s</code>（汇编文件）和<code>.o</code>（目标文件或对象文件）。下面是这个过程的详细解释：</p><ol><li><strong>预处理（Preprocessing）</strong></li></ol><ul><li><strong>输入</strong>：C++源代码文件（通常以<code>.cpp</code>或<code>.cxx</code>为后缀）。</li><li><strong>处理</strong>：预处理器（通常是<code>cpp</code>）读取源代码文件，并对其进行宏展开、条件编译、文件包含（<code>#include</code>）等处理。</li><li><strong>输出</strong>：生成预处理后的文件，通常具有<code>.i</code>后缀（尽管这个步骤可能不是所有编译器都会自动生成<code>.i</code>文件，或者可能需要特定的编译器选项来生成）。</li></ul><ol start="2"><li><strong>编译（Compilation）</strong></li></ol><ul><li><strong>输入</strong>：预处理后的文件（如果有的话，否则直接是源代码文件）。</li><li><strong>处理</strong>：编译器（如<code>g++</code>、<code>clang++</code>等）将预处理后的文件或源代码文件转换为汇编语言代码。这个步骤是编译过程的核心，它执行<strong>词法分析、语法分析、语义分析、中间代码生成、代码优化</strong>等任务。</li><li><strong>输出</strong>：生成汇编文件，通常具有<code>.s</code>或<code>.asm</code>后缀。</li></ul><ol start="3"><li><strong>汇编（Assembly）</strong></li></ol><ul><li><strong>输入</strong>：汇编文件。</li><li><strong>处理</strong>：汇编器（如<code>as</code>、<code>gas</code>等）将汇编语言代码转换为机器语言指令（即目标代码），但这些指令仍然是针对特定架构的，并且尚未被链接成可执行文件。</li><li><strong>输出</strong>：生成目标文件（或对象文件），通常具有<code>.o</code>、<code>.obj</code>或<code>.out</code>后缀。</li></ul><ol start="4"><li><strong>链接（Linking）</strong></li></ol><ul><li><strong>输入</strong>：一个或多个目标文件，以及可能需要的库文件（如C++标准库）。</li><li><strong>处理</strong>：链接器（如<code>ld</code>、<code>lld</code>等）将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用（即函数和变量的调用），并将它们链接到正确的地址。</li><li><strong>输出</strong>：生成可执行文件（在Unix-like系统中通常是<code>.out</code>、<code>.exe</code>或没有特定后缀，在Windows系统中是<code>.exe</code>）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分步编译</span><br>g++ -E hello.cpp -o hello.i    <span class="hljs-comment"># 预处理</span><br>g++ -S hello.i -o hello.s      <span class="hljs-comment"># 编译为汇编</span><br>g++ -c hello.s -o hello.o      <span class="hljs-comment"># 汇编为目标文件</span><br>g++ hello.o -o hello           <span class="hljs-comment"># 链接生成可执行文件</span><br><br><span class="hljs-comment"># 一步完成</span><br>g++ hello.cpp -o hello<br></code></pre></td></tr></table></figure><p>在编译C++程序时，编译器会首先处理源文件（.cpp 文件）。对于源文件中的每个 <code>#include</code> 指令，编译器都会查找并包含相应的头文件（.h 或 .hpp 文件）。然后，编译器将处理源文件中的所有实现代码，并将它们与从头文件中获取的声明进行匹配。</p><h4 id="头文件和源文件"><a href="#头文件和源文件" class="headerlink" title="头文件和源文件"></a>头文件和源文件</h4><p>头文件（.h 或 .hpp）</p><p>头文件主要用于<strong>声明</strong>（declarations），包括：</p><ul><li>类（class）的声明</li><li>函数（functions）的原型（prototypes）</li><li>模板（templates）的声明</li><li>宏定义（#define）</li><li>外部变量（extern variables）的声明</li><li>内联函数（inline functions）</li></ul><p>头文件通常包含预处理指令如 <code>#ifndef</code>、<code>#define</code> 和 <code>#endif</code>，这些指令用于防止头文件被重复包含（也称为“头文件保护”或“包含卫士”）。</p><p><strong>示例头文件（example.h）</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXAMPLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_H</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 构造函数声明</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 成员函数声明</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>源文件（.cpp）</p><p>源文件包含实际的代码实现，即函数体、类的成员函数的实现等。源文件通常包括必要的头文件，以便编译器知道它们正在使用的函数、类等是如何声明的。</p><p><strong>示例源文件（example.cpp）</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;example.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>MyClass::<span class="hljs-built_in">MyClass</span>() &#123;<br>    <span class="hljs-comment">// 构造函数实现</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass::myFunction!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>头文件应该只包含<strong>声明</strong>，源文件应该包含实现。</li><li>使用头文件保护来避免头文件被重复包含。</li><li>在大型项目中，合理组织头文件和源文件可以提高项目的可维护性和可扩展性。</li><li>在编译时，确保所有的源文件都被编译，并且所有的头文件都被正确包含。</li><li>Header Guard: <code>#pragma once</code> 和 宏定义（如 <code>#ifndef, #define, #endif</code>）都是用来防止头文件在一个文件中被重复包含的机制，但它们在工作方式和使用场景上存在一些区别。  预处理阶段</li></ul><p><strong>重定义问题</strong>：</p><p>头文件中如果定义了变量，会导致重定义，程序编译并未产生问题,但是链接产生问题了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DAY05_EXTERN_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DAY05_EXTERN_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">int</span> global_age = <span class="hljs-number">10</span>;<br>std::string global_name = <span class="hljs-string">&quot;llfc&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//DAY05_EXTERN_GLOBAL_H</span></span><br></code></pre></td></tr></table></figure><p>正确做法，头文件只声明不定义，声明放到cpp中。 头文件可能被包含多次但cpp只会被包含一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HEADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HEADER_H</span><br><br><span class="hljs-comment">// 正确：使用extern声明</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> global_counter;  <span class="hljs-comment">// 只是声明，不是定义</span><br><br><span class="hljs-comment">// 正确：使用inline定义，inline函数可以在多个编译单元中定义，链接器合并</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_counter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> global_counter;<br>&#125;<br><span class="hljs-comment">// 编译时的简化过程（对象文件中）:普通函数使用的&quot;强符号&quot;(strong symbol)</span><br><span class="hljs-comment">// file1.o - 包含add()的弱符号定义 </span><br><span class="hljs-comment">// file2.o - 包含add()的弱符号定义</span><br><span class="hljs-comment">// 最终可执行文件 - 只保留一个add()的定义</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header.h&quot;</span></span><br><br><span class="hljs-comment">// 正确：在源文件中定义</span><br><span class="hljs-type">int</span> global_counter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 实际的定义</span><br></code></pre></td></tr></table></figure><h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><p>内联展开：示编译器将函数调用处直接替换为函数体代码，而不是生成函数调用指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用内联函数</span><br><span class="hljs-type">int</span> result = <span class="hljs-built_in">max</span>(x, y);  <br><span class="hljs-comment">// 编译器可能将上面这行展开为: int result = (x &gt; y) ? x : y;</span><br></code></pre></td></tr></table></figure><p>头文件重定义问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UTILITIES_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UTILITIES_H</span><br><br><span class="hljs-comment">// 使用inline避免多重定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, message);<br>&#125;<br><br><span class="hljs-comment">// C++17后，可以直接在头文件中使用inline变量:</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159265358979323846</span>;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> std::string APP_NAME = <span class="hljs-string">&quot;MyApplication&quot;</span>;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 甚至可以是非常量变量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>底层指针实现</p><ol><li>必须初始化</li><li>绑定后不能修改</li><li>不能空引用</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">// b是a的引用</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: a = 100, b = 100</span><br><br>    b = <span class="hljs-number">200</span>; <span class="hljs-comment">// 更改b的值也会更改a的值</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: a = 200, b = 200</span><br><br><br>    <span class="hljs-comment">// int c = 300;</span><br>    <span class="hljs-comment">// 表示修改b的值为c的值  而不是把b作为c的引用</span><br>    <span class="hljs-comment">// b = c; </span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>主要用户函数穿参和返回值，更快</li><li>使用const，防止引用修改了原对象</li><li>底层使用指针实现，但引用更加安全直观</li></ol><h5 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h5><p>在C++中，左值（<code>lvalue</code>）和右值（<code>rvalue</code>）是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。</p><ol><li>左值通常指的是具有持久状态的对象，它们有明确的内存地址，可以被多次赋值。</li><li>右值通常是临时的、没有持久状态的值，它们通常没有内存地址，或者其内存地址在表达式结束后就变得无效。</li></ol><p><strong>C++11</strong>引入了右值引用（<code>rvalue reference</code>），用<code>T&amp;&amp;</code>表示，作为对左值引用（<code>lvalue reference</code>，用<code>T&amp;</code>表示）的补充。这一特性极大地增强了C++的表达能力，特别是在资源管理和性能方面。</p><p><strong>左值引用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a; <span class="hljs-comment">// b是a的左值引用</span><br></code></pre></td></tr></table></figure><p><strong>右值引用</strong>：引用一个右值（临时的）。用于函数参数（实现移动语义）和返回值（允许链式调用等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&amp;&amp; c = <span class="hljs-number">20</span>; <span class="hljs-comment">// c是整数字面量20的右值引用（但这种情况不常见，通常用于函数参数或返回值）</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>); <span class="hljs-comment">// 返回的临时字符串是一个右值</span><br>&#125;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;&amp;d = foo(); <span class="hljs-comment">// d是foo()返回的临时字符串的右值引用</span><br></code></pre></td></tr></table></figure><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 必须初始化</span><br></code></pre></td></tr></table></figure><p>编译器可能会对const进行优化，放到只读区域</p><p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到<code>bufSize</code>的地方，然后用512替换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">在头文件中<br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 错误：可能导致多重定义</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> constVar = <span class="hljs-number">20</span>;    <span class="hljs-comment">// const变量可以在头文件中定义 对于每一个分别的文件中，都会有独立副本</span><br></code></pre></td></tr></table></figure><h5 id="reference-to-const"><a href="#reference-to-const" class="headerlink" title="reference to const"></a>reference to const</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> i5 = <span class="hljs-number">1024</span><br><br><span class="hljs-comment">//用常量引用绑定常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = ci;<br><br><span class="hljs-comment">//允许将const int&amp; 绑定到一个普通的int对象上</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r5 = i5;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r6 = <span class="hljs-number">1024</span>;<br><br>但不允许使用非<span class="hljs-type">const</span>引用绑定<span class="hljs-type">const</span>变量<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误用法，类型不匹配</span><br><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> &amp; rd = dval;<br><br><span class="hljs-comment">//编译通过</span><br><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; ri = dval;<br></code></pre></td></tr></table></figure><h5 id="point"><a href="#point" class="headerlink" title="point"></a>point</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 指向常量的指针  (pointer to constant)  保护数据不被修改 Low-level const</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pconst_func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//指向常量的指针</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br>    <span class="hljs-comment">//不可以用普通指针指向常量</span><br>    <span class="hljs-comment">// double *ptr = π</span><br>    <span class="hljs-comment">//用常量指针指向常量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> *cptr = π<br>    <span class="hljs-comment">//不能给*cptr赋值因为cptr指向的是常量</span><br>    <span class="hljs-comment">// *cptr = 42;</span><br>    <span class="hljs-comment">//指向常量的指针指向非常量  但也不能修改   单向保护</span><br>    <span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br>    cptr = &amp;dval;<br>&#125;<br><br><span class="hljs-comment">// 常量指针(constant pointer) 保指针始终指向同一个地址  ＊放在const关键字之前 指向的地址初始化后不可修改  Top-level const</span><br><span class="hljs-type">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// curErr将一直指向errNumb</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> curErr = &amp;errNumb;<br></code></pre></td></tr></table></figure><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><ul><li>普通值  Buffer a;</li><li>指针值  Buffer *p &#x3D; new Buffer();</li></ul><p>普通值在传递 赋值时有很大的不同，引入了运算符重载、拷贝构造、引用、右值引用</p><p>为什么不直接全用指针，和java一样？ 没有内存回收机制</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612.png" alt="image-20250519102222191"></p><ul><li><p>是否有持久的内存地址，取地址操作</p></li><li><p>只能作为赋值语句右值的值（const只能但算左值）</p></li><li><p>函数返回值？ 只有全局变量的引用是左值</p></li><li><p>纯右值</p><ul><li><p>临时对象、字面量、算术表达式</p></li><li><pre><code class="cpp">int x = 5;           // 5 是纯右值int y = x + 2;       // x + 2 是纯右值std::string(&quot;abc&quot;)   // 构造出来的临时对象是纯右值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 将亡值<br><br>  - 即将“被移动”的对象的值。它有**标识性**（表示某个特定对象），但可以被移动或资源窃取。有地址<br><br>  - ```cpp<br>    std::string&amp;&amp; str = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// std::move(s) 是将亡值</span><br>    std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">front</span>();       <span class="hljs-comment">// 返回的是将亡值</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>将亡值</p><ul><li>我希望有一个对象用完之后不要了<ul><li>直接传参？调用了拷贝构造 白复制了 浪费资源。</li><li>const &amp;，可以延长右值，但内部值不能操作了。此外函数不知道传入的是右值还是左值</li><li>普通引用&amp;，无法传入右值</li></ul></li><li>引入移动语义。显式move实现所有权转交、函数临时返回、表达式<ul><li>用谁来接受这个将亡值？右值引用</li><li>move其实就是<code>static_cast&lt;std::string&amp;&amp;&gt;(s)</code>强转右值引用</li></ul></li></ul></li></ul><p>在矩阵相加中，如何通过充分利用将亡值与移动语义，减少资源的申请</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp">www.bilibili.com/video/BV15v411g7Ma<br>cpp17 + 禁用rvo<br>M r = a + b  +  c<br>       tmpab + c<br>  <br><span class="hljs-comment">// 传统加法：两个 const 引用，返回一个新矩阵（纯右值）</span><br>  <span class="hljs-keyword">friend</span> Matrix <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Matrix &amp;a, <span class="hljs-type">const</span> Matrix &amp;b) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;operator+(const&amp;, const&amp;)\n&quot;</span>);<br>      <span class="hljs-keyword">if</span> (a.row != b.row || a.col != b.col) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Size mismatch&quot;</span>);<br>      <span class="hljs-function">Matrix <span class="hljs-title">res</span><span class="hljs-params">(a.row, a.col)</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.row; ++i)<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a.col; ++j)<br>              res.data[i][j] = a.data[i][j] + b.data[i][j];<br>      <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回纯右值</span><br>  &#125;<br>每加法 一次构造 + 一次返回值拷贝<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp; mat)<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp; mat)<br>  <br><br>优化<span class="hljs-number">1</span> 添加移动构造，编译器会优先使用移动，减少了一次拷贝开销<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br>  <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>  <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br>  <br><br>优化<span class="hljs-number">2</span> 充分利用tmpab的空间,使用右值引用窃取临时变量资源<br>    <span class="hljs-comment">// 利用右值引用加法</span><br>    <span class="hljs-keyword">friend</span> Matrix <span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; a, <span class="hljs-type">const</span> Matrix&amp; b) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;operator+(Matrix&amp;&amp;, const&amp;)\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a.row != b.row || a.col != b.col) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Size mismatch&quot;</span>);<br>        Matrix res = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// 资源转移窃取</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.row; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; res.col; ++j)<br>                res.data[i][j] += b.data[i][j];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span>&amp;, <span class="hljs-type">const</span>&amp;)<br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br>    <span class="hljs-keyword">operator</span>+(Matrix&amp;&amp;, <span class="hljs-type">const</span>&amp;)<br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat) <span class="hljs-comment">// 拷贝变成了移动</span><br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp; mat)<br><br>此外如果调用std::<span class="hljs-built_in">move</span>(a) + b + c，结果的地址会和a一致，也就是窃取了a的资源<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类型推动和别名"><a href="#类型推动和别名" class="headerlink" title="类型推动和别名"></a>类型推动和别名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ulong;<br><br><span class="hljs-comment">// c++11</span><br>using <span class="hljs-type">int64_t</span> = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure><h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算求和</span><br><span class="hljs-type">int</span> age1 = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> age2 = <span class="hljs-number">35</span>;<br><span class="hljs-keyword">auto</span> age_add = age1+age2;<br></code></pre></td></tr></table></figure><p>auto一般会忽略掉顶层<code>const</code>，同时底层<code>const</code>则会保留下来，比如当初始值是一个指向常量的指针时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br>    <span class="hljs-comment">// a是一个整数，类型是r所引用的类型</span><br>    <span class="hljs-keyword">auto</span> a = r;<br>    <span class="hljs-comment">// cr是一个常量引用，ci是int类型的常量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br>    <span class="hljs-comment">// b是一个整数，ci顶层const被忽略了</span><br>    <span class="hljs-keyword">auto</span> b = ci;<br>    <span class="hljs-comment">// c是一个整数，cr是ci的别名，ci本身是一个顶层const</span><br>    <span class="hljs-keyword">auto</span> c = cr;<br>    <span class="hljs-comment">// d 是一个整型指针，i是整型</span><br>    <span class="hljs-keyword">auto</span> d = &amp;i;<br>    <span class="hljs-comment">// e是一个指向整数常量的指针，对常量对象取地址是一种底层const</span><br>    <span class="hljs-keyword">auto</span> e = &amp;ci;<br>&#125;<br><br><span class="hljs-comment">//顶层const可显示指定,f是一个const int类型</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<br></code></pre></td></tr></table></figure><h5 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h5><p>用于在编译时推导表达式的类型。但不和auto一样需要赋值</p><ul><li>单个标识符：保持原类型</li><li>加括号的标识符的左值：变为引用类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">decltype(expression) variable;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br>decltype(x) y = <span class="hljs-number">100</span>;     <span class="hljs-comment">// y的类型是int</span><br>decltype(x + y) sum;     <span class="hljs-comment">// sum的类型是int</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">会包含变量的顶层<span class="hljs-type">const</span>，以及引用<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci, *p = &amp;i;<br><span class="hljs-comment">//x是const int类型</span><br>decltype(ci) x = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//y是一个const int&amp;类型，y绑定到x    必须初始化</span><br>decltype(cj) y = x;<br><br><br>decltype(*p)  <span class="hljs-comment">// *p可以理解为i的引用，所以decltype(*p)上int&amp; 必须初始化</span><br></code></pre></td></tr></table></figure><h5 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>, <span class="hljs-title">class</span>... <span class="hljs-title">Args</span>&gt;</span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; <br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;<span class="hljs-title function_">decltype</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(f)(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...))</span>&gt; &#123;<br>    using RetType = decltype(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(f)(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<br>    <span class="hljs-keyword">if</span> (stop_.load())<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;RetType&gt;&#123;&#125;;<br>    <span class="hljs-keyword">auto</span> task = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::packaged_task&lt;RetType()&gt;&gt;(<br>            <span class="hljs-built_in">std</span>::bind(<span class="hljs-built_in">std</span>::forward&lt;F&gt;(f), <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt;RetType&gt; ret = task-&gt;get_future();<br>    &#123;<br>        <span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">cv_mt</span><span class="hljs-params">(cv_mt_)</span>;<br>        tasks_.emplace([task] &#123; (*task)(); &#125;);<br>    &#125;<br>    cv_lock_.notify_one();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="聚合初始化"><a href="#聚合初始化" class="headerlink" title="聚合初始化"></a>聚合初始化</h4><ol><li>数组</li><li>符合以下条件的类:<ul><li>没有用户声明的构造函数</li><li>没有私有或保护的非静态数据成员</li><li>没有虚函数</li><li>没有基类</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 数组的聚合初始化</span><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 结构体的聚合初始化</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br>Point p = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;<br><br><br><span class="hljs-comment">// c++11 以下两种写法等价</span><br>Person p1 = &#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>&#125;;<br>Person p2&#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Inner</span> &#123;</span><br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Outer</span> &#123;</span><br>    Inner in;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><span class="hljs-comment">// 嵌套聚合初始化</span><br>Outer obj = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, <span class="hljs-number">3</span>&#125;;<br><br><br>stl<br><span class="hljs-comment">// 初始化 vector</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化 array</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化 set</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 初始化 map</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span>&gt; m = &#123;<br>    &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">3</span>&#125;<br>&#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StructName</span> &#123;</span><br>    <span class="hljs-comment">// 成员变量</span><br>    dataType1 member1;<br>    dataType2 member2;<br>    <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> counter;      <span class="hljs-comment">// 仅声明</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 合法：静态常量整型可以在类内初始化  不能取地址，除非额外定义了</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;        <span class="hljs-comment">// C++17支持</span><br><br>&#125;;<br><br><span class="hljs-comment">// 在类外定义并初始化</span><br><span class="hljs-type">int</span> MyClass::counter = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-comment">// Overload the &lt;&lt; operator for Point</span><br>ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; point) &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; point.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Point p1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;; <span class="hljs-comment">// 使用初始化列表</span><br>    Point p3 = &#123; .y = <span class="hljs-number">50</span>, .x = <span class="hljs-number">60</span> &#125;; <span class="hljs-comment">// 使用指定成员初始化，顺序可以不同</span><br>    Point p4;<br>    p4.x = <span class="hljs-number">70</span>; <span class="hljs-comment">// 先初始化x</span><br>    p4.y = <span class="hljs-number">80</span>; <span class="hljs-comment">// 再初始化y</span><br><br>    Point arrPoints[<span class="hljs-number">3</span>] = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; &#125;; <span class="hljs-comment">// 数组初始化</span><br><br>    Point * p5 = new Point; <span class="hljs-comment">// 动态分配内存</span><br><br>    p5-&gt;x = <span class="hljs-number">90</span>; <span class="hljs-comment">// 使用指针访问成员</span><br>    p5-&gt;y = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt; p5 &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt; *p5 &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt; p5-&gt;x &lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;hello &quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义命名空间</span><br>namespace Math &#123;<br>    <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用命名空间中的成员</span><br>Math::PI;         <span class="hljs-comment">// 使用作用域解析运算符</span><br>Math::add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 调用命名空间中的函数</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 方法1：使用整个命名空间</span><br>using namespace Math;<br>PI;  <span class="hljs-comment">// 可以直接使用，不需要Math::</span><br><br><span class="hljs-comment">// 方法2：只使用特定成员</span><br>using Math::PI;<br>PI;  <span class="hljs-comment">// 只导入 PI</span><br><br>对于<span class="hljs-built_in">std</span>同理<br>using <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>;<br>using <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><ul><li>避免在头文件、全局作用域中使用 <code>using namespace</code></li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;Hello, C-strings!&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">str</span><span class="hljs-params">(cstr)</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = str.c_str();<br></code></pre></td></tr></table></figure><h5 id="c风格的"><a href="#c风格的" class="headerlink" title="c风格的"></a>c风格的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> greeting[<span class="hljs-number">6</span>] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> city[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;Beijing&quot;</span>; <span class="hljs-comment">// \0后面有额外空间</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 包含垃圾值</span><br>    <span class="hljs-type">char</span> cstr[] = <span class="hljs-string">&quot;Hello, World!&quot;</span>; <span class="hljs-comment">// 结尾会自动有一个&#x27;\0&#x27;</span><br><br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(cstr);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; cstr[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; cstr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>  <span class="hljs-comment">// 拷贝</span><br>  <span class="hljs-type">char</span> dest[<span class="hljs-number">50</span>];<br>  <span class="hljs-built_in">strcpy</span>(dest, src);<br><br><br>  <span class="hljs-type">char</span> ca[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;P&#x27;</span>,<span class="hljs-string">&#x27;P&#x27;</span>&#125;; <span class="hljs-comment">//有风险，因为ca没有以\0结束，所以strlen可能访问越界</span><br><br>    <span class="hljs-built_in">strcat</span>(p1,p2)    将p2附加到p1之后，返回p1<br>    <span class="hljs-title function_">strcmp</span><span class="hljs-params">(p1,p2)</span>    比较p1和p2的是否相等，如果相等返回0，如果p1&gt;p2返回一个正值，如果p1&lt;p2返回一个负值<br><br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str1;              <span class="hljs-comment">// 空字符串</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;Hello&quot;</span>;    <span class="hljs-comment">// 使用字符串字面量初始化</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str3&#123;<span class="hljs-string">&quot;World&quot;</span>&#125;;     <span class="hljs-comment">// 统一初始化语法</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">str4</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span>;      <span class="hljs-comment">// 创建包含5个&#x27;a&#x27;的字符串：&quot;aaaaa&quot;</span><br><br>str.length();     <span class="hljs-comment">// 获取长度  同.size();</span><br>str.empty();      <span class="hljs-comment">// 判断是否为空</span><br>str.clear();      <span class="hljs-comment">// 清空字符串</span><br><br>str[<span class="hljs-number">0</span>];           <span class="hljs-comment">// 使用下标访问: &#x27;H&#x27;</span><br>str.at(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 使用at()访问（带边界检查）: &#x27;H&#x27; 会抛出越界异常</span><br>str.front();      <span class="hljs-comment">// 首字符: &#x27;H&#x27;</span><br>str.back();       <span class="hljs-comment">// 末字符: &#x27;o&#x27;</span><br><br>str += <span class="hljs-string">&quot; World&quot;</span>;              <span class="hljs-comment">// 追加字符串</span><br>str.append(<span class="hljs-string">&quot; Again&quot;</span>);         <span class="hljs-comment">// 追加</span><br>str.push_back(<span class="hljs-string">&#x27;!&#x27;</span>);          <span class="hljs-comment">// 追加单个字符</span><br>str.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; my&quot;</span>);        <span class="hljs-comment">// 在指定位置插入</span><br>str.erase(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);             <span class="hljs-comment">// 删除从位置5开始的3个字符</span><br>str.replace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Hi&quot;</span>);     <span class="hljs-comment">// 替换从位置0开始的5个字符为&quot;Hi&quot;</span><br><br><br>str.find(<span class="hljs-string">&quot;World&quot;</span>);           <span class="hljs-comment">// 查找子串，返回首次出现位置</span><br>str.rfind(<span class="hljs-string">&quot;o&quot;</span>);             <span class="hljs-comment">// 从右向左查找</span><br>str.find_first_of(<span class="hljs-string">&quot;aeiou&quot;</span>); <span class="hljs-comment">// 查找第一个元音字母</span><br>str.find_last_of(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找最后一个元音字母</span><br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-built_in">std</span>::transform(str.begin(), str.end(), str.begin(), <br>                   [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">toupper</span>(c); &#125;);<br><br><br><span class="hljs-comment">// Method 2: Using range-based for loop with iterator</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = str.begin(); it != str.end(); ++it) &#123;<br>      *it = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">tolower</span>(*it);<br>  &#125;<br></code></pre></td></tr></table></figure><p>字符串转其它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 转字符串 std::to_string()</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str1 = <span class="hljs-built_in">std</span>::to_string(num);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str2 = <span class="hljs-built_in">std</span>::to_string(pi);<br><br><br><span class="hljs-comment">// 字符串转数字  C++11</span><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">std</span>::stoi(numStr);<br><span class="hljs-type">double</span> pi = <span class="hljs-built_in">std</span>::stod(piStr);<br></code></pre></td></tr></table></figure><p>字符串流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br>字符串到流<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> ss;<br>ss &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-number">3.14</span>;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result = ss.str();<br><br><br>流到字符串<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data = <span class="hljs-string">&quot;123 45.67 Hello&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> <span class="hljs-title function_">ss</span><span class="hljs-params">(data)</span>;<br><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> c;<br><br>ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br></code></pre></td></tr></table></figure><p>正则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-built_in">std</span>::regex <span class="hljs-title function_">pattern</span><span class="hljs-params">(<span class="hljs-string">R&quot;(\b\w&#123;5&#125;\b)&quot;</span>)</span>; <span class="hljs-comment">// 匹配所有5个字母的单词</span><br><br><span class="hljs-built_in">std</span>::sregex_iterator <span class="hljs-title function_">it</span><span class="hljs-params">(text.begin(), text.end(), pattern)</span>;<br></code></pre></td></tr></table></figure><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 不同的初始化方式</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec1;                        <span class="hljs-comment">// 空向量</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">vec2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>;                     <span class="hljs-comment">// 5个元素，初始值为0</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">vec3</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span>;                  <span class="hljs-comment">// 5个元素，初始值为1</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec4 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;     <span class="hljs-comment">// 列表初始化</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">vec5</span><span class="hljs-params">(vec4)</span>;                  <span class="hljs-comment">// 拷贝构造</span><br><br><br><span class="hljs-comment">// 创建 M x N 的矩阵</span><br><span class="hljs-type">int</span> M = <span class="hljs-number">3</span>, N = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; matrix(M, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N));<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; grid3 = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>    &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>&#125;;  <span class="hljs-comment">// 直接初始化3x3矩阵</span><br><br><br><span class="hljs-comment">// 添加元素</span><br>vec.push_back(<span class="hljs-number">4</span>);           <span class="hljs-comment">// 在末尾添加元素</span><br>vec.emplace_back(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 在末尾构造元素（更高效）</span><br>vec.insert(vec.begin(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 在指定位置插入元素</span><br><br><span class="hljs-comment">// 删除元素</span><br>vec.pop_back();            <span class="hljs-comment">// 删除末尾元素</span><br>vec.erase(vec.begin());    <span class="hljs-comment">// 删除指定位置元素</span><br>vec.clear();               <span class="hljs-comment">// 清空所有元素</span><br><br><span class="hljs-comment">// 访问元素</span><br><span class="hljs-type">int</span> first = vec[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 下标访问（不检查边界）</span><br><span class="hljs-type">int</span> first_safe = vec.at(<span class="hljs-number">0</span>);<span class="hljs-comment">// 带边界检查的访问</span><br><span class="hljs-type">int</span> last = vec.back();     <span class="hljs-comment">// 访问最后一个元素</span><br><span class="hljs-type">int</span> first2 = vec.front();  <span class="hljs-comment">// 访问第一个元素</span><br><br><br>vec.size();      <span class="hljs-comment">// 当前元素个数</span><br>vec.capacity();  <span class="hljs-comment">// 当前分配的存储空间大小</span><br>vec.empty();     <span class="hljs-comment">// 检查是否为空</span><br>vec.reserve(<span class="hljs-number">10</span>); <span class="hljs-comment">// 预分配空间</span><br>vec.resize(<span class="hljs-number">5</span>);   <span class="hljs-comment">// 改变大小</span><br>vec.shrink_to_fit(); <span class="hljs-comment">// 释放多余内存</span><br><br><br><br><span class="hljs-comment">// 遍历元素</span><br><span class="hljs-comment">// 1. 范围for循环（推荐）  使用引用加速 而const保证不修改</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; element : vec) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// 2. 迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.begin(); it != vec.end(); ++it) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// 3. 索引</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vec.size(); ++i) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::iterator it2;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;::const_iterator it3; <span class="hljs-comment">// 常量</span><br><br><br>v.begin(); <span class="hljs-comment">// const 容器会返回const_iterator</span><br>v.cbegin(); <span class="hljs-comment">// 都会返回const_iterator</span><br><br><br><span class="hljs-comment">// 解引用运算符</span><br>*iter          <span class="hljs-comment">// 访问元素</span><br>iter-&gt;member   <span class="hljs-comment">// 访问成员(如果有)</span><br><br><span class="hljs-comment">// 自增运算</span><br>++iter        <span class="hljs-comment">// 前缀自增,移动到下一个元素</span><br>iter++        <span class="hljs-comment">// 后缀自增</span><br><br><span class="hljs-comment">// 比较运算 </span><br>iter1 == iter2 <span class="hljs-comment">// 判断两个迭代器是否指向相同位置</span><br>iter1 != iter2 <span class="hljs-comment">// 判断两个迭代器是否指向不同位置</span><br></code></pre></td></tr></table></figure><p>迭代器失效：在遍历的时候修改内容，会导致原来的迭代器失效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正确的方式  使用返回值更新迭代器</span><br>it = container.erase(it);  <span class="hljs-comment">// 返回删除元素的下一个元素的迭代器</span><br><br><br><span class="hljs-comment">// 在循环中正确使用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = container.begin(); it != container.end();) &#123;<br>    <span class="hljs-keyword">if</span> (某个条件) &#123;<br>        it = container.erase(it);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ++it;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 声明定长数组  p[i] = *(p+i)</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">5</span>];                     <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// 完全初始化</span><br><span class="hljs-type">int</span> arr3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;           <span class="hljs-comment">// 部分初始化，剩余元素为0</span><br><span class="hljs-type">int</span> arr4[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;         <span class="hljs-comment">// 自动推导大小</span><br><br>不可以用<span class="hljs-built_in">vector</span>初始化数组<br>数组 -&gt; <span class="hljs-built_in">vector</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">ivec</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::begin(int_arr), <span class="hljs-built_in">std</span>::end(int_arr))</span>;<br><br><br><span class="hljs-type">constexpr</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sz = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 访问</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>); ++i)&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// c11 提供快速位置获取</span><br><span class="hljs-type">int</span> * beg = <span class="hljs-built_in">std</span>::begin(ia);<br><span class="hljs-type">int</span> * end = <span class="hljs-built_in">std</span>::end(ia);  <span class="hljs-comment">// == ia + sz</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = beg; it != end; ++it)&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>多维<br><span class="hljs-comment">// 二维数组   函数传参以及表达式运算时会退化成int (*)[4]</span><br><span class="hljs-type">int</span> matrix[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 以下所有表达式都是等价的，都访问值7</span><br><span class="hljs-type">int</span> value1 = a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];           <span class="hljs-comment">// 普通数组访问</span><br><span class="hljs-type">int</span> value2 = *(*(a + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>);   <span class="hljs-comment">// 完全展开的指针访问</span><br><span class="hljs-type">int</span> value3 = *(a[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>);       <span class="hljs-comment">// 混合形式</span><br><span class="hljs-type">int</span> value4 = *((<span class="hljs-type">int</span>*)a + <span class="hljs-number">6</span>);    <span class="hljs-comment">// 将二维数组当作一维数组访问</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; ++p)&#123; <span class="hljs-comment">// ia+i等价于 &amp;(ia[i])</span><br>    <span class="hljs-comment">//q指向4个整数的数组的首元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q = *p; q != *p + <span class="hljs-number">4</span>; ++q)&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>固定大小，编译时确定</li><li>连续内存空间</li><li>栈上分配</li><li>不能改变大小</li><li>快速索引访问</li></ul><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 动态分配</span><br><span class="hljs-type">int</span>* arr = new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 使用完后需要释放</span><br>delete[] arr;<br><br><span class="hljs-comment">// 动态分配并初始化（C++11）</span><br><span class="hljs-type">int</span>* arr = new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><br><br><span class="hljs-comment">// 动态二维数组</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">3</span>, n = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 分配行指针</span><br><span class="hljs-type">int</span>** arr = new <span class="hljs-type">int</span>*[m];<br><span class="hljs-comment">// 分配每一行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    arr[i] = new <span class="hljs-type">int</span>[n];<br>&#125;<br><br><span class="hljs-comment">// 释放内存</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    delete[] arr[i];<br>&#125;<br>delete[] arr;<br></code></pre></td></tr></table></figure><ul><li>运行时确定大小</li><li>堆上分配</li><li>需要手动管理内存</li><li>使用指针访问</li></ul><p>数组的指针和引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;<br><span class="hljs-comment">//arrRef 引用一个含有10个整数的数组</span><br><span class="hljs-type">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<br></code></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> &#123;</span><br>public:<br>    <span class="hljs-type">double</span> real, imag;<br><br>    Complex operator+(<span class="hljs-type">const</span> Complex &amp;c) &#123;<br>        Complex temp;<br>        temp.real = real + c.real;<br>        temp.imag = imag + c.imag;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> &#123;</span><br>public:<br>    <span class="hljs-type">double</span> real, imag;<br>    friend Complex operator-(<span class="hljs-type">const</span> Complex &amp;c1, <span class="hljs-type">const</span> Complex &amp;c2);<br><br>    <span class="hljs-comment">// 重载 &lt;&lt; 运算符（作为友元函数）</span><br>    friend ostream&amp; operator&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Complex &amp;c);<br>&#125;;<br><br>Complex operator-(<span class="hljs-type">const</span> Complex &amp;c1, <span class="hljs-type">const</span> Complex &amp;c2) &#123;<br>    Complex temp;<br>    temp.real = c1.real + c2.real;<br>    temp.imag = c1.imag + c2.imag;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br>ostream&amp; operator&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Complex &amp;c) &#123;<br>    out &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// multiply.h:</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MULTIPLY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MULTIPLY_H</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// multiply.cpp:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;multiply.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;multiply.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> result = multiply(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;4 * 6 = &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>g++ main.cpp multiply.cpp -o program<br></code></pre></td></tr></table></figure><p>传参：</p><ul><li><strong>传值调用</strong>：适用于不需要修改原始数据且数据量较小的情况。  拷贝构造函数</li><li><strong>传引用调用</strong>：适用于需要修改原始数据或传递大型数据结构以提高效率。</li><li><strong>传指针调用</strong>：类似传引用调用，但更灵活，可用于传递<code>nullptr</code>或指向动态分配的内存。</li></ul><p>返回值：</p><ul><li>基本数据类型</li><li>引用类型<code>int&amp; getReference(int&amp; value); int&amp; ref = getReference(x); </code></li><li>指针类型 <code>int* createNumber()</code></li><li>对象  优先移动语义，其次拷贝构造函数 现代编译器通过返回值优化（RVO）减少对象拷贝，提高效率</li></ul><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// Regular function</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Declaring a function pointer</span><br>    <span class="hljs-type">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br>    <span class="hljs-comment">// Assigning function address to pointer</span><br>    func_ptr = add;  <span class="hljs-comment">// 取地址可以省略</span><br><br>    <span class="hljs-comment">// Calling function through pointer</span><br>    <span class="hljs-type">int</span> result = func_ptr(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 解引用可以省略</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// typedef for Cleaner </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*Operation)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br>Operation op = add;<br><br><br><span class="hljs-comment">// 结合lambda</span><br><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>) = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br></code></pre></td></tr></table></figure><h5 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h5><p>Lambda 表达式在编译器生成的代码中会被转换为一个<strong>匿名类</strong>，该类包含以下关键部分：</p><ul><li><strong>捕获的变量</strong>：以值捕获的变量会成为该类的成员变量（例如 <code>std::shared_ptr</code> 会作为成员变量存储）。</li><li>**重载的 <code>operator()</code>**：即 lambda 的函数体逻辑。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">[capture clause](parameters) -&gt; return_type &#123; body &#125;<br><br><br><span class="hljs-type">int</span> multiplier = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> multiply = [multiplier](<span class="hljs-type">int</span> x) <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> x * multiplier; &#125;;<br><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">std</span>::for_each(nums.begin(), nums.end(), <br>    [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br><br><br><span class="hljs-comment">// 使用Lambda表达式计算总和  引用捕获</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">std</span>::for_each(numbers.begin(), numbers.end(), [&amp;sum](<span class="hljs-type">int</span> x) &#123;<br>    sum += x;<br>&#125;);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; callback)</span> &#123;<br>    callback(<span class="hljs-number">42</span>);<br>&#125;<br><span class="hljs-comment">// Usage</span><br>process([](<span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x; &#125;);<br></code></pre></td></tr></table></figure><ol><li><strong>值捕获 (<code>[=]</code>)</strong>: 捕获所有外部变量的副本。 <strong>拷贝构造函数</strong></li><li><strong>引用捕获 (<code>[&amp;]</code>)</strong>: 捕获所有外部变量的引用。</li><li><strong>混合捕获</strong>: 指定部分变量按值捕获，部分按引用捕获，如 <code>[=, &amp;var]</code> 或 <code>[&amp;, var]</code>。</li><li><strong>无捕获 (<code>[]</code>)</strong>: 不捕获任何外部变量。</li></ol><p>使用lambda捕获结合智能指针，可以实现生命周期延续，防止引用捕获时外部对象已经被销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> </span>&#123;<br>    <span class="hljs-type">static</span> std::mutex mtx;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;3. Inside function, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 参数值传递 计数再+1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1. ptr created, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-comment">// 值捕获 ptr：触发拷贝构造，引用计数 +1</span><br>    <span class="hljs-keyword">auto</span> lambda = [ptr]() &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;3. Inside lambda, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>()));<br>    &#125;;<br><br>    <span class="hljs-comment">// 复制到 bind 对象内部 引用计数 +1</span><br>    <span class="hljs-keyword">auto</span> boundFunc = std::<span class="hljs-built_in">bind</span>(printValue, ptr);<br><br><br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;2. After lambda capture, use_count = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 3</span><br><br>    <span class="hljs-built_in">boundFunc</span>();<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([lambda]() &#123;  <span class="hljs-comment">// 拷贝 lambda，其内部的 ptr 被拷贝，引用计数 +1</span></span></span><br><span class="hljs-params"><span class="hljs-function">        lambda();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;4. end = &quot;</span> + std::<span class="hljs-built_in">to_string</span>(ptr.<span class="hljs-built_in">use_count</span>())); <span class="hljs-comment">// 2</span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当定义 lambda 时，编译器实际上创建了一个匿名类（闭包类型）的实例，捕获的变量 add_ptr 确实相当于闭包类型的成员变量，调用lambda时就是<strong>访问成员</strong>变量，值不会增加</li><li>lambda被复制（例如传递给线程），add_ptr作为其成员也会被复制，从而增加引用计数。</li><li>bind 也会创建一个函数对象，并以元组形式存储所有参数的副本 所以计数+1，同时调用函数时会<strong>传参</strong>再次拷贝，额外在+1</li></ul><h5 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h5><p><strong>仿函数（Functors）</strong>，又称<strong>函数对象（Function Objects）</strong>，是在C++中重载了 <code>operator()</code> 的类或结构体实例。使得对象能像函数一样被调用，类似于<code>__call__</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义一个仿函数类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Adder</span> &#123;</span><br>    <span class="hljs-type">int</span> to_add;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    Adder(<span class="hljs-type">int</span> value) : to_add(value) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载()运算符</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x + to_add;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Adder <span class="hljs-title function_">add5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>; <span class="hljs-comment">// 创建一个添加5的仿函数</span><br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;10 + 5 = &quot;</span> &lt;&lt; add5(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: 10 + 5 = 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 结合模版 实现通用代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 通用比较仿函数</span><br>template &lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Compare</span> &#123;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a &lt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>&#125;;<br><br>    <span class="hljs-comment">// 使用仿函数进行排序</span><br>    <span class="hljs-built_in">std</span>::sort(numbers.begin(), numbers.end(), Compare&lt;<span class="hljs-type">int</span>&gt;());<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;排序后的数字: &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : numbers) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 5 8 9</span><br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>许多标准库算法可以接受仿函数作为参数    <code>auto it = std::find_if(numbers.begin(), numbers.end(), greaterThan10);</code></p><h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5><p><code>std::function</code> 是 C++11 引入的通用可调用对象包装器，允许以统一的方式处理多种可调用对象。</p><p><code>std::function&lt;int(int, int)&gt; func; // 接受两个int，返回int的可调用对象</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 函数对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Multiply</span> &#123;</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 封装普通函数</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func1 = add;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Add: &quot;</span> &lt;&lt; func1(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: Add: 7</span><br><br>    <span class="hljs-comment">// 封装Lambda表达式</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func2 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Subtract: &quot;</span> &lt;&lt; func2(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: Subtract: 6</span><br><br>    <span class="hljs-comment">// 封装函数对象</span><br>    Multiply multiply;<br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func3 = multiply;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Multiply: &quot;</span> &lt;&lt; func3(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出: Multiply: 12</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p><code>std::bind</code>的主要作用是生成一个新的可调用对象，通过预先绑定某些参数，或者调整参数顺序，使得调用时更加方便。它支持普通函数、成员函数、函数对象等，并且可以使用占位符来灵活处理参数的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; msg, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 绑定消息为&quot;Hello&quot;，生成新的函数对象，只需要传递次数</span><br>    <span class="hljs-keyword">auto</span> sayHello = <span class="hljs-built_in">std</span>::bind(display, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-built_in">std</span>::placeholders::_1);<br><br>    sayHello(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    输出:</span><br><span class="hljs-comment">    Hello</span><br><span class="hljs-comment">    Hello</span><br><span class="hljs-comment">    Hello</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 绑定次数为2，生成新的函数对象，只需要传递消息</span><br>    <span class="hljs-keyword">auto</span> sayTwice = <span class="hljs-built_in">std</span>::bind(display, <span class="hljs-built_in">std</span>::placeholders::_1, <span class="hljs-number">2</span>);<br>    sayTwice(<span class="hljs-string">&quot;Hi&quot;</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    输出:</span><br><span class="hljs-comment">    Hi</span><br><span class="hljs-comment">    Hi</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bind_result</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    F func;  <span class="hljs-comment">// 存储目标函数</span><br>    std::tuple&lt;Args...&gt; bound_args;  <span class="hljs-comment">// 以元组形式存储所有参数的副本</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bind_result</span>(F f, Args... args) <br>        : <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">bound_args</span>(std::<span class="hljs-built_in">move</span>(args)...) &#123;&#125;<br><br>    <span class="hljs-comment">// 调用运算符，允许对象作为函数使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... CallArgs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(CallArgs&amp;&amp;... call_args)</span> </span>&#123;<br>        <span class="hljs-comment">// 将存储的参数传递给目标函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">invoke_with_args</span>(<br>            std::index_sequence_for&lt;Args...&gt;&#123;&#125;, <br>            std::forward&lt;CallArgs&gt;(call_args)...<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数，用于展开存储的参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>... Is, <span class="hljs-keyword">typename</span>... CallArgs&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">invoke_with_args</span><span class="hljs-params">(std::index_sequence&lt;Is...&gt;, CallArgs&amp;&amp;... call_args)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">get</span>&lt;Is&gt;(bound_args)...);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">可调用对象类型</th><th align="left">状态携带</th><th align="left">性能</th><th align="left">灵活性</th><th align="left">典型场景</th></tr></thead><tbody><tr><td align="left">普通函数</td><td align="left">否</td><td align="left">高</td><td align="left">低</td><td align="left">简单逻辑</td></tr><tr><td align="left">函数指针</td><td align="left">否</td><td align="left">高</td><td align="left">低</td><td align="left">回调机制</td></tr><tr><td align="left">Lambda 表达式</td><td align="left">是</td><td align="left">高</td><td align="left">高</td><td align="left">内联匿名逻辑</td></tr><tr><td align="left">仿函数（函数对象）</td><td align="left">是</td><td align="left">高</td><td align="left">高</td><td align="left">需复用的状态逻辑</td></tr><tr><td align="left"><code>std::function</code></td><td align="left">是</td><td align="left">中</td><td align="left">高</td><td align="left">统一管理多种可调用对象</td></tr><tr><td align="left">成员函数指针</td><td align="left">否</td><td align="left">高</td><td align="left">中</td><td align="left">面向对象回调</td></tr><tr><td align="left"><code>std::bind</code></td><td align="left">是</td><td align="left">中</td><td align="left">高</td><td align="left">参数适配、延迟绑定</td></tr></tbody></table><ul><li><strong>简单回调：</strong> 使用函数指针或Lambda表达式。</li><li><strong>需要携带状态或更复杂逻辑：</strong> 使用Lambda表达式或仿函数（Functors）。</li><li><strong>接口要求 <code>std::function</code>：</strong> 使用 <code>std::function</code>，不过要注意可能的性能开销。</li><li><strong>参数预绑定：</strong> 使用 <code>std::bind</code>，但在现代C++中，许多情况下Lambda表达式能达到相同效果且更直观。</li></ul><h5 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// Network event types</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NetworkEvent</span> &#123;</span><br>    CONNECT,<br>    DISCONNECT,<br>    DATA_RECEIVED,<br>    ERROR<br>&#125;;<br><br><span class="hljs-comment">// Event data structure</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EventData</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> clientId;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data;<br>    <span class="hljs-type">int</span> errorCode;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkEventHandler</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// Register callback for specific event</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">registerHandler</span><span class="hljs-params">(NetworkEvent event, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> EventData&amp;)&gt; handler)</span> &#123;<br>        eventHandlers[event] = handler;<br>    &#125;<br><br>    <span class="hljs-comment">// Simulate event occurring</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(NetworkEvent event, <span class="hljs-type">const</span> EventData&amp; data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (eventHandlers.find(event) != eventHandlers.end()) &#123;<br>            eventHandlers[event](data);<br>        &#125;<br>    &#125;<br><br>private:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;NetworkEvent, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> EventData&amp;)&gt;&gt; eventHandlers;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    NetworkEventHandler handler;<br><br>    <span class="hljs-comment">// Register handlers for different events</span><br>    handler.registerHandler(NetworkEvent::CONNECT, <br>        [](<span class="hljs-type">const</span> EventData&amp; data) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Client &quot;</span> &lt;&lt; data.clientId &lt;&lt; <span class="hljs-string">&quot; connected&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    );<br><br>    handler.registerHandler(NetworkEvent::DATA_RECEIVED, <br>        [](<span class="hljs-type">const</span> EventData&amp; data) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Received data from &quot;</span> &lt;&lt; data.clientId &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; data.data &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    );<br><br>    handler.registerHandler(NetworkEvent::ERROR, <br>        [](<span class="hljs-type">const</span> EventData&amp; data) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Error from &quot;</span> &lt;&lt; data.clientId &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; data.errorCode &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// Simulate some network events</span><br>    handler.handleEvent(NetworkEvent::CONNECT, &#123;<span class="hljs-string">&quot;client123&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>&#125;);<br>    handler.handleEvent(NetworkEvent::DATA_RECEIVED, &#123;<span class="hljs-string">&quot;client123&quot;</span>, <span class="hljs-string">&quot;Hello Server!&quot;</span>, <span class="hljs-number">0</span>&#125;);<br>    handler.handleEvent(NetworkEvent::ERROR, &#123;<span class="hljs-string">&quot;client123&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">404</span>&#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li><strong>封装（Encapsulation）</strong>：将数据和操作数据的代码绑定在一起，保护数据不被外界直接访问。</li><li><strong>抽象（Abstraction）</strong>：通过类定义抽象出具有共同特性的对象，提高代码的可重用性和可维护性。</li><li><strong>继承（Inheritance）和多态（Polymorphism）</strong>：实现代码的复用与动态绑定。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// 公有成员</span><br>protected:<br>    <span class="hljs-comment">// 受保护成员  成员函数 &amp; 友元函数 &amp; 派生类</span><br>private:<br>    <span class="hljs-comment">// 私有成员  成员函数 &amp; 友元函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造顺序：</p><ol><li><p>自动调用父类默认构造函数  （或者在子类初始化列表中主动调用）</p></li><li><p>成员变量构造（按声明顺序）  如果想要有参构造，需要在初始化列表中</p><ol><li>初始化列表初始化   -&gt;  默认构造函数初始化</li></ol></li><li><p>当前类构造函数</p></li></ol><p>析构顺序（与构造相反）：</p><ol><li>当前类析构函数</li><li>成员变量析构</li><li>父类析构函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoveExample</span> &#123;</span><br>public:<br>    <span class="hljs-comment">// 构造函数  实现了有参后，会删除默认的无参</span><br>    MoveExample(<span class="hljs-type">int</span> size) : size_(size), data_(new <span class="hljs-type">int</span>[size]) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Constructor called.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数   </span><br>      <span class="hljs-comment">// 默认拷贝构造会逐个拷贝 指针是浅拷贝； 如果有const、引用、不可拷贝类型则不会生成默认的</span><br>    MoveExample(<span class="hljs-type">const</span> MoveExample&amp; other) : size_(other.size_), data_(new <span class="hljs-type">int</span>[other.size_]) &#123;<br>        <span class="hljs-built_in">std</span>::copy(other.data_, other.data_ + size_, data_);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Copy constructor called.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    MoveExample(MoveExample&amp;&amp; other) noexcept : size_(other.size_), data_(other.data_) &#123;<br>        other.size_ = <span class="hljs-number">0</span>;<br>        other.data_ = nullptr;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Move constructor called.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值运算符</span><br>    MoveExample&amp; operator=(<span class="hljs-type">const</span> MoveExample&amp; other) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Copy assignment operator called.\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> (this == &amp;other)<br>            <span class="hljs-keyword">return</span> *this;<br><br>        delete[] data_;<br>        size_ = other.size_;<br>        data_ = new <span class="hljs-type">int</span>[size_];<br>        <span class="hljs-built_in">std</span>::copy(other.data_, other.data_ + size_, data_);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MoveExample&amp; operator=(MoveExample&amp;&amp; other) noexcept &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Move assignment operator called.\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> (this == &amp;other)<br>            <span class="hljs-keyword">return</span> *this;<br><br>        delete[] data_;<br>        size_ = other.size_;<br>        data_ = other.data_;<br><br>        other.size_ = <span class="hljs-number">0</span>;<br>        other.data_ = nullptr;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MoveExample() &#123;<br>        delete[] data_;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Destructor called.\n&quot;</span>;<br>    &#125;<br><br>private:<br>    <span class="hljs-type">int</span> size_;<br>    <span class="hljs-type">int</span>* data_;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Example ex1;               <span class="hljs-comment">// 调用默认构造函数</span><br>    Example <span class="hljs-title function_">ex2</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span>;           <span class="hljs-comment">// 调用参数化构造函数</span><br>    Example ex3 = ex2;         <span class="hljs-comment">// 调用拷贝构造函数 等价于 Example ex3(ex2);</span><br>    ex3 = ex2;                  <span class="hljs-comment">// 调用拷贝赋值运算符</span><br><br>    <span class="hljs-comment">// 临时右值</span><br>      MoveExample ex3 = MoveExample(<span class="hljs-number">200</span>);   <span class="hljs-comment">// Constructor + Move Constructor；如果启动rvo会只有Constructor </span><br>  <span class="hljs-comment">// 等价于 MoveExample ex3( MoveExample(200));</span><br>  <br>      ex4 = MoveExample(<span class="hljs-number">400</span>);   <span class="hljs-comment">// Move Assignment</span><br><br>      <span class="hljs-comment">// 显式移动</span><br>    MoveExample <span class="hljs-title function_">obj2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(obj1))</span>;<br>    MoveExample obj2 = <span class="hljs-built_in">std</span>::move(obj1);    <span class="hljs-comment">// 移动构造</span><br>    obj2 = <span class="hljs-built_in">std</span>::move(obj1);                <span class="hljs-comment">// 移动赋值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>浅拷贝：int * 直接拷贝值 <code>data = other.data</code><ul><li>如果释放多次资源，就会报错</li></ul></li><li>深拷贝：int * 重新new空间 并设置值相同. <code>data = new int(*other.data)</code></li></ul><h5 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h5><p>资源所有权的交换</p><ul><li><code>MoveExample&amp; operator=(MoveExample&amp;&amp; other)</code></li><li><code>MoveExample(MoveExample&amp;&amp; other) noexcept</code></li></ul><h5 id="MyString"><a href="#MyString" class="headerlink" title="MyString"></a>MyString</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span>&#123;</span><br><br>private:<br>    <span class="hljs-comment">// size and data</span><br>    <span class="hljs-type">size_t</span> size_;<br>    <span class="hljs-type">char</span>* data_;<br><br>public:<br><br>    MyString():size_(<span class="hljs-number">0</span>), data_(new <span class="hljs-type">char</span>[<span class="hljs-number">1</span>])&#123;<br>    &#125;<br><br>    MyString(<span class="hljs-type">char</span> * c):size_(<span class="hljs-built_in">strlen</span>(c)), data_(new <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(c)+<span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-built_in">strcpy</span>(data_, c);<br>    &#125;<br><br>    MyString(<span class="hljs-type">const</span> MyString &amp; s2)&#123;<br>        this-&gt;size_ = s2.getSize();<br>        this-&gt;data_ = new <span class="hljs-type">char</span>[this -&gt; size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data_, s2.getData());<br>    &#125;<br><br>    MyString&amp; operator=(<span class="hljs-type">const</span> MyString&amp; s2)&#123;<br>        this-&gt;size_ = s2.getSize();<br><br>        delete[] this-&gt;data_;<br><br>        this-&gt;data_ = new <span class="hljs-type">char</span>[this-&gt;size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(this-&gt;data_, s2.getData());<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    MyString operator+(<span class="hljs-type">const</span> MyString&amp; s2)&#123;<br>        MyString result;<br>        result.size_ = this-&gt;size_ + s2.getSize();<br>        result.data_ = new <span class="hljs-type">char</span>[result.size_ + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(result.data_, this-&gt;data_);<br>        <span class="hljs-built_in">strcat</span>(result.data_, s2.getData());<br><br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;&amp;result&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// MyString&amp; operator+(const MyString&amp; s2)&#123;</span><br>    <span class="hljs-comment">//     size_ = this-&gt;size_ + s2.getSize();</span><br>    <span class="hljs-comment">//     char* tmp = new char[size_ + 1];</span><br>    <span class="hljs-comment">//     strcpy(tmp, this-&gt;data_);</span><br>    <span class="hljs-comment">//     strcat(tmp, s2.getData());</span><br><br>    <span class="hljs-comment">//     delete[] data_;</span><br>    <span class="hljs-comment">//     data_ = tmp;</span><br><br>    <span class="hljs-comment">//     // std::cout&lt;&lt;&amp;result&lt;&lt;std::endl;</span><br><br>    <span class="hljs-comment">//     return *this;</span><br>    <span class="hljs-comment">// &#125;</span><br><br><br>    MyString(MyString &amp;&amp; s2) noexcept&#123;<br>        this-&gt;size_ = s2.getSize();<br>        this-&gt;data_ = s2.getData();<br>        s2.size_ = <span class="hljs-number">0</span>;<br>        s2.data_ = nullptr;<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;move con&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    MyString&amp; operator=(MyString&amp;&amp; s2)&#123;<br>        this-&gt;size_ = s2.getSize();<br><br>        delete[] this-&gt;data_;<br><br>        this-&gt;data_ = s2.getData();<br>        this-&gt;size_ = s2.getSize();<br>        s2.setData(nullptr);<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;move asi&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    ~MyString()&#123;<br>        delete[] data_;<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;deconstruct&quot;</span> &lt;&lt; <span class="hljs-string">&quot;~MyString(&quot;</span> &lt;&lt; this &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">size_t</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> size_;<br>    &#125;<br><br>    <span class="hljs-type">char</span>* <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> data_;<br>    &#125;<br><br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(<span class="hljs-type">char</span>* newData)</span> &#123;<br>        data_ = newData;<br>    &#125;<br><br><br>    friend <span class="hljs-built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp; os, <span class="hljs-type">const</span> MyString&amp; s);<br><br>&#125;;<br><br><span class="hljs-built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp; os, <span class="hljs-type">const</span> MyString&amp; s)&#123;<br>    os &lt;&lt; s.data_;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RVO"><a href="#RVO" class="headerlink" title="RVO"></a>RVO</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">MyClass <span class="hljs-title function_">createObject</span><span class="hljs-params">()</span> &#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj;   <br>&#125;<br>MyClass obj2 = createObject();<br><br><br>-fno-elide-constructors<br><br><span class="hljs-comment">// 无优化  还额外创建了一个临时变量；obj-&gt;tmp-&gt;obj2</span><br><span class="hljs-comment">// MyClass constructor  // obj 构造</span><br><span class="hljs-comment">// MyClass copy constructor // 返回值临时对象构造</span><br><span class="hljs-comment">// MyClass destructor       // obj 析构</span><br><span class="hljs-comment">// MyClass copy constructor // obj2 构造</span><br><span class="hljs-comment">// MyClass destructor       // 临时对象析构</span><br><span class="hljs-comment">// MyClass destructor      // obj2 对象析构</span><br><br><br><span class="hljs-comment">// 优化后 直接构造在返回值位置 只构造一次  二者地址相同</span><br><span class="hljs-comment">// MyClass constructor</span><br><span class="hljs-comment">// MyClass destructor</span><br><br><br><span class="hljs-comment">// 内存高地址</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// |                  |</span><br><span class="hljs-comment">// | 主函数栈帧       |</span><br><span class="hljs-comment">// | (result变量)     |</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// | 返回值临时对象   | &lt;- Copy Constructor在这里创建对象</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// | createObject     |</span><br><span class="hljs-comment">// | 函数栈帧        |</span><br><span class="hljs-comment">// | (obj1, obj2)    |</span><br><span class="hljs-comment">// +------------------+</span><br><span class="hljs-comment">// |                  |</span><br><span class="hljs-comment">// 内存低地址</span><br></code></pre></td></tr></table></figure><ul><li>忽略优化的情况下-fno-elide-constructors出现上面的情况</li><li>cpp17后，强制不再先构造一个中间临时</li></ul><h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>访问控制</strong>：也就是min(原权限，继承权限)</p><ul><li>公有继承（public inheritance）<ul><li>基类的 <code>public</code> 成员在派生类中保持 <code>public</code>。</li><li>基类的 <code>protected</code> 成员在派生类中保持 <code>protected</code>。</li><li>基类的 <code>private</code> 成员在派生类中不可访问。</li></ul></li><li>保护继承（protected inheritance）<ul><li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>protected</code>。</li></ul></li><li>私有继承（private inheritance）<ul><li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li></ul></li></ul><p><strong>调用顺序：</strong></p><ol><li><p>基类的 <strong>默认构造函数</strong> 首先被调用，除非派生类在初始化列表中显式调用其他基类构造函数。</p></li><li><p>派生类的成员按照声明顺序被构造。</p></li><li><p>派生类的构造函数体被执行。</p></li><li><p>派生类先析构。再子类</p></li></ol><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>实现多态：</p><ul><li>通过对象直接调用函数时，表现与非虚函数相同，直接调用子类</li><li>通过<strong>基类指针&#x2F;引用</strong>调用函数时，会调用实际子类的函数实现，从而实现多态</li><li>当把一个子类对象直接赋值给父类对象（不是指针或引用）时，发生<strong>对象切片</strong> 派生类特性丢失 变成调用父类了，同样<code>vector&lt;Base&gt;</code>也会</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>public:<br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> public Base &#123;<br>public:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> override &#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; base)</span> &#123;<br>    base.show(); <span class="hljs-comment">// 动态绑定，根据实际对象类型调用对应的show()</span><br>&#125;<br><br><br><br><span class="hljs-comment">// 子类中，还可以调用父类的，用于扩展父类行为而非完全替换它、装饰器模式</span><br>Shape::draw();  <span class="hljs-comment">// 调用父类的draw方法</span><br></code></pre></td></tr></table></figure><h6 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a><strong>虚函数原理</strong></h6><ul><li><p>每个包含虚函数的类都有一个**虚函数表 (vtable)**，类对象通过 <strong>vptr</strong> 指向这个表的地址</p></li><li><p>表中存储着虚函数的地址。编译时创建</p></li><li><p>Sizeof(a) 会显示这个对象所占用空间，如果有虚函数需要多8个字节vptr，如果还有一个int结合内存对齐需要16</p></li><li><pre><code class="hljs">+---------------+|     vptr      | -----&gt; +-----------------++---------------+        | 虚函数表(vtable) ||   成员变量1    |        +-----------------++---------------+        | virtualFunc1()  ||   成员变量2    |        +-----------------++---------------+        | virtualFunc2()  |                         +-----------------+                         | virtualFunc3()  |                         +-----------------+<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><br>```c<br>typedef void<span class="hljs-comment">(*Fun)(void*)</span><span class="hljs-punctuation">;</span><br><br>Base* ptr = <span class="hljs-keyword">new</span> Derived()<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">// 获取vptr，ptr是一个地址，内容还是一个地址 所以转换为：指向指针void* 的地址。这个指针代表着虚函数表的起始地址</span><br>void* vptr = *(void**)ptr<span class="hljs-punctuation">;</span><br><span class="hljs-comment">// 获取虚函数表中f1的地址（在虚函数表中的偏移为0）  long long代表取这个地址中8位的数据，long long*等价于void**</span><br>Fun f = (Fun)<span class="hljs-comment">(*(long long*)</span>vptr)<span class="hljs-punctuation">;</span><br><span class="hljs-comment">// 调用f1</span><br>f(ptr)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure>// 获取虚函数表中f2的地址（在虚函数表中的偏移为+8个字节）Fun f2 = (Fun)(*((long long*)vptr + 1));// 调用f1f2(ptr);当然vptr是指向函数(void*)的指针，也可以用void** vptr = *(void***)ptr;Fun f = (Fun)(*vptr);   // (Fun)(vptr[0]);// 取出变量std::cout&lt;&lt; *(int*)((void**)ptr + 1) &lt;&lt; std::endl;</code></pre></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- 当虚函数重写后，f地址不同，否则是相同的；普通的函数不需要vptr，函数放到代码段固定地址，编译时就确定函数地址，少一个查表过程相对更高效<br><br><br><br>包含**纯虚函数**的类为**抽象基类**，不能被初始化<br><br>```c<br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pureVirtualFunction</span>()</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printm</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a><strong>虚析构</strong></h6><p>避免当我们通过基类指针删除一个派生类对象时，派生类的资源没有被正确释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>public:<br>    Base() &#123; <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base constructor\n&quot;</span>; <br>    &#125;<br>    <span class="hljs-comment">// 情况1：普通析构函数</span><br>    <span class="hljs-comment">// ~Base() &#123; </span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; &quot;Base destructor\n&quot;; </span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 情况2：虚析构函数</span><br>    virtual ~Base() &#123; <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base destructor\n&quot;</span>; <br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> public Base &#123;<br>private:<br>    <span class="hljs-type">int</span>* data;<br>public:<br>    Derived() : data(new <span class="hljs-type">int</span>(<span class="hljs-number">100</span>)) &#123; <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Derived constructor\n&quot;</span>; <br>    &#125;<br>    ~Derived() &#123; <br>        delete data;  <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Derived destructor\n&quot;</span>; <br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Base* ptr = new Derived();<br>    delete ptr;  <span class="hljs-comment">// 如果Base析构函数不是virtual，这里只会调用Base的析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h6><ul><li>虚继承主要用于解决菱形继承中的数据重复问题</li><li>在无虚继承的情况下，<code>Convertible</code> 类将拥有两份 <code>Device</code> 的成员变量，这会导致二义性问题。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-comment">// 不使用虚继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> :</span> public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span> :</span> public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D1</span> :</span> public B1, public C1 &#123;&#125;;<br><br><span class="hljs-comment">// 使用虚继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> :</span> virtual public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C2</span> :</span> virtual public A &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D2</span> :</span> public B2, public C2 &#123;&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    D1 d1;  <span class="hljs-comment">// 菱形继承</span><br>    <span class="hljs-comment">// d1.data;        // 错误：数据模糊</span><br>    d1.B1::data = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 必须指定路径</span><br>    d1.C1::data = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 两份数据</span><br><br>    D2 d2;  <span class="hljs-comment">// 虚继承</span><br>    d2.data = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 正确：只有一份数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h5><ul><li><p>delete <code>DefaultClass(const DefaultClass &amp;) = delete; </code>  单例下删除一些函数，或者防止资源复制</p></li><li><p>移动构造和拷贝构造：性能更高，直接转移空间而不是复制资源，适用于临时对象</p></li><li><p>初始化列表作用：提高性能、常量成员和引用必须、避免先构造再赋值减少开销</p></li><li><p>析构函数作用：主线程等待子循环、资源释放</p></li><li><p>RAII：构造函数获取资源，析构函数释放资源，确保资源不会泄漏</p><ul><li><pre><code class="c">void unsafeFunction() &#123;    mtx.lock();    std::cout &lt;&lt; &quot;Thread is working...&quot; &lt;&lt; std::endl;    // 如果这里有异常，mutex 将无法解锁，导致死锁    mtx.unlock();&#125;void safeFunction() &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 自动加锁    std::cout &lt;&lt; &quot;Thread is working...&quot; &lt;&lt; std::endl;&#125;  // 作用域结束，自动解锁<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 自定义guard</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockGuard</span> &#123;<br><span class="hljs-keyword">private</span>:<br><br>    std::mutex&amp; mtx;  <span class="hljs-comment">// 引用外部互斥锁</span><br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LockGuard</span><span class="hljs-params">(std::mutex&amp; m)</span> : mtx(m) &#123;</span><br>        mtx.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// 构造函数加锁</span><br>    &#125;<br>    <br>    ~<span class="hljs-built_in">LockGuard</span>() &#123;<br>        mtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 析构函数解锁</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 禁止拷贝和赋值，防止多个 LockGuard 实例管理同一把锁</span><br>    <span class="hljs-built_in">LockGuard</span>(<span class="hljs-type">const</span> LockGuard&amp;) = <span class="hljs-keyword">delete</span>;<br>    LockGuard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LockGuard&amp;) = <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-operator">-</span> 静态成员在程序开始时初始化，结束时析构<br>  <br>  ```c<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-keyword">static</span> <span class="hljs-type">MyClass</span> instance;<br>      <span class="hljs-type">MyClass</span>() &#123; cout <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;构造<span class="hljs-subst">\n</span>&quot;</span>; &#125;<br>      <span class="hljs-operator">~</span><span class="hljs-type">MyClass</span>() &#123; cout <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;析构<span class="hljs-subst">\n</span>&quot;</span>; &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 放在类外面的 cpp中</span><br>  <span class="hljs-type">MyClass</span> <span class="hljs-type">MyClass</span>::instance; <span class="hljs-comment">// 静态成员变量定义</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>C++ 提供了多种内存管理方式，包括传统的 C 风格的 <code>malloc</code> 和 <code>free</code>，以及 C++ 专用的 <code>new</code> 和 <code>delete</code>。</p><p>在 C++ 程序中，内存主要分为以下几个区域：</p><ul><li><p><strong>栈（Stack）</strong>：自动管理内存，存储局部变量和函数调用信息。内存分配和释放速度快，但空间有限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;      <span class="hljs-comment">// x存储在栈上</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;    <span class="hljs-comment">// c存储在栈上</span><br>&#125; <span class="hljs-comment">// 函数结束时，x和c自动释放</span><br></code></pre></td></tr></table></figure></li><li><p><strong>堆（Heap）</strong>：手动管理内存，用于动态分配内存。内存分配和释放由程序员控制，灵活但易出错（如内存泄漏、悬挂指针）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 内存在堆上分配</span><br><span class="hljs-comment">// 使用p指向的内存...</span><br>delete p;                <span class="hljs-comment">// 必须手动释放内存，否则会造成内存泄漏</span><br></code></pre></td></tr></table></figure></li><li><p><strong>全局&#x2F;静态区（<code>Data/BSS Segment</code>）</strong>：存储全局变量和静态变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;           <span class="hljs-comment">// 全局变量存储在全局区</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar = <span class="hljs-number">5</span>; <span class="hljs-comment">// 静态变量存储在静态区</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc&#x2F;free"></a>malloc&#x2F;free</h5><ul><li><strong>类型转换</strong>：<code>malloc</code> 返回 <code>void*</code>，需要显式转换为所需类型的指针。</li><li><strong>初始化</strong>：<code>malloc</code> 分配的内存未初始化，内容不确定。</li><li><strong>释放对应性</strong>：由 <code>malloc</code> 分配的内存必须使用 <code>free</code> 释放，避免使用 <code>delete</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// 包含 malloc 和 free</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 分配一个整数的内存</span><br>    <span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (p == nullptr) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    *p = <span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(p);<br><br><br>    <span class="hljs-comment">// 分配一个数组的内存  [ 记录的大小（20） | 你可以用的20字节 ]</span><br>    p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="new-delete"><a href="#new-delete" class="headerlink" title="new&#x2F;delete"></a>new&#x2F;delete</h5><ul><li><strong>类型安全</strong>：<code>new</code> 返回正确类型的指针，免去了强制类型转换。</li><li><strong>构造&#x2F;析构</strong>：<code>new</code> 和 <code>delete</code> 自动调用构造函数和析构函数。</li><li><strong>异常处理</strong>：在分配失败时，<code>new</code> 默认抛出 <code>std::bad_alloc</code> 异常，而 <code>malloc</code> 返回 <code>nullptr</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Type* ptr = new Type(parameters);<br>Type* <span class="hljs-built_in">array</span> = new Type[size];<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br>public:<br>    MyClass(<span class="hljs-type">int</span> val) : value(val) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~MyClass() &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Destructor called for value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    MyClass* obj = new MyClass(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    delete obj; <span class="hljs-comment">// 调用析构函数并释放内存</span><br><br><br>    <span class="hljs-type">int</span>* arr = new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 分配5个整数  对类会调用默认构造函数</span><br>    delete[] arr; <span class="hljs-comment">// 释放数组内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>可能的内存布局:<span class="hljs-type">size_t</span>用于delete[]<br>+----------------+------------------------------------------------------------+<br>| 长度信息(<span class="hljs-type">size_t</span>) | 对象<span class="hljs-number">1</span> | 对象<span class="hljs-number">2</span> | 对象<span class="hljs-number">3</span> | ... | 对象n |<br>+----------------+------------------------------------------------------------+<br>^                 ^<br>|                 |<br>内部指针           返回给用户的指针<br></code></pre></td></tr></table></figure><p>可以通过 <code>nothrow</code> 参数防止 <code>new</code> 抛出异常，改为返回 <code>nullptr</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = new(<span class="hljs-built_in">std</span>::nothrow) <span class="hljs-type">int</span>;<br><span class="hljs-keyword">if</span> (p == nullptr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;malloc failed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>malloc&#x2F;free</th><th>new&#x2F;delete</th></tr></thead><tbody><tr><td>类型安全</td><td>需要显式类型转换</td><td>自动类型转换，无需显式转换</td></tr><tr><td>构造&#x2F;析构函数</td><td><strong>不调用</strong>对象的构造&#x2F;析构函数</td><td>调用对象的构造&#x2F;析构函数</td></tr><tr><td>返回值</td><td><code>void*</code>，需要转换为目标类型</td><td>返回目标类型指针，类型安全</td></tr><tr><td>错误处理</td><td>分配失败返回 <code>nullptr</code></td><td>分配失败抛出 <code>std::bad_alloc</code> 异常</td></tr><tr><td>多态行为</td><td>无</td><td>支持多态，通过虚函数正确调用析构函数</td></tr><tr><td>内存分配与释放对应性</td><td>必须使用 <code>free</code> 释放由 <code>malloc</code> 分配的内存</td><td>必须使用 <code>delete</code> 释放由 <code>new</code> 分配的内存</td></tr></tbody></table><p>重新分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 重新分配为 5 个整数</span><br><span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(arr, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (temp == nullptr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Realloc failed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">free</span>(arr); <span class="hljs-comment">// 释放原内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>arr = temp;<br></code></pre></td></tr></table></figure><h5 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h5><ul><li><code>operator new[]</code> 是一个<strong>内存分配函数</strong>，用于为<strong>动态数组</strong>分配内存。类似于malloc。需要结合placement new使用</li><li>::表示这是调用<strong>全局作用域中的版本</strong>，避免调用类中重载的 <code>operator new[]</code>。</li><li><code>::operator new[]</code> 是一种<strong>低层级、无构造行为的内存分配方式</strong>，适用于对内存管理和性能有<strong>精细要求的场景</strong>，比如容器实现、内存池、自定义 allocator 等，实现延时构造以及适配无默认构造函数。</li><li>new T 底层会调用operator new + 执行构造函数，delete T底层析构+::operator delete</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* mem = ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">sizeof</span>(MyClass) * <span class="hljs-number">10</span>);  <span class="hljs-comment">// 只分配内存</span><br>MyClass* p = <span class="hljs-built_in">static_cast</span>&lt;MyClass*&gt;(mem);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">new</span> (p + i) <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// placement new 构造对象</span><br>&#125;<br><br><span class="hljs-comment">// later: 手动析构并释放</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    (p + i)-&gt;~<span class="hljs-built_in">MyClass</span>();<br>&#125;<br>::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](mem);<br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>分配内存</th><th>调用构造</th><th>调用析构</th><th>释放内存</th></tr></thead><tbody><tr><td><code>new T</code></td><td>✅</td><td>✅</td><td>（配合 <code>delete</code>）</td><td>（配合 <code>delete</code>）</td></tr><tr><td>delete</td><td></td><td></td><td>✅</td><td>✅</td></tr><tr><td><code>::operator new</code></td><td>✅</td><td></td><td></td><td>（配合 <code>delete</code>）</td></tr><tr><td><code>new (ptr) T</code><br /> (placement new)</td><td></td><td>✅</td><td></td><td></td></tr><tr><td><code>obj-&gt;~T()</code></td><td></td><td></td><td>✅</td><td></td></tr><tr><td><code>::operator delete</code></td><td></td><td></td><td></td><td>✅</td></tr></tbody></table><h5 id="动态数组-1"><a href="#动态数组-1" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> &#123;</span><br>public:<br>    DynamicArray()<br>        : capacity(<span class="hljs-number">2</span>), size(<span class="hljs-number">0</span>), data((<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (data == nullptr) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>    &#125;<br><br>    ~DynamicArray() &#123;<br>        <span class="hljs-built_in">free</span>(data);<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            resize(capacity * <span class="hljs-number">2</span>);<br>        &#125;<br>        data[size++] = value;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            throw <span class="hljs-built_in">std</span>::out_of_range(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> size; &#125;<br><br>private:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> new_capacity)</span> &#123;<br>        <span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(data, new_capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (temp == nullptr) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>        data = temp;<br>        capacity = new_capacity;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> capacity;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-type">int</span>* data;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    try &#123;<br>        DynamicArray arr;<br>        arr.add(<span class="hljs-number">10</span>);<br>        arr.add(<span class="hljs-number">20</span>);<br>        arr.add(<span class="hljs-number">30</span>); <span class="hljs-comment">// 触发扩展</span><br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Dynamic Array Contents:&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.getSize(); ++i) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; arr.get(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    catch (<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::bad_alloc&amp; e) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Memory allocation error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    catch (<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::out_of_range&amp; e) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Array access error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h5><p>提前new了空间，这个空间被当作student还是别的类使用都不关pool，pool只负责提供相应大小的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPool</span> &#123;</span><br>public:<br>    MemoryPool(<span class="hljs-type">size_t</span> objectSize, <span class="hljs-type">size_t</span> poolSize)<br>        : objSize(objectSize), totalSize(poolSize), pool((<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(objectSize * poolSize)) &#123;<br>        <span class="hljs-keyword">if</span> (pool == nullptr) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>        <span class="hljs-comment">// 初始化 free list</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; ++i) &#123;<br>            freeList.push(pool + i * objectSize);<br>        &#125;<br>    &#125;<br><br>    ~MemoryPool() &#123;<br>        <span class="hljs-built_in">free</span>(pool);<br>    &#125;<br><br>    <span class="hljs-type">void</span>* <span class="hljs-title function_">allocate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (freeList.empty()) &#123;<br>            throw <span class="hljs-built_in">std</span>::bad_alloc();<br>        &#125;<br>        <span class="hljs-type">void</span>* ptr = freeList.top();<br>        freeList.pop();<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>        freeList.push((<span class="hljs-type">char</span>*)ptr);<br>    &#125;<br><br>private:<br>    <span class="hljs-type">size_t</span> objSize;<br>    <span class="hljs-type">size_t</span> totalSize;<br>    <span class="hljs-type">char</span>* pool;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">void</span>*&gt; freeList;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br>public:<br>    MyClass(<span class="hljs-type">int</span> val) : value(val) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~MyClass() &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    try &#123;<br>        <span class="hljs-comment">// 创建一个能容纳 3 个 MyClass 对象的内存池</span><br>        MemoryPool <span class="hljs-title function_">pool</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(MyClass), <span class="hljs-number">3</span>)</span>;<br><br>        <span class="hljs-comment">// 分配对象内存</span><br>        <span class="hljs-type">void</span>* mem1 = pool.allocate();<br>        <span class="hljs-type">void</span>* mem2 = pool.allocate();<br><br>        <span class="hljs-comment">// 使用“定位 new”构造对象</span><br>        MyClass* obj1 = new(mem1) MyClass(<span class="hljs-number">100</span>);<br>        MyClass* obj2 = new(mem2) MyClass(<span class="hljs-number">200</span>);<br><br>        <span class="hljs-comment">// 使用对象</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;obj1 value: &quot;</span> &lt;&lt; obj1-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;obj2 value: &quot;</span> &lt;&lt; obj2-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>        <span class="hljs-comment">// 显式调用析构函数</span><br>        obj1-&gt;~MyClass();<br>        obj2-&gt;~MyClass();<br><br>        <span class="hljs-comment">// 释放内存</span><br>        pool.deallocate(mem1);<br>        pool.deallocate(mem2);<br><br>    &#125;<br>    catch (<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::bad_alloc&amp; e) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Memory pool allocation error: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><h5 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h5><p><strong>栈展开</strong>：当异常被抛出时，程序会沿着函数调用栈回溯，查找能够处理该异常的catch块。在这个过程中，所有途经函数中已构造的局部对象都会被正确析构，从而释放资源和执行清理操作。<strong>但new的对象，delete并不会执行</strong>。</p><ul><li>在C++中，函数内部创建的局部对象的生命周期绑定到其作用域（即花括号<code>&#123;&#125;</code>限定的代码块）</li><li>当离开作用域时，局部对象会自动析构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">()</span> &#123;<br>    Resource <span class="hljs-title function_">r3</span><span class="hljs-params">(<span class="hljs-string">&quot;in function3&quot;</span>)</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Function 3 begins throwing exception&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    throw <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Exception from function3&quot;</span>);<br>    <span class="hljs-comment">// This line won&#x27;t execute， but ～Resource()  will execute</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Function 3 ends&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的智能指针的原理其实还是依靠<strong>指针对象栈展开时，自动调用析构函数</strong>实现资源的释放</p><p>RAII通过将资源管理与对象生命周期绑定，提供了一种高效、安全的资源管理方式，能够在大多数情况下替代<code>try-catch-finally</code>结构</p><h5 id="new问题"><a href="#new问题" class="headerlink" title="new问题"></a>new问题</h5><ul><li><p>忘记释放内存导致的内存泄漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">functionWithLeak</span><span class="hljs-params">()</span> &#123;<br>    MyClass* ptr = new MyClass(); <span class="hljs-comment">// 分配内存</span><br><br>    <span class="hljs-comment">// 某些操作...</span><br><br>    <span class="hljs-keyword">if</span> (someCondition) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 在这里返回，忘记释放内存</span><br>    &#125;<br><br>    <span class="hljs-comment">// 更多操作...</span><br><br>    delete ptr; <span class="hljs-comment">// 如果提前返回，永远不会执行到这一行</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">functionNoLeak</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;(); <span class="hljs-comment">// 分配内存  提高效率和异常安全性</span><br><br>    <span class="hljs-comment">// 某些操作...</span><br><br>    <span class="hljs-keyword">if</span> (someCondition) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 即使在这里返回，智能指针也会自动释放内存</span><br>    &#125;<br><br>    <span class="hljs-comment">// 更多操作...</span><br><br>    <span class="hljs-comment">// 不需要手动delete，智能指针离开作用域时自动释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重复释放内存导致的未定义行为， 或<strong>悬挂指针</strong>指向已经释放的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">processData</span><span class="hljs-params">(MyClass* ptr, <span class="hljs-type">bool</span> takeOwnership)</span> &#123;<br>    <span class="hljs-comment">// 使用ptr...</span><br><br>    <span class="hljs-keyword">if</span> (takeOwnership) &#123;<br>        delete ptr; <span class="hljs-comment">// 只有在需要负责释放时才delete</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">caller</span><span class="hljs-params">()</span> &#123;<br>    MyClass* ptr = new MyClass();<br>    processData(ptr, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 调用者保留所有权</span><br><br>    <span class="hljs-comment">// 其他操作...</span><br><br>    delete ptr; <span class="hljs-comment">// 调用者必须记得删除</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式容易导致混淆：谁应该删除指针？可能导致重复释放（double delete）或者忘记释放。</p><p>智能指针通过明确的所有权语义解决了这个问题：</p><ul><li><code>unique_ptr</code>：表示独占所有权，清楚地表明谁负责资源</li><li><code>shared_ptr</code>：表示共享所有权，当所有共享者都不再需要该资源时自动释放</li><li><code>weak_ptr</code>：表示无所有权的观察者，不影响资源的生命周期</li></ul></li><li><p>异常发生时确保资源正确释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">functionWithLeakOnException</span><span class="hljs-params">()</span> &#123;<br>    MyClass* ptr = new MyClass();<br><br>    <span class="hljs-comment">// 某些可能抛出异常的操作...</span><br>    riskyOperation(); <span class="hljs-comment">// 如果这里抛出异常，后面的delete不会执行</span><br><br>    delete ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">functionSafeWithException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;();<br><br>    <span class="hljs-comment">// 某些可能抛出异常的操作...</span><br>    riskyOperation(); <span class="hljs-comment">// 即使抛出异常，智能指针的析构函数仍会被调用</span><br><br>    <span class="hljs-comment">// 无需手动delete</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>任何时候只有一个对象含有所有权，一次没有拷贝只有移动</p><p>管理mutex、thread、singleton、boost::asiio iocontext</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个 unique_ptr</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Test&gt; <span class="hljs-title function_">ptr1</span><span class="hljs-params">(new Test(<span class="hljs-number">100</span>))</span>;<br>    ptr1-&gt;show();<br><br>    <span class="hljs-comment">// 使用 make_unique（C++14 引入）</span><br>    <span class="hljs-keyword">auto</span> ptr2 = <span class="hljs-built_in">std</span>::make_unique&lt;Test&gt;(<span class="hljs-number">200</span>);<br>    ptr2-&gt;show();<br><br>    <span class="hljs-comment">// 移动 unique_ptr</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Test&gt; ptr3 = <span class="hljs-built_in">std</span>::move(ptr1);<br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ptr1 is now nullptr after move.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ptr3-&gt;show();<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>template&lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUniquePtr</span> &#123;</span><br>private:<br>    T* ptr;<br><br>public:<br>    <span class="hljs-comment">// 构造函数</span><br>    explicit <span class="hljs-title function_">MyUniquePtr</span><span class="hljs-params">(T* p = nullptr)</span> : <span class="hljs-title function_">ptr</span><span class="hljs-params">(p)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MyUniquePtr() &#123;<br>        <span class="hljs-keyword">if</span> (ptr) &#123;<br>            delete ptr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝</span><br>    MyUniquePtr(<span class="hljs-type">const</span> MyUniquePtr&amp;) = delete;<br>    MyUniquePtr&amp; operator=(<span class="hljs-type">const</span> MyUniquePtr&amp;) = delete;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    MyUniquePtr(MyUniquePtr&amp;&amp; other) noexcept : ptr(other.ptr) &#123;<br>        other.ptr = nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MyUniquePtr&amp; operator=(MyUniquePtr&amp;&amp; other) noexcept &#123;<br>        <span class="hljs-keyword">if</span> (this != &amp;other) &#123;<br>            delete ptr;<br>            ptr = other.ptr;<br>            other.ptr = nullptr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 访问操作</span><br>    T&amp; operator*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125;<br>    T* operator-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T* <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br><br>    <span class="hljs-comment">// 放弃所有权</span><br>    T* <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        T* temp = ptr;<br>        ptr = nullptr;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br>    <span class="hljs-comment">// 重置指针</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(T* p = nullptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ptr != p) &#123;<br>            delete ptr;<br>            ptr = p;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    explicit operator <span class="hljs-title function_">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr != nullptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Student&gt; <span class="hljs-title function_">stdPtr</span><span class="hljs-params">(new Student())</span>;<br><span class="hljs-keyword">auto</span> stdPtr2 = <span class="hljs-built_in">std</span>::make_shared&lt;Student&gt;();<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>template&lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySharedPtr</span> &#123;</span><br>private:<br>    T* ptr;<br>    <span class="hljs-type">size_t</span>* ref_count;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">decrease_ref</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (ptr &amp;&amp; ref_count) &#123;<br>            (*ref_count)--;<br>            <span class="hljs-keyword">if</span> (*ref_count == <span class="hljs-number">0</span>) &#123;<br>                delete ptr;<br>                delete ref_count;<br>                ptr = nullptr;<br>                ref_count = nullptr;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>public:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    MySharedPtr() : ptr(nullptr), ref_count(nullptr) &#123;&#125;<br><br>    <span class="hljs-comment">// 接收原始指针的构造函数</span><br>    explicit <span class="hljs-title function_">MySharedPtr</span><span class="hljs-params">(T* p)</span> : <span class="hljs-title function_">ptr</span><span class="hljs-params">(p)</span>, <span class="hljs-title function_">ref_count</span><span class="hljs-params">(nullptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            ref_count = new <span class="hljs-type">size_t</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    MySharedPtr(<span class="hljs-type">const</span> MySharedPtr&amp; other) : ptr(other.ptr), ref_count(other.ref_count) &#123;<br>        <span class="hljs-keyword">if</span> (ref_count) &#123;<br>            (*ref_count)++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值运算符</span><br>    MySharedPtr&amp; operator=(<span class="hljs-type">const</span> MySharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (this != &amp;other) &#123;<br>            decrease_ref();<br><br>            ptr = other.ptr;<br>            ref_count = other.ref_count;<br><br>            <span class="hljs-keyword">if</span> (ref_count) &#123;<br>                (*ref_count)++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    MySharedPtr(MySharedPtr&amp;&amp; other) noexcept : ptr(other.ptr), ref_count(other.ref_count) &#123;<br>        other.ptr = nullptr;<br>        other.ref_count = nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MySharedPtr&amp; operator=(MySharedPtr&amp;&amp; other) noexcept &#123;<br>        <span class="hljs-keyword">if</span> (this != &amp;other) &#123;<br>            decrease_ref();<br><br>            ptr = other.ptr;<br>            ref_count = other.ref_count;<br><br>            other.ptr = nullptr;<br>            other.ref_count = nullptr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MySharedPtr() &#123;<br>        decrease_ref();<br>    &#125;<br><br>    <span class="hljs-comment">// 访问操作</span><br>    T&amp; operator*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125;<br>    T* operator-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T* <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br><br>    <span class="hljs-comment">// 获取引用计数</span><br>    <span class="hljs-type">size_t</span> <span class="hljs-title function_">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>        <span class="hljs-keyword">return</span> (ref_count ? *ref_count : <span class="hljs-number">0</span>); <br>    &#125;<br><br>    <span class="hljs-comment">// 重置指针</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(T* p = nullptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ptr != p) &#123;<br>            decrease_ref();<br><br>            ptr = p;<br>            <span class="hljs-keyword">if</span> (p) &#123;<br>                ref_count = new <span class="hljs-type">size_t</span>(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ref_count = nullptr;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    explicit operator <span class="hljs-title function_">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr != nullptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// MyUniquePtr 示例</span><br>    &#123;<br>        <span class="hljs-function">MyUniquePtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;up1: &quot;</span> &lt;&lt; *up1 &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 移动所有权</span><br>        MyUniquePtr&lt;<span class="hljs-type">int</span>&gt; up2 = std::<span class="hljs-built_in">move</span>(up1);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;up2: &quot;</span> &lt;&lt; *up2 &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// up1 现在不拥有任何资源</span><br>        <span class="hljs-keyword">if</span> (!up1) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;up1 is now empty&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125; <span class="hljs-comment">// up2 自动释放资源</span><br><br>    <span class="hljs-comment">// MySharedPtr 示例</span><br>    &#123;<br>        <span class="hljs-function">MySharedPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">100</span>))</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sp1 count: &quot;</span> &lt;&lt; sp<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>        &#123;<br>            MySharedPtr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;After copy, sp1 count: &quot;</span> &lt;&lt; sp<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;<br>        &#125; <span class="hljs-comment">// sp2 析构，计数减一</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;After inner scope, sp1 count: &quot;</span> &lt;&lt; sp<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-comment">// sp1 析构，资源被释放</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><ul><li><strong>非拥有所有权</strong>：不增加引用计数。</li><li><strong>可从 <code>shared_ptr</code> 生成</strong>：通过 <code>std::weak_ptr</code> 可以访问 <code>shared_ptr</code> 管理的对象。</li><li><strong>避免循环引用</strong>：适用于双向关联或观察者模式。</li></ul><p>在存在双向关联（如父子关系）时，使用多个 <code>shared_ptr</code> 可能导致循环引用，导致内存泄漏。此时，可以使用 <code>weak_ptr</code> 来打破循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;B&gt; b_ptr;<br><br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A 构造函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A 析构函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::weak_ptr&lt;A&gt; a_ptr; <span class="hljs-comment">// 改用 weak_ptr，不增加引用计数</span><br><br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B 构造函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B 析构函数调用&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>        std::shared_ptr&lt;B&gt; b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br><br>        a-&gt;b_ptr = b;<br>        b-&gt;a_ptr = a; <span class="hljs-comment">// weak_ptr 不会增加引用计数</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a 的引用计数: &quot;</span> &lt;&lt; a.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;b 的引用计数: &quot;</span> &lt;&lt; b.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-comment">// 离开作用域</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main 函数结束&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 现在会看到析构函数被调用</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h5><p>有时，默认的 <code>delete</code> 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileDeleter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE* fp)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (fp) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Closing file.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-built_in">fclose</span>(fp);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;FILE&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), FileDeleter())</span></span>;<br>        <span class="hljs-keyword">if</span> (filePtr) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-comment">// 使用 filePtr 进行文件操作</span><br>            <span class="hljs-built_in">fprintf</span>(filePtr.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-comment">// 自动关闭文件</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting main...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><table><thead><tr><th>分类</th><th>容器类型</th></tr></thead><tbody><tr><td><strong>序列容器</strong></td><td><code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></td></tr><tr><td><strong>关联容器</strong></td><td><code>set</code>&#x2F;<code>multiset</code>、<code>map</code>&#x2F;<code>multimap </code> 红黑树</td></tr><tr><td><strong>无序关联容器</strong></td><td><code>unordered_set</code>&#x2F;<code>unordered_multiset</code>、<code>unordered_map</code>&#x2F;<code>unordered_multimap</code>  哈希表</td></tr><tr><td><strong>容器适配器</strong></td><td><code>stack</code>、<code>queue</code>、<code>priority_queue</code></td></tr></tbody></table><h5 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h5><p>内部使用动态数组，可随机访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个空的整数vector</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; numbers;<br><br><span class="hljs-comment">// 向vector末尾添加元素</span><br>numbers.push_back(<span class="hljs-number">10</span>);<br>numbers[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = numbers.begin(); it != numbers.end(); ++it) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>numbers.pop_back();<br></code></pre></td></tr></table></figure><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>多个不连续的固定大小缓冲区，可随机访问，并且中间插入相较于vector效率更好</p><ul><li>频繁头尾插入</li><li>随机访问</li><li>较少的中间插入操作</li></ul><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><ul><li>固定大小数组的封装，大小在编译时确定</li><li>性能与原生数组相当</li><li>提供边界检查和额外安全特性</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 随机访问</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第三个元素: &quot;</span> &lt;&lt; arr[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 边界检查访问</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第四个元素: &quot;</span> &lt;&lt; arr.at(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;所有元素: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : arr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>内部使用双向链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">// 在开头和结尾添加元素</span><br>lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">// 在中间插入元素</span><br><span class="hljs-keyword">auto</span> it = lst.<span class="hljs-built_in">begin</span>();<br>std::<span class="hljs-built_in">advance</span>(it, <span class="hljs-number">3</span>); <span class="hljs-comment">// 移动到第四个位置</span><br>lst.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">99</span>);<br><br><span class="hljs-comment">// 遍历列表</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;所有元素: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : lst) &#123;<br>    std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-built_in">front</span>(), <span class="hljs-built_in">back</span>()<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h5 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h5><ul><li><strong>查找操作</strong><ul><li><code>find()</code>：查找指定值的迭代器   <code>x.find(name) != x.end()</code></li><li><code>count()</code>：统计指定值的元素个数</li><li><code>empty()、size()</code>: 容器元素数量</li><li><code>equal_range()</code>：返回等于指定值的元素范围</li></ul></li><li><strong>修改操作</strong><ul><li><code>insert()</code>：插入元素</li><li><code>erase()</code>：删除元素</li><li><code>clear()</code>：清空</li></ul></li><li><strong>有序容器</strong><ul><li><code>lower_bound()</code>：返回不小于k的第一个元素</li><li><code>upper_bound()</code>：返回大于k的第一个元素</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 5只会被存储一次</span><br>s.insert(<span class="hljs-number">6</span>);<br><br><span class="hljs-keyword">if</span> (s.find(<span class="hljs-number">3</span>) != s.end())<br></code></pre></td></tr></table></figure><h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p>stack</p><ul><li><code>push()</code>：压栈</li><li><code>pop()</code>：出栈</li><li><code>top()</code>：访问栈顶元素</li><li><code>emplace()</code>：原地构造并压栈</li></ul><p>queue</p><ul><li><code>push()</code>：入队</li><li><code>pop()</code>：出队</li><li><code>front()</code>：访问队首元素</li><li><code>back()</code>：访问队尾元素</li><li><code>emplace()</code>：原地构造并入队</li></ul><p>priority_queue</p><ul><li><code>push()</code>：入队</li><li><code>pop()</code>：出队（移除最高优先级元素）</li><li><code>top()</code>：访问最高优先级元素</li><li><code>emplace()</code>：原地构造并入队</li></ul><h5 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h5><p>为容器提供内存分配和释放的机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleAllocator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <br>    <span class="hljs-built_in">SimpleAllocator</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-built_in">SimpleAllocator</span>(<span class="hljs-type">const</span> SimpleAllocator&lt;U&gt;&amp;) &#123;&#125;<br>    <br>    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">max_size</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(std::<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(T)))) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Allocated &quot;</span> &lt;&lt; <span class="hljs-function">n * <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;&lt; &quot; bytes\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* p, std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        std::<span class="hljs-built_in">free</span>(p);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Deallocated &quot;</span> &lt;&lt; <span class="hljs-function">n * <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;&lt; &quot; bytes\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">max_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">size_t</span>(<span class="hljs-number">-1</span>) / <span class="hljs-built_in">sizeof</span>(T);<br>    &#125;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* p, Args&amp;&amp;... args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span>(p) <span class="hljs-built_in">U</span>(std::forward&lt;Args&gt;(args)...);<br>    &#125;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* p)</span> </span>&#123;<br>        p-&gt;~<span class="hljs-built_in">U</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 比较运算符，使分配器可以比较</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> SimpleAllocator&lt;T&gt;&amp;, <span class="hljs-type">const</span> SimpleAllocator&lt;U&gt;&amp;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> SimpleAllocator&lt;T&gt;&amp;, <span class="hljs-type">const</span> SimpleAllocator&lt;U&gt;&amp;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义分配器的vector</span><br>    std::vector&lt;<span class="hljs-type">int</span>, SimpleAllocator&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        vec.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="手写list"><a href="#手写list" class="headerlink" title="手写list"></a>手写list</h5><p>需要实现Iterator类，并且list中的一些插入删除操作都基于iterator实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span> &#123;</span><br>private:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        T data;<br>        Node* next;<br>        Node* prev;<br><br>        Node(<span class="hljs-type">const</span> T&amp; value) : data(value), next(nullptr), prev(nullptr) &#123;&#125;<br>    &#125;;<br><br>    Node* head;<br>    Node* tail;<br>    <span class="hljs-type">size_t</span> _size;<br><br>public:<br>    <span class="hljs-comment">// 迭代器实现</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iterator</span> &#123;</span><br>    public:<br>        using iterator_category = <span class="hljs-built_in">std</span>::bidirectional_iterator_tag;<br>        using value_type = T;<br>        using difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-type">ptrdiff_t</span>;<br>        using pointer = T*;<br>        using reference = T&amp;;<br><br>    private:<br>        Node* current;<br><br>    public:<br>        <span class="hljs-comment">// 构造函数</span><br>        iterator(Node* ptr = nullptr) : current(ptr) &#123;&#125;<br><br>        <span class="hljs-comment">// 解引用操作符</span><br>        reference operator*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> current-&gt;data; &#125;<br>        pointer operator-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> &amp;(current-&gt;data); &#125;<br><br>        <span class="hljs-comment">// 递增操作符</span><br>        iterator&amp; operator++() &#123;<br>            current = current-&gt;next;<br>            <span class="hljs-keyword">return</span> *this;<br>        &#125;<br><br>        iterator operator++(<span class="hljs-type">int</span>) &#123;<br>            iterator temp = *this;<br>            current = current-&gt;next;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 递减操作符</span><br>        iterator&amp; operator--() &#123;<br>            current = current-&gt;prev;<br>            <span class="hljs-keyword">return</span> *this;<br>        &#125;<br><br>        iterator operator--(<span class="hljs-type">int</span>) &#123;<br>            iterator temp = *this;<br>            current = current-&gt;prev;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 比较操作符</span><br>        <span class="hljs-type">bool</span> operator==(<span class="hljs-type">const</span> iterator&amp; other) <span class="hljs-type">const</span> &#123; <br>            <span class="hljs-keyword">return</span> current == other.current; <br>        &#125;<br><br>        <span class="hljs-type">bool</span> operator!=(<span class="hljs-type">const</span> iterator&amp; other) <span class="hljs-type">const</span> &#123; <br>            <span class="hljs-keyword">return</span> current != other.current; <br>        &#125;<br><br>        <span class="hljs-comment">// 友元声明，让MyList可以访问迭代器的私有成员</span><br>        friend <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>;</span><br>    &#125;;<br><br>    <span class="hljs-comment">// const迭代器实现（类似上面的iterator，但返回const引用和指针）</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">const_iterator</span> &#123;</span><br>        <span class="hljs-comment">// 类似实现但返回const T&amp;和const T*</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 构造函数和析构函数</span><br>    MyList() : head(nullptr), tail(nullptr), _size(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建哨兵节点（sentinel）简化迭代器实现</span><br>        head = new Node(T());<br>        tail = new Node(T());<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br><br>    ~MyList() &#123;<br>        clear();<br>        delete head;<br>        delete tail;<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代器方法</span><br>    iterator <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> iterator(head-&gt;next); &#125;<br>    iterator <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> iterator(tail); &#125;<br>    const_iterator <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> const_iterator(head-&gt;next); &#125;<br>    const_iterator <span class="hljs-title function_">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> const_iterator(tail); &#125;<br><br>    <span class="hljs-comment">// 其他方法（push_back, push_front, clear等）</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 插入元素到迭代器位置之前</span><br>  iterator <span class="hljs-title function_">insert</span><span class="hljs-params">(iterator pos, <span class="hljs-type">const</span> T&amp; value)</span> &#123;<br>      Node&lt;T&gt;* current = pos.node_ptr;<br>      Node&lt;T&gt;* new_node = new Node&lt;T&gt;(value);<br><br>      Node&lt;T&gt;* prev_node = current-&gt;prev;<br><br>      new_node-&gt;next = current;<br>      new_node-&gt;prev = prev_node;<br><br>      prev_node-&gt;next = new_node;<br>      current-&gt;prev = new_node;<br><br>      <span class="hljs-keyword">return</span> iterator(new_node);<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="手写deque"><a href="#手写deque" class="headerlink" title="手写deque"></a>手写deque</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-04-15-144449407.png" alt="image-20250415144404330"></p><p>这里简单实现，只实现一个头尾插入删除的vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deque</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* buffer;               <span class="hljs-comment">// 内部缓冲区</span><br>    <span class="hljs-type">size_t</span> capacity;         <span class="hljs-comment">// 缓冲区容量</span><br>    <span class="hljs-type">size_t</span> front_idx;        <span class="hljs-comment">// 头部索引</span><br>    <span class="hljs-type">size_t</span> back_idx;         <span class="hljs-comment">// 尾部索引</span><br>    <span class="hljs-type">size_t</span> count;            <span class="hljs-comment">// 当前元素数量</span><br><br>  <span class="hljs-built_in">resize</span>();<br>  <span class="hljs-built_in">push_front</span>();<br>  <span class="hljs-built_in">push_back</span>();<br>&#125;<br><br><span class="hljs-comment">// 代码</span><br></code></pre></td></tr></table></figure><h5 id="BST实现map"><a href="#BST实现map" class="headerlink" title="BST实现map"></a>BST实现map</h5><p><a href="https://gitbookcpp.llfc.club/sections/cpp/base/cppbase28.html">https://gitbookcpp.llfc.club/sections/cpp/base/cppbase28.html</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// For std::pair</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    std::pair&lt;Key, T&gt; data;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode* parent;<br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value, TreeNode* parentNode = <span class="hljs-literal">nullptr</span>)<br>        : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_pair</span>(key, value)), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">parent</span>(parentNode) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyMap</span>() : <span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    ~<span class="hljs-built_in">MyMap</span>() &#123; <span class="hljs-built_in">clear</span>(root); &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝构造和赋值</span><br>    <span class="hljs-built_in">MyMap</span>(<span class="hljs-type">const</span> MyMap&amp;) = <span class="hljs-keyword">delete</span>;<br>    MyMap&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyMap&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 插入或更新键值对</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>&lt;Key, T&gt;(key, value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        TreeNode&lt;Key, T&gt;* current = root;<br>        TreeNode&lt;Key, T&gt;* parent = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            parent = current;<br>            <span class="hljs-keyword">if</span> (key &lt; current-&gt;data.first) &#123;<br>                current = current-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; current-&gt;data.first) &#123;<br>                current = current-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 键已存在，更新值</span><br>                current-&gt;data.second = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (key &lt; parent-&gt;data.first) &#123;<br>            parent-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>&lt;Key, T&gt;(key, value, parent);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>&lt;Key, T&gt;(key, value, parent);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找元素，返回指向节点的指针</span><br>    <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span> </span>&#123;<br>        TreeNode&lt;Key, T&gt;* current = root;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (key &lt; current-&gt;data.first) &#123;<br>                current = current-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; current-&gt;data.first) &#123;<br>                current = current-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> </span>&#123;<br>        TreeNode&lt;Key, T&gt;* node = <span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到要删除的节点</span><br><br>        <span class="hljs-comment">// 节点有两个子节点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 找到中序后继</span><br>            TreeNode&lt;Key, T&gt;* successor = <span class="hljs-built_in">minimum</span>(node-&gt;right);<br>            node-&gt;data = successor-&gt;data; <span class="hljs-comment">// 替换数据</span><br>            node = successor; <span class="hljs-comment">// 将要删除的节点指向后继节点</span><br>        &#125;<br><br>        <span class="hljs-comment">// 节点有一个或没有子节点</span><br>        TreeNode&lt;Key, T&gt;* child = (node-&gt;left) ? node-&gt;left : node-&gt;right;<br>        <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">nullptr</span>) &#123;<br>            child-&gt;parent = node-&gt;parent;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node-&gt;parent == <span class="hljs-literal">nullptr</span>) &#123;<br>            root = child;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>            node-&gt;parent-&gt;left = child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node-&gt;parent-&gt;right = child;<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 清空所有节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">clear</span>(root);<br>        root = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取迭代器</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Iterator</span>(TreeNode&lt;Key, T&gt;* node = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">current</span>(node) &#123;&#125;<br><br>        std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current-&gt;data;<br>        &#125;<br><br>        std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;(current-&gt;data);<br>        &#125;<br><br>        <span class="hljs-comment">// 前置递增</span><br>        Iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            current = <span class="hljs-built_in">successor</span>(current);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 后置递增</span><br>        Iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            Iterator temp = *<span class="hljs-keyword">this</span>;<br>            current = <span class="hljs-built_in">successor</span>(current);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current == other.current;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current != other.current;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        TreeNode&lt;Key, T&gt;* current;<br><br>        <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">minimum</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                node = node-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">successor</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">minimum</span>(node-&gt;right);<br>            &#125;<br><br>            TreeNode&lt;Key, T&gt;* p = node-&gt;parent;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; node == p-&gt;right) &#123;<br>                node = p;<br>                p = p-&gt;parent;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-built_in">minimum</span>(root));<br>    &#125;<br><br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    TreeNode&lt;Key, T&gt;* root;<br><br>    <span class="hljs-comment">// 删除树中的所有节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">clear</span>(node-&gt;left);<br>        <span class="hljs-built_in">clear</span>(node-&gt;right);<br>        <span class="hljs-keyword">delete</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到最小的节点</span><br>    <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">minimum</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到最大的节点</span><br>    <span class="hljs-function">TreeNode&lt;Key, T&gt;* <span class="hljs-title">maximum</span><span class="hljs-params">(TreeNode&lt;Key, T&gt;* node)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="AVL实现map"><a href="#AVL实现map" class="headerlink" title="AVL实现map"></a>AVL实现map</h5><p>左右子树高度差不超过1</p><p>右旋：左左情况：y为+2 且 x为+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    y                             x<br>   / \                           / \<br>  x   T3            ==&gt;          z   y<br> / \                               / \<br>z   T2                            T2  T3<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br>AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-built_in">rightRotate</span>(AVLNode&lt;KeyType, ValueType&gt;* y) &#123;<br>    AVLNode&lt;KeyType, ValueType&gt;* x = y-&gt;left;<br>    AVLNode&lt;KeyType, ValueType&gt;* T2 = x-&gt;right;<br><br>    <span class="hljs-comment">// 执行旋转</span><br>    x-&gt;right = y;<br>    y-&gt;left = T2;<br><br>    <span class="hljs-comment">// 更新高度</span><br>    y-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(y-&gt;left), <span class="hljs-built_in">getHeight</span>(y-&gt;right)) + <span class="hljs-number">1</span>;<br>    x-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(x-&gt;left), <span class="hljs-built_in">getHeight</span>(x-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 返回新的根</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>左旋：右右情况：A为-2 且 B为-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    A                           B<br>   / \                         / \<br>  T1  B          ==&gt;          A   C<br>     / \                     / \ <br>    T2  C                   T1 T2 <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br>AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-built_in">leftRotate</span>(AVLNode&lt;KeyType, ValueType&gt;* x) &#123;<br>    AVLNode&lt;KeyType, ValueType&gt;* y = x-&gt;right;<br>    AVLNode&lt;KeyType, ValueType&gt;* T2 = y-&gt;left;<br><br>    <span class="hljs-comment">// 执行旋转</span><br>    y-&gt;left = x;<br>    x-&gt;right = T2;<br><br>    <span class="hljs-comment">// 更新高度</span><br>    x-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(x-&gt;left), <span class="hljs-built_in">getHeight</span>(x-&gt;right)) + <span class="hljs-number">1</span>;<br>    y-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(y-&gt;left), <span class="hljs-built_in">getHeight</span>(y-&gt;right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 返回新的根</span><br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p>左-右(LR)型：A+2 且  B -1；B进行<strong>左旋</strong> 后 A<strong>右旋</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    A                  A                  C<br>   / \                / \                / \<br>  B   T4     =&gt;     C   T4     =&gt;      B   A<br> / \                / \                / \ / \<br>T1  C              B   T3            T1 T2 T3 T4<br>   / \            / \<br>  T2  T3        T1  T2<br></code></pre></td></tr></table></figure><p>右-左(LR)型：A-2 且 B +1 ；B进行<strong>右旋</strong> 后 A<strong>左旋</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  A                  A                  C<br> / <span class="hljs-string">\</span>                / <span class="hljs-string">\</span>                / <span class="hljs-string">\</span><br>T1  B      =&gt;     T1  C      =&gt;      A   B<br>   / <span class="hljs-string">\</span>                / <span class="hljs-string">\</span>            / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br>  C   T4            T2   B         T1 T2 T3 T4<br> / <span class="hljs-string">\</span>                    / <span class="hljs-string">\</span><br>T2  T3                 T3  T4<br></code></pre></td></tr></table></figure><h6 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-function">AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-title">insertNode</span><span class="hljs-params">(AVLNode&lt;KeyType, ValueType&gt;* node, <span class="hljs-type">const</span> KeyType&amp; key, <span class="hljs-type">const</span> ValueType&amp; value)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 执行标准的BST插入</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">AVLNode</span>&lt;KeyType, ValueType&gt;(key, value);<br><br>    <span class="hljs-keyword">if</span> (key &lt; node-&gt;key)<br>        node-&gt;left = <span class="hljs-built_in">insertNode</span>(node-&gt;left, key, value);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; node-&gt;key)<br>        node-&gt;right = <span class="hljs-built_in">insertNode</span>(node-&gt;right, key, value);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果键已经存在，更新其值</span><br>        node-&gt;value = value;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 更新节点高度</span><br>    node-&gt;height = <span class="hljs-number">1</span> + std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(node-&gt;left), <span class="hljs-built_in">getHeight</span>(node-&gt;right));<br><br>    <span class="hljs-comment">// 3. 获取平衡因子</span><br>    <span class="hljs-type">int</span> balance = <span class="hljs-built_in">getBalance</span>(node);<br><br>    <span class="hljs-comment">// 4. 根据平衡因子进行旋转</span><br><br>    <span class="hljs-comment">// 左左情况  这里可以使用getBalance(node-&gt;left) 但更低效</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br><br>    <span class="hljs-comment">// 右右情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br><br>    <span class="hljs-comment">// 左右情况</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;<br>        node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-comment">// 右左情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;<br>        node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType&gt;<br><span class="hljs-function">AVLNode&lt;KeyType, ValueType&gt;* <span class="hljs-title">deleteNode</span><span class="hljs-params">(AVLNode&lt;KeyType, ValueType&gt;* root, <span class="hljs-type">const</span> KeyType&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 执行标准的BST删除</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-keyword">if</span> (key &lt; root-&gt;key)<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key)<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 节点有一个或没有子节点</span><br>        <span class="hljs-keyword">if</span> ((root-&gt;left == <span class="hljs-literal">nullptr</span>) || (root-&gt;right == <span class="hljs-literal">nullptr</span>)) &#123;<br>            AVLNode&lt;KeyType, ValueType&gt;* temp = root-&gt;left ? root-&gt;left : root-&gt;right;<br><br>            <span class="hljs-comment">// 没有子节点</span><br>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">nullptr</span>) &#123;<br>                temp = root;<br>                root = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 一个子节点</span><br>                *root = *temp; <span class="hljs-comment">// 复制内容  可以避免改父的指针</span><br><br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 节点有两个子节点，获取中序后继</span><br>            AVLNode&lt;KeyType, ValueType&gt;* temp = <span class="hljs-built_in">getMinValueNode</span>(root-&gt;right);<br>            <span class="hljs-comment">// 复制中序后继的内容到此节点</span><br>            root-&gt;key = temp-&gt;key;<br>            root-&gt;value = temp-&gt;value;<br>            <span class="hljs-comment">// 删除中序后继</span><br>            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, temp-&gt;key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果树只有一个节点</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 2. 更新节点高度</span><br>    root-&gt;height = <span class="hljs-number">1</span> + std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(root-&gt;left), <span class="hljs-built_in">getHeight</span>(root-&gt;right));<br><br>    <span class="hljs-comment">// 3. 获取平衡因子</span><br>    <span class="hljs-type">int</span> balance = <span class="hljs-built_in">getBalance</span>(root);<br><br>    <span class="hljs-comment">// 4. 根据平衡因子进行旋转</span><br><br>    <span class="hljs-comment">// 左左情况</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;left) &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(root);<br><br>    <span class="hljs-comment">// 左右情况</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;left) &lt; <span class="hljs-number">0</span>) &#123;<br>        root-&gt;left = <span class="hljs-built_in">leftRotate</span>(root-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(root);<br>    &#125;<br><br>    <span class="hljs-comment">// 右右情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;right) &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(root);<br><br>    <span class="hljs-comment">// 右左情况</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; <span class="hljs-built_in">getBalance</span>(root-&gt;right) &gt; <span class="hljs-number">0</span>) &#123;<br>        root-&gt;right = <span class="hljs-built_in">rightRotate</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(root);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="手写unorderedmap"><a href="#手写unorderedmap" class="headerlink" title="手写unorderedmap"></a>手写unorderedmap</h5><p><a href="https://www.bilibili.com/video/BV18bwPe4EfG">https://www.bilibili.com/video/BV18bwPe4EfG</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_map&lt;KeyType, ValueType, Hash = std::hash&lt;KeyType&gt;, KeyEqual = std::equal_to&lt;KeyType&gt;, Allocator = std::allocator&lt;std::pair&lt;<span class="hljs-type">const</span> KeyType, ValueType&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>KeyType</strong>：键的类型，需要支持哈希运算和相等比较。</li><li><strong>ValueType</strong>：值的类型。</li><li><strong>Hash</strong>：哈希函数，默认为 <code>std::hash&lt;KeyType&gt;</code>。</li><li><strong>KeyEqual</strong>：键相等的比较函数，默认为 <code>std::equal_to&lt;KeyType&gt;</code>。使用类的operator&#x3D;&#x3D;</li><li><strong>Allocator</strong>：内存分配器，默认为 <code>std::allocator</code>。</li></ul><p>自定义类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">// 自定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载相等运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> name == other.name &amp;&amp; age == other.age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 自定义哈希函数对象(等价于Java的hashCode)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonHash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 组合哈希值的一种简单方法</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(p.name) ^ std::<span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(p.age);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 自定义相等比较函数对象(等价于Java的equals)，使用operator==实现</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PersonEqual</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p1, <span class="hljs-type">const</span> Person&amp; p2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 直接调用Person类的operator==</span><br>        <span class="hljs-keyword">return</span> p1 == p2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在unordered_map模板参数中指定哈希和相等函数对象</span><br>    std::unordered_map&lt;Person, std::string, PersonHash, PersonEqual&gt; personMap;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)</span></span>;  <span class="hljs-comment">// 与p1相同</span><br><br>    personMap[p1] = <span class="hljs-string">&quot;工程师&quot;</span>;<br>    personMap[p2] = <span class="hljs-string">&quot;设计师&quot;</span>;<br><br>    <span class="hljs-comment">// 由于p3和p1相等，这将打印&quot;工程师&quot;</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p3的职业: &quot;</span> &lt;&lt; personMap[p3] &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// For std::pair</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">// For std::hash</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span> <span class="hljs-comment">// For iterator_traits</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// For exceptions</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// HashNode 结构定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashNode</span> &#123;<br>    std::pair&lt;<span class="hljs-type">const</span> Key, T&gt; data;<br>    HashNode* next;<br><br>    <span class="hljs-built_in">HashNode</span>(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value)<br>        : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_pair</span>(key, value)), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// MyHashMap 类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;<br><span class="hljs-keyword">class</span> MyHashMap &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 迭代器类前向声明</span><br>    <span class="hljs-keyword">class</span> Iterator;<br><br>    <span class="hljs-comment">// 类型定义</span><br>    <span class="hljs-keyword">using</span> key_type = Key;<br>    <span class="hljs-keyword">using</span> mapped_type = T;<br>    <span class="hljs-keyword">using</span> value_type = std::pair&lt;<span class="hljs-type">const</span> Key, T&gt;;<br>    <span class="hljs-keyword">using</span> size_type = <span class="hljs-type">size_t</span>;<br><br>    <span class="hljs-comment">// 构造函数及析构函数</span><br>    <span class="hljs-built_in">MyHashMap</span>(size_type initial_capacity = <span class="hljs-number">16</span>, <span class="hljs-type">double</span> max_load_factor = <span class="hljs-number">0.75</span>);<br>    ~<span class="hljs-built_in">MyHashMap</span>();<br><br>    <span class="hljs-comment">// 禁止拷贝构造和赋值</span><br>    <span class="hljs-built_in">MyHashMap</span>(<span class="hljs-type">const</span> MyHashMap&amp;) = <span class="hljs-keyword">delete</span>;<br>    MyHashMap&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyHashMap&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 基本操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value)</span></span>;<br>    <span class="hljs-function">T* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span></span>;<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 迭代器操作</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 迭代器类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 迭代器别名</span><br>        <span class="hljs-keyword">using</span> iterator_category = std::forward_iterator_tag;<br>        <span class="hljs-keyword">using</span> value_type = std::pair&lt;Key, T&gt;;<br>        <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>        <span class="hljs-keyword">using</span> pointer = value_type*;<br>        <span class="hljs-keyword">using</span> reference = value_type&amp;;<br><br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node);<br><br>        <span class="hljs-comment">// 解引用操作符</span><br>        reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;<br>        pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>;<br><br>        <span class="hljs-comment">// 递增操作符</span><br>        Iterator&amp; <span class="hljs-keyword">operator</span>++();<br>        Iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);<br><br>        <span class="hljs-comment">// 比较操作符</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span>;<br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        MyHashMap* map_;<br>        size_type bucket_index_;<br>        HashNode&lt;Key, T&gt;* current_node_;<br><br>        <span class="hljs-comment">// 移动到下一个有效节点</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">()</span></span>;<br>    &#125;;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; buckets_;<br>    size_type bucket_count_;<br>    size_type element_count_;<br>    <span class="hljs-type">double</span> max_load_factor_;<br>    Hash hash_func_;<br><br>    <span class="hljs-comment">// 辅助函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">MyHashMap</span>(size_type initial_capacity, <span class="hljs-type">double</span> max_load_factor)<br>    : <span class="hljs-built_in">bucket_count_</span>(initial_capacity),<br>      <span class="hljs-built_in">element_count_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">max_load_factor_</span>(max_load_factor),<br>      <span class="hljs-built_in">hash_func_</span>(<span class="hljs-built_in">Hash</span>()) &#123;<br>    buckets_.<span class="hljs-built_in">resize</span>(bucket_count_, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>MyHashMap&lt;Key, T, Hash&gt;::~<span class="hljs-built_in">MyHashMap</span>() &#123;<br>    <span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-comment">// 插入函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> T&amp; value) &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            node-&gt;data.second = value; <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node = node-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 键不存在，插入新节点到链表头部</span><br>    HashNode&lt;Key, T&gt;* new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashNode</span>&lt;Key, T&gt;(key, value);<br>    new_node-&gt;next = buckets_[index];<br>    buckets_[index] = new_node;<br>    ++element_count_;<br><br>    <span class="hljs-comment">// 检查负载因子，可能需要扩容</span><br>    <span class="hljs-type">double</span> load_factor = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(element_count_) / bucket_count_;<br>    <span class="hljs-keyword">if</span> (load_factor &gt; max_load_factor_) &#123;<br>        <span class="hljs-built_in">rehash</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找函数（非常量版本）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>T* MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            <span class="hljs-keyword">return</span> &amp;(node-&gt;data.second);<br>        &#125;<br>        node = node-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 查找函数（常量版本）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">const</span> T* MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> Key&amp; key) <span class="hljs-type">const</span> &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            <span class="hljs-keyword">return</span> &amp;(node-&gt;data.second);<br>        &#125;<br>        node = node-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">erase</span>(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>    size_type hash_value = <span class="hljs-built_in">hash_func_</span>(key);<br>    size_type index = hash_value % bucket_count_;<br><br>    HashNode&lt;Key, T&gt;* node = buckets_[index];<br>    HashNode&lt;Key, T&gt;* prev = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;data.first == key) &#123;<br>            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">nullptr</span>) &#123;<br>                buckets_[index] = node-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev-&gt;next = node-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> node;<br>            --element_count_;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        prev = node;<br>        node = node-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 未找到键</span><br>&#125;<br><br><span class="hljs-comment">// 清空函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">clear</span>() &#123;<br>    <span class="hljs-keyword">for</span> (size_type i = <span class="hljs-number">0</span>; i &lt; bucket_count_; ++i) &#123;<br>        HashNode&lt;Key, T&gt;* node = buckets_[i];<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            HashNode&lt;Key, T&gt;* temp = node;<br>            node = node-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        buckets_[i] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    element_count_ = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 动态扩容函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">rehash</span>() &#123;<br>    size_type new_bucket_count = bucket_count_ * <span class="hljs-number">2</span>;<br>    std::vector&lt;HashNode&lt;Key, T&gt;*&gt; <span class="hljs-built_in">new_buckets</span>(new_bucket_count, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// 重新分配所有元素</span><br>    <span class="hljs-keyword">for</span> (size_type i = <span class="hljs-number">0</span>; i &lt; bucket_count_; ++i) &#123;<br>        HashNode&lt;Key, T&gt;* node = buckets_[i];<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            HashNode&lt;Key, T&gt;* next_node = node-&gt;next;<br>            size_type new_index = <span class="hljs-built_in">hash_func_</span>(node-&gt;data.first) % new_bucket_count;<br><br>            <span class="hljs-comment">// 插入到新桶的头部</span><br>            node-&gt;next = new_buckets[new_index];<br>            new_buckets[new_index] = node;<br><br>            node = next_node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 替换旧桶</span><br>    buckets_ = std::<span class="hljs-built_in">move</span>(new_buckets);<br>    bucket_count_ = new_bucket_count;<br>&#125;<br><br><span class="hljs-comment">// begin() 函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator<br>MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">begin</span>() &#123;<br>    <span class="hljs-keyword">for</span> (size_type i = <span class="hljs-number">0</span>; i &lt; bucket_count_; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (buckets_[i] != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-keyword">this</span>, i, buckets_[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">end</span>();<br>&#125;<br><br><span class="hljs-comment">// end() 函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator<br>MyHashMap&lt;Key, T, Hash&gt;::<span class="hljs-built_in">end</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-keyword">this</span>, bucket_count_, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// Iterator 构造函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-built_in">Iterator</span>(MyHashMap* map, size_type bucket_index, HashNode&lt;Key, T&gt;* node)<br>    : <span class="hljs-built_in">map_</span>(map), <span class="hljs-built_in">bucket_index_</span>(bucket_index), <span class="hljs-built_in">current_node_</span>(node) &#123;&#125;<br><br><span class="hljs-comment">// 解引用操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::reference<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (current_node_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Iterator out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> current_node_-&gt;data;<br>&#125;<br><br><span class="hljs-comment">// 成员访问操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::pointer<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (current_node_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Iterator out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;(current_node_-&gt;data);<br>&#125;<br><br><span class="hljs-comment">// 前置递增操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator&amp;<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>++() &#123;<br>    <span class="hljs-built_in">advance</span>();<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 后置递增操作符</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-keyword">typename</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator<br>MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>    Iterator temp = *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-built_in">advance</span>();<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">// 比较操作符==</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> map_ == other.map_ &amp;&amp;<br>           bucket_index_ == other.bucket_index_ &amp;&amp;<br>           current_node_ == other.current_node_;<br>&#125;<br><br><span class="hljs-comment">// 比较操作符!=</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">bool</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<br>&#125;<br><br><span class="hljs-comment">// advance 函数：移动到下一个有效节点</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hash&gt;<br><span class="hljs-type">void</span> MyHashMap&lt;Key, T, Hash&gt;::Iterator::<span class="hljs-built_in">advance</span>() &#123;<br>   <span class="hljs-keyword">if</span>(current_node_ != <span class="hljs-literal">nullptr</span>)&#123;<br>         current_node_ = current_node_-&gt;next;<br>    &#125;<br>   <span class="hljs-keyword">while</span>(current_node_ == <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(bucket_index_ <span class="hljs-number">+1</span>  &lt; map_-&gt;bucket_count_)&#123;<br>                   ++bucket_index_;<br>                   current_node_ = map_-&gt;buckets_[bucket_index_];<br>          &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket_index_ <span class="hljs-number">+1</span>  == map_-&gt;bucket_count_)&#123;<br>                   ++bucket_index_;<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><p>模版函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">functionName</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><br><span class="hljs-comment">// 多类型模板函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T a, U b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">maxValue</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">maxValue</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>) &lt;&lt; std::endl;         <span class="hljs-comment">// int 类型</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">maxValue</span>(<span class="hljs-number">3.14</span>, <span class="hljs-number">2.72</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// double 类型</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">maxValue</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>) &lt;&lt; std::endl;    <span class="hljs-comment">// char 类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 或者用 template &lt;class T&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T value) : <span class="hljs-built_in">data</span>(value) &#123;&#125;<br>    <span class="hljs-function">T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123; data = value; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="模版参数"><a href="#模版参数" class="headerlink" title="模版参数"></a>模版参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">类型参数用于表示任意类型，在模板实例化时被具体的类型替代。<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data;<br>&#125;;<br><br><br>非类型参数允许模板接受非类型的值，如整数、指针或引用。C+<span class="hljs-number">+17</span> 支持更多非类型参数类型，如 <span class="hljs-keyword">auto</span>。<br>非类型参数必须是编译期常量。<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data[N];<br>&#125;;<br><br><br>模板模板参数<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerPrinter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&lt;T, std::allocator&lt;T&gt;&gt;&amp; container)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : container)<br>            std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><br>    ContainerPrinter&lt;std::vector, <span class="hljs-type">int</span>&gt; vecPrinter;<br>    vecPrinter.<span class="hljs-built_in">print</span>(vec); <span class="hljs-comment">// 输出：1 2 3 4 5 </span><br><br>    ContainerPrinter&lt;std::list, <span class="hljs-type">int</span>&gt; listPrinter;<br>    listPrinter.<span class="hljs-built_in">print</span>(lst); <span class="hljs-comment">// 输出：10 20 30 </span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="全特化偏特化"><a href="#全特化偏特化" class="headerlink" title="全特化偏特化"></a>全特化偏特化</h5><ul><li>全特化：提供了模板的一个所有参数的特定版本，当模板参数完全匹配特化类型时，编译器将优先使用该特化版本。</li><li>偏特化：允许模板对部分参数进行特定类型的处理。<strong>函数模版不支持</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原始模板（Primary template）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;原始模板&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 全特化 - 为&lt;int, double&gt;提供特殊实现</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;全特化版本: &lt;int, double&gt;&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 偏特化 - 为第二个参数是int的情况提供特殊实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T, <span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;偏特化版本: &lt;T, int&gt;, T = &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 偏特化 - 为两个参数类型相同的情况提供特殊实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T, T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;偏特化版本: &lt;T, T&gt;, T = &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="变参模版"><a href="#变参模版" class="headerlink" title="变参模版"></a>变参模版</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(T first, Args... args)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>递归展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基本情况（递归终止条件）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 递归展开参数包</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T first, Args... rest)</span> </span>&#123;<br>    std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 处理第一个参数</span><br>    <span class="hljs-built_in">print</span>(rest...);             <span class="hljs-comment">// 递归处理剩余参数</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// 输出: 1 2.5 hello c</span><br></code></pre></td></tr></table></figure><p>折叠表达式 cpp17</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一元折叠 - 求和</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (... + args);  <span class="hljs-comment">// (((arg1 + arg2) + arg3) + ...)</span><br>&#125;<br><br><span class="hljs-comment">// 二元折叠 - 打印</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;  <span class="hljs-comment">// 链式输出</span><br>&#125;<br><br><span class="hljs-comment">// 带初始值的折叠</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printWithComma</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    ((std::cout &lt;&lt; args &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>), ...);  <span class="hljs-comment">// 每个参数后面加逗号</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>一元右折叠</strong>：<code>(pack op ...)</code></li><li><strong>一元左折叠</strong>：<code>(... op pack)</code></li><li><strong>二元右折叠</strong>：<code>(pack op ... op init)</code></li><li><strong>二元左折叠</strong>：<code>(init op ... op pack)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 一元右折叠</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum1</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ...);  <span class="hljs-comment">// 等价于 a1 + (a2 + (... + aN))</span><br>&#125;<br><br><span class="hljs-comment">// 一元左折叠</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum2</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (... + args);  <span class="hljs-comment">// 等价于 ((a1 + a2) + ...) + aN</span><br>&#125;<br><br><span class="hljs-comment">// 二元右折叠（带初始值）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum3</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ... + <span class="hljs-number">0</span>);  <span class="hljs-comment">// 即使参数包为空也能工作</span><br>&#125;<br><br><span class="hljs-comment">// 二元左折叠（带初始值）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum4</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + args);  <span class="hljs-comment">// 即使参数包为空也能工作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum1(1, 2, 3, 4, 5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum2(1, 2, 3, 4, 5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum3() = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum3</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 空参数包，结果为 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sum4() = &quot;</span> &lt;&lt; <span class="hljs-built_in">sum4</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 空参数包，结果为 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h4><p>Substitution Failure Is Not An Error</p><ul><li><strong>函数重载选择</strong>：根据参数类型的不同选择不同的函数实现。</li><li><strong>类型特性检测</strong>：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。</li><li><strong>条件编译</strong>：根据模板参数的特性决定是否编译某些代码段。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-type">enable_if_t</span>&lt;condition&gt;` 来替代 std::enable_if&lt;condition&gt;::type<br><br><br>当T满足条件时 → 表达式变为<span class="hljs-type">void</span>（或者enable_if第二个模板参数指定的类型）<br>当T不满足条件时 → 表达式无效，导致模板替换失败，编译器不会报错，而是简单地丢弃该重载。  替换失败不是错误<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 使用std::enable_if实现SFINAE</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <br>          <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">enable_if_t</span>&lt;std::is_integral&lt;T&gt;::value&gt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">process</span>(T value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理整数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>          <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">enable_if_t</span>&lt;std::is_floating_point&lt;T&gt;::value&gt;,<br>          <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-comment">// 额外参数避免签名冲突</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">process</span>(T value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理浮点数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 选择整数版本</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 选择浮点数版本</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果没有</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 运行时判断类型</span><br>    <span class="hljs-keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;处理整数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::is_floating_point&lt;T&gt;::value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;处理浮点数: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;未知类型&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 主模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Enable = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> MyClass &#123;<br>    <span class="hljs-comment">// 默认实现</span><br>&#125;;<br><br><span class="hljs-comment">// 特化版本（当T满足某条件时）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T, <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt; &#123;<br>    <span class="hljs-comment">// 针对整数类型的特殊实现</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h4><p>需求：</p><ol><li>对于普通类型，使用通用的打印格式。</li><li>对于指针类型，打印指针地址或指向的值。</li><li>对于<code>std::string</code>类型，使用专门的格式。</li><li>支持可变数量的参数，通过折叠表达式实现参数的逐一打印。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Enable = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> Logger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-built_in">log</span>(<span class="hljs-type">const</span> T&amp; message) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;T, <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; message)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging integer: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;std::string&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging string: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logOne</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; message)</span></span>&#123;<br>    Logger&lt;T&gt;::<span class="hljs-built_in">log</span>(message);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAll</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... args)</span></span>&#123;<br><br>    (<span class="hljs-built_in">logOne</span>(args), ...);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAllC</span><span class="hljs-params">(T first, <span class="hljs-type">const</span> Args&amp;... args)</span></span>&#123;<br>    <span class="hljs-built_in">logOne</span>(first);<br>    <span class="hljs-built_in">logAll</span>(args...);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h4><p><strong>定义</strong><br> 模板元编程是利用 C++ 模板机制，在编译阶段执行“算法”或“计算”，最终在生成的二进制中只留下结果，不留任何运行时开销的编程手段。</p><p><strong>本质</strong></p><ul><li><strong>类型计算</strong>：通过类型递归、偏特化来在编译期对类型进行判断、转换、组合。</li><li><strong>值计算</strong>：通过整型非类型模板参数，利用编译器对常量表达式求值来进行数值计算。</li></ul><p><strong>与运行时多态的对比</strong></p><ul><li><strong>静态多态</strong>（模板）在编译期“展平”成具体代码，可获得极致优化；</li><li><strong>动态多态</strong>（虚函数）则要靠 vtable 在运行时分派。</li></ul><p><strong>递归 + 偏特化：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 计算阶乘：Factorial&lt;N&gt;::value 在编译期算出 N!</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N<span class="hljs-number">-1</span>&gt;::value;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-built_in">static_assert</span>(Factorial&lt;<span class="hljs-number">5</span>&gt;::value == <span class="hljs-number">120</span>, <span class="hljs-string">&quot;&quot;</span>);  <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">当编译器遇到Factorial&lt;<span class="hljs-number">5</span>&gt;::value时，会触发一系列模板实例化：<br><br><br><span class="hljs-comment">// 主模板应用于N=5</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">5</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">5</span> * Factorial&lt;<span class="hljs-number">4</span>&gt;::value;<br>&#125;;<br><br><span class="hljs-comment">// 递归实例化N=4,3,2,1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">4</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">4</span> * Factorial&lt;<span class="hljs-number">3</span>&gt;::value; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">3</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">3</span> * Factorial&lt;<span class="hljs-number">2</span>&gt;::value; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">2</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">2</span> * Factorial&lt;<span class="hljs-number">1</span>&gt;::value; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">1</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span> * Factorial&lt;<span class="hljs-number">0</span>&gt;::value; &#125;;<br><br><span class="hljs-comment">// 特化模板终止递归</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>; &#125;;<br></code></pre></td></tr></table></figure><p><strong>类型计算：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 检测是否可以对T类型进行加法操作</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">struct</span> is_addable : std::false_type &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_addable</span>&lt;T, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">void</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;() + std::<span class="hljs-built_in">declval</span>&lt;T&gt;()))&gt; : std::true_type &#123;&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">static_assert</span>(is_addable&lt;<span class="hljs-type">int</span>&gt;::value, <span class="hljs-string">&quot;int should be addable&quot;</span>);<br><span class="hljs-built_in">static_assert</span>(!is_addable&lt;<span class="hljs-type">void</span>*&gt;::value, <span class="hljs-string">&quot;void* should not be addable&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>变参模板</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基本递归模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span>... Ns&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>;<br><br><span class="hljs-comment">// 递归终止</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>&lt;&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 递归定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N, <span class="hljs-type">int</span>... Ns&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>&lt;N, Ns...&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N + Sum&lt;Ns...&gt;::value;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = Sum&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&gt;::value; <span class="hljs-comment">// 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Type Lists</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义类型列表</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeList</span> &#123;&#125;;<br><br><span class="hljs-comment">// 获取类型列表中第N个类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> List, std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeAt</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, <span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = Head;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail, std::<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeAt</span>&lt;TypeList&lt;Head, Tail...&gt;, N&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> TypeAt&lt;TypeList&lt;Tail...&gt;, N - <span class="hljs-number">1</span>&gt;::type;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">using</span> list = TypeList&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt;;<br><span class="hljs-keyword">using</span> third_type = TypeAt&lt;list, <span class="hljs-number">2</span>&gt;::type; <span class="hljs-comment">// char</span><br></code></pre></td></tr></table></figure><h4 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h4><p><strong>左值（lvalue）</strong>和<strong>右值（rvalue）</strong>是C++中用于描述表达式值类别的重要概念。</p><ul><li>左值（lvalue）：<ul><li>表示具有持久存储的对象。</li><li>可以出现在赋值语句的左侧。</li><li>可以被取地址（即，可以使用<code>&amp;</code>运算符）。</li><li>示例：变量名、引用等。</li></ul></li><li>右值（rvalue）：<ul><li>表示临时对象或没有持久存储的值。</li><li>通常出现在赋值语句的右侧。</li><li>不能被取地址。</li><li>示例：字面量、临时对象、表达式结果等。</li></ul></li></ul><p>C++11进一步细化了右值的分类：</p><ul><li><strong>纯右值（prvalues）</strong>：表示临时对象或字面量，如<code>42</code>、<code>3.14</code>。</li><li><strong>将亡值（xvalues，expiring values）</strong>：表示即将被移动的对象，如<code>std::move</code>的结果。</li></ul><p>C++标准库提供了几个类型特性（type traits）用于判断表达式的值类别：</p><ul><li><code>std::is_lvalue_reference&lt;T&gt;</code>：判断类型<code>T</code>是否为左值引用。</li><li><code>std::is_rvalue_reference&lt;T&gt;</code>：判断类型<code>T</code>是否为右值引用。</li><li><code>std::is_lvalue&lt;T&gt;</code>（C++20起）：判断表达式是否为左值。</li><li><code>std::is_rvalue&lt;T&gt;</code>（C++20起）：判断表达式是否为右值。</li></ul><h4 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp;)</span> </span>&#123; <br>    <span class="hljs-comment">// 将分析 T 的类型和 T&amp;&amp; 折叠后的类型</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对左值 以及 左值引用 以及右值引用(命名的右值引用被视为左值)：T 推导为左值引用类型</li><li>对右值 以及 move()：T 推导为非引用类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 值类别基础：左值与右值<br>让我们从最基本的概念开始：<br><br>左值(lvalue)：可以取地址、有名字的表达式<br><br>例如：变量、数组元素、返回引用的函数<br>特点：通常可以出现在赋值号(=)左边<br>右值(rvalue)：不能取地址、没有名字的临时表达式<br><br>例如：字面常量(<span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello&quot;</span>)、临时对象、返回非引用的函数结果<br>特点：只能出现在赋值号(=)右边<br>C++<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;        <span class="hljs-comment">// x 是左值</span><br><span class="hljs-type">int</span> y = x + <span class="hljs-number">20</span>;    <span class="hljs-comment">// (x + 20) 是右值</span><br><span class="hljs-type">int</span>&amp; ref = x;      <span class="hljs-comment">// 左值引用必须绑定到左值</span><br><span class="hljs-comment">// int&amp; ref2 = 42; // 错误：左值引用不能绑定到右值</span><br><span class="hljs-number">2.</span> 引用类型基础<br>C++有两种基本引用：<br><br>左值引用(T&amp;)：只能绑定到左值<br>右值引用(T&amp;&amp;)：主要用于绑定右值（C+<span class="hljs-number">+11</span>引入）<br>C++<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-comment">// a 是左值</span><br><span class="hljs-type">int</span>&amp; lref = a;     <span class="hljs-comment">// 正确：左值引用绑定到左值</span><br><span class="hljs-comment">// int&amp; badref = 20; // 错误：左值引用不能绑定到右值</span><br><br><span class="hljs-type">int</span>&amp;&amp; rref = <span class="hljs-number">30</span>;   <span class="hljs-comment">// 正确：右值引用绑定到右值</span><br><span class="hljs-comment">// int&amp;&amp; badrref = a; // 错误：右值引用不能绑定到左值</span><br>特殊情况：<span class="hljs-type">const</span> 左值引用可以绑定到右值：<br><br>C++<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 正确：const左值引用可以绑定到右值</span><br><span class="hljs-number">3.</span> 函数参数中的引用<br>C++<br><span class="hljs-comment">// 接收左值的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理左值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    x += <span class="hljs-number">1</span>;  <span class="hljs-comment">// 可以修改原始值</span><br>&#125;<br><br><span class="hljs-comment">// 接收右值的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;处理右值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 可能会移动资源，而不是复制</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">processLValue</span>(a);     <span class="hljs-comment">// 正确：a是左值</span><br>    <span class="hljs-comment">// processLValue(42); // 错误：42是右值，不能绑定到左值引用参数</span><br><br>    <span class="hljs-comment">// processRValue(a);  // 错误：a是左值，不能绑定到右值引用参数</span><br>    <span class="hljs-built_in">processRValue</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// 正确：42是右值</span><br>&#125;<br><span class="hljs-number">4.</span> 重要观察：命名的右值引用是左值！<br>这是理解后面内容的关键点：<br><br>C++<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>&amp;&amp; rref = <span class="hljs-number">42</span>;  <span class="hljs-comment">// rref的类型是int&amp;&amp;（右值引用）</span><br><br>    <span class="hljs-comment">// 但是rref本身是左值，因为它有名字！</span><br>    <span class="hljs-type">int</span>&amp; lref = rref;  <span class="hljs-comment">// 正确：可以将左值引用绑定到rref</span><br><br>    <span class="hljs-built_in">processLValue</span>(rref);  <span class="hljs-comment">// 正确：rref是左值</span><br>    <span class="hljs-comment">// processRValue(rref);  // 错误：不能将左值传给右值引用参数</span><br>&#125;<br>核心理解：引用变量的类型与它的值类别是不同的概念！<br><br>rref的类型是<span class="hljs-type">int</span>&amp;&amp;（右值引用类型）<br>但rref的值类别是左值（因为它有名字）<br><span class="hljs-number">5.</span> 模板与通用引用<br>当在模板参数中使用T&amp;&amp;时，它不一定是右值引用，而是一种特殊的<span class="hljs-string">&quot;通用引用&quot;</span>：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;  <span class="hljs-comment">// 这里的T&amp;&amp;不一定是右值引用</span><br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(x);    <span class="hljs-comment">// 用左值调用：T推导为int&amp;，param类型为int&amp;</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 用右值调用：T推导为int，param类型为int&amp;&amp;</span><br>&#125;<br><span class="hljs-number">6.</span> 模板类型推导规则<br>当使用通用引用T&amp;&amp;时，类型推导遵循以下规则：<br><br>传入左值，T被推导为左值引用：T = X&amp;<br>传入右值，T被推导为非引用类型：T = X<br>C++<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">printType</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;T的类型: &quot;</span>;<br>    <span class="hljs-built_in">printType</span>&lt;T&gt;();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;param的类型: &quot;</span>;<br>    <span class="hljs-built_in">printType</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">f</span>(a);   <span class="hljs-comment">// 传入左值: T = int&amp;, param类型 = int&amp;</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 传入右值: T = int, param类型 = int&amp;&amp;</span><br>&#125;<br><span class="hljs-number">7.</span> 引用折叠规则<br>C++有四条引用折叠规则，当涉及到引用的引用时：<br><br>T&amp; &amp; → T&amp; (左值引用的左值引用 = 左值引用)<br>T&amp; &amp;&amp; → T&amp; (左值引用的右值引用 = 左值引用)<br>T&amp;&amp; &amp; → T&amp; (右值引用的左值引用 = 左值引用)<br>T&amp;&amp; &amp;&amp; → T&amp;&amp; (右值引用的右值引用 = 右值引用)<br>简单来说：只要有一个是左值引用(&amp;)，结果就是左值引用；只有当两个都是右值引用(&amp;&amp;)时，结果才是右值引用。<br><br><span class="hljs-number">8.</span> 引用折叠与通用引用结合<br>当我们结合模板类型推导和引用折叠规则，以下情况发生：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">wrapper</span>(x);   <span class="hljs-comment">// 左值情况</span><br>左值调用流程：<br><br>x是左值，所以T被推导为<span class="hljs-type">int</span>&amp;<br>参数类型变为<span class="hljs-type">int</span>&amp; &amp;&amp;<br>引用折叠：<span class="hljs-type">int</span>&amp; &amp;&amp; → <span class="hljs-type">int</span>&amp;<br>最终param类型为<span class="hljs-type">int</span>&amp;（左值引用）<br>C++<br><span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 右值情况</span><br>右值调用流程：<br><br><span class="hljs-number">42</span>是右值，所以T被推导为<span class="hljs-type">int</span><br>参数类型变为<span class="hljs-type">int</span>&amp;&amp;<br>无需折叠，保持为<span class="hljs-type">int</span>&amp;&amp;<br>最终param类型为<span class="hljs-type">int</span>&amp;&amp;（右值引用）<br><span class="hljs-number">9.</span> 问题：参数转发<br>考虑一个包装函数，它需要将参数传递给另一个函数：<br><br>C++<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;左值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;右值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(param);  <span class="hljs-comment">// 问题在这里！</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(a);    <span class="hljs-comment">// 期望调用process(int&amp;)</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 期望调用process(int&amp;&amp;)</span><br>&#125;<br>关键问题：即使<span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>)中的param类型是<span class="hljs-type">int</span>&amp;&amp;，但由于param有名字，它在函数体内是左值！所以<span class="hljs-built_in">process</span>(param)总是调用左值版本。<br><br><span class="hljs-number">10.</span> std::forward 的作用<br>std::forward解决了上述问题，它可以在必要时（当原始参数是右值时）将参数转换回右值：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(param));  <span class="hljs-comment">// 保持参数的原始值类别</span><br>&#125;<br>std::forward的简化原理：<br><br>C++<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(arg);<br>&#125;<br>当T是<span class="hljs-type">int</span>&amp;（传入左值）时，T&amp;&amp;折叠为<span class="hljs-type">int</span>&amp;，不改变值类别。 当T是<span class="hljs-type">int</span>（传入右值）时，T&amp;&amp;保持为<span class="hljs-type">int</span>&amp;&amp;，将左值arg转换回右值引用。<br></code></pre></td></tr></table></figure><p>参数转发:当我们编写通用的模板函数（如工厂、封装器）时，通常想把参数“原样”传递给另一个函数或构造器，而不改变它的值类别（左值&#x2F;右值）和 cv 限定（const&#x2F;volatile）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;左值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;右值版本&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(param);  <span class="hljs-comment">// 问题在这里！</span><br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(param));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(a);    <span class="hljs-comment">// 期望调用process(int&amp;)</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 期望调用process(int&amp;&amp;)</span><br>&#125;<br><span class="hljs-comment">// 即使wrapper(42)中的param类型是int&amp;&amp;，但由于param有名字，它在函数体内是左值！所以process(param)总是调用左值版本。</span><br></code></pre></td></tr></table></figure><p>vector中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-type">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">emplace_back</span>(Args&amp;&amp;... args) &#123;<br>    <span class="hljs-built_in">checkSize</span>();  <span class="hljs-comment">// 扩容（如果需要）</span><br>    <span class="hljs-keyword">new</span> (data_ + size_) <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...);  <span class="hljs-comment">// 原地构造</span><br>    ++size_;<br>&#125;<br><br><br>Vector&lt;Foo&gt; v;<br>Foo a;<br>v.<span class="hljs-built_in">emplace_back</span>(a);           <span class="hljs-comment">// 应该调用 copy ctor</span><br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Foo</span>(<span class="hljs-number">42</span>));     <span class="hljs-comment">// 应该调用 move ctor</span><br></code></pre></td></tr></table></figure><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><h5 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h5><p>Meyer’s Singleton </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++11 及以上版本线程安全</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局访问点</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// C++11 保证了局部静态变量的线程安全初始化</span><br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>(静态成员变量)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 静态实例成员</span><br>    <span class="hljs-type">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在类外定义和初始化静态成员</span><br>Singleton Singleton::instance;<br></code></pre></td></tr></table></figure><h5 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//懒汉式指针</span><br><span class="hljs-comment">//即使创建指针类型也存在问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglePointer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SinglePointer</span>()<br>    &#123;<br>    &#125;<br>    <span class="hljs-built_in">SinglePointer</span>(<span class="hljs-type">const</span> SinglePointer &amp;) = <span class="hljs-keyword">delete</span>;<br>    SinglePointer &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SinglePointer &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SinglePointer *<span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        s_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (single != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s_mutex.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SinglePointer</span>();<br>        s_mutex.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> SinglePointer *single;<br>    <span class="hljs-type">static</span> mutex s_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题：2、3可能调换，导致其他线程使用了为完全初始化的对象</p><ol><li>calloc 开辟空间</li><li>调用构造函数</li><li>将构造好的对象赋值给single</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglePointer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">SinglePointer</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">SinglePointer</span>(<span class="hljs-type">const</span> SinglePointer&amp;) = <span class="hljs-keyword">delete</span>;<br>    SinglePointer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SinglePointer&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 获取单例实例</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> SinglePointer* <span class="hljs-title">GetInst</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 使用内存序语义的原子操作进行第一次检查</span><br>        SinglePointer* tmp = instance.<span class="hljs-built_in">load</span>(std::memory_order_acquire);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 使用RAII锁管理，确保异常情况下也能释放锁</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_mutex)</span></span>;<br><br>            <span class="hljs-comment">// 再次检查，避免另一个线程已经创建了实例</span><br>            tmp = instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SinglePointer</span>();<br><br>                <span class="hljs-comment">// 使用内存序语义存储指针，确保其他线程能看到完全初始化的对象</span><br>                instance.<span class="hljs-built_in">store</span>(tmp, std::memory_order_release);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 提供清理单例实例的方法（可选）</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DestroyInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_mutex)</span></span>;<br>        SinglePointer* tmp = instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (tmp != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> tmp;<br>            instance.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数（如果需要在销毁时执行清理操作）</span><br>    ~<span class="hljs-built_in">SinglePointer</span>() <br>    &#123;<br>        <span class="hljs-comment">// 清理资源的代码</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 使用原子类型确保线程安全的指针访问</span><br>    <span class="hljs-type">static</span> std::atomic&lt;SinglePointer*&gt; instance;<br>    <span class="hljs-type">static</span> std::mutex s_mutex;<br>&#125;;<br><br><span class="hljs-comment">// 静态成员初始化</span><br>std::atomic&lt;SinglePointer*&gt; SinglePointer::instance&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>std::mutex SinglePointer::s_mutex;<br></code></pre></td></tr></table></figure><h5 id="once-flag"><a href="#once-flag" class="headerlink" title="once_flag"></a><strong>once_flag</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-type">static</span> std::once_flag flag;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        std::<span class="hljs-built_in">call_once</span>(flag, createInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroyInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> instance;<br>        instance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// cpp中初始化静态成员</span><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::once_flag Singleton::flag;<br></code></pre></td></tr></table></figure><p>但不能保证destroyInstance被调用，因此可以使用shared_ptr优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; instance;<br>    <span class="hljs-type">static</span> std::once_flag flag;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        instance = std::<span class="hljs-built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>());<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        std::<span class="hljs-built_in">call_once</span>(flag, createInstance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 不再需要destroyInstance方法，shared_ptr会自动管理内存</span><br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员</span><br>std::shared_ptr&lt;Singleton&gt; Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::once_flag Singleton::flag;<br></code></pre></td></tr></table></figure><h5 id="通用模版"><a href="#通用模版" class="headerlink" title="通用模版"></a>通用模版</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TempClass</span> &#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;;<br><span class="hljs-comment">//CRTP</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealClass</span>: <span class="hljs-keyword">public</span> TempClass&lt;RealClass&gt;&#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; _instance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> std::once_flag s_flag;<br>        std::<span class="hljs-built_in">call_once</span>(s_flag, [&amp;]() &#123;<br>            _instance = <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T);<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; _instance.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//通过继承方式实现网络模块单例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleNet</span> : <span class="hljs-keyword">public</span> Singleton&lt;SingleNet&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;SingleNet&gt;; <span class="hljs-comment">// Singleton里面有new操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleNet</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">SingleNet</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;SingleNet destruct &quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><ol><li><p><strong>Reactor模式</strong>:</p><ul><li>先接收”可以进行IO”的通知</li><li>应用程序自己执行实际的IO操作(read&#x2F;write)</li><li>处理结果来自自己执行的IO操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 等待事件通知（哪些fd准备好了）</span><br><span class="hljs-type">int</span> ready_fds = <span class="hljs-built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">// 处理就绪的文件描述符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ready_fds; i++) &#123;<br>    <span class="hljs-type">int</span> fd = events[i].data.fd;<br><br>    <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<br>        <span class="hljs-comment">// 通知：数据可读了</span><br>        <span class="hljs-comment">// 但我们必须自己执行读取操作</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> bytes_read = <span class="hljs-built_in">read</span>(fd, buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br><br>        <span class="hljs-keyword">if</span> (bytes_read &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 处理读取到的数据</span><br>            <span class="hljs-built_in">process_data</span>(fd, buffer, bytes_read);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;<br>        <span class="hljs-comment">// 通知：可以写数据了</span><br>        <span class="hljs-comment">// 但我们必须自己执行写入操作</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* response = <span class="hljs-built_in">get_response</span>(fd);<br>        <span class="hljs-built_in">write</span>(fd, response, <span class="hljs-built_in">strlen</span>(response));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Proactor模式</strong>:</p><ul><li>先发起异步IO请求</li><li>等待”IO已完成”的通知</li><li>处理结果来自系统已经完成的IO操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 发起异步读取操作</span><br>socket-&gt;<span class="hljs-built_in">async_read_some</span>(<br>    boost::asio::<span class="hljs-built_in">buffer</span>(*buffer),<br>    [<span class="hljs-keyword">this</span>, socket, buffer](<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::<span class="hljs-type">size_t</span> bytes_transferred) &#123;<br>        <span class="hljs-keyword">if</span> (!error) &#123;<br>            <span class="hljs-comment">// 读取操作已完成，直接处理数据</span><br>            <span class="hljs-comment">// 不需要自己调用read函数</span><br>            <span class="hljs-built_in">process_data</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), bytes_transferred);<br><br>            <span class="hljs-comment">// 发送响应</span><br>            <span class="hljs-built_in">start_write</span>(socket, <span class="hljs-string">&quot;Response&quot;</span>);<br><br>            <span class="hljs-comment">// 继续读取</span><br>            <span class="hljs-built_in">start_read</span>(socket);<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure></li></ol><p>操作系统底层io模型存在差异，如何实现Asio中Proactor风格的API？</p><ul><li><strong>Windows</strong>：Windows操作系统从早期就提供了真正的异步I&#x2F;O机制(IOCP)，天然支持Proactor模式</li><li><strong>Unix&#x2F;Linux</strong>：传统上依赖于I&#x2F;O多路复用机制(select&#x2F;poll&#x2F;epoll)，这些本质上是Reactor模式，Asio巧妙地使用底层的Reactor机制(epoll&#x2F;kqueue)<strong>模拟出</strong>Proactor行为</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">用户代码                     Asio库内部                     操作系统<br>    |                           |                             |<br>    |--<span class="hljs-built_in">async_read</span>()-----------&gt;|                             |<br>    |                           |--注册读事件到epoll---------&gt;|<br>    |                           |                             |<br>    |                           |&lt;--通知<span class="hljs-string">&quot;可读&quot;</span>----------------|<br>    |                           |                             |<br>    |                           |--执行实际<span class="hljs-built_in">read</span>()系统调用----&gt;|<br>    |                           |&lt;--返回数据------------------|<br>    |                           |                             |<br>    |&lt;--调用完成回调函数--------|                             |<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Asio在Linux上的简化工作原理</span><br><br><span class="hljs-comment">// 1. 用户发起异步读取请求</span><br>socket.<span class="hljs-built_in">async_read_some</span>(buffer, [](error_code ec, <span class="hljs-type">size_t</span> bytes_transferred) &#123;<br>    <span class="hljs-comment">// 5. 用户回调在数据已读取后执行</span><br>    <span class="hljs-built_in">process_data</span>(buffer, bytes_transferred);<br>&#125;);<br><br><span class="hljs-comment">// 2. Asio内部实现（对用户不可见）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">internal_register_read</span><span class="hljs-params">(socket_type sock, buffer_type&amp; buffer, callback_type&amp; callback)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个操作描述符</span><br>    op_state* state = <span class="hljs-keyword">new</span> op_state&#123;sock, buffer, callback&#125;;<br><br>    <span class="hljs-comment">// 注册到epoll，告诉系统&quot;当这个socket可读时通知我&quot;</span><br>    <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock, &amp;event);<br><br>    <span class="hljs-comment">// 保存状态以便之后处理</span><br>    operations_[sock] = state;<br>&#125;<br><br><span class="hljs-comment">// 3. Asio内部事件循环（在io_context::run中）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">io_context::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 等待epoll事件（这是Reactor风格的I/O事件等待）</span><br>        <span class="hljs-built_in">epoll_wait</span>(epoll_fd, events, max_events, timeout);<br><br>        <span class="hljs-keyword">for</span> (each ready_event) &#123;<br>            socket_type sock = ready_event.data.fd;<br>            op_state* state = operations_[sock];<br><br>            <span class="hljs-keyword">if</span> (ready_event.events &amp; EPOLLIN) &#123;<br>                <span class="hljs-comment">// 4. 事件发生时，Asio自己执行读取操作（这是关键部分）</span><br>                <span class="hljs-type">int</span> bytes = <span class="hljs-built_in">read</span>(sock, state-&gt;buffer, state-&gt;buffer_size);<br><br>                <span class="hljs-comment">// 读取完成后，安排调用用户的回调函数</span><br>                <span class="hljs-built_in">post_completion</span>(state-&gt;callback, error_code&#123;&#125;, bytes);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-1.png" alt="image-20250426200128683"></p><p><code>socket.write_some()</code></p><ul><li><strong>部分写入操作</strong>：一次尝试写入尽可能多的数据</li><li><strong>返回值</strong>：返回实际写入的字节数(可能小于缓冲区大小)</li><li><strong>完成条件</strong>：<strong>操作系统缓冲区</strong>部分填满即可返回</li></ul><p><code>asio::write()</code></p><ul><li><strong>完整写入操作</strong>：保证写入整个缓冲区的所有数据</li><li><strong>内部实现</strong>：可能会进行多次<code>write_some()</code>调用</li><li><strong>返回值</strong>：返回总写入字节数(通常等于传入缓冲区大小)</li><li><strong>完成条件</strong>：所有数据都写入完毕才会返回</li></ul><p><code>socket.read_some()</code></p><ul><li><strong>部分读取操作</strong>：只要有任何数据可用就返回</li><li><strong>读取行为</strong>：读取部分数据（最多填充提供的缓冲区大小）</li><li><strong>返回值</strong>：返回实际读取的字节数</li><li><strong>错误处理</strong>：使用传入的[error](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;Applications&#x2F;Visual Studio Code.app&#x2F;Contents&#x2F;Resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html)参数报告错误，不抛出异常</li><li><strong>阻塞行为</strong>：有数据就立即返回，即使只读到一个字节&#96;</li></ul><p><code>asio::read()</code></p><ul><li><strong>完整读取操作</strong>：尝试填满整个缓冲区（代码中的buffer）</li><li><strong>读取行为</strong>：会进行多次底层读取，直到缓冲区填满</li><li><strong>返回值</strong>：返回读取的总字节数（通常等于缓冲区大小）</li><li><strong>错误处理</strong>：默认情况下会抛出异常</li><li><strong>阻塞行为</strong>：会一直阻塞直到缓冲区填满、到达文件末尾或发生错误</li></ul><h4 id="同步客户端服务器"><a href="#同步客户端服务器" class="headerlink" title="同步客户端服务器"></a>同步客户端服务器</h4><h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><p>同步的读写，并且完全单线程处理</p><ul><li>客户端之间会相互阻塞，并且如果客户端不发送也会阻塞</li><li>如果开辟子线程分别处理客户端，会消耗资源</li><li>发送接收为应答模式，不能实现全双工通讯</li><li>粘包问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">io_context: Asio的核心，所有I/O操作都需要它</span><br><span class="hljs-comment">endpoint: 表示网络地址(IP+端口)的抽象</span><br><span class="hljs-comment">acceptor: 服务器用来接受新连接的组件</span><br><span class="hljs-comment">resolver: 用于域名解析为IP地址</span><br><span class="hljs-comment">socket: 表示网络连接的抽象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1. An instance of &#x27;io_service&#x27; class is required by</span><br>            <span class="hljs-comment">// socket constructor. </span><br>    asio::io_context  ios;<br><br>    <span class="hljs-comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span><br>    <span class="hljs-comment">// a TCP protocol with IPv4 as underlying protocol.</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3. Instantiating an active TCP socket object.</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Used to store information about error that happens</span><br>    <span class="hljs-comment">// while opening the socket.</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 4. Opening the socket.</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Failed to open the socket.</span><br>        std::cout<br>            &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// TCP客户端示例，连接服务器并发送/接收消息</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_client</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br>        <span class="hljs-comment">// 解析主机名和端口</span><br>        asio::ip::<span class="hljs-function">tcp::resolver <span class="hljs-title">resolver</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::ip::tcp::resolver::results_type endpoints = <br>            resolver.<span class="hljs-built_in">resolve</span>(host, std::<span class="hljs-built_in">to_string</span>(port));<br><br>        <span class="hljs-comment">// 创建socket并连接到服务器</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::<span class="hljs-built_in">connect</span>(socket, endpoints);<br><br>        <span class="hljs-comment">// socket.connect(endpoints);</span><br><br>        <span class="hljs-comment">// 发送消息</span><br>        asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(message));<br><br>        <span class="hljs-comment">// 接收响应</span><br>        std::array&lt;<span class="hljs-type">char</span>, 1024&gt; recv_buffer;<br>        <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(recv_buffer));<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;接收到: &quot;</span>;<br>        std::cout.<span class="hljs-built_in">write</span>(recv_buffer.<span class="hljs-built_in">data</span>(), length);<br>        std::cout &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// TCP服务器示例，接受连接并处理客户端请求</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_server</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br><br>        <span class="hljs-comment">// 创建接收器监听新连接</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(io_context, </span></span><br><span class="hljs-params"><span class="hljs-function">            asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))</span></span>;<br><br>        <span class="hljs-comment">// 方式二: 分步操作</span><br>        <span class="hljs-comment">// asio::ip::tcp::endpoint ep(asio::ip::tcp::v4(), port);</span><br>        <span class="hljs-comment">// asio::ip::tcp::acceptor acceptor2(io_context, ep.protocol());</span><br>        <span class="hljs-comment">// // 需要后续显式调用 bind 和 listen</span><br>        <span class="hljs-comment">// acceptor2.bind(ep);</span><br>        <span class="hljs-comment">// acceptor2.listen();</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;服务器启动，监听端口 &quot;</span> &lt;&lt; port &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 为新连接创建socket</span><br>            asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br><br>            <span class="hljs-comment">// 等待连接</span><br>            acceptor.<span class="hljs-built_in">accept</span>(socket);<br><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;接受来自 &quot;</span> &lt;&lt; socket.<span class="hljs-built_in">remote_endpoint</span>() &lt;&lt; <span class="hljs-string">&quot; 的连接&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 读取客户端数据</span><br>            std::array&lt;<span class="hljs-type">char</span>, 1024&gt; buffer;<br>            boost::system::error_code error;<br><br>            <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(buffer), error);<br><br>            <span class="hljs-keyword">if</span> (!error) &#123;<br>                <span class="hljs-comment">// 处理请求</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;收到: &quot;</span>;<br>                std::cout.<span class="hljs-built_in">write</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                std::cout &lt;&lt; std::endl;<br><br>                <span class="hljs-comment">// 发送响应</span><br>                std::string response = <span class="hljs-string">&quot;服务器回应: &quot;</span>;<br>                response.<span class="hljs-built_in">append</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(response));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;用法: &quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; socket      - 测试socket创建&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; server 端口  - 启动TCP服务器&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; client 主机 端口 消息 - 运行TCP客户端&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::string mode = argv[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;socket&quot;</span>) &#123;<br>        <span class="hljs-comment">// 测试socket创建</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Socket创建成功!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;server&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 运行服务器</span><br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_server</span>(port);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;client&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">// 运行客户端</span><br>        std::string host = argv[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">3</span>]);<br>        std::string message = argv[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_client</span>(host, port, message);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无效的参数!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="多线程处理连接"><a href="#多线程处理连接" class="headerlink" title="多线程处理连接"></a>多线程处理连接</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 全局线程管理集合</span><br>std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;<br>std::mutex thread_set_mutex;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1. An instance of &#x27;io_service&#x27; class is required by</span><br>            <span class="hljs-comment">// socket constructor. </span><br>    asio::io_context  ios;<br><br>    <span class="hljs-comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span><br>    <span class="hljs-comment">// a TCP protocol with IPv4 as underlying protocol.</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3. Instantiating an active TCP socket object.</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Used to store information about error that happens</span><br>    <span class="hljs-comment">// while opening the socket.</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 4. Opening the socket.</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Failed to open the socket.</span><br>        std::cout<br>            &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// TCP客户端示例，连接服务器并发送/接收消息</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_client</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; host, <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br>        <span class="hljs-comment">// 解析主机名和端口</span><br>        asio::ip::<span class="hljs-function">tcp::resolver <span class="hljs-title">resolver</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::ip::tcp::resolver::results_type endpoints = <br>            resolver.<span class="hljs-built_in">resolve</span>(host, std::<span class="hljs-built_in">to_string</span>(port));<br><br>        <span class="hljs-comment">// 创建socket并连接到服务器</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br>        asio::<span class="hljs-built_in">connect</span>(socket, endpoints);<br><br>        <span class="hljs-comment">// 发送消息</span><br>        asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(message));<br><br>        <span class="hljs-comment">// 接收响应</span><br>        std::array&lt;<span class="hljs-type">char</span>, 1024&gt; recv_buffer;<br>        <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(recv_buffer));<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;接收到: &quot;</span>;<br>        std::cout.<span class="hljs-built_in">write</span>(recv_buffer.<span class="hljs-built_in">data</span>(), length);<br>        std::cout &lt;&lt; std::endl;<br><br><br>        <span class="hljs-comment">// asio::write(socket, asio::buffer(message));</span><br><br>        <span class="hljs-comment">// // 接收响应</span><br>        <span class="hljs-comment">// length = socket.read_some(asio::buffer(recv_buffer));</span><br><br>        <span class="hljs-comment">// std::cout &lt;&lt; &quot;接收到: &quot;;</span><br>        <span class="hljs-comment">// std::cout.write(recv_buffer.data(), length);</span><br>        <span class="hljs-comment">// std::cout &lt;&lt; std::endl;</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理客户端会话的函数 - 将在独立线程中运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_client</span><span class="hljs-params">(asio::ip::tcp::socket socket)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;线程启动 - 处理来自 &quot;</span> &lt;&lt; socket.<span class="hljs-built_in">remote_endpoint</span>() &lt;&lt; <span class="hljs-string">&quot; 的连接&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">for</span>(;;)&#123;<br>            <span class="hljs-comment">// 读取客户端数据</span><br>            std::array&lt;<span class="hljs-type">char</span>, 1024&gt; buffer;<br>            boost::system::error_code error;<br>            <span class="hljs-type">size_t</span> length = socket.<span class="hljs-built_in">read_some</span>(asio::<span class="hljs-built_in">buffer</span>(buffer), error);<br><br>            <span class="hljs-keyword">if</span> (!error) &#123;<br>                <span class="hljs-comment">// 处理请求</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;收到: &quot;</span>;<br>                std::cout.<span class="hljs-built_in">write</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                std::cout &lt;&lt; std::endl;<br><br>                <span class="hljs-comment">// 发送响应</span><br>                std::string response = <span class="hljs-string">&quot;服务器回应: &quot;</span>;<br>                response.<span class="hljs-built_in">append</span>(buffer.<span class="hljs-built_in">data</span>(), length);<br>                asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(response));<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (error == boost::asio::error::eof) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;connection closed by peer&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error) &#123;<br>                <span class="hljs-keyword">throw</span> boost::system::<span class="hljs-built_in">system_error</span>(error);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;会话处理异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 修改后的TCP服务器，使用多线程处理连接</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tcp_server</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建IO上下文</span><br>        asio::io_context io_context;<br><br>        <span class="hljs-comment">// 创建接收器监听新连接</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(io_context, </span></span><br><span class="hljs-params"><span class="hljs-function">            asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))</span></span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;服务器启动，监听端口 &quot;</span> &lt;&lt; port &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 为新连接创建socket  </span><br>            asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_context)</span></span>;<br><br>            <span class="hljs-comment">// 等待连接</span><br>            acceptor.<span class="hljs-built_in">accept</span>(socket);<br><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;接受来自 &quot;</span> &lt;&lt; socket.<span class="hljs-built_in">remote_endpoint</span>() &lt;&lt; <span class="hljs-string">&quot; 的连接&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 创建新线程处理这个连接 </span><br>            <span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;(handle_client, std::<span class="hljs-built_in">move</span>(socket));<br><br>            <span class="hljs-comment">// 将线程添加到管理集合中 防止作用域结束线程销毁</span><br>            <span class="hljs-comment">// &#123;</span><br>            <span class="hljs-comment">//     std::lock_guard&lt;std::mutex&gt; lock(thread_set_mutex);</span><br>            <span class="hljs-comment">//     thread_set.insert(t);</span><br>            <span class="hljs-comment">// &#125;</span><br>            thread_set.<span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 清理所有线程</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(thread_set_mutex)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : thread_set) &#123;<br>            <span class="hljs-keyword">if</span> (t-&gt;<span class="hljs-built_in">joinable</span>()) &#123;<br>                t-&gt;<span class="hljs-built_in">join</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;用法: &quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; socket      - 测试socket创建&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; server 端口  - 启动TCP服务器&quot;</span> &lt;&lt; std::endl<br>                  &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; client 主机 端口 消息 - 运行TCP客户端&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::string mode = argv[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;socket&quot;</span>) &#123;<br>        <span class="hljs-comment">// 测试socket创建</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Socket创建成功!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;server&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 运行服务器</span><br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_server</span>(port);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;client&quot;</span> &amp;&amp; argc &gt;= <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">// 运行客户端</span><br>        std::string host = argv[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> port = std::<span class="hljs-built_in">stoi</span>(argv[<span class="hljs-number">3</span>]);<br>        std::string message = argv[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tcp_client</span>(host, port, message);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无效的参数!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异步写API"><a href="#异步写API" class="headerlink" title="异步写API"></a>异步写API</h4><h5 id="base"><a href="#base" class="headerlink" title="base"></a>base</h5><p>node：管理数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最大报文接收大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RECVSIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MsgNode</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> total_len): _total_len(total_len), _cur_len(<span class="hljs-number">0</span>)&#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>        <span class="hljs-built_in">memcpy</span>(_msg, msg, total_len);<br>    &#125;<br><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>    &#125;<br><br>    ~<span class="hljs-built_in">MsgNode</span>()&#123;<br>        <span class="hljs-keyword">delete</span>[]_msg;<br>    &#125;<br>    <span class="hljs-comment">//消息首地址</span><br>    <span class="hljs-type">char</span>* _msg;<br>    <span class="hljs-comment">//总长度</span><br>    <span class="hljs-type">int</span> _total_len;<br>    <span class="hljs-comment">//当前长度</span><br>    <span class="hljs-type">int</span> _cur_len;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">      std::shared_ptr&lt;MsgNode&gt;)</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>      std::shared_ptr&lt;MsgNode&gt; _send_node;<br>      std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>  &#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br><br><span class="hljs-comment">// 因为WriteCallBackErr函数为三个参数且为成员函数，而async_write_some需要的回调函数为两个参数，所以我们通过bind将三个参数转换为两个参数的普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, </span></span><br><span class="hljs-params"><span class="hljs-function">    std::<span class="hljs-type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len <br>        &lt; msg_node-&gt;_total_len) &#123;<br>        _send_node-&gt;_cur_len += bytes_transferred;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,<br>            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：连续发送两个 <code>WriteToSocketErr(&quot;Hello World!&quot;); </code>可能出现”HelloHello World! World!” </p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>引入队列，以及_send_pending，每次只会有一个线程进行发送<code>（_send_pending=true）</code>，并在发送完成后处理队列中剩余的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    <span class="hljs-type">bool</span> _send_pending;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf), std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec,  std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//取出队首元素即当前未发送完数据</span><br>    <span class="hljs-keyword">auto</span> &amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>    send_data-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//数据未发送完， 则继续发送</span><br>    <span class="hljs-keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len-send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p>write替代write_some简化实现，每次回调中肯定发送完了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不能与async_write_some混合使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不考虑粘包情况， 先用固定的字节接收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//没读完继续读</span><br>    <span class="hljs-keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;<br>        _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len,<br>            _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>receive简化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取async_read_some更快，写入直接wirte更方便</p><h4 id="异步回调实现"><a href="#异步回调实现" class="headerlink" title="异步回调实现"></a>异步回调实现</h4><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>处理客户端消息收发的会话类，一个session对应一个客户端，封装了socket以及数据buffer: _data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc):_socket(ioc)&#123;<br>    &#125;<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">Socket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _socket;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    tcp::socket _socket;<br>    <span class="hljs-keyword">enum</span> &#123;max_length = <span class="hljs-number">1024</span>&#125;;<br>    <span class="hljs-type">char</span> _data[max_length];<br>&#125;;<br><br><span class="hljs-number">1</span>   _data用来接收客户端传递的数据 <br><span class="hljs-number">2</span>   _socket为单独处理客户端读写的socket。 <br><span class="hljs-number">3</span>   handle_read和handle_write分别为读回调函数和写回调函数。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始开始读</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2)<br>    );<br>&#125;<br><br><span class="hljs-comment">// 读回调：会写相同数据到peer，同时写完后触发写回调handle_write</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transfered), <br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写回调：打印读读数据，并继续等待读取  打乒乓球模式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">// 写完后继续读取新数据</span><br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>                placeholders::_2)<br>        );<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Write error: &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="server"><a href="#server" class="headerlink" title="server"></a>server</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_accept</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    boost::asio::io_context&amp; _ioc;<br>    tcp::acceptor _acceptor;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Server::<span class="hljs-built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port) :_ioc(ioc),<br>_acceptor(ioc, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)) &#123;<br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    Session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Session</span>(_ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br><br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>二次析构：如果同时注册了客户端的读和写回调，然后客户端断开请求，这时候可能会导致同时进入到delete this;导致重复回收资源。<strong>解决：智能指针+伪闭包实现</strong><ul><li>目前是乒乓球模式，并不会同时注册读写事件，所以不会出错，实际应用是全双工的</li></ul></li><li>未处理粘包，序列化，以及逻辑和收发线程解耦等问题</li><li>未做到完全的收发分离(全双工逻辑)</li></ul><p>client代码和之前同步的一致</p><h5 id="智能指针优化"><a href="#智能指针优化" class="headerlink" title="智能指针优化"></a>智能指针优化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用指针指针代替new    </span><br><span class="hljs-comment">// Session* new_session = new Session(_ioc);</span><br>shared_ptr&lt;Session&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;Session&gt;(_ioc);<br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>    std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br><br><br>bind后计数++<br>shared_ptr传递给所有回调函数，实现生命周期自动管理。<br><br><br><br>  如何从自身成员函数内部获取指向自己的 std::shared_ptr？<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>: <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Session&gt;<br>&#123;<br>    <span class="hljs-comment">// 现在可以调用 shared_from_this() 了</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="队列优化-05"><a href="#队列优化-05" class="headerlink" title="队列优化-05"></a>队列优化-05</h5><p>希望服务器一直监听写事件；此外多次发送是有序的。</p><p>server端发送添加一个队列，放到session中，代表对每一个客户端的发送队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br>  std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>  std::mutex _send_lock;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务器端的数据发送，抽象出一个send函数，将数据加入到发送队列中，并通过判断是否有其他线程正在工作来决定自己是否执行send</li><li>服务端接受到数据后，调用send，并重新回到监听读事件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> max_length)</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>    _send_que.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><br>    <span class="hljs-keyword">if</span>(_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length), <br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Server received data: &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        <span class="hljs-comment">// boost::asio::async_write(_socket, boost::asio::buffer(_data, bytes_transfered), </span><br>        <span class="hljs-comment">//     std::bind(&amp;Session::handle_write, this, placeholders::_1, session));</span><br><br>        <span class="hljs-comment">// 服务器接受到之后，不是打乒乓球回传，而是使用队列发送，并且重新监听写回调</span><br>        <span class="hljs-built_in">Send</span>(_data, bytes_transfered);<br><br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2, <span class="hljs-built_in">shared_from_this</span>())<br>        );<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Read error: &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">// 写完后继续读取新数据</span><br>        <span class="hljs-comment">// memset(_data, 0, max_length);</span><br>        <span class="hljs-comment">// _socket.async_read_some(boost::asio::buffer(_data, max_length),</span><br>        <span class="hljs-comment">//     std::bind(&amp;Session::handle_read, this, placeholders::_1,</span><br>        <span class="hljs-comment">//         placeholders::_2, session)</span><br>        <span class="hljs-comment">// );</span><br><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>        _send_que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(!_send_que.<span class="hljs-built_in">empty</span>())&#123;<br>            boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_send_que.<span class="hljs-built_in">front</span>()-&gt;_data, _send_que.<span class="hljs-built_in">front</span>()-&gt;_max_len), <br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Write error: &quot;</span> &lt;&lt; error.<span class="hljs-built_in">message</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="粘包TLV-06"><a href="#粘包TLV-06" class="headerlink" title="粘包TLV-06"></a>粘包TLV-06</h4><p>记录下包的长度，使得TCP层的数据流可以被正确的解析</p><h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p>简单实现：使用指定长度的read先读取长度，再根据长度读取内容，需要额外添加以下存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前在解析头 还是 体</span><br><span class="hljs-type">bool</span> _b_head_parse;<br><br><span class="hljs-comment">// 当前收到的消息结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br><br><span class="hljs-comment">// 当前收到的头部结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br></code></pre></td></tr></table></figure><p>还能更加简化，使用lambda嵌套lambda</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read_fix</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">200</span>));<br>        <span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br>            _b_head_parse = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-type">short</span> data_len;<br>            <span class="hljs-built_in">memcpy</span>(&amp;data_len, _data, HEAD_LENGTH);<br><br>            _recv_msg_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br><br>            boost::asio::<span class="hljs-built_in">async_read</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, data_len),<br>                std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read_fix, <span class="hljs-keyword">this</span>, placeholders::_1,<br>                    placeholders::_2, <span class="hljs-built_in">shared_from_this</span>())<br>            );<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            _b_head_parse = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data, _data, _recv_msg_node-&gt;_total_len);<br>            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            std::cout&lt;&lt; <span class="hljs-string">&quot;recieve msg: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;<br><br>            <span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br>            boost::asio::<span class="hljs-built_in">async_read</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, HEAD_LENGTH),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read_fix, <span class="hljs-keyword">this</span>, placeholders::_1,<br>                placeholders::_2, <span class="hljs-built_in">shared_from_this</span>())<br>        );<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="read-some"><a href="#read-some" class="headerlink" title="read_some"></a>read_some</h5><p>复杂实现：使用read_some函数，需要每次将读出来的数据_data组装到合适的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred, pointer session)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">2000</span>));<br>        <span class="hljs-comment">//已经移动的字符数</span><br>        <span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 核心是将接收的数据buffer: _data放入到合适的位置</span><br>        <span class="hljs-keyword">while</span> (bytes_transferred&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 正在接收头部？</span><br>            <span class="hljs-comment">//     头部还没完成，复制数据后return</span><br>            <span class="hljs-comment">//     头部完成还有剩余，复制头部数据后，continue</span><br><br>            <span class="hljs-comment">// 接收数据部分</span><br>            <span class="hljs-comment">//     接收不够，复制数据后return</span><br>            <span class="hljs-comment">//     接收超出，复制数据、回发报文、处理剩下的</span><br><br>            <span class="hljs-keyword">if</span>(!_b_head_parse)&#123;<br>                <span class="hljs-keyword">if</span>(bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH)&#123;<br>                    <span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>                    _recv_head_node-&gt;_cur_len += bytes_transferred;<br>                    copy_len += bytes_transferred;<br>                    bytes_transferred -= bytes_transferred;<br>                    <span class="hljs-keyword">continue</span> ;<br>                &#125;<br><br>                <span class="hljs-comment">// head and body</span><br>                <span class="hljs-type">short</span> left_head = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;<br>                <span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, left_head);<br>                copy_len += left_head;<br>                bytes_transferred -= left_head;<br><br>                <span class="hljs-type">short</span> data_len;<br>                <span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br>                std::cout&lt;&lt; <span class="hljs-string">&quot;recieve data len: &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;<br><br>                _recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br>                _recv_msg_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br>                _b_head_parse = <span class="hljs-literal">true</span>;<br><br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(bytes_transferred + _recv_msg_node-&gt;_cur_len &lt; _recv_msg_node-&gt;_total_len)&#123;<br>                    <span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>                    _recv_msg_node-&gt;_cur_len += bytes_transferred;<br>                    copy_len += bytes_transferred;<br>                    bytes_transferred -= bytes_transferred;<br>                    <span class="hljs-keyword">continue</span> ;<br>                &#125;<br><br>                <span class="hljs-type">short</span> left_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br>                <span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, left_msg);<br>                bytes_transferred -= left_msg;<br>                copy_len += left_msg;<br>                _recv_msg_node-&gt;_cur_len += left_msg;<br><br>                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                std::cout&lt;&lt; <span class="hljs-string">&quot;recieve msg: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;<br><br>                <span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br>                _b_head_parse = <span class="hljs-literal">false</span>;<br><br>            &#125;<br>        &#125;<br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length), <br>                        std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read, <span class="hljs-keyword">this</span>,  placeholders::_1, placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理客户端也要做一定的修改，额外添加长度并且收发分离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">thread <span class="hljs-title">send_thread</span><span class="hljs-params">([&amp;socket] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">for</span>(;;)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">10</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> * message = <span class="hljs-string">&quot;Hello from client!&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">char</span> send_data[MAX_LENGTH];</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">short</span> msg_len = strlen(message);</span></span><br><span class="hljs-params"><span class="hljs-function">                memcpy(send_data, &amp;msg_len, HEAD_LENGTH);</span></span><br><span class="hljs-params"><span class="hljs-function">                memcpy(send_data + HEAD_LENGTH, message, msg_len);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                boost::asio::write(socket, boost::asio::buffer(send_data, msg_len + HEAD_LENGTH));</span></span><br><span class="hljs-params"><span class="hljs-function">                cout &lt;&lt; <span class="hljs-string">&quot;Message sent: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br><br>        <span class="hljs-function">thread <span class="hljs-title">recv_thread</span><span class="hljs-params">([&amp;socket] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">for</span> (;;) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-comment">// 接收回显</span></span></span><br><span class="hljs-params"><span class="hljs-function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">2</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">char</span> reply_head[HEAD_LENGTH];</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">size_t</span> reply_length = boost::asio::read(socket, boost::asio::buffer(reply_head, HEAD_LENGTH));</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">short</span> reply_len;</span></span><br><span class="hljs-params"><span class="hljs-function">                memcpy(&amp;reply_len, &amp;reply_head, HEAD_LENGTH);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">char</span> msg[MAX_LENGTH] = &#123;<span class="hljs-number">0</span>&#125;;</span></span><br><span class="hljs-params"><span class="hljs-function">                reply_length = boost::asio::read(socket, boost::asio::buffer(msg, reply_len));</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                cout &lt;&lt; <span class="hljs-string">&quot;Server replied: &quot;</span> &lt;&lt; string(msg, reply_length) &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="字节序和序列化"><a href="#字节序和序列化" class="headerlink" title="字节序和序列化"></a>字节序和序列化</h4><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>多字节数据在内存中的存储顺序。</p><ul><li><strong>大端序（Big-Endian）</strong>：高位字节存储在低地址</li><li><strong>小端序（Little-Endian）</strong>：低位字节存储在低地址</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">0x12345678<br>大端序存储<br>内存地址： 0x1000  0x1001  0x1002  0x1003<br>内存内容：  <span class="hljs-number"> 12 </span>    <span class="hljs-number"> 34 </span>    <span class="hljs-number"> 56 </span>    <span class="hljs-number"> 78 </span>  <br><br>小端<br>内存地址： 0x1000  0x1001  0x1002  0x1003<br>内存内容：  <span class="hljs-number"> 78 </span>    <span class="hljs-number"> 56 </span>    <span class="hljs-number"> 34 </span>    <span class="hljs-number"> 12 </span>  <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 当前系统为小端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当前系统为大端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>长度信息，发送接收统一<strong>本地序-&gt;网络序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len=boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br><br><br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span> * msg, <span class="hljs-type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="hljs-number">0</span>)&#123;<br>    _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len<span class="hljs-number">+1</span>]();<br>    <span class="hljs-comment">//转为网络字节序</span><br>    <span class="hljs-type">int</span> max_len_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(max_len);<br>    <span class="hljs-built_in">memcpy</span>(_data, &amp;max_len_host, HEAD_LENGTH);<br>    <span class="hljs-built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len);<br>    _data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h5><p>Protocol Buffers（简称 Protobuf）是一种轻便高效的序列化数据结构的协议，由 Google 开发。它可以用于将结构化数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域。 我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install protobuf<br><br>protoc --cpp_out=. message.proto<br><br>clang++ -std=c++17 main.cpp message.pb.cc -I/opt/homebrew/include -L/opt/homebrew/lib \<br>  -lprotobuf -labsl_base -labsl_log_internal_check_op -labsl_log_internal_message \<br>  -labsl_log_internal_log_sink_set -o main<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">syntax</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;proto3&quot;</span><span class="hljs-comment">;</span><br>package tutorial<span class="hljs-comment">;</span><br><br>message Person &#123;<br>  string name <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  int32 id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>  string email <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;message.pb.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    tutorial::Person person;<br>    person.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;John Doe&quot;</span>);<br>    person.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">123</span>);<br>    person.<span class="hljs-built_in">set_email</span>(<span class="hljs-string">&quot;john@example.com&quot;</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Person: &quot;</span> &lt;&lt; person.<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 序列化为字符串</span><br>    std::string serialized_str;<br>    person.<span class="hljs-built_in">SerializeToString</span>(&amp;serialized_str);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;序列化后大小: &quot;</span> &lt;&lt; serialized_str.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 反序列化</span><br>    tutorial::Person deserialized_person;<br>    <span class="hljs-keyword">if</span> (deserialized_person.<span class="hljs-built_in">ParseFromString</span>(serialized_str)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;反序列化成功!&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;反序列化后的 Person: &quot;</span> &lt;&lt; deserialized_person.<span class="hljs-built_in">name</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot;, ID: &quot;</span> &lt;&lt; deserialized_person.<span class="hljs-built_in">id</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot;, Email: &quot;</span> &lt;&lt; deserialized_person.<span class="hljs-built_in">email</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;反序列化失败!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="json"><a href="#json" class="headerlink" title="json"></a>json</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/json.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> json = boost::json;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    json::object obj;<br>    obj[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span>;<br>    obj[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">30</span>;<br>    obj[<span class="hljs-string">&quot;skills&quot;</span>] = json::array&#123;<span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;JSON&quot;</span>&#125;;<br><br>    <span class="hljs-comment">// 序列化</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;序列化输出: &quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; obj &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 转换为字符串用于反序列化</span><br>    std::string json_str = json::<span class="hljs-built_in">serialize</span>(obj);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n字符串形式: &quot;</span> &lt;&lt; json_str &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 反序列化</span><br>    json::value parsed = json::<span class="hljs-built_in">parse</span>(json_str);<br><br>    <span class="hljs-comment">// 访问反序列化后的数据</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n反序列化后访问数据: &quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; parsed.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-built_in">as_string</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;年龄: &quot;</span> &lt;&lt; parsed.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-built_in">as_int64</span>() &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;技能: &quot;</span>;<br>    json::array skills = parsed.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;skills&quot;</span>).<span class="hljs-built_in">as_array</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; skills.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        std::cout &lt;&lt; skills[i].<span class="hljs-built_in">as_string</span>();<br>        <span class="hljs-keyword">if</span> (i &lt; skills.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逻辑层-08"><a href="#逻辑层-08" class="headerlink" title="逻辑层-08"></a>逻辑层-08</h4><p>目前所有的逻辑只有一个线程处理，无法充分利用多线程</p><ul><li>之前的逻辑层和asio回调在一个线程中顺序处理，一个socket时间长可能会影响其他socket消息的处理。</li><li>现在业务处理放到一个队列中，由逻辑层消费者线程处理<ul><li>逻辑层在接收到用户的消息后，处理具体的业务，如查询数据库</li></ul></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-2.png" alt="image-20250428095058092"></p><p><strong>解决方案</strong>：再抽象一层，handle_read读取出用户请求后加入事件就绪队列，逻辑层额外单线程或多线程处理这个队列。redis类似就是这种设计</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-05-16-152244743.png" alt="image-20250428095336148"></p><p>数据包格式改造：tlv格式，增加id字段作为type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">short</span> _cur_len;<br>    <span class="hljs-type">short</span> _total_len;<br>    <span class="hljs-type">short</span> _msg_id;<br>    <span class="hljs-type">char</span>* _data;<br></code></pre></td></tr></table></figure><h5 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h5><p>本质上是一个生产者消费者模型，asio是生产者，而逻辑线程是消费者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionExample</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::mutex _mutex;                <span class="hljs-comment">// 互斥锁</span><br>    std::condition_variable _consume; <span class="hljs-comment">// 条件变量</span><br>    <span class="hljs-type">bool</span> cond = <span class="hljs-literal">false</span>;                <span class="hljs-comment">// 这里可以是任何条件表达式</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waitForCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建唯一锁，用于自动管理互斥锁</span><br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <br>        <span class="hljs-comment">// 使用while循环检查条件，防止虚假唤醒</span><br>        <span class="hljs-keyword">while</span> (!cond) &#123;<br>            <span class="hljs-comment">// 释放锁并等待，当被通知时重新获取锁</span><br>            _consume.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <br>        <span class="hljs-built_in">assert</span>(cond);  <span class="hljs-comment">// 此时条件肯定满足</span><br>        <br>        <span class="hljs-comment">// 条件满足后的处理逻辑</span><br>        <br>        <span class="hljs-comment">// 作用域结束时自动释放互斥锁</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signalCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建唯一锁</span><br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <br>        <span class="hljs-comment">// 更新条件</span><br>        cond = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 或其他使条件成立的逻辑</span><br>        <br>        <span class="hljs-comment">// 通知所有等待的线程</span><br>        _consume.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 相当于notifyAll</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">wait(lock) 内部执行</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">&#123;</span><br><span class="hljs-attribute">  1. 将当前线程加入条件变量的等待队列</span><br><span class="hljs-attribute">  2. 原子地释放互斥锁</span><br><span class="hljs-attribute">  3. 将线程置于睡眠状态</span><br><span class="hljs-attribute">  4. 被唤醒后重新获取互斥锁</span><br><span class="hljs-attribute">  5. 返回到调用点</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">notify操作的执行流程</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">notify_one()</span><span class="hljs-punctuation">:</span> <span class="hljs-string">从等待队列中选择一个线程唤醒</span><br>  <span class="hljs-attribute">notify_all()</span><span class="hljs-punctuation">:</span> <span class="hljs-string">唤醒等待队列中的所有线程</span><br>  <span class="hljs-attribute">被唤醒的线程会竞争获取互斥锁，只有获得锁后才能继续执行</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">等待与唤醒机制</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">Linux</span><span class="hljs-punctuation">:</span> <span class="hljs-string">使用futex系统调用(fast userspace mutex)</span><br>  <span class="hljs-attribute">Windows</span><span class="hljs-punctuation">:</span> <span class="hljs-string">使用WaitForSingleObject和条件变量API</span><br>  现代实现大多使用futex避免不必要的内核态切换<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">notify时的锁管理<br>C++<br>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>    cond = <span class="hljs-literal">true</span>;<br>&#125;  <span class="hljs-comment">// 先释放锁</span><br>_cv.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 再通知</span><br>效率考量:<br>  持有锁时通知会导致被唤醒线程立即阻塞在锁获取上<br>  先释放锁再通知可以减少线程切换开销<br>执行顺序:<br>先改变条件再发出通知的顺序是关键<br>先通知后改变条件会导致竞态条件<br></code></pre></td></tr></table></figure><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span>  function&lt;<span class="hljs-type">void</span>(F&lt;CSession&gt;, <span class="hljs-type">short</span> msg_id, string msg_data)&gt; FunCallBack;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicSystem</span>:<span class="hljs-keyword">public</span> Singleton&lt;LogicSystem&gt;&#123;<br><br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 生产者消费者中的并发控制</span><br>  std::mutex _mutex;<br>    std::condition_variable _consume;<br><br>    <span class="hljs-comment">// 消费队列</span><br>    std::queue&lt;shared_ptr&lt;LogicNode&gt;&gt; _msg_queue;<br><br>    <span class="hljs-comment">// 回调函数  根据id 决定不同的回调函数</span><br>    std::map&lt;<span class="hljs-type">short</span>, FunCallBack&gt; _fun_callbacks;<br>    <br>    std::thread _thread;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// #include &lt;thread&gt;</span><br><span class="hljs-comment">// #include &lt;memory&gt;</span><br><span class="hljs-comment">// #include &lt;functional&gt;</span><br><span class="hljs-comment">// #include &lt;boost/asio.hpp&gt;</span><br><span class="hljs-comment">// #include &quot;const.h&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MsgNode.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;session.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Singleton.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LogicSystem.h&quot;</span></span><br><br><br>LogicSystem::<span class="hljs-built_in">LogicSystem</span>():_b_stop(<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-built_in">RegisterCallBacks</span>();<br>    _thread = std::<span class="hljs-built_in">thread</span>(&amp;LogicSystem::DealMsg, <span class="hljs-keyword">this</span>);<br>&#125;<br><br>LogicSystem::~<span class="hljs-built_in">LogicSystem</span>()&#123;<br>    _b_stop = <span class="hljs-literal">true</span>;<br>    _consume.<span class="hljs-built_in">notify_one</span>();<br>    _thread.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::PostMsgToQue</span><span class="hljs-params">(std::shared_ptr &lt;LogicNode&gt; msg)</span></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>    _msg_queue.<span class="hljs-built_in">push</span>(msg);<br><br>    <span class="hljs-comment">// 这里是不管三七二十一都通知，也可以是转为非空时 进行通知，其他时间不通知</span><br>    <span class="hljs-comment">// 通知前可以先主动释放锁unique_lk.unlock(); 但也可以默认退出作用域自动释放</span><br>    _consume.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::DealOneMsg</span><span class="hljs-params">(std::shared_ptr&lt;LogicNode&gt; msg)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> it = _fun_callbacks.<span class="hljs-built_in">find</span>(msg-&gt;_recvnode-&gt;_msg_id);<br>    <span class="hljs-keyword">if</span>(it != _fun_callbacks.<span class="hljs-built_in">end</span>())&#123;<br>        it-&gt;<span class="hljs-built_in">second</span>(msg-&gt;_session, msg-&gt;_recvnode-&gt;_msg_id, <br>            std::<span class="hljs-built_in">string</span>(msg-&gt;_recvnode-&gt;_data, msg-&gt;_recvnode-&gt;_total_len));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::DealMsg</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br><br>        <span class="hljs-keyword">while</span>(_msg_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; !_b_stop)&#123;<br>            _consume.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(_b_stop)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;LogicSystem is stop, process the left&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">while</span>(!_msg_queue.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">auto</span> msg = _msg_queue.<span class="hljs-built_in">front</span>();<br>                _msg_queue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">DealOneMsg</span>(msg);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> msg = _msg_queue.<span class="hljs-built_in">front</span>();<br>        _msg_queue.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-comment">// 提前unlock，防止处理线程一直拿着锁！！！</span><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-built_in">DealOneMsg</span>(msg);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::RegisterCallBacks</span><span class="hljs-params">()</span></span>&#123;<br>    _fun_callbacks[MSG_IDS::MSG_HELLO_WORLD] = <br>        <span class="hljs-built_in">bind</span>(&amp;LogicSystem::HelloWordCallBack, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2, placeholders::_3);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogicSystem::HelloWordCallBack</span><span class="hljs-params">(shared_ptr&lt;Session&gt; session, <span class="hljs-type">short</span> msg_id, string msg_data)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World call back! &quot;</span> &lt;&lt; msg_data &lt;&lt; std::endl;<br><br>    this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10000</span>));<br><br>    <span class="hljs-type">char</span>* non_const_msg_data = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(msg_data.<span class="hljs-built_in">c_str</span>());<br>    session-&gt;<span class="hljs-built_in">Send</span>(non_const_msg_data, msg_data.<span class="hljs-built_in">length</span>(), MSG_IDS::MSG_HELLO_WORLD);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h5><p>利用signal_set 定义了一系列信号合集，并且绑定了一个匿名函数，匿名函数捕获了io_context的引用，并且函数中设置了停止操作，也就是说当捕获到SIGINT,SIGTERM等信号时，会调用<code>io_context.stop</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span> <span class="hljs-comment">// For SIGINT and SIGTERM</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        boost::asio::io_context  io_context;<br>        boost::<span class="hljs-function">asio::signal_set <span class="hljs-title">signals</span><span class="hljs-params">(io_context, SIGINT, SIGTERM)</span></span>;<br>        signals.<span class="hljs-built_in">async_wait</span>([&amp;io_context](<span class="hljs-keyword">auto</span>, <span class="hljs-keyword">auto</span>) &#123;<br>            io_context.<span class="hljs-built_in">stop</span>();<br>            &#125;);<br>        <span class="hljs-function">CServer <span class="hljs-title">s</span><span class="hljs-params">(io_context, <span class="hljs-number">10086</span>)</span></span>;<br>        io_context.<span class="hljs-built_in">run</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多线程ioc-09"><a href="#多线程ioc-09" class="headerlink" title="多线程ioc-09"></a>多线程ioc-09</h4><p><a href="https://xiaolincoding.com/os/8_network_system/reactor.html">https://xiaolincoding.com/os/8_network_system/reactor.html</a></p><ul><li>图中业务处理是串联的，实际上业务我们已经交给了业务线程</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-3.png" alt="image-20250508213456352"></p><p>之前是解耦了io和业务处理，现在将io进一步解耦并扩展</p><h5 id="多ioc-多线程"><a href="#多ioc-多线程" class="headerlink" title="多ioc+多线程"></a>多ioc+多线程</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-4.png" alt="image-20250508172344229"></p><p>运行多个io_context在不同的线程中，主线程还是一个io_context用于处理客户端接收连接，客户端的读写请求用pool中的某一个io_context处理。实现在io层面多线程，并且接受客户端请求和处理客户端读写分开。</p><ul><li>之前：一个io_context负责服务器socket接受新客户端，同时负责所有客户端socket读写</li><li>现在：io_context只负责接受新客户端，接收到的客户端由pool中的ioc负责读写<ul><li>同一个客户端，绑定的始终是<strong>同一个</strong>pool中的ioc</li><li>每一个ioc可以理解为创建了一个独立的epoll，并有一个线程处理</li><li>一个主线程做 listen&#x2F;accept，N 个 I&#x2F;O 线程各自跑自己的 EventLoop（每个对应一个 epoll 实例），accept 分发新连接给不同子 loop。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsioIOServicePool</span>: <span class="hljs-keyword">public</span> Singleton&lt;AsioIOServicePool&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;AsioIOServicePool&gt;;<br><br><br>    <span class="hljs-keyword">using</span> WorkGuard = boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;;<br>    <span class="hljs-keyword">using</span> WorkGuardPtr = std::unique_ptr&lt;WorkGuard&gt;;<br><br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">AsioIOServicePool</span>();<br><br>    boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">GetIOService</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">AsioIOServicePool</span>(std::<span class="hljs-type">size_t</span> size = std::thread::<span class="hljs-built_in">hardware_concurrency</span>());<br><br>    std::vector&lt;boost::asio::io_context&gt; _io_contexts;<br><br>  <span class="hljs-comment">// 防止没有注册事件的ioc直接结束了</span><br>    std::vector&lt;WorkGuardPtr&gt; _works;<br>    std::vector&lt;std::thread&gt; _threads;<br>    std::<span class="hljs-type">size_t</span>   _nextIOService;<br>&#125;;<br>AsioIOServicePool::<span class="hljs-built_in">AsioIOServicePool</span>(std::<span class="hljs-type">size_t</span> size):_io_contexts(size), _works(size), _nextIOService(<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        _works[i] = std::<span class="hljs-built_in">make_unique</span>&lt;WorkGuard&gt;(boost::asio::<span class="hljs-built_in">make_work_guard</span>(_io_contexts[i]));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        _threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>, i]()&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;IOService thread &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; started.&quot;</span> &lt;&lt; std::endl;<br>            _io_contexts[i].<span class="hljs-built_in">run</span>();<br>        &#125;);<br>    &#125;<br>&#125;<br>boost::<span class="hljs-function">asio::io_context&amp; <span class="hljs-title">AsioIOServicePool::GetIOService</span><span class="hljs-params">()</span></span>&#123;<br>    _nextIOService = (_nextIOService + <span class="hljs-number">1</span>) % _io_contexts.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">return</span> _io_contexts[_nextIOService];<br>&#125;<br><br><br><span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(ioc, port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Session* new_session = new Session(_ioc);</span><br>    <span class="hljs-keyword">auto</span>&amp; ioc = AsioIOServicePool::<span class="hljs-built_in">getInstance</span>()-&gt;<span class="hljs-built_in">GetIOService</span>();<br>    shared_ptr&lt;Session&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;Session&gt;(ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-05-16-203252837.png" alt="image-20250508213523316"></p><h6 id="对比tomcat"><a href="#对比tomcat" class="headerlink" title="对比tomcat"></a>对比tomcat</h6><table><thead><tr><th>Layer</th><th>Your Asio Server</th><th>Tomcat NIO Connector</th></tr></thead><tbody><tr><td>接收连接<br />监听 socket 上的 IO<br />处理请求</td><td>main_ioc+<br />AsioIOServicePool+<br />LogicSystem</td><td>Acceptor（接收线程+ <br />Poller（Selector 轮询线程+<br /> Worker（请求处理线程池）</td></tr><tr><td><strong>Accept</strong></td><td>1 acceptor on <code>main io_context</code></td><td>1 (or configurable) acceptor threads</td></tr><tr><td><strong>I&#x2F;O Reactors</strong></td><td>N <code>io_context</code> threads</td><td>1 (by default) NIO selector thread</td></tr><tr><td><strong>I&#x2F;O → Business Handoff</strong></td><td><code>LogicSystem::PostMsgToQue</code> → separate queue</td><td>selector thread hands to a servlet thread pool</td></tr><tr><td><strong>Business Threads</strong></td><td>1 (or more if you extend) <code>LogicSystem</code> thread(s)</td><td>configurable <code>maxThreads</code> executor (200+)</td></tr></tbody></table><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss">      ┌────────────────────────┐<br>      │   <span class="hljs-selector-tag">Main</span> Thread (Acceptor)│<br>      │   - async_accept       │<br>      └────────────┬───────────┘<br>                   ↓<br>┌────────────────────────────────────┐<br>│         AsioIOServicePool          │<br>│   (like Poller / Selector pool)    │<br>└────────────┬────────────┬──────────┘<br>             ↓            ↓<br>      ┌────────────┐ ┌────────────┐<br>      │ Session N  │ │ Session M  │ ...<br>      └────┬───────┘ └────┬───────┘<br>           ↓              ↓<br>     │PostMsgToQue│ │PostMsgToQue│<br>           ↓              ↓<br>   ┌─────────────────────────────────┐<br>   │       LogicSystem (Worker)      │<br>   │     单线程 → 改为线程池优化        │<br>   └─────────────────────────────────┘<br></code></pre></td></tr></table></figure><h5 id="单ioc-多线程run"><a href="#单ioc-多线程run" class="headerlink" title="单ioc+多线程run"></a>单ioc+多线程run</h5><p>直接同一个ioc，但多个线程中执行run</p><ul><li>只有一个内核事件队列，也就是epoll实例</li><li>多个线程同时调用ioc.run，也就是<code>epoll_wait</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadNum; ++i) &#123;<br>    _threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]() &#123;<br>        _service.<span class="hljs-built_in">run</span>();<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-5.png" alt="image-20250508210545803"></p><ul><li>可以多个线程执行回调函数</li><li>存在问题，可能多个线程同时处理同一个用户socket，导致并发以及处理顺序问题（同时调用回调）</li><li>引入一个strand，实现维护一个队列：<strong>保证所有通过同一个 <code>strand</code> 提交的 handler，永远不会并行执行</strong>，它们会“排队”并由某个线程一个接一个地执行。</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-6.png" alt="image-20250508210243102"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在 Session 里声明：</span><br>boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; _strand;<br><br><span class="hljs-comment">// 构造函数里初始化：</span><br><span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc)<br>  : _socket(ioc), _strand(ioc.<span class="hljs-built_in">get_executor</span>()) &#123; ... &#125;<br><br><span class="hljs-comment">// async 调用时包装到 strand：</span><br>boost::asio::<span class="hljs-built_in">async_read</span>(_socket, buf,<br>  boost::asio::<span class="hljs-built_in">bind_executor</span>(_strand,<br>    std::<span class="hljs-built_in">bind</span>(&amp;Session::handle_read_fix, <span class="hljs-built_in">shared_from_this</span>(), ...))<br>);<br><br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/2025-06-17-224700612-7.png" alt="image-20250508213440635"></p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li><strong>轻量级</strong>： 协程运行在用户态，不需要操作系统提供线程上下文切换支持，因此比线程更加轻量级。</li><li><strong>非抢占式</strong>： 协程的切换是由程序员显式控制的（通常通过 <code>yield</code> 或 <code>await</code>），而非由操作系统抢占。</li><li><strong>单线程并发</strong>： 协程虽然可以实现并发，但它们是在单线程内完成的，没有真正的并行。</li><li><strong>状态保存</strong>： 协程可以在中途暂停并保存当前执行状态，稍后恢复并继续执行。</li></ul><table><thead><tr><th>特性</th><th>协程</th><th>线程</th></tr></thead><tbody><tr><td>调度方式</td><td>主动让出控制权（协作式）</td><td>由操作系统内核调度（抢占式）</td></tr><tr><td>开销</td><td>轻量级，创建和上下文切换很快</td><td>较重，需要系统资源进行调度</td></tr><tr><td>并发能力</td><td>单线程中的并发</td><td>多线程并发，支持多核并行</td></tr><tr><td>共享数据安全性</td><td>不需要同步机制（单线程）</td><td>需要锁等同步机制</td></tr></tbody></table><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>HTTP 请求头:</p><ul><li><strong>Request-line</strong>：包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</li><li><strong>Host</strong>：指定被请求资源的主机名或IP地址和端口号。</li><li><strong>Accept</strong>：指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text&#x2F;plain, text&#x2F;html。</li><li><strong>User-Agent</strong>：客户端使用的浏览器类型和版本号，供服务器统计用户代理信息。</li><li><strong>Cookie</strong>：如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</li><li><strong>Connection</strong>：表示是否需要持久连接（keep-alive）。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html, application/xhtml+xml, */*<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>sessionid=abcdefg1234567<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><p>HTTP 响应头:</p><ul><li><strong>Status-line</strong>：包含协议版本、状态码和状态消息。</li><li><strong>Content-Type</strong>：响应体的MIME类型。</li><li><strong>Content-Length</strong>：响应体的字节数。</li><li><strong>Set-Cookie</strong>：服务器向客户端发送cookie信息时使用该字段。</li><li><strong>Server</strong>：服务器类型和版本号。</li><li><strong>Connection</strong>：表示是否需要保持长连接（keep-alive）。</li></ul><p>在实际的HTTP报文头中，还可以包含其他可选字段。 如下是一个http响应头的示例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content</span>-Type: text/html; charset=UTF-<span class="hljs-number">8</span><br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">1024</span><br><span class="hljs-attribute">Set</span>-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/<br><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">32</span> (Unix) mod_ssl/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">32</span> OpenSSL/<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>e-fips mod_bwlimited/<span class="hljs-number">1</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">Connection</span>: keep-alive<br></code></pre></td></tr></table></figure><h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(hello_function)</span></span>; <span class="hljs-comment">// 创建线程</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside scope&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 没有调用t.join()或t.detach()</span><br>    &#125; <span class="hljs-comment">// t离开作用域 - 程序在这里终止</span><br><br>    <span class="hljs-comment">// 这行永远不会执行</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Outside scope&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始实现秒杀系统（四）：系统优化篇</title>
    <link href="/2025/02/21/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F4/"/>
    <url>/2025/02/21/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F4/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文介绍了秒杀系统的关键优化技术，重点解决高并发下系统的稳定性、性能和数据一致性问题。主要优化措施包括：    1. <strong>分布式限流</strong>：基于Redis的令牌桶算法实现精准流量控制，通过注解和AOP实现接口级限流，防止瞬时流量击垮系统。    2. <strong>订单超时处理</strong>：利用RocketMQ延时消息实现未支付订单的自动取消和库存释放，确保库存数据准确性。    3. <strong>多级缓存优化</strong>：引入Guava本地缓存与Redis形成两级缓存，加速库存耗尽判断，减少Redis访问压力。    4. <strong>库存对账机制</strong>：通过动态水位线策略对Redis与数据库库存进行一致性校验，包括核心公式”Redis库存 + 预占库存 &#x3D; 数据库库存”，并实现自动重试和告警功能，确保数据最终一致。    这些技术共同提升了系统的健壮性、可靠性和响应速度，使其能有效应对海量并发请求，同时保持高性能和数据准确性。</p></blockquote><h1 id="从零开始实现秒杀系统（四）：系统优化篇"><a href="#从零开始实现秒杀系统（四）：系统优化篇" class="headerlink" title="从零开始实现秒杀系统（四）：系统优化篇"></a>从零开始实现秒杀系统（四）：系统优化篇</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在前三篇文章中，我们从基础版本开始，通过引入Redis缓存和RocketMQ消息队列，逐步构建了一个高性能的秒杀系统。然而，在面对海量用户同时抢购时，系统仍然面临着几个关键挑战：如何有效控制流量、如何保证数据一致性、如何处理超时订单，以及如何进一步提升系统性能。</p><p>本文作为系列的第四篇，将介绍几种关键的系统优化技术，使我们的秒杀系统更加健壮和高效。</p><h2 id="系统优化核心技术"><a href="#系统优化核心技术" class="headerlink" title="系统优化核心技术"></a>系统优化核心技术</h2><h3 id="一、基于Redis的分布式限流保护"><a href="#一、基于Redis的分布式限流保护" class="headerlink" title="一、基于Redis的分布式限流保护"></a>一、基于Redis的分布式限流保护</h3><p>在高并发场景下，没有限流保护的系统很容易被瞬时流量击垮。我们实现了一个基于Redis的分布式令牌桶限流机制，可以有效控制接口的访问频率。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027938.png" alt="image-20250310162452284"></p><h4 id="1-1-限流注解设计"><a href="#1-1-限流注解设计" class="headerlink" title="1.1 限流注解设计"></a>1.1 限流注解设计</h4><p>首先，我们设计了一个简单易用的注解，可以轻松地为任何接口添加限流功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RateLimit &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 限流唯一标识，用于区分不同接口的限流</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 限流模式，支持按用户ID、IP、全局限流</span><br><span class="hljs-comment">     */</span><br>    RateLimitType <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> RateLimitType.USER;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 令牌生成速率，每秒生成的令牌数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">rate</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1.0</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 令牌桶容量，允许突发请求的最大数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单次请求消耗的令牌数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">tokens</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 限流提示消息</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;请求过于频繁，请稍后再试&quot;</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 限流类型枚举</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RateLimitType</span> &#123;<br>        USER,  <span class="hljs-comment">// 按用户ID限流</span><br>        IP,    <span class="hljs-comment">// 按IP限流</span><br>        GLOBAL <span class="hljs-comment">// 全局限流</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-Redis令牌桶算法实现"><a href="#1-2-Redis令牌桶算法实现" class="headerlink" title="1.2 Redis令牌桶算法实现"></a>1.2 Redis令牌桶算法实现</h4><p>我们使用Lua脚本在Redis中实现了令牌桶算法，确保限流操作的原子性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisRateLimiter</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br>    <br>    <span class="hljs-keyword">private</span> DefaultRedisScript&lt;Long&gt; tokenBucketScript;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        tokenBucketScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        tokenBucketScript.setScriptSource(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;scripts/token_bucket.lua&quot;</span>)));<br>        tokenBucketScript.setResultType(Long.class);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获取令牌</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(String key, <span class="hljs-type">double</span> rate, <span class="hljs-type">int</span> capacity, <span class="hljs-type">int</span> requested)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; keys = Collections.singletonList(key);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <br>            <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.execute(<br>                tokenBucketScript, <br>                keys, <br>                Double.toString(rate), <br>                Integer.toString(capacity), <br>                Long.toString(now),<br>                Integer.toString(requested)<br>            );<br>            <br>            <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span> ? result : -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Error executing token bucket script for key: &#123;&#125;&quot;</span>, key, e);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，token_bucket.lua脚本实现了令牌桶核心算法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取基本参数</span><br><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> rate = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">local</span> capacity = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">local</span> now = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])<br><span class="hljs-keyword">local</span> requested = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">4</span>])<br><br><span class="hljs-comment">-- 获取令牌桶当前状态</span><br><span class="hljs-keyword">local</span> bucket = redis.call(<span class="hljs-string">&#x27;hmget&#x27;</span>, key, <span class="hljs-string">&#x27;last_refresh&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>)<br><span class="hljs-keyword">local</span> last_refresh = <span class="hljs-built_in">tonumber</span>(bucket[<span class="hljs-number">1</span>]) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">local</span> tokens = <span class="hljs-built_in">tonumber</span>(bucket[<span class="hljs-number">2</span>]) <span class="hljs-keyword">or</span> capacity<br><br><span class="hljs-comment">-- 计算时间间隔内新生成的令牌</span><br><span class="hljs-keyword">local</span> elapsed = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, now - last_refresh)<br><span class="hljs-keyword">local</span> new_tokens = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(capacity, tokens + (elapsed / <span class="hljs-number">1000.0</span>) * rate)<br><br><span class="hljs-comment">-- 检查令牌是否足够</span><br><span class="hljs-keyword">if</span> new_tokens &lt; requested <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 令牌不足，计算需要等待的时间</span><br>    <span class="hljs-keyword">local</span> wait_time = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">ceil</span>((requested - new_tokens) * <span class="hljs-number">1000</span> / rate)<br>    <span class="hljs-keyword">return</span> -wait_time<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">-- 令牌足够，更新令牌桶</span><br>    <span class="hljs-keyword">local</span> remaining = new_tokens - requested<br>    redis.call(<span class="hljs-string">&#x27;hmset&#x27;</span>, key, <span class="hljs-string">&#x27;last_refresh&#x27;</span>, now, <span class="hljs-string">&#x27;tokens&#x27;</span>, remaining)<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, <span class="hljs-number">60</span>) <span class="hljs-comment">-- 设置60秒过期时间防止内存泄漏</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- 成功获取令牌</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="1-3-限流切面的应用"><a href="#1-3-限流切面的应用" class="headerlink" title="1.3 限流切面的应用"></a>1.3 限流切面的应用</h4><p>使用AOP技术自动拦截带有@RateLimit注解的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimitAspect</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisRateLimiter redisRateLimiter;<br>    <br>    <span class="hljs-meta">@Before(&quot;@annotation(com.example.seckill.annotation.RateLimit)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">(JoinPoint point)</span> &#123;<br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) point.getSignature();<br>        <span class="hljs-type">RateLimit</span> <span class="hljs-variable">rateLimit</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(RateLimit.class);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> buildRateLimitKey(rateLimit, point);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> redisRateLimiter.tryAcquireWithWaitTime(<br>            key, rateLimit.rate(), rateLimit.capacity(), rateLimit.tokens());<br>        <br>        <span class="hljs-keyword">if</span> (waitTime &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取令牌失败，需要等待</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> rateLimit.message();<br>            <span class="hljs-keyword">if</span> (waitTime &gt; <span class="hljs-number">1000</span>) &#123;<br>                message += <span class="hljs-string">&quot;，需等待&quot;</span> + (waitTime / <span class="hljs-number">1000</span>) + <span class="hljs-string">&quot;秒&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimitException</span>(message);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构建限流键</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">buildRateLimitKey</span><span class="hljs-params">(RateLimit rateLimit, JoinPoint point)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;rate_limit:&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (!rateLimit.key().isEmpty()) &#123;<br>            key.append(rateLimit.key()).append(<span class="hljs-string">&quot;:&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            key.append(point.getSignature().getDeclaringTypeName())<br>               .append(<span class="hljs-string">&quot;.&quot;</span>)<br>               .append(point.getSignature().getName())<br>               .append(<span class="hljs-string">&quot;:&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">switch</span> (rateLimit.type()) &#123;<br>            <span class="hljs-keyword">case</span> USER:<br>                key.append(<span class="hljs-string">&quot;user:&quot;</span>).append(point.getArgs()[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> IP:<br>                <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) <br>                    RequestContextHolder.getRequestAttributes()).getRequest();<br>                key.append(<span class="hljs-string">&quot;ip:&quot;</span>).append(getClientIp(request));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> GLOBAL:<br>                key.append(<span class="hljs-string">&quot;global&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> key.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用限流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/&#123;userId&#125;/&#123;goodsId&#125;&quot;)</span><br><span class="hljs-meta">@RateLimit(</span><br><span class="hljs-meta">    key = &quot;seckill&quot;, </span><br><span class="hljs-meta">    type = RateLimit.RateLimitType.IP, </span><br><span class="hljs-meta">    rate = 0.2,  // 每5秒允许1个请求</span><br><span class="hljs-meta">    capacity = 1, </span><br><span class="hljs-meta">    tokens = 1, </span><br><span class="hljs-meta">    message = &quot;操作频率超限，请稍后再试&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">seckill</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> Long userId,</span><br><span class="hljs-params">        <span class="hljs-meta">@PathVariable(&quot;goodsId&quot;)</span> Long goodsId)</span> &#123;<br>    <span class="hljs-comment">// 秒杀逻辑...</span><br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/result/&#123;userId&#125;/&#123;goodsId&#125;&quot;)</span><br><span class="hljs-meta">@RateLimit(</span><br><span class="hljs-meta">    key = &quot;result&quot;, </span><br><span class="hljs-meta">    type = RateLimit.RateLimitType.USER, </span><br><span class="hljs-meta">    rate = 1.5,  // 每秒1.5个请求</span><br><span class="hljs-meta">    capacity = 3, </span><br><span class="hljs-meta">    tokens = 1,</span><br><span class="hljs-meta">    message = &quot;查询太频繁，请稍后再试&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> Result&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getSeckillResult</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> Long userId,</span><br><span class="hljs-params">        <span class="hljs-meta">@PathVariable(&quot;goodsId&quot;)</span> Long goodsId)</span> &#123;<br>    <span class="hljs-comment">// 查询秒杀结果逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、基于RocketMQ延时消息的订单超时处理"><a href="#二、基于RocketMQ延时消息的订单超时处理" class="headerlink" title="二、基于RocketMQ延时消息的订单超时处理"></a>二、基于RocketMQ延时消息的订单超时处理</h3><p>在秒杀系统中，未支付的订单需要在一定时间后自动取消并释放库存。我们使用RocketMQ的延时消息实现了这一功能。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027939.png" alt="image-20250310161900445"></p><h4 id="2-1-订单创建时发送延时消息"><a href="#2-1-订单创建时发送延时消息" class="headerlink" title="2.1 订单创建时发送延时消息"></a>2.1 订单创建时发送延时消息</h4><p>在订单创建成功后，我们发送一条延时消息，用于触发订单超时取消：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendOrderCancellationMessage</span><span class="hljs-params">(String transactionId, <span class="hljs-type">int</span> delayLevel)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;Sending order cancellation message for transaction: &#123;&#125;, delayLevel: &#123;&#125;&quot;</span>, <br>            transactionId, delayLevel);<br>    <br>    Message&lt;String&gt; message = MessageBuilder<br>        .withPayload(transactionId)<br>        .build();<br>    <br>    rocketMQTemplate.asyncSend(<br>        TOPIC_ORDER_CANCEL, <br>        message,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendCallback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(SendResult sendResult)</span> &#123;<br>                log.info(<span class="hljs-string">&quot;Order cancellation message sent successfully for txId: &#123;&#125;&quot;</span>, transactionId);<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onException</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;Failed to send order cancellation message for txId: &#123;&#125;&quot;</span>, <br>                    transactionId, throwable);<br>            &#125;<br>        &#125;, <br>        producer.getSendMsgTimeout(), <br>        delayLevel<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>RocketMQ支持18个不同的延时等级，我们可以根据业务需要选择合适的延时级别。</p><h4 id="2-2-订单取消消费者实现"><a href="#2-2-订单取消消费者实现" class="headerlink" title="2.2 订单取消消费者实现"></a>2.2 订单取消消费者实现</h4><p>消费者接收到延时消息后，处理订单取消和库存回滚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RocketMQMessageListener(</span><br><span class="hljs-meta">    topic = MQProducer.TOPIC_ORDER_CANCEL,</span><br><span class="hljs-meta">    consumerGroup = &quot;order-cancellation-consumer-group&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCancellationConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RocketMQListener</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> GoodsDao goodsDao;<br>    <br>    <span class="hljs-comment">// Lua脚本用于回滚Redis库存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; ROLLBACK_STOCK_REDIS_SCRIPT = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(<br>            <span class="hljs-string">&quot;local stock = redis.call(&#x27;get&#x27;, KEYS[1]) &quot;</span> +<br>            <span class="hljs-string">&quot;if stock then &quot;</span> +<br>            <span class="hljs-string">&quot;   redis.call(&#x27;incr&#x27;, KEYS[1]) &quot;</span> +<br>            <span class="hljs-string">&quot;end &quot;</span> +<br>            <span class="hljs-string">&quot;local reserved = redis.call(&#x27;get&#x27;, KEYS[2]) &quot;</span> +<br>            <span class="hljs-string">&quot;if reserved and tonumber(reserved) &gt; 0 then &quot;</span> +<br>            <span class="hljs-string">&quot;   redis.call(&#x27;decr&#x27;, KEYS[2]) &quot;</span> +<br>            <span class="hljs-string">&quot;end &quot;</span> +<br>            <span class="hljs-string">&quot;return 1&quot;</span>, Long.class);<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String transactionId)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Received order cancellation message for transaction: &#123;&#125;&quot;</span>, transactionId);<br>        <span class="hljs-keyword">try</span> &#123;<br>            processOrderCancellation(transactionId);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Error processing order cancellation&quot;</span>, e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrderCancellation</span><span class="hljs-params">(String transactionId)</span> &#123;<br>        <span class="hljs-comment">// 1. 获取订单信息</span><br>        <span class="hljs-type">SeckillOrder</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderService.getOrderByTransactionId(transactionId);<br>        <br>        <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;Order not found for cancellation, transactionId: &#123;&#125;&quot;</span>, transactionId);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 2. 检查订单状态，只有未支付的订单才能取消</span><br>        <span class="hljs-keyword">if</span> (order.getStatus() != <span class="hljs-number">0</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;Order already processed (paid or cancelled), transactionId: &#123;&#125;&quot;</span>, <br>                    transactionId, order.getStatus());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3. 更新订单状态为已取消</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> orderService.cancelOrder(transactionId);<br>        <br>        <span class="hljs-keyword">if</span> (success) &#123;<br>            log.info(<span class="hljs-string">&quot;Order cancelled successfully: &#123;&#125;&quot;</span>, transactionId);<br>            <br>            <span class="hljs-comment">// 4. 回滚库存</span><br>            goodsDao.rollbackStock(order.getGoodsId());<br>            rollbackRedisStock(order.getGoodsId());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.error(<span class="hljs-string">&quot;Failed to cancel order: &#123;&#125;&quot;</span>, transactionId);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackRedisStock</span><span class="hljs-params">(Long goodsId)</span> &#123;<br>        redisService.executeScript(<br>            ROLLBACK_STOCK_REDIS_SCRIPT,<br>            Arrays.asList(<br>                redisService.getRealKey(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsId),<br>                redisService.getRealKey(SeckillKey.reservedStock, <span class="hljs-string">&quot;&quot;</span> + goodsId)<br>            )<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、多级缓存优化库存查询"><a href="#三、多级缓存优化库存查询" class="headerlink" title="三、多级缓存优化库存查询"></a>三、多级缓存优化库存查询</h3><p>为了进一步提高性能，我们实现了基于Guava Cache的本地缓存，与Redis形成多级缓存架构。本地的guava可以进一步加速无库存的判断，为了简化系统库存管理，具体的库存数量信息不使用guava进行存储，guava只用于判断库存是否耗尽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Local cache for sold-out goods with 5 minutes expiration</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Cache&lt;Long, Boolean&gt; localSoldOutCache = CacheBuilder.newBuilder()<br>    .maximumSize(<span class="hljs-number">1000</span>)  <span class="hljs-comment">// Maximum items in cache</span><br>    .expireAfterWrite(<span class="hljs-number">5</span>, TimeUnit.MINUTES)  <span class="hljs-comment">// Cache entries expire after 5 minutes</span><br>    .build();<br></code></pre></td></tr></table></figure><p>在进行库存判断是否耗尽时，先优先从本地guava中判断，减少对redis的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Mark goods as sold out</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGoodsOver</span><span class="hljs-params">(Long goodsId)</span> &#123;<br>    <span class="hljs-comment">// Update Redis</span><br>    redisService.set(SeckillKey.isGoodsOver, <span class="hljs-string">&quot;&quot;</span> + goodsId, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// Update local cache</span><br>    localSoldOutCache.put(goodsId, <span class="hljs-literal">true</span>);<br>    log.debug(<span class="hljs-string">&quot;Goods &#123;&#125; marked as sold out in both Redis and local cache&quot;</span>, goodsId);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Check if goods are sold out using local cache first, then Redis</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGoodsOver</span><span class="hljs-params">(Long goodsId)</span> &#123;<br>    <span class="hljs-comment">// First check local cache (much faster)</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isOver</span> <span class="hljs-operator">=</span> localSoldOutCache.getIfPresent(goodsId);<br>    <span class="hljs-keyword">if</span> (isOver != <span class="hljs-literal">null</span> &amp;&amp; isOver) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// If not in local cache, check Redis</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSoldOutInRedis</span> <span class="hljs-operator">=</span> redisService.exists(SeckillKey.isGoodsOver, <span class="hljs-string">&quot;&quot;</span> + goodsId);<br><br>    <span class="hljs-comment">// If found in Redis but not in local cache, update local cache</span><br>    <span class="hljs-keyword">if</span> (isSoldOutInRedis) &#123;<br>        localSoldOutCache.put(goodsId, <span class="hljs-literal">true</span>);<br>        log.debug(<span class="hljs-string">&quot;Goods &#123;&#125; sold-out status loaded from Redis to local cache&quot;</span>, goodsId);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isSoldOutInRedis;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、库存数据一致性对账机制"><a href="#四、库存数据一致性对账机制" class="headerlink" title="四、库存数据一致性对账机制"></a>四、库存数据一致性对账机制</h3><p>为了解决Redis与数据库库存可能出现的不一致问题，我们实现了一套库存对账机制。以监控系统缓存和数据库中数据一致性，并在不一致出现时及时告警。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027940.png" alt="image-20250310162206333"></p><h4 id="4-1-库存模型设计"><a href="#4-1-库存模型设计" class="headerlink" title="4.1 库存模型设计"></a>4.1 库存模型设计</h4><p>为确保数据一致性，我们设计了库存模型：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">Redis库存 + Redis预占库存 </span>=<span class="hljs-string"> 数据库总库存</span><br></code></pre></td></tr></table></figure><ul><li><strong>Redis库存</strong>：可售卖的实时库存</li><li><strong>Redis预占库存</strong>：已在Redis减少但尚未在数据库落库的预占量</li><li><strong>数据库总库存</strong>：真实的最终库存数据</li></ul><p>库存状态流转：</p><ol><li>秒杀请求扣减Redis可用库存(goodsStock)并增加预占库存(reservedStock)</li><li>MQ消费减少数据库库存，并减少对应的Redis预占库存</li></ol><p>这种设计确保了即使在消息处理过程中存在延迟，系统仍然能实现一致性对账。</p><h4 id="4-2-对账机制实现"><a href="#4-2-对账机制实现" class="headerlink" title="4.2 对账机制实现"></a>4.2 对账机制实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockReconciliationService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> GoodsService goodsService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br>    <br>    <span class="hljs-comment">// 对账相关配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ALERT_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">// 连续不一致触发告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOW_STOCK_THRESHOLD_PERCENTAGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>; <span class="hljs-comment">// 低库存门槛</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">RECONCILE_ALL_ITEMS</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 是否对账所有商品</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RETRY_DELAY_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; <span class="hljs-comment">// 重试间隔</span><br>    <br>    <span class="hljs-comment">// 使用Lua脚本原子获取Redis中的库存数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">GET_STOCK_VALUES_SCRIPT</span> <span class="hljs-operator">=</span> <br>        <span class="hljs-string">&quot;local stockValue = redis.call(&#x27;get&#x27;, KEYS[1]) &quot;</span> +<br>        <span class="hljs-string">&quot;local reservedValue = redis.call(&#x27;get&#x27;, KEYS[2]) &quot;</span> +<br>        <span class="hljs-string">&quot;local result = &#123;&#125; &quot;</span> +<br>        <span class="hljs-string">&quot;if stockValue == false then result[1] = &#x27;&#x27; else result[1] = stockValue end &quot;</span> +<br>        <span class="hljs-string">&quot;if reservedValue == false then result[2] = &#x27;&#x27; else result[2] = reservedValue end &quot;</span> +<br>        <span class="hljs-string">&quot;return result&quot;</span>;<br><br>    <span class="hljs-comment">// 定时对账任务</span><br>    <span class="hljs-meta">@Scheduled(fixedRate = 1 * 60 * 1000)</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduledReconciliation</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Starting scheduled stock reconciliation&quot;</span>);<br>        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<br>        <br>        <span class="hljs-keyword">if</span> (goodsList == <span class="hljs-literal">null</span> || goodsList.isEmpty()) &#123;<br>            log.warn(<span class="hljs-string">&quot;No goods found for reconciliation&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (GoodsVo goods : goodsList) &#123;<br>            <span class="hljs-keyword">if</span> (shouldReconcile(goods)) &#123;<br>                reconcileStock(goods.getId());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-1-水位线对账策略"><a href="#4-2-1-水位线对账策略" class="headerlink" title="4.2.1 水位线对账策略"></a>4.2.1 水位线对账策略</h5><p>为了减少系统负担，我们基于水位线策略选择性地对商品进行对账：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldReconcile</span><span class="hljs-params">(GoodsVo goods)</span> &#123;<br>    <span class="hljs-keyword">if</span> (RECONCILE_ALL_ITEMS) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查Redis库存</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">redisStock</span> <span class="hljs-operator">=</span> redisService.get(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goods.getId());<br>    <br>    <span class="hljs-comment">// 商品不在Redis中，不需要对账</span><br>    <span class="hljs-keyword">if</span> (redisStock == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算当前库存百分比</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">initialStock</span> <span class="hljs-operator">=</span> goods.getTotalStock();<br>    <span class="hljs-keyword">if</span> (initialStock &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 初始库存异常，执行对账</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">stockPercentage</span> <span class="hljs-operator">=</span> (redisStock * <span class="hljs-number">100</span>) / initialStock;<br>    <span class="hljs-keyword">return</span> stockPercentage &lt;= LOW_STOCK_THRESHOLD_PERCENTAGE; <span class="hljs-comment">// 库存低于水位线才对账</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-2-对账流程与重试机制"><a href="#4-2-2-对账流程与重试机制" class="headerlink" title="4.2.2 对账流程与重试机制"></a>4.2.2 对账流程与重试机制</h5><p>对账核心逻辑包含了原子性数据采集、一致性校验和自动重试机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reconcileStock</span><span class="hljs-params">(Long goodsId)</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;Reconciling stock for goods ID: &#123;&#125;&quot;</span>, goodsId);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isConsistent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 重试ALERT_THRESHOLD次</span><br>    <span class="hljs-keyword">while</span> (!isConsistent &amp;&amp; retryCount &lt; ALERT_THRESHOLD) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取数据库库存</span><br>            <span class="hljs-type">GoodsVo</span> <span class="hljs-variable">goods</span> <span class="hljs-operator">=</span> goodsService.getGoodsVoByGoodsId(goodsId);<br>            <span class="hljs-keyword">if</span> (goods == <span class="hljs-literal">null</span>) &#123;<br>                log.error(<span class="hljs-string">&quot;Failed to get goods info for ID: &#123;&#125; during reconciliation&quot;</span>, goodsId);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">dbStock</span> <span class="hljs-operator">=</span> goods.getStockCount();<br>            <br>            <span class="hljs-comment">// 原子获取Redis库存和预占库存</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockKey</span> <span class="hljs-operator">=</span> redisService.getRealKey(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsId);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">reservedKey</span> <span class="hljs-operator">=</span> redisService.getRealKey(SeckillKey.reservedStock, <span class="hljs-string">&quot;&quot;</span> + goodsId);<br><br>            List&lt;Object&gt; values = redisService.executeScript(<br>                GET_STOCK_VALUES_SCRIPT_OBJ, <br>                Arrays.asList(stockKey, reservedKey)<br>            );<br>            <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">redisStock</span> <span class="hljs-operator">=</span> values.get(<span class="hljs-number">0</span>) != <span class="hljs-literal">null</span> &amp;&amp; !values.get(<span class="hljs-number">0</span>).toString().isEmpty() ? <br>                Integer.parseInt(values.get(<span class="hljs-number">0</span>).toString()) : <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">reservedStock</span> <span class="hljs-operator">=</span> values.get(<span class="hljs-number">1</span>) != <span class="hljs-literal">null</span> &amp;&amp; !values.get(<span class="hljs-number">1</span>).toString().isEmpty() ? <br>                Integer.parseInt(values.get(<span class="hljs-number">1</span>).toString()) : <span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-keyword">if</span> (redisStock == <span class="hljs-literal">null</span>) &#123;<br>                log.warn(<span class="hljs-string">&quot;Redis stock not found for goods: &#123;&#125;&quot;</span>, goodsId);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 核心对账公式: Redis库存 + 预占库存 = DB库存</span><br>            isConsistent = (redisStock + reservedStock == dbStock);<br>            <br>            <span class="hljs-keyword">if</span> (!isConsistent) &#123;<br>                retryCount++;<br>                log.warn(<span class="hljs-string">&quot;Stock inconsistency detected for goods &#123;&#125;: Redis(&#123;&#125;) + Reserved(&#123;&#125;) = All(&#123;&#125;) != DB(&#123;&#125;), retry: &#123;&#125;/&#123;&#125;&quot;</span>, <br>                        goodsId, redisStock, reservedStock, redisStock + reservedStock, dbStock, retryCount, ALERT_THRESHOLD);<br>                <br>                <span class="hljs-keyword">if</span> (retryCount &gt;= ALERT_THRESHOLD) &#123;<br>                    <span class="hljs-comment">// 连续不一致达到阈值，发送告警</span><br>                    sendAlert(goodsId, redisStock, reservedStock, dbStock);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 重试前等待一段时间</span><br>                    Thread.sleep(RETRY_DELAY_MS);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.info(<span class="hljs-string">&quot;Stock reconciliation successful for goods &#123;&#125;: Redis(&#123;&#125;) + Reserved(&#123;&#125;) = DB(&#123;&#125;)&quot;</span>, <br>                        goodsId, redisStock, reservedStock, dbStock);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            retryCount++;<br>            log.error(<span class="hljs-string">&quot;Error during stock reconciliation for goods: &#123;&#125;, retry: &#123;&#125;/&#123;&#125;&quot;</span>, <br>                     goodsId, retryCount, ALERT_THRESHOLD, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-3-告警机制"><a href="#4-2-3-告警机制" class="headerlink" title="4.2.3 告警机制"></a>4.2.3 告警机制</h5><p>当多次对账依然不一致时，系统会触发告警机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendAlert</span><span class="hljs-params">(Long goodsId, Integer redisStock, Integer reservedStock, Integer dbStock)</span> &#123;<br>    <span class="hljs-comment">// 集成各种告警系统（邮件、短信、企业微信等）</span><br>    log.error(<span class="hljs-string">&quot;ALERT: Persistent stock inconsistency for goods &#123;&#125;: Redis(&#123;&#125;) + Reserved(&#123;&#125;) != DB(&#123;&#125;)&quot;</span>, <br>            goodsId, redisStock, reservedStock, dbStock);<br>    <br>    <span class="hljs-comment">// 生产环境中，添加发送邮件或消息的告警代码</span><br>    <span class="hljs-comment">// alertService.send(...);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了秒杀系统的几个关键优化技术：</p><ol><li><strong>基于Redis的分布式限流</strong>：使用令牌桶算法实现精确的流量控制，保护系统免受流量峰值冲击</li><li><strong>基于RocketMQ的延时消息</strong>：实现可靠的订单超时自动取消，确保库存正确释放</li><li><strong>多级缓存架构</strong>：结合Guava本地缓存和Redis分布式缓存，进一步提升系统性能</li><li><strong>库存对账机制</strong>：确保Redis与数据库之间的库存数据一致性</li></ol><p>通过这些优化，我们的秒杀系统不仅能够应对高并发场景，还能在保证性能的同时确保数据一致性和系统可靠性。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027941.png" alt="image-20250310164130689"></p><hr><p>本文源码已开源在GitHub：<a href="https://github.com/Goinggoinggoing/seckill">Goinggoinggoing&#x2F;seckill</a></p><p>如有疑问或建议，欢迎在评论区讨论！</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
      <tag>秒杀系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始实现秒杀系统（三）：RocketMQ消息队列篇</title>
    <link href="/2025/02/14/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F3/"/>
    <url>/2025/02/14/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文是秒杀系统优化系列的第三篇，介绍如何利用RocketMQ消息队列解决V2版本遗留的问题。V2版本通过Redis预减库存和内存队列提升了性能，但仍存在服务可靠性差（宕机导致内存队列任务丢失）、数据一致性风险（Redis与数据库操作分离）、单机瓶颈（内存队列无法水平扩展）以及数据库行锁影响库存扣减性能等问题。  V3架构的核心优化是引入RocketMQ消息队列，关键改进包括：保留Redis预减库存机制但改为同步创建订单（不涉及行锁），将高争用的库存扣减操作异步化，通过事务消息确保操作执行可靠性，并实现三种消息消费模式（至少一次、至多一次、恰好一次）。主要工作流程为：先进行Redis库存校验和预减库存，发送半消息到RocketMQ后同步创建订单并确认消息，最终返回秒杀成功。消费者根据配置选择不同消费模式处理库存扣减。  技术实现上重点采用RocketMQ事务消息的两阶段提交机制：先发送半消息，执行本地订单创建事务，根据结果确认或回滚消息，并支持事务状态回查。文章详细展示了事务消息的生产者实现代码和事务监听器代码，后者包含本地事务执行和状态回查逻辑。针对不同业务场景，提供了三种库存扣减实现：简单但可能重复的至少一次模式、基于Redis幂等的至多一次模式，以及通过数据库事务和幂等表确保的恰好一次模式。  优化后的系统具备高可靠性（消息不丢失）、解耦性（订单与库存操作分离）、可扩展性（消费者水平扩展）和削峰填谷能力，同时通过事务消息和幂等设计保障数据一致性。文章也指出后续优化方向，包括限流保护、库存对账和监控告警体系建设。该系列完整展现了从基础MySQL实现到集成Redis缓存，最终引入消息队列的渐进式优化过程。</p></blockquote><h1 id="从零开始实现秒杀系统（三）：RocketMQ消息队列篇"><a href="#从零开始实现秒杀系统（三）：RocketMQ消息队列篇" class="headerlink" title="从零开始实现秒杀系统（三）：RocketMQ消息队列篇"></a>从零开始实现秒杀系统（三）：RocketMQ消息队列篇</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在前两篇文章中，我们先后探讨了基于MySQL的秒杀系统实现（V1）和基于Redis优化的秒杀系统（V2）。虽然V2版本通过Redis预减库存和内存队列显著提升了系统性能，但我们仍面临着几个关键挑战：服务可靠性、数据一致性、系统扩展性以及高并发下的内存压力问题。</p><p>本文作为系列的第三篇，将介绍如何利用RocketMQ消息队列进一步优化秒杀系统，解决V2版本中的剩余问题，实现一个更可靠、更具扩展性的高性能秒杀系统。</p><h2 id="V3版本架构改进"><a href="#V3版本架构改进" class="headerlink" title="V3版本架构改进"></a>V3版本架构改进</h2><h3 id="V2架构的问题回顾"><a href="#V2架构的问题回顾" class="headerlink" title="V2架构的问题回顾"></a>V2架构的问题回顾</h3><p>V2版本虽然性能显著提升，但存在以下问题：</p><ol><li><strong>服务可靠性问题</strong>：内存队列中的任务在服务宕机时会丢失</li><li><strong>数据一致性问题</strong>：Redis减库存与数据库操作的分离增加了不一致风险</li><li><strong>单机瓶颈</strong>：内存队列在单机运行，难以水平扩展</li><li><strong>库存扣减性能</strong>：库存扣减仍在数据库事务内，受行锁影响</li></ol><h3 id="V3架构设计"><a href="#V3架构设计" class="headerlink" title="V3架构设计"></a>V3架构设计</h3><p>V3架构引入了RocketMQ消息队列，主要优化点如下：</p><ol><li><strong>Redis预减库存 + 同步订单创建</strong>：利用订单创建操作不涉及行锁的特点，保留同步创建</li><li><strong>异步库存扣减</strong>：将高争用的库存扣减操作异步化，减轻数据库压力</li><li><strong>事务消息保证</strong>：通过RocketMQ事务消息确保库存扣减操作一定执行</li><li><strong>三种消息消费模式</strong>：实现不同级别的消息处理保证</li></ol><h2 id="核心流程设计"><a href="#核心流程设计" class="headerlink" title="核心流程设计"></a>核心流程设计</h2><h3 id="v3整体架构图"><a href="#v3整体架构图" class="headerlink" title="v3整体架构图"></a>v3整体架构图</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027568.png" alt="image-20250307135544501"></p><h3 id="秒杀接口执行流程"><a href="#秒杀接口执行流程" class="headerlink" title="秒杀接口执行流程"></a>秒杀接口执行流程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 库存校验（Redis快速失败）<br><span class="hljs-bullet">2.</span> Redis预减库存<br><span class="hljs-bullet">3.</span> 发送半消息到RocketMQ<br><span class="hljs-bullet">4.</span> 本地事务同步创建订单（不涉及行锁，速度较快）<br><span class="hljs-bullet">5.</span> 确认消息发送<br><span class="hljs-bullet">6.</span> 返回秒杀成功<br></code></pre></td></tr></table></figure><p>基于此，工作流程为：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027569.png" alt="image-20250307135055826"></p><h3 id="异步库存扣减流程"><a href="#异步库存扣减流程" class="headerlink" title="异步库存扣减流程"></a>异步库存扣减流程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> RocketMQ消费者接收库存扣减消息<br><span class="hljs-bullet">2.</span> 根据配置选择消费模式（至少一次/至多一次/恰好一次）<br><span class="hljs-bullet">3.</span> 执行库存扣减操作<br><span class="hljs-bullet">4.</span> 处理结果记录（根据消费模式）<br></code></pre></td></tr></table></figure><h2 id="事务消息保证异步库存扣减的可靠性"><a href="#事务消息保证异步库存扣减的可靠性" class="headerlink" title="事务消息保证异步库存扣减的可靠性"></a>事务消息保证异步库存扣减的可靠性</h2><p>在V3版本中，我们引入了RocketMQ的事务消息机制，确保库存扣减消息能够可靠地执行。这是一个关键的改进，解决了V2版本中数据一致性的问题。</p><h3 id="什么是RocketMQ事务消息？"><a href="#什么是RocketMQ事务消息？" class="headerlink" title="什么是RocketMQ事务消息？"></a>什么是RocketMQ事务消息？</h3><p>RocketMQ事务消息是一种分布式事务解决方案，它通过两阶段提交（2PC）的机制确保消息发送和本地事务的原子性。简单来说，事务消息可以保证：</p><ol><li>消息一定会被发送且被消费，或者</li><li>消息和本地事务都不会执行</li></ol><h3 id="事务消息工作流程"><a href="#事务消息工作流程" class="headerlink" title="事务消息工作流程"></a>事务消息工作流程</h3><p>在秒杀系统中，事务消息的工作流程如下：</p><ol><li><strong>发送半消息</strong>：系统先向RocketMQ发送一条”半消息”，此时消息不会被消费</li><li><strong>执行本地事务</strong>：系统执行本地事务（创建订单）</li><li><strong>提交或回滚</strong>：根据本地事务执行结果，向RocketMQ发送确认或回滚指令</li><li><strong>事务状态回查</strong>：如果因网络等原因未收到确认指令，RocketMQ会回查事务状态</li><li><strong>消息消费</strong>：确认后，消息才能被消费者消费</li></ol><p><img src="https://rocketmq.apache.org/zh/assets/images/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png" alt="事务消息"></p><h3 id="实现代码示例"><a href="#实现代码示例" class="headerlink" title="实现代码示例"></a>实现代码示例</h3><p>半消息发送代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MQProducer</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Send transaction message for stock reduction</span><br><span class="hljs-comment">     * This ensures the inventory is reduced only if the order is successfully created</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendStockReductionTransactionMessage</span><span class="hljs-params">(Long userId, GoodsVo goodsVo)</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">transactionId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <br>        <span class="hljs-comment">// Message = what downstream services need</span><br>        <span class="hljs-comment">// Args = what local transaction needs</span><br><br>        <span class="hljs-comment">// Prepare stock reduction message data</span><br>        Map&lt;String, Object&gt; payload = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        payload.put(<span class="hljs-string">&quot;goodsId&quot;</span>, goodsVo.getId());<br>        payload.put(<span class="hljs-string">&quot;transactionId&quot;</span>, transactionId);<br><br>        <br>        <span class="hljs-comment">// Create the message with transaction ID in headers</span><br>        Message&lt;String&gt; message = MessageBuilder.withPayload(objectMapper.writeValueAsString(payload))<br>                .setHeader(<span class="hljs-string">&quot;transactionId&quot;</span>, transactionId)<br>                .build();<br>        <br>        <span class="hljs-comment">// Prepare transaction arguments to be used in the local transaction execution</span><br>        Map&lt;String, Object&gt; transactionArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        transactionArgs.put(<span class="hljs-string">&quot;userId&quot;</span>, userId);<br>        transactionArgs.put(<span class="hljs-string">&quot;goodsVo&quot;</span>, goodsVo);<br>        transactionArgs.put(<span class="hljs-string">&quot;transactionId&quot;</span>, transactionId);<br>        <br><br>        log.info(<span class="hljs-string">&quot;begin Transaction message sent for order creation with txId: &#123;&#125;&quot;</span>, transactionId);<br><br>        <span class="hljs-comment">// Store transaction start time in Redis with expiration</span><br>        redisService.set(SeckillKey.txStartTime, transactionId, System.currentTimeMillis());<br><br>        <span class="hljs-comment">// Send transactional message</span><br>        rocketMQTemplate.sendMessageInTransaction(<br>                TOPIC_STOCK_REDUCTION, <br>                message, <br>                transactionArgs);<br>        <br>        log.info(<span class="hljs-string">&quot;Transaction message sent for order creation with txId: &#123;&#125;&quot;</span>, transactionId);<br><br>        <span class="hljs-keyword">return</span> transactionId;<br>    &#125;<br>&#125;<br><br><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveTransactionRecord</span><span class="hljs-params">(String transactionId, <span class="hljs-type">boolean</span> success)</span> &#123;<br>        <span class="hljs-type">TransactionRecord</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionRecord</span>();<br>        record.setTransactionId(transactionId);<br>        record.setSuccess(success);<br>        record.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        transactionRecordDao.insert(record);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心事务监听器实现：包含执行本地事务（在半消息发送后调用）以及 回查本地事务状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockReductionTransactionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RocketMQLocalTransactionListener</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TransactionRecordDao transactionRecordDao;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RocketMQLocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;Executing local transaction for message: &#123;&#125;&quot;</span>, msg);<br>            <br>            <span class="hljs-comment">// Parse the message body and arguments</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) arg;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (Long) params.get(<span class="hljs-string">&quot;userId&quot;</span>);<br>            <span class="hljs-type">GoodsVo</span> <span class="hljs-variable">goodsVo</span> <span class="hljs-operator">=</span> (GoodsVo) params.get(<span class="hljs-string">&quot;goodsVo&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">transactionId</span> <span class="hljs-operator">=</span> (String) params.get(<span class="hljs-string">&quot;transactionId&quot;</span>);<br>            <br>            <span class="hljs-comment">// Execute local transaction - create order in database with transaction ID</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> createOrderInDB(userId, goodsVo, transactionId);<br>            <br>            <span class="hljs-comment">// Record transaction result</span><br>            <span class="hljs-type">RocketMQLocalTransactionState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> success ? <br>                    RocketMQLocalTransactionState.COMMIT : <br>                    RocketMQLocalTransactionState.ROLLBACK;<br>            <br>            localTransactionMap.put(transactionId, state);<br>            <br>            log.info(<span class="hljs-string">&quot;Local transaction executed with result: &#123;&#125;, txId: &#123;&#125;&quot;</span>, state, transactionId);<br>            <span class="hljs-keyword">return</span> state;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Error executing local transaction&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RocketMQLocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Extract transaction id from message headers</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">transactionId</span> <span class="hljs-operator">=</span> (String) msg.getHeaders().get(<span class="hljs-string">&quot;transactionId&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;Checking transaction status for txId: &#123;&#125;&quot;</span>, transactionId);<br>            <br>            <span class="hljs-comment">// Get cached transaction state (for performance)</span><br>            <span class="hljs-type">RocketMQLocalTransactionState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> localTransactionMap.get(transactionId);<br>            <br>            <span class="hljs-keyword">if</span> (state != <span class="hljs-literal">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;Found transaction state in cache: &#123;&#125;&quot;</span>, state);<br>                <span class="hljs-keyword">return</span> state;<br>            &#125;<br>            <br>            <span class="hljs-comment">// If not found in memory (e.g., after service restart), query database</span><br>            log.info(<span class="hljs-string">&quot;Transaction state not in cache, checking database...&quot;</span>);<br>            <br>            <span class="hljs-comment">// 1. Check if order exists with this transaction ID</span><br>            <span class="hljs-type">SeckillOrder</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderService.getOrderByTransactionId(transactionId);<br>            <br>            <span class="hljs-keyword">if</span> (order != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Order exists, transaction was successful</span><br>                log.info(<span class="hljs-string">&quot;Transaction found in database, order exists: &#123;&#125;&quot;</span>, order.getId());<br>                localTransactionMap.put(transactionId, RocketMQLocalTransactionState.COMMIT);<br>                <span class="hljs-keyword">return</span> RocketMQLocalTransactionState.COMMIT;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 2. Check if transaction is still within valid time window</span><br>            <span class="hljs-keyword">if</span> (NEED_CHECK_TIMEOUT &amp;&amp; isTransactionExpired(transactionId)) &#123;<br>                log.info(<span class="hljs-string">&quot;Transaction considered failed: timeout reached&quot;</span>);<br>                localTransactionMap.put(transactionId, RocketMQLocalTransactionState.ROLLBACK);<br>                <span class="hljs-keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 3. Still within processing window, return UNKNOWN to trigger retry</span><br>            log.info(<span class="hljs-string">&quot;Transaction status still unknown, will retry check later&quot;</span>);<br>            <span class="hljs-keyword">return</span> RocketMQLocalTransactionState.UNKNOWN;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Error checking local transaction status&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> RocketMQLocalTransactionState.UNKNOWN;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在秒杀场景中使用事务消息具有以下优势：</p><ol><li><p><strong>数据一致性保证</strong>：确保订单创建和库存扣减消息发送的原子性</p></li><li><p><strong>异步解耦</strong>：将高争用的库存扣减操作异步化，提高系统吞吐量</p></li><li><p><strong>可靠性</strong>：即使系统崩溃或网络故障，消息也不会丢失</p></li></ol><h2 id="三种消息消费保证模式详解"><a href="#三种消息消费保证模式详解" class="headerlink" title="三种消息消费保证模式详解"></a>三种消息消费保证模式详解</h2><p>消费者用于消费库存扣减的消息，本文共实现3中不同的扣减方式，总体流程如下所示：<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102027570.png" alt="image-20250307134959200"></p><h3 id="1-至少一次处理-At-Least-Once"><a href="#1-至少一次处理-At-Least-Once" class="headerlink" title="1. 至少一次处理 (At-Least-Once)"></a>1. 至少一次处理 (At-Least-Once)</h3><p>最简单的实现，默认的处理方式，但可能导致重复处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockAtLeastOnce</span><span class="hljs-params">(Long goodsId)</span>&#123;<br>    <span class="hljs-comment">// The message ack might be lost, leading to repeated deductions</span><br>    <span class="hljs-keyword">return</span> goodsService.reduceStockWhenLeft(goodsId);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式下，如果消息处理成功但ACK失败，消息会被重新投递，导致重复扣减。适用于对数据一致性要求不高的场景。</p><h3 id="2-至多一次处理-At-Most-Once"><a href="#2-至多一次处理-At-Most-Once" class="headerlink" title="2. 至多一次处理 (At-Most-Once)"></a>2. 至多一次处理 (At-Most-Once)</h3><p>使用Redis进行幂等性检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockAtMostOnce</span><span class="hljs-params">(Long goodsId, String transactionId)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idempotentKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;stock:reduction:&quot;</span> + transactionId;<br><br>    <span class="hljs-comment">// Use Redis SETNX to implement idempotence check. If SETNX fails due to a crash,</span><br>    <span class="hljs-comment">// there will be no chance to deduct the stock again, so it is at most once deduction.</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isFirstProcess</span> <span class="hljs-operator">=</span> redisService.setIfNotExists(idempotentKey, <span class="hljs-string">&quot;PROCESSED&quot;</span>, MESSAGE_RECORD_EXPIRE_TIME);<br><br>    <span class="hljs-comment">// If already processed, return directly</span><br>    <span class="hljs-keyword">if</span> (!isFirstProcess) &#123;<br>        log.info(<span class="hljs-string">&quot;Message already processed, transactionId: &#123;&#125;&quot;</span>, transactionId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Execute stock reduction logic</span><br>    <span class="hljs-keyword">return</span> goodsService.reduceStockWhenLeft(goodsId);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式通过Redis的setnx实现幂等性检查，避免重复处理。但如果在Redis设置成功后、扣减库存前发生故障，消息将不会重新处理，可能导致库存不一致。</p><h3 id="3-恰好一次处理-Exactly-Once"><a href="#3-恰好一次处理-Exactly-Once" class="headerlink" title="3. 恰好一次处理 (Exactly-Once)"></a>3. 恰好一次处理 (Exactly-Once)</h3><p>通过数据库事务和幂等性表实现最严格的一致性保证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processStockReductionWithIdempotence</span><span class="hljs-params">(Long goodsId, String transactionId)</span>&#123;<br>    <span class="hljs-comment">// 1. Check if the message has been processed</span><br>    <span class="hljs-type">IdempotenceRecord</span> <span class="hljs-variable">existingRecord</span> <span class="hljs-operator">=</span> idempotenceRecordDao.findByTransactionId(transactionId);<br><br>    <span class="hljs-comment">// 2. If the message was already processed, return false</span><br>    <span class="hljs-keyword">if</span> (existingRecord != <span class="hljs-literal">null</span>) &#123;<br>        log.info(<span class="hljs-string">&quot;Message already processed, transactionId: &#123;&#125;&quot;</span>, transactionId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3. Execute stock reduction and record the message in the same transaction</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">StockReductionConsumer</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> applicationContext.getBean(StockReductionConsumer.class);<br>        <span class="hljs-keyword">return</span> proxy.processWithTransaction(goodsId, transactionId);<br>    &#125; <span class="hljs-keyword">catch</span> (org.springframework.dao.DataIntegrityViolationException e) &#123;<br>        <span class="hljs-comment">// Catch the unique index violation exception, indicating concurrent processing record already exists</span><br>        log.info(<span class="hljs-string">&quot;Duplicate processing detected, transactionId: &#123;&#125;&quot;</span>, transactionId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processWithTransaction</span><span class="hljs-params">(Long goodsId, String transactionId)</span> &#123;<br>    <span class="hljs-comment">// 1. Execute business logic - reduce inventory</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> goodsService.reduceStockWhenLeft(goodsId);<br>    <br>    <span class="hljs-comment">// 2. Record the processing result regardless of success or failure.</span><br>    <span class="hljs-comment">// The database unique index ensures that when multiple calls enter this function simultaneously, only one will succeed and others will roll back.</span><br>    <span class="hljs-comment">// alse you can try to use distributedLock without unique index</span><br>    <span class="hljs-type">IdempotenceRecord</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdempotenceRecord</span>();<br>    record.setTransactionId(transactionId);<br>    record.setProcessed(success);<br>    record.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    idempotenceRecordDao.insertRecord(record); <br>    <br>    <span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式通过数据库事务将业务操作和幂等性记录绑定在一起，确保消息恰好被处理一次。但性能略微低于其他方法</p><h2 id="V3架构的优势"><a href="#V3架构的优势" class="headerlink" title="V3架构的优势"></a>V3架构的优势</h2><ol><li><strong>高可靠性</strong>：消息队列保证消息不丢失，服务重启也可恢复处理</li><li><strong>系统解耦</strong>：订单创建与库存扣减解耦，减少相互影响</li><li><strong>水平扩展</strong>：消费者可以水平扩展，提高处理能力</li><li><strong>削峰填谷</strong>：消息队列能够缓冲突发流量，保护后端系统</li><li><strong>数据一致性</strong>：通过事务消息和幂等性设计确保数据一致性</li></ol><h2 id="挑战与解决方案"><a href="#挑战与解决方案" class="headerlink" title="挑战与解决方案"></a>挑战与解决方案</h2><h3 id="1-消息积压问题"><a href="#1-消息积压问题" class="headerlink" title="1. 消息积压问题"></a>1. 消息积压问题</h3><p><strong>挑战</strong>：高并发下可能导致消息积压<br><strong>解决方案</strong>：</p><ul><li>消费者集群水平扩展</li><li>消费者线程池优化提高消费速度</li><li>消息批量处理减少数据库交互次数</li></ul><h3 id="2-系统复杂性增加"><a href="#2-系统复杂性增加" class="headerlink" title="2. 系统复杂性增加"></a>2. 系统复杂性增加</h3><p><strong>挑战</strong>：引入消息队列增加了系统复杂性和运维难度<br><strong>解决方案</strong>：</p><ul><li>完善监控和告警机制</li><li>构建消息队列健康检查系统</li></ul><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>V3版本通过引入RocketMQ消息队列，成功解决了V2版本中存在的服务可靠性和水平扩展问题。通过将高争用的库存扣减操作异步化，结合事务消息和三种消息消费保证模式，我们实现了一个高性能、高可靠、可扩展的秒杀系统。在实际生产环境中，可以根据业务需求和一致性要求选择适合的消息消费模式。</p><p>在这三篇文章中，我们从零开始，逐步构建了一个高性能、高可用的秒杀系统：</p><ul><li>V1版本：基于MySQL的基础秒杀实现</li><li>V2版本：引入Redis缓存优化，实现库存预减和异步下单</li><li>V3版本：整合RocketMQ消息队列，解决可靠性和扩展性问题</li></ul><p>然而，在实际生产环境中，秒杀系统仍面临一些挑战，我们将在下一篇文章中进一步优化系统：</p><p>在下一篇文章中，我们将继续完善秒杀系统，重点关注以下方面：</p><ol><li><strong>限流保护</strong>：令牌桶限流方案确保系统可用性</li><li><strong>库存对账</strong>：解决Redis与数据库之间可能存在的库存不一致问题</li><li><strong>监控告警</strong>：构建完善的监控体系，实现问题的早发现早解决</li></ol><hr><p>本文源码已开源在GitHub：<a href="https://github.com/Goinggoinggoing/seckill">Goinggoinggoing&#x2F;seckill</a></p><p>如有疑问或建议，欢迎在评论区讨论！</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
      <tag>秒杀系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始实现秒杀系统（二）：Redis优化篇</title>
    <link href="/2025/02/07/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F2/"/>
    <url>/2025/02/07/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章介绍了如何利用Redis优化秒杀系统，解决基于MySQL方案的性能瓶颈。作者针对V1版本中数据库压力大、系统吞吐量有限和用户体验差的问题，提出了V2版本的改进方案，主要包含以下关键技术：  1. <strong>Redis预减库存</strong>：使用Redis原子操作减少数据库访问，将库存信息缓存在Redis中处理扣减，显著提高性能。  2. <strong>库存快速失败检查</strong>：通过Redis标记售罄商品，快速拒绝无效请求，避免无谓资源消耗。  3. <strong>异步下单</strong>：将耗时的订单创建操作异步化，提高系统响应速度，同时通过线程池控制数据库并发压力。  4. <strong>分布式锁</strong>：采用双重检查锁模式保证Redis缓存初始化的线程安全，避免重复初始化。  5. <strong>内存队列</strong>：使用内存线程池处理订单创建，减轻数据库压力。  文章详细比较了V1和V2版本的架构差异，V1直接操作MySQL数据库，而V2引入Redis作为缓存层，结合异步处理技术大幅提升性能。测试数据显示V2版本在QPS、响应时间和并发处理能力等方面均有显著提升，特别是QPS从约500-1000提升到10,000-20,000。  文章最后指出V2版本仍面临的挑战，包括服务可靠性、单机瓶颈、峰值处理等问题，并预告将在下一篇文章中通过引入RocketMQ消息队列进一步优化系统。整篇文章通过具体代码示例和架构图，清晰展示了如何构建一个高性能的秒杀系统。</p></blockquote><h1 id="从零开始实现秒杀系统（二）：Redis优化篇"><a href="#从零开始实现秒杀系统（二）：Redis优化篇" class="headerlink" title="从零开始实现秒杀系统（二）：Redis优化篇"></a>从零开始实现秒杀系统（二）：Redis优化篇</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在<a href="https://github.com/copilot/c/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMySQL%E8%A1%8C%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%AF%87">上一篇文章</a>中，我们探讨了基于MySQL实现秒杀系统的几种方案，包括无锁实现、悲观锁、乐观锁以及最优的单SQL原子更新方案。这些方案都直接操作数据库，在高并发场景下仍然存在性能瓶颈。</p><p>本文作为系列的第二篇，将介绍如何利用Redis来优化秒杀系统，大幅提升系统的并发处理能力。在V2版本中，我们引入了Redis作为缓存和预减库存的工具，并结合异步处理技术，实现了一个更高性能的秒杀系统。</p><h2 id="1-高并发秒杀系统的挑战"><a href="#1-高并发秒杀系统的挑战" class="headerlink" title="1. 高并发秒杀系统的挑战"></a>1. 高并发秒杀系统的挑战</h2><p>回顾V1版本，我们虽然解决了超卖问题，但仍然面临以下挑战：</p><ol><li><strong>数据库压力大</strong>：所有请求都直接访问数据库，导致数据库成为瓶颈</li><li><strong>系统吞吐量有限</strong>：MySQL的行锁机制虽然保证了数据一致性，但限制了并发处理能力</li><li><strong>用户体验差</strong>：高并发下，大量请求等待数据库锁释放，导致响应时间长</li></ol><p>V2版本就是为了解决这些问题而设计的, 于引入了以下关键技术：</p><ol><li><strong>Redis预减库存</strong>：使用Redis原子操作减少数据库访问</li><li><strong>库存快速失败检查</strong>：通过Redis标记售罄商品，避免无效请求</li><li><strong>异步下单</strong>：将下单操作异步化，提高系统吞吐量</li><li><strong>分布式锁</strong>：保证Redis缓存初始化的线程安全</li><li><strong>内存队列</strong>：使用内存线程池处理订单创建，减轻数据库压力</li></ol><p>这些创新点共同构成了一个高性能、高可用的秒杀系统。下面我们将详细介绍每个创新点的实现。</p><h2 id="2-V1V2架构对比"><a href="#2-V1V2架构对比" class="headerlink" title="2. V1V2架构对比"></a>2. V1V2架构对比</h2><p><strong>V1架构（基于MySQL）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Code">用户请求 -&gt; 应用服务器 -&gt; MySQL(减库存+创建订单)<br></code></pre></td></tr></table></figure><img src="从零开始实现秒杀系统2.assets/image-20250307140357358.png" alt="image-20250307140357358" style="zoom:50%;" /><p><strong>V2架构（Redis优化）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Code">用户请求 -&gt; 应用服务器 -&gt; Redis预减库存 -&gt; 快速返回结果给用户<br>                      -&gt; 异步队列 -&gt; MySQL(最终减库存+创建订单)<br>                      -&gt; 用户查询结果 -&gt; Redis查询状态<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102023113.png" alt="image-20250307140435122"></p><h2 id="3-Redis预减库存"><a href="#3-Redis预减库存" class="headerlink" title="3. Redis预减库存"></a>3. Redis预减库存</h2><p>在V1版本中，每个秒杀请求都需要访问数据库查询和更新库存，这是系统的主要瓶颈。V2版本引入了Redis预减库存机制，将库存信息缓存在Redis中，使用Redis的原子操作来处理库存扣减。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Redis预减库存，减少对数据库的访问</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisService.decr(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsVo.getId());<br><br><span class="hljs-comment">// 判断库存是否充足</span><br><span class="hljs-keyword">if</span> (stock &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 库存不足，回滚Redis库存，设置商品已售罄标识</span><br>    redisService.incr(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsVo.getId());<br>    setGoodsOver(goodsVo.getId());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的优势在于：</p><ol><li><strong>高性能</strong>：Redis的内存操作速度远快于数据库磁盘操作</li><li><strong>原子性</strong>：Redis的incr&#x2F;decr操作是原子的，无需额外加锁</li><li><strong>减轻数据库压力</strong>：只有通过Redis预减库存的请求才会访问数据库</li></ol><h3 id="3-1-库存初始化的优化"><a href="#3-1-库存初始化的优化" class="headerlink" title="3.1 库存初始化的优化"></a>3.1 库存初始化的优化</h3><p>为了避免每次启动服务或处理请求时重复初始化Redis库存，V2版本使用了分布式锁来保证线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStockIfNeeded</span><span class="hljs-params">(GoodsVo goodsVo)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">goodsId</span> <span class="hljs-operator">=</span> goodsVo.getId();<br>    <br>    <span class="hljs-comment">// 检查库存是否已在Redis中初始化</span><br>    <span class="hljs-keyword">if</span> (!redisService.exists(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsId)) &#123;<br>        <span class="hljs-comment">// 创建分布式锁，设置过期时间和唯一标识符</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_PREFIX + goodsId;<br>        <span class="hljs-type">RedisDistributedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisDistributedLock</span>(redisService, lockKey, LOCK_EXPIRE_SECONDS);<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">lockAcquired</span> <span class="hljs-operator">=</span> lock.tryLock(LOCK_TIMEOUT_MS);<br>        <span class="hljs-keyword">if</span> (lockAcquired) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 双重检查避免重复初始化</span><br>                <span class="hljs-keyword">if</span> (!redisService.exists(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsId)) &#123;<br>                    log.info(<span class="hljs-string">&quot;Initializing stock for goods: &#123;&#125;&quot;</span>, goodsId);<br>                    <span class="hljs-comment">// 从数据库获取最新库存</span><br>                    <span class="hljs-type">GoodsVo</span> <span class="hljs-variable">freshGoodsInfo</span> <span class="hljs-operator">=</span> goodsService.getGoodsVoByGoodsId(goodsId);<br>                    <span class="hljs-keyword">if</span> (freshGoodsInfo != <span class="hljs-literal">null</span>) &#123;<br>                        redisService.set(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + goodsId, freshGoodsInfo.getStockCount());<br>                        log.info(<span class="hljs-string">&quot;Stock initialized for goods &#123;&#125;: &#123;&#125;&quot;</span>, goodsId, freshGoodsInfo.getStockCount());<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码使用了双重检查锁（DCL）模式和Redis分布式锁来确保在多实例、多线程环境下，库存只被初始化一次，避免了缓存重复初始化的问题。</p><h2 id="4-库存快速失败检查"><a href="#4-库存快速失败检查" class="headerlink" title="4. 库存快速失败检查"></a>4. 库存快速失败检查</h2><p>在高并发秒杀场景中，大部分请求都是在商品已售罄后到达的。为了避免这些请求无谓地消耗系统资源，V2版本引入了库存快速失败检查机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 快速失败检查：商品是否已标记为售罄</span><br><span class="hljs-keyword">if</span> (isGoodsOver(goodsVo.getId())) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 标记商品已售罄</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGoodsOver</span><span class="hljs-params">(Long goodsId)</span> &#123;<br>    redisService.set(SeckillKey.isGoodsOver, <span class="hljs-string">&quot;&quot;</span> + goodsId, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 判断商品是否售罄</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGoodsOver</span><span class="hljs-params">(Long goodsId)</span> &#123;<br>    <span class="hljs-keyword">return</span> redisService.exists(SeckillKey.isGoodsOver, <span class="hljs-string">&quot;&quot;</span> + goodsId);<br>&#125;<br></code></pre></td></tr></table></figure><p>这一优化使得系统能够快速拒绝无效请求，将宝贵的系统资源用于处理有效请求，极大地提高了系统的吞吐能力。</p><h2 id="5-异步下单处理"><a href="#5-异步下单处理" class="headerlink" title="5. 异步下单处理"></a>5. 异步下单处理</h2><p>秒杀过程中最耗时的操作是创建订单和更新数据库，为了进一步提升系统性能，V2版本将下单操作异步化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用线程池异步处理订单创建</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">orderExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">// 标记订单为处理中状态</span><br>redisService.set(SeckillKey.seckillPending, finalUserId + <span class="hljs-string">&quot;_&quot;</span> + finalGoodsVo.getId(), System.currentTimeMillis());<br><br><span class="hljs-comment">// 异步下单</span><br>orderExecutor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SeckillOrder</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> createSeckillOrder(finalUserId, finalGoodsVo);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;Create order async error: &quot;</span>, e);<br>        <span class="hljs-comment">// 出错时回滚Redis库存</span><br>        redisService.incr(SeckillKey.goodsStock, <span class="hljs-string">&quot;&quot;</span> + finalGoodsVo.getId());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 清理处理中状态</span><br>        redisService.delete(SeckillKey.seckillPending, finalUserId + <span class="hljs-string">&quot;_&quot;</span> + finalGoodsVo.getId());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>异步下单的优势：</p><ol><li><strong>提高响应速度</strong>：用户无需等待下单完成即可获得响应</li><li><strong>控制数据库并发</strong>：通过线程池限制并发数量，避免数据库压力过大</li><li><strong>失败自动回滚</strong>：异常情况下自动回滚Redis库存，保证数据一致性</li></ol><h2 id="6-订单状态查询"><a href="#6-订单状态查询" class="headerlink" title="6. 订单状态查询"></a>6. 订单状态查询</h2><p>由于订单处理是异步的，用户需要一种机制来查询秒杀结果。V2版本实现了一个专门的结果查询接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取秒杀结果</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> orderId: 成功, -1: 秒杀失败, 0: 排队中, -2: 处理超时</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getSeckillResult</span><span class="hljs-params">(Long userId, Long goodsId)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pendingKey</span> <span class="hljs-operator">=</span> userId + <span class="hljs-string">&quot;_&quot;</span> + goodsId;<br><br>    <span class="hljs-comment">// 1. 优先检查处理中状态</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> redisService.get(SeckillKey.seckillPending, pendingKey);<br>    <span class="hljs-keyword">if</span> (startTime != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;<br>        <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">30000</span>) &#123; <span class="hljs-comment">// 超时30秒</span><br>            redisService.delete(SeckillKey.seckillPending, pendingKey);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">2L</span>; <span class="hljs-comment">// 处理超时</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>; <span class="hljs-comment">// 正在处理</span><br>    &#125;<br><br>    <span class="hljs-comment">// 2. 查询订单信息</span><br>    <span class="hljs-type">SeckillOrder</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderService.getOrderByUserIdGoodsId(userId, goodsId);<br>    <span class="hljs-keyword">if</span> (order != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> order.getId(); <span class="hljs-comment">// 秒杀成功</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 查询商品是否已售罄</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isOver</span> <span class="hljs-operator">=</span> isGoodsOver(goodsId);<br>    <span class="hljs-keyword">if</span> (isOver) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>; <span class="hljs-comment">// 已售罄，秒杀失败</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>; <span class="hljs-comment">// 秒杀失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口设计考虑了多种状态：</p><ul><li>订单处理中（排队）</li><li>处理超时</li><li>秒杀成功</li><li>秒杀失败（商品售罄）</li></ul><p>这种设计极大地提升了用户体验，让用户能够及时了解秒杀结果。</p><h2 id="7-V2版本的完整秒杀流程"><a href="#7-V2版本的完整秒杀流程" class="headerlink" title="7. V2版本的完整秒杀流程"></a>7. V2版本的完整秒杀流程</h2><p>结合上述优化，V2版本的秒杀流程如下：</p><ol><li><strong>判断商品是否售罄</strong>（快速失败）</li><li><strong>初始化Redis库存</strong>（如果需要）</li><li><strong>Redis预减库存</strong></li><li><strong>异步创建订单</strong></li><li><strong>返回临时结果</strong></li><li><strong>用户查询秒杀结果</strong></li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102023114.png" alt="image-20250307140652054"></p><p>这一流程不仅保证了系统的高性能，还确保了数据的一致性和良好的用户体验。</p><h2 id="8-V1与V2性能对比"><a href="#8-V1与V2性能对比" class="headerlink" title="8. V1与V2性能对比"></a>8. V1与V2性能对比</h2><p>单个 MySQL 的每秒写入在 4000 QPS，读取如果记录超过千万级别效率会大大降低。而Redis单分片写入瓶颈在 2w 左右，读瓶颈在 10w 左右</p><table><thead><tr><th>性能指标</th><th>V1（MySQL实现）</th><th>V2（Redis优化）</th><th>提升</th></tr></thead><tbody><tr><td>QPS</td><td>约500-1000</td><td>约10,000-20,000</td><td>20倍左右</td></tr><tr><td>响应时间</td><td>平均200-500ms</td><td>平均100ms以下</td><td>10倍左右</td></tr><tr><td>并发连接数</td><td>约1,000</td><td>约50,000</td><td>50倍</td></tr><tr><td>数据库压力</td><td>所有请求直接访问数据库</td><td>只有成功减库存的请求访问数据库</td><td>显著降低</td></tr><tr><td>系统资源利用</td><td>CPU和数据库IO高负荷</td><td>内存使用率高，CPU和IO负载分散</td><td>更均衡</td></tr><tr><td>可扩展性</td><td>受限于数据库性能，难以水平扩展</td><td>可通过增加Redis和应用节点水平扩展</td><td>大幅提升</td></tr></tbody></table><h2 id="9-潜在问题"><a href="#9-潜在问题" class="headerlink" title="9. 潜在问题"></a>9. 潜在问题</h2><p>尽管V2版本在性能上有了显著提升，但我们仍然面临一些挑战：</p><ol><li><strong>服务可靠性与一致性</strong>：内存线程池处理订单可能因服务重启或宕机导致任务丢失，同时异步处理增加了保证数据一致性的难度</li><li><strong>单机瓶颈</strong>：线程池在单机内存中运行，难以实现真正的分布式横向扩展</li><li><strong>峰值处理</strong>：在极端高并发下，内存队列可能迅速堆积，导致系统内存压力增大</li><li><strong>监控与重试</strong>：缺乏完善的监控和失败任务重试机制</li><li><strong>性能问题</strong>：在库存扣减和订单入库依旧是一个数据库事务处理的，库存扣减依旧是行锁导致系统性能不佳，而事务也加剧了性能的下降。如果秒杀场景持续进行会导致待处理的请求挤压</li></ol><p>这些挑战将在系列的第三篇文章中通过引入RocketMQ等技术得到解决。</p><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>V2版本秒杀系统通过引入Redis预减库存、快速失败检查、异步下单等创新技术，成功解决了V1版本中的性能瓶颈，实现了一个高性能、高可靠的秒杀系统。</p><p>Redis作为高性能内存数据库，与MySQL行锁机制相比，具有显著的性能优势。通过将热点数据（库存）放在Redis中，系统能够承受更高的并发压力，同时保证数据的一致性。</p><p>在系列的下一篇文章《从零开始实现秒杀系统（三）：RocketMQ消息队列篇》中，我们将引入RocketMQ消息队列，进一步优化秒杀系统，解决V2版本中存在的剩余问题</p><hr><p>本文源码已开源在GitHub：<a href="https://github.com/Goinggoinggoing/seckill">Goinggoinggoing&#x2F;seckill</a></p><p>如有疑问或建议，欢迎在评论区讨论！</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
      <tag>秒杀系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始实现秒杀系统（一）：MySQL行锁与事务篇</title>
    <link href="/2025/02/01/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F1/"/>
    <url>/2025/02/01/project/seckill/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F1/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章介绍了基于MySQL实现秒杀系统的基础版本，重点探讨了高并发场景下的数据一致性问题。秒杀系统核心需求包括商品展示、库存管理、订单处理、防重复购买和时间控制。文章对比了四种库存扣减方案：    1. <strong>V0错误示范</strong>：不加锁直接更新库存，导致超卖问题。   2. <strong>V1悲观锁</strong>：使用<code>FOR UPDATE</code>实现串行化操作，保证一致性但吞吐量低。   3. <strong>V2乐观锁</strong>：版本号机制减少锁竞争，但高并发下失败率高。   4. <strong>V3优化方案</strong>：单条<code>UPDATE</code>语句结合条件判断（<code>stock_count &gt; 0</code>），利用MySQL行锁实现原子操作，平衡性能与一致性，是最佳实践。    总结指出仅依赖数据库优化存在瓶颈，预告下一篇文章将引入Redis（预减库存、异步下单、分布式锁）进一步优化系统性能。</p></blockquote><h1 id="从零开始实现秒杀系统（一）：MySQL行锁与事务篇"><a href="#从零开始实现秒杀系统（一）：MySQL行锁与事务篇" class="headerlink" title="从零开始实现秒杀系统（一）：MySQL行锁与事务篇"></a>从零开始实现秒杀系统（一）：MySQL行锁与事务篇</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>秒杀系统是电商领域常见的应用场景，也是检验系统高并发处理能力的经典案例。本系列文章将从零开始，一步步构建一个完整的秒杀系统，探讨其中涉及的技术点和解决方案。</p><p>本篇作为系列的第一篇，将重点介绍基于MySQL实现的秒杀基础版本。在这个版本中，我们将专注于基础业务逻辑的实现和数据库层面的并发控制，确保系统在高并发访问下不会出现超卖或少卖的问题。</p><h2 id="1-秒杀系统需求分析"><a href="#1-秒杀系统需求分析" class="headerlink" title="1. 秒杀系统需求分析"></a>1. 秒杀系统需求分析</h2><p>秒杀系统本质上是一个短时间内承受高并发访问，并保证数据一致性的交易系统。核心需求包括：</p><ul><li><strong>商品展示</strong>：展示秒杀商品列表和详情</li><li><strong>库存管理</strong>：准确控制商品库存，防止超卖和少卖</li><li><strong>订单处理</strong>：秒杀成功后生成订单</li><li><strong>防重复购买</strong>：同一用户只能秒杀一次同一商品</li><li><strong>秒杀时间控制</strong>：在指定时间段内才能秒杀</li></ul><h2 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2. 数据库设计"></a>2. 数据库设计</h2><p>秒杀系统的数据库设计相对简单，主要包含以下几个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 用户表</span><br><span class="hljs-keyword">CREATE TABLE</span> `<span class="hljs-keyword">user</span>` (...)<br><br><span class="hljs-comment">-- 商品表</span><br><span class="hljs-keyword">CREATE TABLE</span> `goods` (...)<br><br><span class="hljs-comment">-- 秒杀商品表</span><br><span class="hljs-keyword">CREATE TABLE</span> `seckill_goods` (...)<br><br><span class="hljs-comment">-- 秒杀订单表</span><br><span class="hljs-keyword">CREATE TABLE</span> `seckill_order` (...)<br></code></pre></td></tr></table></figure><p>其中，最为关键的是<code>seckill_goods</code>表中的<code>stock_count</code>字段和<code>version</code>字段，它们将用于实现库存控制和并发管理。在后续优化版本中，我们也会介绍没有<code>version</code>实现的版本。</p><h2 id="3-秒杀核心流程设计"><a href="#3-秒杀核心流程设计" class="headerlink" title="3. 秒杀核心流程设计"></a>3. 秒杀核心流程设计</h2><p>秒杀的核心流程包括：</p><ol><li><strong>查询商品信息</strong>：展示商品详情和秒杀状态</li><li><strong>验证秒杀条件</strong>：判断用户是否合法、秒杀是否已开始、是否已结束、是否已参与过</li><li><strong>扣减库存</strong>：使用MySQL行锁保证库存操作的原子性</li><li><strong>生成订单</strong>：创建秒杀订单记录</li><li><strong>返回结果</strong>：通知用户秒杀结果</li></ol><p>整个流程的关键在于第3步和第4步，需要保证这两步的原子性，避免出现库存减了但订单没创建成功，或者订单创建了多次但库存只减了一次的情况。</p><h2 id="4-高并发下的数据一致性挑战"><a href="#4-高并发下的数据一致性挑战" class="headerlink" title="4. 高并发下的数据一致性挑战"></a>4. 高并发下的数据一致性挑战</h2><p>秒杀系统面临的最大挑战是如何在高并发情况下保证数据一致性。共包含两个问题：</p><ol><li>生成订单和扣减库存操作一致：例如库存扣了10， 那么订单就要生成10个。</li><li>库存不超卖：10个库存不能卖出超过10个</li></ol><p>在V1版本中，我们主要通过MySQL的行锁机制和事务来解决这个问题。事务保证生成订单和扣减库存操作要么同时成功，要么同时失败，保证二者的一致性。锁机制保证不超卖</p><h3 id="4-0使用事务确保原子性"><a href="#4-0使用事务确保原子性" class="headerlink" title="4.0使用事务确保原子性"></a>4.0使用事务确保原子性</h3><p>在秒杀过程中，减库存和创建订单必须是一个原子操作，要么都成功，要么都失败。我们使用Spring的事务管理来实现这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> SeckillOrder <span class="hljs-title function_">seckill</span><span class="hljs-params">(Long userId, GoodsVo goodsVo)</span> &#123;<br>    <span class="hljs-comment">// 1. 减少库存  这里减少的逻辑影响着并发量和正确性 </span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> goodsService.reduceStock(goodsVo.getSeckillGoodsId());<br>    <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-comment">// 2. 创建订单</span><br>        <span class="hljs-keyword">return</span> orderService.createOrder(userId, goodsVo);<br>    &#125;<br>    <span class="hljs-comment">// 库存减少失败，秒杀失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>@Transactional</code>注解，Spring会自动管理事务，确保减库存和创建订单要么都成功，要么都失败。</p><h3 id="4-1-超卖问题"><a href="#4-1-超卖问题" class="headerlink" title="4.1 超卖问题"></a>4.1 超卖问题</h3><p>超卖是指实际卖出的商品数量超过了库存数量。这通常是由于并发环境下，多个事务同时读取了当前库存，并同时进行了扣减，导致最终库存变成了负数。</p><p>核心代码为    <code>boolean success = goodsService.reduceStock(goodsVo.getSeckillGoodsId());</code> </p><h4 id="v0错误示范"><a href="#v0错误示范" class="headerlink" title="v0错误示范"></a>v0错误示范</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102025652.png" alt="image-20250307140912254"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockIncorrect</span><span class="hljs-params">(Long seckillGoodsId)</span> &#123;<br>    <span class="hljs-comment">// 1. 查询库存（未加锁）</span><br>    <span class="hljs-type">SeckillGoods</span> <span class="hljs-variable">goods</span> <span class="hljs-operator">=</span> goodsDao.getStock(seckillGoodsId);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> goods.getStockCount();<br>    <br>    <span class="hljs-comment">// 同时大量请求到达（例如10000），大家在数据库中查询的数量都是同一个例如10，那么所有人都会认为库存充足，导致超卖</span><br>    <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2. 扣减库存</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> goodsDao.updateStock(seckillGoodsId);<br>        <span class="hljs-keyword">return</span> affectedRows &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br>&lt;!-- 查询信息，不加锁 --&gt;<br>&lt;select id=<span class="hljs-string">&quot;getStock&quot;</span> resultType=<span class="hljs-string">&quot;SeckillGoods&quot;</span>&gt;<br>    SELECT * FROM seckill_goods <span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125;<br>&lt;/select&gt;<br><br>&lt;!-- 更新库存 --&gt;<br>&lt;update id=<span class="hljs-string">&quot;updateStock&quot;</span>&gt;<br>    UPDATE seckill_goods<br>    <span class="hljs-type">SET</span> <span class="hljs-variable">stock_count</span> <span class="hljs-operator">=</span> stock_count - <span class="hljs-number">1</span>, version = version + <span class="hljs-number">1</span><br>    <span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125;<br>&lt;/update&gt;<br></code></pre></td></tr></table></figure><h4 id="v1-悲观锁实现"><a href="#v1-悲观锁实现" class="headerlink" title="v1 悲观锁实现"></a>v1 悲观锁实现</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102025653.png" alt="image-20250307141148942"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockByPessimisticLock</span><span class="hljs-params">(Long seckillGoodsId)</span> &#123;<br>    <span class="hljs-comment">// 1. 查询时加锁（FOR UPDATE）</span><br>    <span class="hljs-type">SeckillGoods</span> <span class="hljs-variable">goods</span> <span class="hljs-operator">=</span> goodsDao.getSeckillGoodsForUpdate(seckillGoodsId);<br>    <span class="hljs-keyword">if</span> (goods != <span class="hljs-literal">null</span> &amp;&amp; goods.getStockCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2. 扣减库存</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> goodsDao.updateStock(seckillGoodsId);<br>        <span class="hljs-keyword">return</span> affectedRows &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>-- 查询时加锁<br>SELECT * FROM seckill_goods<br><span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125; AND stock_count &gt; <span class="hljs-number">0</span><br>FOR UPDATE<br><br>-- 更新库存<br>UPDATE seckill_goods<br><span class="hljs-type">SET</span> <span class="hljs-variable">stock_count</span> <span class="hljs-operator">=</span> stock_count - <span class="hljs-number">1</span>, version = version + <span class="hljs-number">1</span><br><span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125;<br></code></pre></td></tr></table></figure><p>这个版本为悲观锁的实现，是最基础的实现，也就是在查询的使用通过<code>FOR UPDATE</code>实现排他，实现其他事务会被阻塞，直到当前事务结束。也就是说，当同时多个请求到达时，只有一个请求能够获取到行级锁，从而执行扣减库存以及生成订单过程，其他请求会被阻塞直到当前事务完成。相当于整个过程变成了串行。系统瓶颈变成了MySQL的处理速度。</p><h4 id="v2-乐观锁实现（版本号方式）"><a href="#v2-乐观锁实现（版本号方式）" class="headerlink" title="v2 乐观锁实现（版本号方式）"></a>v2 乐观锁实现（版本号方式）</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102025654.png" alt="image-20250307141400081"></p><p>这个版本中没用使用锁，而是通过版本号的方式来实现扣减库存，第一步获得库存以及版本后，基于版本进行CAS操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockByVersion</span><span class="hljs-params">(Long seckillGoodsId)</span> &#123;<br>    <span class="hljs-comment">// 1. 获取当前版本号 以及库存</span><br>    <span class="hljs-type">SeckillGoods</span> <span class="hljs-variable">goods</span> <span class="hljs-operator">=</span> goodsDao.getStock(seckillGoodsId);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> goods.getStockCount();<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> goods.getVersion();<br><br>    <span class="hljs-keyword">if</span> (version == <span class="hljs-literal">null</span> || stock &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. 扣减库存（CAS 更新）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> goodsDao.reduceStockByVersion(seckillGoodsId, version);<br>    <span class="hljs-keyword">return</span> affectedRows &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><br>-- 获取版本号 以及库存信息<br>&lt;!-- 查询信息，不加锁 --&gt;<br>&lt;select id=<span class="hljs-string">&quot;getStock&quot;</span> resultType=<span class="hljs-string">&quot;SeckillGoods&quot;</span>&gt;<br>    SELECT * FROM seckill_goods <span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125;<br>&lt;/select&gt;<br>        <br>-- 使用乐观锁更新库存<br>&lt;update id=<span class="hljs-string">&quot;reduceStockByVersion&quot;</span>&gt;<br>    UPDATE seckill_goods<br>    <span class="hljs-type">SET</span> <span class="hljs-variable">stock_count</span> <span class="hljs-operator">=</span> stock_count - <span class="hljs-number">1</span>, version = version + <span class="hljs-number">1</span><br>    <span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125; <span class="hljs-type">AND</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> #&#123;version&#125;<br>&lt;/update&gt;<br></code></pre></td></tr></table></figure><p>第一步查询操作会有多个用户同时获得同样的库存以及版本信息，然后拿着这个库存以及版本去做CAS的库存更新操作，只有第一个人的<code>AND version = #&#123;version&#125;</code>条件可以满足，后面的都会失败，从而实现不超卖。</p><p><strong>缺点</strong>：在大量并发请求下，非常多的请求都会失败，只有少部分能成功，导致并发量很低。例如极端场景下，1000个库存，100个人来抢并且同时进来，只会有一个人成功，剩余99个都因为版本对不上导致失败，但其实数据库还有999个库存。</p><p>改进：其实stock在这里就是代表着版本，并不需要再额外使用一个version字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockByVersion</span><span class="hljs-params">(Long seckillGoodsId)</span> &#123;<br>    <span class="hljs-comment">// 1. 获取当前版本号 以及库存</span><br>    <span class="hljs-type">SeckillGoods</span> <span class="hljs-variable">goods</span> <span class="hljs-operator">=</span> goodsDao.getStock(seckillGoodsId);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> goods.getStockCount();<br><br>    <span class="hljs-keyword">if</span> (stock &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. 扣减库存（CAS 更新 基于stock）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> goodsDao.reduceStockByVersion(seckillGoodsId, stock);<br>    <span class="hljs-keyword">return</span> affectedRows &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br>&lt;!-- 查询信息，不加锁 --&gt;<br>&lt;select id=<span class="hljs-string">&quot;getStock&quot;</span> resultType=<span class="hljs-string">&quot;SeckillGoods&quot;</span>&gt;<br>    SELECT * FROM seckill_goods <span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125;<br>&lt;/select&gt;<br>        <br>-- 使用乐观锁更新库存<br>&lt;update id=<span class="hljs-string">&quot;reduceStockByStock&quot;</span>&gt;<br>    UPDATE seckill_goods<br>    <span class="hljs-type">SET</span> <span class="hljs-variable">stock_count</span> <span class="hljs-operator">=</span> stock_count - <span class="hljs-number">1</span><br>    <span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125; <span class="hljs-type">AND</span> <span class="hljs-variable">stock_count</span> <span class="hljs-operator">=</span> #&#123;stock_count&#125;<br>&lt;/update&gt;<br></code></pre></td></tr></table></figure><h4 id="V3：最终优化实现"><a href="#V3：最终优化实现" class="headerlink" title="V3：最终优化实现"></a>V3：最终优化实现</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202503102022648.png" alt="image-20250307141458066"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reduceStockWhenLeft</span><span class="hljs-params">(Long seckillGoodsId)</span> &#123;<br>    <span class="hljs-comment">// 直接执行原子更新，由数据库保证并发安全</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> goodsDao.reduceStockWhenLeft(seckillGoodsId);<br>    <span class="hljs-keyword">return</span> affectedRows &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><br>-- 原子更新：只在库存大于<span class="hljs-number">0</span>时更新，单条 SQL 保证原子性<br>UPDATE seckill_goods<br><span class="hljs-type">SET</span> <span class="hljs-variable">stock_count</span> <span class="hljs-operator">=</span> stock_count - <span class="hljs-number">1</span><br><span class="hljs-type">WHERE</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;seckillGoodsId&#125; AND stock_count &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里的stock_count本质上也可也看作一种乐观锁，只是锁的条件没有那么严格，并不是进行等值条件的乐观，而是大于零都放行，使得大量的用户请求都可以执行，只有没有库存时才会执行失败。失败率远远小于v2.</p><p>在本质上，其实是基于mysql的行锁来实现排他的，<code>SET stock_count = stock_count - 1</code>在mysql底层会获取一个排他锁</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在本篇文章中，我们从零开始实现了秒杀系统的基础版本，重点探讨了如何利用MySQL的事务和锁机制来解决高并发场景下的数据一致性问题。我们对比了四种不同的库存扣减实现方案：</p><ol><li><strong>错误示范（V0）</strong>：不加锁直接读取和更新库存，在并发环境下会导致超卖问题。</li><li><strong>悲观锁实现（V1）</strong>：使用<code>FOR UPDATE</code>语句在查询时加锁，保证同一时间只有一个事务可以操作库存，但会导致请求串行化，系统吞吐量受限。</li><li><strong>乐观锁实现（V2）</strong>：通过版本号机制实现无锁并发控制，避免了长时间的锁等待，但在高并发下成功率较低，可能导致大量请求失败。</li><li><strong>优化实现（V3）</strong>：使用单条带条件的UPDATE语句实现原子性操作，既保证了数据一致性，又提高了系统的并发处理能力。</li></ol><p>这四种实现方案各有优缺点，在实际应用中可以根据业务场景和性能需求进行选择。其中，第四种实现是最为推荐的方案，它在保证数据一致性的同时，提供了较好的并发性能。</p><p>然而，在实际的秒杀系统中，仅依靠数据库层面的优化是不够的。当并发量达到一定程度时，数据库很容易成为系统的瓶颈，影响整体性能和用户体验。</p><h2 id="6-展望：Redis优化篇"><a href="#6-展望：Redis优化篇" class="headerlink" title="6. 展望：Redis优化篇"></a>6. 展望：Redis优化篇</h2><p>在下一篇《从零开始实现秒杀系统（二）：Redis优化篇》中，我们将继续深入探讨如何优化秒杀系统，重点介绍如何利用Redis来提升系统性能。主要内容将包括：</p><ol><li><strong>Redis预减库存</strong>：使用Redis缓存库存信息，在Redis中预先扣减库存，减轻数据库压力。</li><li><strong>异步下单</strong>：通过消息队列实现异步下单，提高系统吞吐量。</li><li><strong>Redis分布式锁</strong>：使用Redis实现分布式锁，保证分布式环境下的数据一致性。</li></ol><p>通过引入Redis等中间件技术，我们将构建一个更加高效、稳定的秒杀系统，能够承受更高的并发压力，为用户提供更好的秒杀体验。敬请期待！</p><hr><p>本文源码已开源在GitHub：<a href="https://github.com/Goinggoinggoing/seckill">Goinggoinggoing&#x2F;seckill</a></p><p>如有疑问或建议，欢迎在评论区讨论！</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
      <tag>秒杀系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线上BUG定位</title>
    <link href="/2024/07/27/TechDigest/%E7%BA%BF%E4%B8%8Abug%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/07/27/TechDigest/%E7%BA%BF%E4%B8%8Abug%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文讨论了大规模项目开发中常见的运维与调试问题，并提出了一系列解决方案：  1. <strong>Bug应急管理</strong>：对于影响较大的Bug，优先采取紧急止损措施，如回滚版本或关闭功能模块。同时强调事后复盘的重要性以避免类似问题。  2. <strong>数据一致性问题</strong>：    - 缓存与数据库不一致时（如新增字段未同步缓存），需手动清除缓存或刷新数据。    - 避免滥用重启（可能掩盖问题），重点关注单例数据被意外修改的场景（如YAML配置污染）。  3. <strong>调试优化建议</strong>：    - 建立常见问题文档库，提倡以日志为主、单元测试为辅的调试方式。    - 生产环境优先通过日志、链路追踪定位问题，谨慎使用远程Debug。    - 推荐使用开关控制入参&#x2F;出参打印，平衡问题排查与性能消耗。  4. <strong>资源消耗故障案例</strong>：    - <strong>CPU过载</strong>：死循环代码（如自旋等待文件更新）或线程管理不当（未使用线程池）会导致资源耗尽。    - <strong>内存问题</strong>：大文件一次性加载（如<code>readAllBytes</code>）可能触发虚拟内存频繁交换，应改用流式处理（如<code>BufferedReader</code>）；频繁GC（如循环内重复创建对象）可通过对象复用优化。    - <strong>资源泄漏</strong>：未关闭文件句柄、HTTP连接或僵尸线程需通过工具检测。  5. <strong>诊断工具链</strong>：    - 基础命令：<code>jps</code>定位进程、<code>top</code>&#x2F;<code>ps</code>查线程、<code>jstack</code>抓取线程栈。    - 高级工具：Arthas实时监控（<code>dashboard</code>）、线程分析（<code>thread -n 3</code>）及详细堆栈查看。  全文贯穿”预防-处理-复盘”的闭环思路，强调通过规范开发习惯（如日志优先、流式处理）和工具化手段提升系统稳定性。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="BUG处理"><a href="#BUG处理" class="headerlink" title="BUG处理"></a>BUG处理</h2><h3 id="feature还是bug"><a href="#feature还是bug" class="headerlink" title="feature还是bug"></a>feature还是bug</h3><ul><li>大规模项目，沉淀所有的feature也有难度，需求也是不断变化的（QA）</li><li>bug紧急程度、bug负责团队以及人员</li></ul><h3 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h3><ol><li><strong>紧急止损</strong>：根据 bug 的严重性，判断是否需要快速下线相关功能或回滚版本。对于影响较大的 bug，应优先考虑通过回滚代码或关闭功能模块来避免对用户产生进一步影响。</li><li>问题排查</li><li>事后复盘</li></ol><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><h4 id="基本解决思路"><a href="#基本解决思路" class="headerlink" title="基本解决思路"></a>基本解决思路</h4><ul><li><p>清缓存：对象加了字段，数据库用脚本补充了，但缓存没有补充，导致缓存数据不完整</p></li><li><p>刷新</p></li><li><p>重启：可能可以临时解决问题，但会影响bug定位</p></li><li><p>单例数据：YAML对象被别人修改了，导致后续其他业务场景出现BUG</p></li><li><p>维护一个文档，常见问题以及解决方法</p></li><li><p>非生产以及本地写代码时，养成习惯不要依靠单步调试，<strong>以日志为主</strong></p></li><li><p>不依赖本地项目启动来测试服务，而是通过单元测试实现</p></li></ul><h4 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h4><p>逻辑+数据，逻辑在代码中，但不同的数据也会走不同的逻辑，生产的完整数据比较难拿到</p><ul><li>看日志（生产INFO，测试DEBUG）以及错误码定位问题</li><li>链路追踪，在链路中定位问题</li><li>测试环境复现，远程debug</li><li>生产环境复现</li><li>打印入参出参：开关</li></ul><h2 id="CPU占用高"><a href="#CPU占用高" class="headerlink" title="CPU占用高"></a>CPU占用高</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410291625637.png" alt="image-20241029154240811"></p><h3 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h3><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>例如：我们有一段代码用来检查文件的更新状态，但由于逻辑错误，条件永远无法满足，结果程序进入了死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (file.isUpdated()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>如果是自旋等待，就会耗尽CPU</li><li>如果是休眠等待，例如synchronized ，会耗尽系统资源（线程、内存、锁、数据库连接、文件句柄）</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410291625640.png" alt="image-20241029154327812"></p><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>使用线程池来管理线程资源，设置合理的线程数量</p><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><h4 id="内存不足"><a href="#内存不足" class="headerlink" title="内存不足"></a>内存不足</h4><p>当系统内存不足时，就会将磁盘存储作为虚拟内存使用，而虚拟内存的运行速度要慢得多。</p><blockquote><p>例如：直接一次性加载一个非常大的文件到内存中，导致内存不足</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] largeData = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;largeFile.txt&quot;</span>))<br></code></pre></td></tr></table></figure><p>这种过度的分页和交换会导致 CPU 占用率居高不下，因为处理器需要花费更多时间来管理内存访问，而不是高效地执行进程。</p><p><strong>解决方案</strong>：优化内存使用，采用流式处理避免一次性加载大文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Files.newBufferedReader(Paths.get(<span class="hljs-string">&quot;largeFile.txt&quot;</span>))) &#123;<br>    String line;<br>    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 处理每一行数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="频繁GC"><a href="#频繁GC" class="headerlink" title="频繁GC"></a>频繁GC</h4><p>频繁的垃圾回收（GC）操作会占用大量CPU资源，导致性能下降。</p><blockquote><p>例如：程序中频繁创建和销毁对象，导致GC频繁触发</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;temp&quot;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>内存资源没有释放，例如文件、http请求没有close、线程创建后卡死在某个地方没有销毁</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>首先，需要找到CPU占用高的Java进程的PID（进程ID）。可以使用 top 或 ps 命令来找到该进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps <span class="hljs-comment"># java的进程</span><br>top -H -p &lt;PID&gt; <span class="hljs-comment"># 找到进程中最耗 CPU 的线程 ID</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%x\n&quot;</span> &lt;thread_id&gt;  <span class="hljs-comment"># 转换为十六进制</span><br>jstack -l &lt;PID&gt; &gt; thread_dump.txt  <span class="hljs-comment"># 生成线程快照</span><br>grep <span class="hljs-string">&quot;0x&lt;hex_thread_id&gt;&quot;</span> thread_dump.txt -A 20  <span class="hljs-comment"># 显示包含该线程ID的线程栈信息</span><br></code></pre></td></tr></table></figure><h4 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O https://arthas.aliyun.com/arthas-boot.jar<br>java -jar arthas-boot.jar  <span class="hljs-comment"># 启动</span><br><br>dashboard <span class="hljs-comment"># 显示整体性能  memory情况</span><br>thread -n 3  <span class="hljs-comment"># CPU 使用率最高的 3 个线程</span><br>thread 8 <span class="hljs-comment"># 8号线程堆栈信息</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.nowcoder.com/discuss/676462263401836544?sourceSSR=users">面试官最爱问：CPU100%如何处理？_牛客网</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1iU2WYnENL/">如何快速定位问题_哔哩哔哩_bilibili</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线上处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hotKey检测</title>
    <link href="/2024/07/20/TechDigest/hotKey%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/07/20/TechDigest/hotKey%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>摘要内容：  热点检测的核心是从流式数据中高效计算topk。传统Hashmap+堆排序适用于有限数据，但海量数据场景需更优算法。对于频率超过半数的问题，可以通过候选计数法解决（维护候选元素，相同则+1，不同则-1，扣减次数有限保证结果正确）。推广到频率超过m&#x2F;k的元素时，需维护k-1个候选集合，通过增减计数过滤低频项，结果可能出现假阳性但无假阴性。  优化算法层面： 1. <strong>Count-Min Sketch</strong>：通过多哈希函数映射到二维桶数组，取最小值降低哈希冲突影响，配合最小堆获取topk。 2. <strong>衰减改进（2018年）</strong>：引入指纹与指数衰减（如概率P &#x3D; b^(-C)），有效剔除低频干扰。 3. <strong>突发流量适应</strong>：原始算法因历史数据堆积难以快速检测突发热点（如新元素需长时间累积频次）。引入衰减因子（如Ci &#x3D; Ci&#x2F;n），通过等比数列求和平衡实时性与准确性。  系统实现（以Burning为例）： - <strong>架构分层</strong>：Client上报Key，Worker集群计算热点，Config中心（如etcd）存储规则，Admin管理台监控配置。 - <strong>关键能力</strong>：Client本地缓存热Key，Worker滑动窗口统计，Admin实时推送，Config保证一致性。 - <strong>优势</strong>：无状态Worker、长连接通信、动态规则配置，兼顾实时探测与资源效率。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>对于访问流量的热点检测，本质是如何从流式数据计算出topk。对于有限的数据项，可以简单地使用 Hashmap+Heap-Sort来对数据进行计数排序。但是对于海量数据以及有限的内存，该方法几乎是行不通的。因此我们需要使用更高效的数据结构和算法来实现。</p><h3 id="Majority问题"><a href="#Majority问题" class="headerlink" title="Majority问题"></a>Majority问题</h3><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半 m &#x2F; 2，请找出这个数字。</p></blockquote><p><a href="https://leetcode.cn/problems/majority-element/description/">169. 多数元素 - 力扣（LeetCode）</a></p><p>解决：维护一个候选元素以及数量，如果下一个元素相同，则++， 否者–；计数为0时更换候选元素</p><ul><li>最多扣减 m &#x2F; 2 - 1次，因此majority元素不会被扣成0</li></ul><h3 id="Misra-Gries算法"><a href="#Misra-Gries算法" class="headerlink" title="Misra-Gries算法"></a>Misra-Gries算法</h3><p>推广</p><blockquote><p>数据流中一共有m个元素，请找出出现频率超过m &#x2F; k的k - 1个元素。</p></blockquote><p>维护k - 1个候选值与计数器的集合：</p><ul><li><p>如果元素在集合中，将其对应的计数器自增；</p></li><li><p>如果元素不在集合中且集合未满，就将元素加入集合，计数器设为1；</p></li><li><p>如果元素不在集合中且集合已满，将集合内所有计数器自减，计数器减为0的元素被移</p></li><li><p>每次减少计数k次（k-1 + 触发元素1），最多减少m&#x2F;k 次，所以最终大于m&#x2F;k的一定能留下来</p></li><li><p>最终结果能够保证没有假阴性（false negative），即不会漏掉实际频率高于m &#x2F; k的元素。但可能会出现假阳性（false positive），即混入实际频率低于m &#x2F; k的元素。</p></li></ul><h3 id="Lossy-Counting"><a href="#Lossy-Counting" class="headerlink" title="Lossy Counting"></a>Lossy Counting</h3><ul><li>将数据切分成k个窗口，每次添加窗口内元素的频率并且最后 所有元素频率–，删除等于零的元素</li><li>窗口越大误差越小</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091919356.png" alt="image-20241009151313681"></p><h3 id="Count-Min-Sketch"><a href="#Count-Min-Sketch" class="headerlink" title="Count-Min Sketch"></a>Count-Min Sketch</h3><ul><li><p>一个二维数组，宽w（桶的个数），深度d（hash函数个数）</p></li><li><p>d个hash函数</p></li><li><p>每一个元素x，通过d个hash映射到d个位置上++</p></li><li><p>计数时，为d个hash函数的结果最小值；</p></li><li><p>结果偏大，hash冲突越低约接近真实值</p></li><li><p>获得topk：额外维护一个最小堆topk</p></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091919357.png" alt="image-20241009151820033"></p><h3 id="HeavyKeeper"><a href="#HeavyKeeper" class="headerlink" title="HeavyKeeper"></a>HeavyKeeper</h3><p>2018年提出，对CM sketch算法在hash冲突时进行了优化，使用指纹结合指数衰减，剔除低频袁术</p><ol><li><p>初始化d个w桶的哈希表,所有指纹和计数器置零</p></li><li><p>对于数据流中的每个元素x:</p><ul><li>计算d个哈希值: h1(x), h2(x), …, hd(x)</li><li>对每个哈希表i (1 ≤ i ≤ d):<ul><li>if 第hi(x)个桶的指纹为空或等于x的指纹:<ul><li>增加计数器</li></ul></li><li>else:<ul><li>以一定概率减少计数器<code>P = b^(-C)</code>，<strong>C越小衰减概率越低，可用保证低频元素快速被剔除，而高频可以保留</strong><ul><li>b 是一个大于1的参数，通常设置为1.08</li><li>C 是当前的计数器值</li></ul></li><li>如果计数器变为0,则用x的指纹替换当前指纹</li></ul></li></ul></li></ul></li><li><p>查询时,返回d个表中x对应位置的最大计数值作为频率估计</p></li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091919358.png" alt="image-20241009154341231"></p><p><strong>突发流量：</strong></p><p>原始的算法实现在统计topk的时候具有很高的准确率，但是对于在线<strong>实时热点统计</strong>，当出现突发热点数据的时候，由于历史数据流的频次统计堆积，原有算法很难快速识别突发热点。举个简单例子:</p><p>在实时数据流中统计出现频次最高的 top3，假设元素 a b c 是历史数据中访问频次最高的三个元素，且qps 都为10 ，在不考虑哈希冲突的情况下，假设数据流持续了1000s， 那么此时二维数组中这三个元素对应的频次则都为 1w, 从1001s开始，出现了一个突发热点元素d， 元素 d 的 qps 为100，按原始算法， 元素 d 得在频次超过1w以后才会被加入top3，当频次达到1w时，距离突发热点出现已经过去了100s，原始实现对于突发热点的检测是相当迟钝的。</p><p><strong>引入衰减</strong>：每隔 1s 所有元素的统计频次 Ci 衰减为 Ci &#x3D; Ci &#x2F; n, n为衰减因子，且n大于1 </p><p>假如qps为x，k秒后的值为等比数列求和，当k区域无穷大时，C(j,k) &#x3D; n&#x2F;(n-1) * x</p><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><p><strong>1、etcd集群</strong></p><p>etcd作为一个高性能的配置中心，可以以极小的资源占用，提供高效的监听订阅服务。主要用于存放规则配置，各worker的ip地址，以及探测出的热key、手工添加的热key等。</p><p><strong>2、client端jar包</strong></p><p>就是在服务中添加的引用jar，引入后，就可以以便捷的方式去判断某key是否热key。同时，该jar完成了key上报、监听etcd里的rule变化、worker信息变化、热key变化，对热key进行本地caffeine缓存等。</p><p><strong>3、worker端集群</strong></p><p>worker端是一个独立部署的Java程序，启动后会连接etcd，并定期上报自己的ip信息，供client端获取地址并进行长连接。之后，主要就是对各个client发来的待测key进行累加计算，当达到etcd里设定的rule阈值后，将热key推送到各个client。</p><p><strong>4、dashboard控制台</strong></p><p>控制台是一个带可视化界面的Java程序，也是连接到etcd，之后在控制台设置各个APP的key规则，譬如2秒出现20次算热key。然后当worker探测出来热key后，会将key发往etcd，dashboard也会监听热key信息，进行入库保存记录。同时，dashboard也可以手工添加、删除热key，供各个client端监听。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091919359.png" alt="image-20241009162919213"></p><h3 id="得物"><a href="#得物" class="headerlink" title="得物"></a>得物</h3><p>Burning的架构设计遵循了以上热点探测的技术原理，同时借鉴了jd-hotKey的设计思路，主要分为Burning-Admin、Burning-Worker、Burning-Config、Burning-Client四个模块：</p><ul><li><strong>Burning-Admin （热点探测管理台）</strong>：与Worker节点Netty长链接通信，提供不同维度的应用管理和热点规则配置，提供查询热点数据统计，规则和热点数据监控大盘，提供工作集群信息查询及客户端节点信息查询，提供本地缓存动态配置及热点信息实时通知</li><li><strong>Burning-Worker（热点集中计算单元）</strong>：无状态server端，与管理台和客户端进行Netty长链接通信，获取规则，滑动窗口计算热点，将热点记录推送到管理台展示和客户端处理</li><li><strong>Burning-Config（热点配置中心）</strong>：作为热点、规则配置中心和注册中心，将规则配置下发到Worker节点和客户端，通过Raft算法进行系统高可用一致性保证</li><li><strong>Burning-Client（热点客户端SDK）</strong>：与Worker节点建立Netty长链接通信，监听配置中心配置变化定时推送热Key数据，获取热Key推送本地内缓存设置，与Redis-client无缝集成及其他ORM框架无缝集成</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091919360.png" alt="image-20241009162933639"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/nazeniwaresakini/article/details/109113529">大数据流的在线Heavy Hitters算法（上篇）：基于计数器的方法-CSDN博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/read/cv20999025/">热点检测治理 - 哔哩哔哩 (bilibili.com)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/xOzEj5HtCeh_ezHDPHw6Jw">京东毫秒级热key探测框架设计与实践，已实战于618大促 (qq.com)</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://tech.dewu.com/article?id=23">得物热点探测技术架构设计与实践 (dewu.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>高并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>热点key</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见限流算法</title>
    <link href="/2024/07/10/TechDigest/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/10/TechDigest/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>文章主要讨论了限流算法的几种实现方式及其特点。  首先提到固定窗口限流算法（Fixed Window），通过设定时间窗口内的最大请求数来限流。该方法实现简便，但存在临界突发问题，即在窗口边界可能出现流量突增的情况（如两个窗口交界处可能允许两倍流量通过）。  滑动窗口限流算法（Sliding Window）通过记录请求时间戳队列动态计算窗口内请求数，相比固定窗口更精确，但内存消耗大且清理过期数据可能影响性能。  平滑滑动窗口（Smooth Sliding Window）进一步优化，将大窗口划分为多个子窗口，通过周期重置子窗口计数来平滑流量统计。使用锁保证线程安全，适合热点检测等场景。  漏桶算法（Leaky Bucket）以恒定速率处理请求，实现流量整形。通过控制漏水速率和桶容量来平滑流量，但对突发流量处理较严格。文中代码示例仅实现容量检查，未完全体现匀速处理特性。  令牌桶算法（Token Bucket）定期向桶添加令牌，允许突发流量消耗积累的令牌。通过控制令牌生成速率和桶容量实现灵活限流，适合需要容忍短期突发的场景。  各算法对比：固定窗口实现简单但有临界问题；滑动窗口精度高但资源消耗大；漏桶强制流量匀速；令牌桶允许突发但控制速率。选择时需权衡精度、性能和业务需求。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h3><p><strong>临界突发问题</strong>：在窗口的边界，可能有大量流量</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091809783.png" alt="image-20241009180923079"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedWindowRateLimiter</span> &#123;<br><br>    <span class="hljs-comment">// 每个窗口允许的最大请求数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxRequests;<br>    <span class="hljs-comment">// 窗口大小，单位为毫秒</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowSizeInMillis;<br>    <span class="hljs-comment">// 记录当前窗口开始的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> windowStart;<br>    <span class="hljs-comment">// 当前窗口内的请求计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger requestCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FixedWindowRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> maxRequests, <span class="hljs-type">long</span> windowSizeInMillis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.maxRequests = maxRequests;<br>        <span class="hljs-built_in">this</span>.windowSizeInMillis = windowSizeInMillis;<br>        <span class="hljs-built_in">this</span>.windowStart = System.currentTimeMillis();<br>        <span class="hljs-built_in">this</span>.requestCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allowRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-comment">// 判断当前时间是否已经进入新的窗口</span><br>        <span class="hljs-keyword">if</span> (currentTime - windowStart &gt;= windowSizeInMillis) &#123;<br>            <span class="hljs-comment">// 重置窗口</span><br>            windowStart = currentTime;<br>            requestCount.set(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 判断是否可以在当前窗口内处理请求</span><br>        <span class="hljs-keyword">if</span> (requestCount.incrementAndGet() &lt;= maxRequests) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 允许请求</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 拒绝请求</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>简单实现：内存占用可能较大，每次请求都需要清理过期数据，可能影响性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlidingWindowRateLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowSizeInMillis;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxRequests;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Long&gt; requestTimestamps;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SlidingWindowRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> windowSizeInSeconds, <span class="hljs-type">int</span> maxRequests)</span> &#123;<br>        <span class="hljs-built_in">this</span>.windowSizeInMillis = windowSizeInSeconds * <span class="hljs-number">1000L</span>;<br>        <span class="hljs-built_in">this</span>.maxRequests = maxRequests;<br>        <span class="hljs-built_in">this</span>.requestTimestamps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allowRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        <span class="hljs-comment">// 移除窗口外的请求时间戳</span><br>        <span class="hljs-keyword">while</span> (!requestTimestamps.isEmpty() &amp;&amp; currentTime - requestTimestamps.peek() &gt;= windowSizeInMillis) &#123;<br>            requestTimestamps.poll();<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否超过限制</span><br>        <span class="hljs-keyword">if</span> (requestTimestamps.size() &lt; maxRequests) &#123;<br>            requestTimestamps.offer(currentTime);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">SlidingWindowRateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SlidingWindowRateLimiter</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 1秒内最多3个请求</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Request &quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; allowed: &quot;</span> + rateLimiter.allowRequest());<br>            Thread.sleep(<span class="hljs-number">300</span>); <span class="hljs-comment">// 每次请求间隔300毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>平滑滑动窗口（划分多个小窗口）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmoothSlidingWindowRateLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowSizeInMillis;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxRequests;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> subWindowCount;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger[] subWindows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> currentWindowStart;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmoothSlidingWindowRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> windowSizeInSeconds, <span class="hljs-type">int</span> maxRequests, <span class="hljs-type">int</span> subWindowCount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.windowSizeInMillis = windowSizeInSeconds * <span class="hljs-number">1000L</span>;<br>        <span class="hljs-built_in">this</span>.maxRequests = maxRequests;<br>        <span class="hljs-built_in">this</span>.subWindowCount = subWindowCount;<br>        <span class="hljs-built_in">this</span>.subWindows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>[subWindowCount];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subWindowCount; i++) &#123;<br>            subWindows[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.currentWindowStart = System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allowRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (now - currentWindowStart &gt; windowSizeInMillis) &#123;<br>                slideWindow(now);<br>            &#125;<br>            <br>            <span class="hljs-type">long</span> <span class="hljs-variable">totalRequests</span> <span class="hljs-operator">=</span> getTotalRequests();<br>            <span class="hljs-keyword">if</span> (totalRequests &lt; maxRequests) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (((now - currentWindowStart) * subWindowCount) / windowSizeInMillis);<br>                subWindows[index].incrementAndGet();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">slideWindow</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">newWindowStart</span> <span class="hljs-operator">=</span> now - windowSizeInMillis;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">windowDiff</span> <span class="hljs-operator">=</span> newWindowStart - currentWindowStart;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resetCount</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((windowDiff * subWindowCount) / windowSizeInMillis);<br>        <br>        <span class="hljs-keyword">if</span> (resetCount &gt;= subWindowCount) &#123;<br>            <span class="hljs-keyword">for</span> (AtomicInteger subWindow : subWindows) &#123;<br>                subWindow.set(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; resetCount; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (((currentWindowStart - newWindowStart) * subWindowCount) / windowSizeInMillis + i) % subWindowCount;<br>                subWindows[index].set(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        currentWindowStart = newWindowStart;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTotalRequests</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (AtomicInteger subWindow : subWindows) &#123;<br>            total += subWindow.get();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">SmoothSlidingWindowRateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmoothSlidingWindowRateLimiter</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 1秒内最多10个请求，分成10个小窗口</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Request &quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; allowed: &quot;</span> + rateLimiter.allowRequest());<br>            Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 每次请求间隔100毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也常用于热点key的检测</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>固定速率处理请求，处理任意流量更加平滑，可以实现流量整形；</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091910916.png" alt="image-20241009182620292"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeakyBucket</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity; <span class="hljs-comment">//漏桶容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rate; <span class="hljs-comment">//漏水速率</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> water; <span class="hljs-comment">//当前水量</span><br>    <span class="hljs-keyword">private</span> Instant timestamp; <span class="hljs-comment">//上次漏水时间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LeakyBucket</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">int</span> rate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.rate = rate;<br>        <span class="hljs-built_in">this</span>.water = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.timestamp = Instant.now();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allow</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//判断是否允许通过</span><br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Instant.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> now.toEpochMilli() - timestamp.toEpochMilli(); <span class="hljs-comment">//计算距上次漏水过去了多久</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">outflow</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (duration * rate / <span class="hljs-number">1000</span>); <span class="hljs-comment">//计算过去的时间内漏出的水量</span><br>        water = Math.max(<span class="hljs-number">0</span>, water - outflow); <span class="hljs-comment">//更新当前水量，不能小于0</span><br>        <span class="hljs-keyword">if</span> (water &lt; capacity) &#123; <span class="hljs-comment">//如果漏桶还没满，放行</span><br>            water++;<br>            timestamp = now;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//否则拒绝通过</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 感觉这个代码只做到了  对超过桶容量的请求拒绝对接受的请求，好像并没有按照漏桶的速度进行处理，而是小于capacity就立马处理了？</span><br></code></pre></td></tr></table></figure><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>通过控制桶中的令牌实现限流，可以处理一定的突发流量，比如处理一次洪峰。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202410091910917.png" alt="image-20241009182632661"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenBucket</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lastTime;  <span class="hljs-comment">// 上次请求时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> rate;    <span class="hljs-comment">// 令牌放入速率</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> capacity;  <span class="hljs-comment">// 令牌桶容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> tokens;    <span class="hljs-comment">// 当前令牌数量</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TokenBucket</span><span class="hljs-params">(<span class="hljs-type">double</span> rate, <span class="hljs-type">long</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lastTime = System.currentTimeMillis();<br>        <span class="hljs-built_in">this</span>.rate = rate;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.tokens = capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeElapsed</span> <span class="hljs-operator">=</span> now - lastTime;<br>        tokens += timeElapsed * rate;<br>        <span class="hljs-keyword">if</span> (tokens &gt; capacity) &#123;<br>            tokens = capacity;<br>        &#125;<br>        lastTime = now;<br>        <span class="hljs-keyword">if</span> (tokens &gt;= <span class="hljs-number">1</span>) &#123;<br>            tokens--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.51cto.com/article/746838.html">面试官：限流算法有哪些？-推荐算法面试 (51cto.com)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/niumoo/p/16007224.html">5种限流算法，7种限流方式，挡住突发流量？ - 程序猿阿朗 - 博客园 (cnblogs.com)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>高并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发</tag>
      
      <tag>限流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.kafka-rocketmq对比-MQ</title>
    <link href="/2024/07/01/TechDigest/mq/3.kafka-rocketmq%E5%AF%B9%E6%AF%94-MQ/"/>
    <url>/2024/07/01/TechDigest/mq/3.kafka-rocketmq%E5%AF%B9%E6%AF%94-MQ/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要介绍了Kafka和RocketMQ在消息存储和读写机制上的对比。首先解释了Kafka的关键概念，包括Broker（消息处理节点）、Topic（消息类别）、Partition（物理分组）、Segment（存储文件段）和Offset（消息唯一标识）。Kafka采用segment文件存储数据，由.log文件（存储消息数据）和.index文件（稀疏索引）组成，通过二分查找定位消息。写入时使用顺序写和mmap，读取时利用sendfile零拷贝优化性能，但多topic和partition可能导致随机写入问题。    RocketMQ则采用不同设计：所有消息写入统一的CommitLog文件，同时为每个队列建立轻量级ConsumeQueue索引。写入和读取均使用mmap，确保完全顺序写入，但牺牲了sendfile带来的零拷贝优势。两者的对比显示，Kafka适合大数据量场景，但队列过多时性能下降；RocketMQ通过单一CommitLog提升写入性能，但随机读可能因缺页中断影响效率。最后提到RocketMQ的额外功能（如tag过滤、事务支持），并解释其选择mmap而非sendfile是为了灵活性。</p></blockquote><h2 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h2><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p>Kafka部分名词解释如下：</p><ul><li><p>Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</p></li><li><p>Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。</p></li><li><p>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。</p></li><li><p>Segment：partition物理上由多个segment组成。</p></li><li><p>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition<strong>唯一标识</strong>一条消息.（只在partition下唯一）</p></li><li><p>同一个topic下有多个不同partition，每个partition为一个目录，命名规则为topic名称+partition的有序序号</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923111352406.png" alt="image-20240923111352406" style="zoom:50%;" /></li><li><p>一个partition相当于一个巨型文件，被顺序分配到了多个segment文件中，文件名为当前第一条消息的offset</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923111647323.png" alt="image-20240923111647323"></p></li><li><p>segment文件组成</p><ul><li><strong>xxxx.log</strong>：<a href="https://cloud.tencent.com/solution/cloudlog?from_column=20065&from=20065">日志数据</a>文件，按照固定的格式存储生产者分送过来的消息数据 </li><li><strong>xxxx.index</strong>：索引文件，该文件主要记录了哪条消息(offset)写在对应的xxxx.log文件中的哪个位置(position)，查询消息时首先查询该文件，然后再去日志数据文件中读取对应的消息数据。（<strong>稀疏索引存储</strong>的，也就是每隔几条消息数据建一条索引。所以在查找该条消息时只需要找到对应的消息编号最近的索引位置，然后再在数据文件中顺序查找。）</li></ul></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923111653552.png" alt="image-20240923111653552"></p><p>当消费者给出一个offset，需要查找该消息：</p><p>例如读取offset&#x3D;368776的message，需要通过下面2个步骤查找。</p><ul><li>第一步二分查找segment文件，因为文件名是按照offset来命名的</li><li>找到正确的 <code>.index</code> 文件后，Kafka 使用该索引文件中的记录，定位消息在 <code>.log</code> 文件中的大致物理位置。由于 Kafka 的索引是稀疏的，可能并不会直接定位到目标 <code>offset</code> 对应的精确位置，因此 Kafka 会从索引定位的物理地址开始，顺序读取 <code>.log</code> 文件，直到找到目标 <code>offset</code> 的消息。</li></ul><blockquote><p>为什么需要index文件：</p><p>​segment.log文件中存储的每一条消息长度是不一样的，因此如果直接查找需要遍历整个大的log文件，一条一条对比offset，而有了index文件后，变成了O(log n)（二分查找索引）+ O(k)（扫描少量消息）</p></blockquote><p>写（生产）消息：</p><ul><li>index文件较小，可以直接用mmap进行内存映射</li><li>segment文件较大，可以采用普通的write（FileChannel.write），由于是顺序写PageCache，可以达到很高的性能</li></ul><p>读（消费）消息：</p><ul><li>index文件仍然通过mmap读，缺页中断的可能性较小</li><li>segment可以使用sendfile进行零拷贝的发送给消费者，达到非常高的性能</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-comment">// 单次系统调用，以及3 or 2 次数据拷贝</span><br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923115252328.png" alt="image-20240923115252328"></p><p><strong>存在问题：</strong></p><p>在Kafka文件读写中，针对segment文件写入是采用<strong>顺序write</strong>的，但是如果<strong>topic数量以及下面parition数量</strong>一多，从操作系统的角度看就变成了随机写入，导致写入性能下降。</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923113541061.png" alt="image-20240923113541061" style="zoom:50%;" /><h3 id="rocketmq"><a href="#rocketmq" class="headerlink" title="rocketmq"></a>rocketmq</h3><ol><li>所有的消息数据（不同topic、不同队列）都写入同一个文件（当然物理存储时还是会以固定大小进行文件切割），这个文件称之为CommitLog</li><li>为了加速消费消息，建立轻量级索引，为每个队列新增ConsumeQueue文件，存储消息在CommitLog中的文件偏移量，而不是像kafka一样存储完整的消息内容  topic&#x2F;queue&#x2F;file</li><li>现在读取变成了两次，先去queue读偏移，再去CommitLog读数据</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923191338314.png" alt="image-20240923191338314"></p><p>写（生产）消息：</p><ul><li>无论是ConsumeQueue还是CommitLog都使用mmap进行写</li></ul><p>读（消费）消息：</p><ul><li>无论是ConsumeQueue还是CommitLog都使用mmap进行读</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">buf = mmap(file, len);<br>write(sockfd, buf, len);<br><br><span class="hljs-comment">// 两次系统调用 3次数据拷贝（减少一次内核到用户拷贝）</span><br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240923115304549.png" alt="image-20240923115304549"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th></th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td><strong>文件结构</strong></td><td>1.index索引文件 +log文件<br />2.多个队列多个segment消息文件</td><td>1.ConsumeQueue索引文件 <br />2.多个队列一个CommitLog消息文件</td></tr><tr><td><strong>IO写</strong></td><td>1.index文件采用mmap 2.segment采用write</td><td>均采用mmap</td></tr><tr><td><strong>IO读</strong></td><td>1.index文件采用mmap 2.segment采用sendfile</td><td>均采用mmap</td></tr><tr><td><strong>优点</strong></td><td>1.每个topic的队列互不影响 <br />2.数据量较大（&gt;4kb）时写入性能更高 <br />3.消费时可以利用sendfile+DMA零拷贝机制</td><td>1.commitLog完全顺序写 <br />2.单机可以配置更多队列</td></tr><tr><td><strong>缺点</strong></td><td>1.单机队列配置较多时，有性能损失</td><td>1.随机读遇到缺页中断成本高 <br />2.不能利用sendfile机制</td></tr></tbody></table><p>架构上做减法</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>rocketmq </p><ul><li>tag过滤</li><li>支持事务</li><li>延时队列</li><li>死信队列</li></ul><p>sendfile更快，为什么rocketmq不使用？</p><p><code>sendfile</code> 更适用于简单的文件传输，而 RocketMQ 需要对消息数据进行一定的处理和转换（例如死信队列）。<code>mmap</code> 允许直接在用户态中对文件数据进行操作，提供了更大的灵活性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1m7421Z7fN">https://www.bilibili.com/video/BV1m7421Z7fN</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://t1mek1ller.github.io/2019/11/13/kafka-rocketmq-storage/">Kafka和RocketMQ文件存储机制对比 (t1mek1ller.github.io)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html">Kafka文件存储机制那些事 - 美团技术团队 (meituan.com)</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.分布式事务-MQ</title>
    <link href="/2024/06/17/TechDigest/mq/2.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-MQ/"/>
    <url>/2024/06/17/TechDigest/mq/2.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-MQ/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>分布式系统拆分导致的数据一致性问题需要通过分布式事务来解决。文中探讨了分布式事务的几种实现方案，包括基于本地事务包裹消息投递的方式、非可靠消息结合本地消息表和定时任务校对的方法、TCC（Try-Confirm-Cancel）模式，以及传统的两阶段提交（2PC）和三阶段提交（3PC）协议。</p></blockquote><h2 id="分布式事务产生原因？"><a href="#分布式事务产生原因？" class="headerlink" title="分布式事务产生原因？"></a>分布式事务产生原因？</h2><p>分布式系统拆分导致的</p><h3 id="存储拆分"><a href="#存储拆分" class="headerlink" title="存储拆分"></a>存储拆分</h3><p><strong>分库分表</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923037.png" alt="image-20240910151240942"></p><h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a><strong>服务拆分</strong></h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923039.png" alt="image-20240910151827142"></p><p>每个服务有自己的库，不能跨库访问</p><p>用户再下单时，创建订单和扣减库存，需要同时对订单DB和库存DB进行操作。两步操作必须同时成功，否则就会造成业务混乱，可此时我们只能保证自己服务的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p><p>分布式系统中，通常谈论一致性，都是最终一致性，因为即时一致性是不切实际的</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>背景知识：MQ能够实现 at least once（消费者自己处理幂等）</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923040.png" alt="image-20240910154832741" style="zoom:50%;" /><ol><li>A作为生产者，B作为消费者</li><li>A执行动作1，然后发送消息，驱动B执行动作2（动作2幂等）</li></ol><p>问题：</p><ol><li>如果B服务是业务失败（库存不足），如何回滚A的动作？</li><li>A （1）执行动作   （2）发送消息， 如何保证这两个动作的原子性？  （重点问题）</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h3><p>可能的解决方案：基于本地事务包裹消息投递操作的实现方式，对应执行步骤如下：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923041.png" alt="image-20240910155737406"></p><p>致命问题：</p><ol><li>在和数据库交互的本地事务中，夹杂了和第三方组件的 IO 操作，可能存在引发长事务的风险</li><li>执行消息投递时，可能因为超时或其他意外原因，导致出现消息在事实上已投递成功，但 producer 获得的投递响应发生异常的问题，这样就会导致本地事务被误回滚的问题</li><li>在执行事务提交操作时，可能发生失败. 此时事务内的数据库修改操作自然能够回滚，然而 MQ 消息一经发出，就已经无法回收了</li></ol><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>非可靠消息+本地消息事物表+<strong>定时任务校对</strong></p><ol><li><p>不可靠消息：业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失(不可靠消息)。</p></li><li><p>主动方需要本地事务写入 <strong>业务数据+消息数据</strong></p></li><li><p>定期校对：定时查看处于中间态的消息，重新投送</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923042.png" alt="image-20240910175403560"></p></li></ol><p>优点：</p><ul><li>逻辑简单、不依赖特定消息中间件</li><li>引入消息表，占用资源，影响数据库性能</li></ul><h3 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h3><ol><li>本地事物不能包裹消息发送，所以先发一个半消息</li><li>核心是对半消息+check接口判断本地事务的状态（MQ主动发起询问）</li></ol><ul><li>本地事务失败，或者直接宕机，check保证消息被推送到失败状态</li><li>本地事务执行成功，然后宕机，check同样保证消息能被推送到成功状态（特别阶段情况下，比如上游一直没恢复还是会不一致）</li><li>check的机制有点像本地任务表中的定时任务</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923043.png" alt="image-20240830214006481"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示demo，模拟订单表查询服务，用来确认订单事务是否提交成功。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOrderById</span><span class="hljs-params">(String orderId)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//演示demo，模拟本地事务的执行结果。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doLocalTransaction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClientException &#123;<br>    <span class="hljs-type">ClientServiceProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientServiceProvider</span>();<br>    <span class="hljs-type">MessageBuilder</span> <span class="hljs-variable">messageBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBuilderImpl</span>();<br>    <span class="hljs-comment">//构造事务生产者：事务消息需要生产者构建一个事务检查器，用于检查确认异常半事务的中间状态。</span><br>    <span class="hljs-type">Producer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> provider.newProducerBuilder()<br>            .setTransactionChecker(messageView -&gt; &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 事务检查器一般是根据业务的ID去检查本地事务是否正确提交还是回滚，此处以订单ID属性为例。</span><br><span class="hljs-comment">                 * 在订单表找到了这个订单，说明本地事务插入订单的操作已经正确提交；如果订单表没有订单，说明本地事务已经回滚。</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> messageView.getProperties().get(<span class="hljs-string">&quot;OrderId&quot;</span>);<br>                <span class="hljs-keyword">if</span> (Strings.isNullOrEmpty(orderId)) &#123;<br>                    <span class="hljs-comment">// 错误的消息，直接返回Rollback。</span><br>                    <span class="hljs-keyword">return</span> TransactionResolution.ROLLBACK;<br>                &#125;<br>                <span class="hljs-keyword">return</span> checkOrderById(orderId) ? TransactionResolution.COMMIT : TransactionResolution.ROLLBACK;<br>            &#125;)<br>            .build();<br>    <span class="hljs-comment">//开启事务分支。</span><br>    <span class="hljs-keyword">final</span> Transaction transaction;<br>    <span class="hljs-keyword">try</span> &#123;<br>        transaction = producer.beginTransaction();<br>    &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-comment">//事务分支开启失败，直接退出。</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> messageBuilder.setTopic(<span class="hljs-string">&quot;topic&quot;</span>)<br>            <span class="hljs-comment">//设置消息索引键，可根据关键字精确查找某条消息。</span><br>            .setKeys(<span class="hljs-string">&quot;messageKey&quot;</span>)<br>            <span class="hljs-comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span><br>            .setTag(<span class="hljs-string">&quot;messageTag&quot;</span>)<br>            <span class="hljs-comment">//一般事务消息都会设置一个本地事务关联的唯一ID，用来做本地事务回查的校验。</span><br>            .addProperty(<span class="hljs-string">&quot;OrderId&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>            <span class="hljs-comment">//消息体。</span><br>            .setBody(<span class="hljs-string">&quot;messageBody&quot;</span>.getBytes())<br>            .build();<br>    <span class="hljs-comment">//发送半事务消息</span><br>    <span class="hljs-keyword">final</span> SendReceipt sendReceipt;<br>    <span class="hljs-keyword">try</span> &#123;<br>        sendReceipt = producer.send(message, transaction);<br>    &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>        <span class="hljs-comment">//半事务消息发送失败，事务可以直接退出并回滚。</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行本地事务，并确定本地事务结果。</span><br><span class="hljs-comment">     * 1. 如果本地事务提交成功，则提交消息事务。</span><br><span class="hljs-comment">     * 2. 如果本地事务提交失败，则回滚消息事务。</span><br><span class="hljs-comment">     * 3. 如果本地事务未知异常，则不处理，等待事务消息回查。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">localTransactionOk</span> <span class="hljs-operator">=</span> doLocalTransaction();<br>    <span class="hljs-keyword">if</span> (localTransactionOk) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            transaction.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>            <span class="hljs-comment">// 业务可以自身对实时性的要求选择是否重试，如果放弃重试，可以依赖事务消息回查机制进行事务状态的提交。</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            transaction.rollback();<br>        &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>            <span class="hljs-comment">// 建议记录异常信息，回滚异常时可以无需重试，依赖事务消息回查机制进行事务状态的提交。</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：<strong>不具备回滚的能力</strong></p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ol><li><strong>应用方 Application</strong>：指的是需要使用到分布式事务能力的应用方，即这套 TCC 框架服务的甲方</li><li><strong>TCC 组件 TCC Component</strong>：指的是需要完成分布式事务中<strong>某个特定步骤的子模块</strong>. 这个模块通常负责一些状态数据的维护和更新操作，需要<strong>对外暴露出 Try、Confirm 和 Cancel 三个 API</strong>：<ul><li><strong>Try</strong>：锁定资源，【冻结】资源，保留后续变化的可能性   <a href="https://chatgpt.com/share/3f76f5ef-4b75-49a7-92a9-647b84b152a6">gpt参考</a><ul><li>订单服务：添加一个try状态</li><li>库存服务：添加一个预占库存列  预占库存列++； 库存–；同时插入冻结流水记录 用于回滚</li></ul></li><li><strong>Confirm</strong>：对 Try 操作进行二次确认，将记录中的【冻结】态改为【成功】态<ul><li>try-&gt;success</li><li>预占库存列–； 流水修改try-&gt;success</li></ul></li><li><strong>Cancel</strong>：对 Try 操作进行回滚，将记录中的【冻结】状消除或者改为【失败】态. 其底层对应的状态数据会进行回滚<ul><li>try-&gt;cancel</li><li>预占库存– ；库存++   ；流水修改try-&gt;cancel</li></ul></li></ul></li><li><strong>事务协调器 TX Manager</strong>：负责统筹分布式事务的执行：<ul><li>实现 TCC Component 的注册管理功能</li><li>负责和 Application 交互，提供分布式事务的创建入口，给予 Application 事务执行结果的响应</li><li>串联 Try -&gt; Confirm&#x2F;Cancel 的两阶段流程. 在第一阶段中批量调用 TCC Component 的 Try 接口，根据其结果，决定第二阶段是批量调用 TCC Component 的 Confirm 接口还是 Cancel 接口</li><li>对于每一个事物，都有一个tx id并且记录到 <strong>事物日志表</strong>，以及明细表记录每一个tcc组件状态</li></ul></li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923044.png" alt="image-20240910162811798"></p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>Application 调用 TX Manager 的接口，创建一轮分布式事务；声明，这次操作涉及到的 TCC Component 范围，包括 订单组件、账户组件和库存组件；传递好，用于和每个 TCC Component 交互的请求参数（ TX Manager 调用 Component Try 接口时需要传递）</li><li>TX Manager 分配一个全局唯一的事务主键 Transaction ID，记录日志表</li><li>TX Manager 分别调用订单、账户、库存组件的 Try 接口，流水表记录每一个try的结果<ol><li>某一个失败，执行Cancel；在cancel都响应后设置日志表状态<strong>【失败】</strong></li><li>都成功，执行Confirm ；在Confirm 都响应后设置日志表状态<strong>【成功】</strong></li></ol></li><li>根据try结构，返回给application最终结果（不等待CC的结果，只看try）</li></ol><h4 id="一致性保证：轮询"><a href="#一致性保证：轮询" class="headerlink" title="一致性保证：轮询"></a>一致性保证：轮询</h4><p>TX Manager 轮询重试 + TCC Component 幂等去重（携带tx id）</p><p>定时任务：轮询所有未被更新为【成功&#x2F;失败】对应终态的事务，推进到最终状态</p><ul><li>如果try已经存在失败，则再补偿性调用Cancel 操作</li><li>如果try都成功，则补偿性地批量调用Confirm操作</li><li>如果try还在进行中，则检查时间，如果太长按照失败处理</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923045.png" alt="image-20240910170713079"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>悬挂问题：try操作拥堵了，cancel操作先到达了，如果 cancel -&gt; try 会导致后续try无法释放</p><p>解决：支持空回退：记录下cancel操作Transaction ID，之后try到达了直接忽略</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>支持回滚</li><li>成功率高<ul><li>进行了try  说明网络不错</li><li>try 保证了资源的充分</li><li>轮询重试保证补偿</li></ul></li></ul><p><strong>缺点：</strong></p><ul><li>最终一致性</li><li>严格上：如果confirm或cancel始终失败，还是会不一致</li><li>实现成本高，需要TCC组件格式</li></ul><h4 id="下单场景"><a href="#下单场景" class="headerlink" title="下单场景"></a>下单场景</h4><p>现在假设我们需要维护一个电商后台系统，需要处理来自用户的支付请求. 每当有一笔支付请求到达，我们需要执行下述三步操作，并要求其前后状态保持一致性：</p><ul><li>在订单模块中，创建出这笔订单流水记录</li><li>在账户模块中，对用户的账户进行相应金额的扣减</li><li>在库存模块中，对商品的库存数量进行扣减</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923046.png" alt="image-20240910163518305"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923047.png" alt="image-20240910163539671"></p><p>核心就是订单表添加try状态，库存表添加预占库存概念</p><h5 id="1-订单模块"><a href="#1-订单模块" class="headerlink" title="1. 订单模块"></a>1. <strong>订单模块</strong></h5><p>Try 阶段：</p><ul><li><p>订单模块的 Try 操作主要是<strong>创建订单流水</strong>，但此时订单状态还不会设置为“已确认”。</p></li><li><p>在这个阶段，系统会预创建一个订单记录，订单状态可以标记为“处理中”</p></li><li><p>同时，订单模块可以记录操作的上下文信息（如用户、商品、金额等）以便后续 Confirm 或 Cancel 使用。</p></li><li><p>操作</p><ul><li>写入订单流水表，标记订单状态为“处理中”。</li><li>返回成功结果，并携带订单的流水号供后续操作使用。</li></ul></li></ul><p>Confirm 阶段：</p><ul><li><p>当所有模块的 Try 操作都成功时，订单模块会进入 Confirm 阶段。</p></li><li><p>在 Confirm 阶段，订单模块需要<strong>确认订单</strong>，将订单状态由“处理中”更新为“已确认”。</p></li><li><p>操作</p><ul><li>将订单状态从“处理中”改为“已确认”。</li><li>写入操作日志，更新订单的最终状态。</li></ul></li></ul><p>Cancel 阶段：</p><ul><li><p>如果任意一个模块的 Try 操作失败，订单模块会执行 Cancel 操作，<strong>取消订单</strong>。</p></li><li><p>在 Cancel 阶段，订单模块需要将“处理中”的订单作废或删除。</p></li><li><p>操作</p><ul><li>将订单状态从“处理中”更新为“已取消”。</li><li>记录取消原因和操作日志。</li></ul></li></ul><hr><h5 id="2-账户模块"><a href="#2-账户模块" class="headerlink" title="2. 账户模块"></a>2. <strong>账户模块</strong></h5><p>略</p><hr><h5 id="3-库存模块"><a href="#3-库存模块" class="headerlink" title="3. 库存模块"></a>3. <strong>库存模块</strong></h5><p>Try 阶段：</p><ul><li><p>库存模块的 Try 操作是<strong>预扣减库存</strong>，这意味着暂时锁定所需的库存量，确保后续可以顺利完成库存扣减。</p></li><li><p>此时并不会真正减少商品库存，而是将库存设置为冻结状态。</p></li><li><p>操作</p><ul><li>检查商品库存是否充足，充足则冻结相应的库存。同时插入冻结流水</li><li>将冻结的库存数量记录到库存系统，确保其他订单无法占用这部分库存。</li><li>返回冻结成功的结果，并记录库存操作流水号。</li></ul></li></ul><p>Confirm 阶段：</p><ul><li><p>当所有模块的 Try 操作都成功时，库存模块进入 Confirm 阶段，执行实际的<strong>扣减库存操作</strong>。</p></li><li><p>在这个阶段，库存模块会将冻结的库存真正扣减，减少商品的可用库存。</p></li><li><p>操作</p><ul><li>将商品的冻结库存数量正式扣除，减少可用库存。</li><li>更新库存状态，移除冻结记录。</li><li>记录库存扣减成功的操作日志。</li></ul></li></ul><p>Cancel 阶段：</p><ul><li>如果任意一个模块的 Try 操作失败，库存模块会执行 Cancel 操作，<strong>解冻库存</strong>，恢复冻结的库存数量。</li><li>操作<ul><li>将冻结的库存数量恢复到可用库存中。</li><li>更新库存的冻结记录，确保库存回到 Try 操作之前的状态。</li><li>记录取消操作日志。</li></ul></li></ul><hr><h5 id="完整流程示例："><a href="#完整流程示例：" class="headerlink" title="完整流程示例："></a><strong>完整流程示例</strong>：</h5><p>假设用户 A 在系统中下单购买商品 B，总价为 100 元，库存需要扣减 1 件：</p><ol><li><strong>Try 阶段</strong>：<ul><li>订单模块创建订单流水，状态为“处理中”。</li><li>库存模块冻结商品 B 的 1 件库存。（库存-1 冻结库存+1）</li></ul></li><li><strong>Confirm 阶段</strong>：<ul><li>订单模块将订单状态更新为“已确认”。</li><li>库存模块从库存中正式扣减 1 件商品 B。 （冻结库存-1）</li></ul></li><li><strong>Cancel 阶段</strong>（假设某个服务的 Try 阶段失败或网络问题导致整体操作失败）：<ul><li>订单模块将订单状态更新为“已取消”。</li><li>库存模块解冻商品 B 的 1 件库存，还原库存状态。 （库存+1 冻结库存-1）</li></ul></li></ol><p>目前其实3个方案都加入了一个定时的任务，取轮询状态推进到最终态</p><h3 id="两阶段提交2PC"><a href="#两阶段提交2PC" class="headerlink" title="两阶段提交2PC"></a>两阶段提交2PC</h3><p>简单而言：参与者（participant）用来管理资源，协调者（coordinator）用来协调事务状态</p><p>两段提交（2PC - Prepare &amp; Commit）是指两个阶段的提交：</p><ul><li>第一阶段: 准备阶段； <ul><li>协调者向所有参与者发送 REQUEST-TO-PREPARE</li><li>当参与者收到REQUEST-TO-PREPARE 消息后, 它向协调者发送消息PREPARED或者NO，表示事务是否准备好；如果发送的是NO，那么事务要回滚；</li></ul></li><li>第二阶段: 提交阶段。 <ul><li>协调者收集所有参与者的返回消息, 如果所有的参与者都回复的是PREPARED， 那么协调者向所有参与者发送COMMIT 消息；否则，协调者向所有回复PREPARED的参与者发送ABORT消息；</li><li>参与者如果回复了PREPARED消息并且收到协调者发来的COMMIT消息，或者它收到ABORT消息，它将执行提交或回滚，并向协调者发送DONE消息以确认。</li></ul></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231923048.png" alt="image-20240910152819014"></p><p>二阶段提交看似能够提供原子性的操作，但它存在着严重的缺陷：</p><ul><li><strong>网络抖动导致的数据不一致</strong>：第二阶段中协调者向参与者发送commit命令之后，一旦此时发生网络抖动，导致一部分参与者接收到了commit请求并执行，可其他未接到commit请求的参与者无法执行事务提交。进而导致整个分布式系统出现了数据不一致。</li><li><strong>超时导致的同步阻塞问题</strong>：2PC中的所有的参与者节点都为事务阻塞型，当某一个参与者节点出现通信超时，其余参与者都会被动阻塞占用资源不能释放。</li><li><strong>单点故障的风险</strong>：由于严重的依赖协调者，一旦协调者发生故障，而此时参与者还都处于锁定资源的状态，无法完成事务commit操作。虽然协调者出现故障后，会重新选举一个协调者，可无法解决因前一个协调者宕机导致的参与者处于阻塞状态的问题。</li></ul><h3 id="三阶段提交3PC"><a href="#三阶段提交3PC" class="headerlink" title="三阶段提交3PC"></a>三阶段提交3PC</h3><p><strong>3PC的三个阶段分别是CanCommit、PreCommit、DoCommit</strong>：</p><ul><li><strong>CanCommit</strong>：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。</li><li><strong>PreCommit</strong>：协调者向所有参与者发送PreCommit命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回Yes响应，进入最终commit阶段。一旦参与者中有向协调者发送了No响应，或因网络造成超时，协调者没有接到参与者的响应，协调者向所有参与者发送abort请求，参与者接受abort命令执行事务的中断。</li><li><strong>DoCommit</strong>：在前两个阶段中所有参与者的响应反馈均是YES后，协调者向参与者发送DoCommit命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送abort请求命令，执行事务的中断。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1R14y1q7WX/">万字漫谈分布式事务技术实现原理_哔哩哔哩_bilibili</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/Z-ZY9VYUzNER8iwk80XSxA">万字漫谈分布式事务技术实现原理-微信公众平台 (qq.com)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage/">事务消息 | RocketMQ (apache.org)</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://juejin.cn/post/6934911674969227295#heading-28">分布式事务实战方案汇总1. 最终一致性 2. 弱一致性 3. 总结 5. 参考 1. 最终一致性 这是一个重构系统新老系 - 掘金 (juejin.cn)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://pdai.tech/md/arch/arch-z-transection.html">分布式系统 - 分布式事务及实现方案 | Java 全栈知识体系 (pdai.tech)</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.为什么要引入MQ-MQ</title>
    <link href="/2024/06/10/TechDigest/mq/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5MQ-MQ/"/>
    <url>/2024/06/10/TechDigest/mq/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5MQ-MQ/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>消息队列（MQ）的核心优势在于解耦、异步处理和流量削峰。在秒杀系统中，MQ能够将非核心流程异步化，大幅提升系统吞吐量，通过削峰填谷缓解数据库压力（前端千万级请求 vs 数据库万级处理能力）。引入MQ需权衡响应时间延长、系统复杂度增加及运维成本。    微服务间通信模式包括调用链、聚合器和事件驱动，其中基于事件的异步通信（如订单状态变更通知）能实现上下游解耦，灵活扩展。主流MQ需具备可靠性（消息不丢失）、高可用（集群容灾）和高性能。    典型MQ对比：   - <strong>RabbitMQ</strong>：轻量级，擅长灵活路由，但消息堆积能力弱（几万TPS），适合简单场景。   - <strong>RocketMQ</strong>：低延迟、强一致性，适合订单&#x2F;物流等分布式事务场景，经双十一验证。   - <strong>Kafka</strong>：大数据生态优，支持百万级日志吞吐，但实时性可能受批量设计影响。    消息投递语义：   - <strong>至少一次（At-Least-Once）</strong>：通过ACK重试确保不丢，需消费者幂等处理（如唯一ID+版本检查）。   - <strong>精确一次（Exactly-Once）</strong>：依赖事务或幂等，实现成本高（如金融交易）。   - <strong>至多一次（At-Most-Once）</strong>：可能丢消息，适合非关键场景（如缓存更新）。    最佳实践为“At-Least-Once + 幂等”，结合同步刷盘（保障可靠性）和半数以上节点复制（提高可用性）。突发流量可通过扩容消费者、降级非核心服务应急，后续优化分区数量及消费端性能。消息有序性可通过递增ID或时间戳部分保证。    总之，MQ选型需权衡业务需求（一致性&#x2F;实时性&#x2F;吞吐量），并配套容错机制（如DLedger集群、手动提交offset）确保稳定运行。</p></blockquote><p>MQ有哪些优点，为什么需要MQ？</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>一个秒杀系统包含很多步骤，有的很重要，有的不重要。借助MQ可以只保留核心流程，提升系统性能</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924357.png" alt="image-20240910141247065"></p><h3 id="流量扩展"><a href="#流量扩展" class="headerlink" title="流量扩展"></a>流量扩展</h3><p>流量：web前端可以上千万请求，但数据库（分库分表）是万级别水平</p><p>简单实现，压测评估流量，并引入限流算法：</p><ul><li>固定窗口</li><li>滑动窗口</li><li>漏桶算法</li><li>令牌桶算法</li></ul><p>加入异步后，秒杀流程</p><ol><li>收到请求后，将整个请求加入MQ</li><li>MQ消费者异步完成秒杀过程，处理响应</li><li>轮询秒杀结果</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924359.png" alt="image-20240910141812485"></p><p>增加MQ可以削峰填谷</p><p>代价：</p><ol><li>增加了系统调用环节，总体响应时间延长</li><li>同步-&gt;异步 增加了系统复杂度</li><li>成本问题：MQ的高性能 高可用</li></ol><h3 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h3><p>微服务之间如何通信？</p><ul><li><p>调用链模式</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924360.png" alt="image-20240910142308284"></p></li><li><p>聚合器模式</p><ul><li>一调多</li></ul></li><li><p>基于事件的异步</p></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924361.png" alt="image-20240910142515875"></p><p>​电商系统，订单信息变动后上游发出消息，对于下游服务来说，只需要订阅相关的主题的消息，下游就可以收到消息，增加或者减少下游，上游服务都不需要变化，实现了上游服务和其他服务的解耦</p><h2 id="如何选型"><a href="#如何选型" class="headerlink" title="如何选型"></a>如何选型</h2><p>基本特性</p><ul><li>可靠性：消息不丢失</li><li>高可用：可用集群，某个宕机整体还可以运行</li><li>高性能</li></ul><h3 id="Rabbitmq"><a href="#Rabbitmq" class="headerlink" title="Rabbitmq"></a>Rabbitmq</h3><p>特点：</p><ul><li>Erlang语言编写，轻量级，基于AMQP 协议</li><li>灵活的路由机制：交换机</li><li>客户端支持多</li></ul><p>问题：</p><ul><li>消息堆积支持不好</li><li>性能较差（几万~十万）</li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul><li>经历过双十一考验，速度快</li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>处理海量日志，大数据和流计算场景，周边生态好</li><li>几十万条消息</li><li>异步批量设计（可能会影响实时性）</li></ul><h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><ul><li>简单易用，性能不需要很高：RabbitMQ</li><li>RocketMQ一致性良好、低延时、稳定<ul><li>例如订单完成后通知物流，实现解耦</li><li>最终一致性的分布式事务</li></ul></li><li>Kafka：大数据、日志<ul><li>数据埋点：电商用户行为日志（点击、购买），收集后提供给计算引擎进行实时计算分析，得出营销活动的转化率</li><li>监控、大数据分析：收集监控系统、传感器、日志信息进行实时分析和处理</li></ul></li></ul><h2 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h2><h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>最初的消息模型：队列模型</p><p>生产者Producer发送消息就是入队，消费者Consumer消费消息就是出队</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924362.png" alt="image-20240910144716185"></p><p>默认所有消费者<strong>共同消费</strong>所有消息</p><p>如何让多个消费者收到呢？ 交换机exchange根据策略转发到多个队列</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924363.png" alt="image-20240910145341478"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924364.png" alt="image-20240910145359547"></p><h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><p>发布者Publisher、接收者Subscriber、主题Topic</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924365.png" alt="image-20240910145004643"></p><p>默认订阅者都可以接受完整的消息，rocketmq中是消费组可以消费完整消息，组内是竞争关系</p><ul><li>如何保证有序性？topic中引入队列，队列中消息有序（Orderly模式下、Concurrently不保证）</li><li>每一个消费组中每一个queue都会维护一个offset</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924366.png" alt="image-20240910150349650"></p><p>几乎所有MQ都是“请求-确认机制”</p><ul><li>broker接收到消息后，会发送确认，如果生产者没有收到确认，会重新发送</li><li>消费者消费后，会发送确认消息，否者MQ会重新发送消息</li></ul><h2 id="消费模式-重复消费问题"><a href="#消费模式-重复消费问题" class="headerlink" title="消费模式&amp;重复消费问题"></a>消费模式&amp;重复消费问题</h2><h3 id="1-至少一次（At-Least-Once）"><a href="#1-至少一次（At-Least-Once）" class="headerlink" title="1. 至少一次（At-Least-Once）"></a>1. <strong>至少一次（At-Least-Once）</strong></h3><ul><li><strong>定义</strong>：消息会被<strong>至少消费一次</strong>，即消费者可能会收到重复的消息。</li><li><strong>原理</strong>：消息队列会在消息投递后，等待消费者的确认（ACK）。如果消费者处理失败或ACK没有及时收到，消息队列会重新投递该消息。因此，消费者可能会处理同一条消息多次（消费组<strong>幂等性</strong>）。</li><li>特点<ul><li><strong>可靠性高</strong>：消息不会丢失，但可能会重复。</li><li><strong>应用场景</strong>：适用于对消息丢失敏感的场景，但允许重复消费的场景，比如日志系统、支付系统（必须通过幂等性保证结果一致）。</li></ul></li></ul><h3 id="2-仅一次（Exactly-Once）"><a href="#2-仅一次（Exactly-Once）" class="headerlink" title="2. 仅一次（Exactly-Once）"></a>2. <strong>仅一次（Exactly-Once）</strong></h3><ul><li><strong>定义</strong>：消息会被<strong>准确消费一次</strong>，即不会重复投递或消费。</li><li><strong>原理</strong>：这是最复杂的交付模式，通常通过消费者的幂等性处理或者分布式事务保证。消息队列和消费者之间需要实现严格的幂等性机制或事务机制，确保每条消息只被处理一次且不会遗漏。</li><li>特点<ul><li><strong>高可靠性且无重复</strong>：不会丢失或重复消息，保证消息精确传递和处理。</li><li><strong>应用场景</strong>：适用于对数据处理准确性要求极高的场景，比如银行交易、库存管理系统。</li><li><strong>实现难度</strong>：通常实现较为复杂，性能也可能较低，因为要处理事务、幂等和重试机制等。</li></ul></li></ul><h3 id="3-最多一次（At-Most-Once）"><a href="#3-最多一次（At-Most-Once）" class="headerlink" title="3. 最多一次（At-Most-Once）"></a>3. <strong>最多一次（At-Most-Once）</strong></h3><ul><li><strong>定义</strong>：消息会被<strong>最多消费一次</strong>，即消费者可能会<strong>漏掉</strong>一些消息。</li><li><strong>原理</strong>：消息在传递给消费者后，不需要等待确认，即使消费者处理失败，消息也不会重发。这种模式保证不会重复消费，但可能会导致消息丢失。</li><li>特点<ul><li><strong>低可靠性</strong>：消息可能丢失，但绝不重复。</li><li><strong>应用场景</strong>：适用于对消息丢失不敏感的场景，如缓存更新、临时通知等。</li></ul></li></ul><p>最佳实践：At-Least-Once + 消费者幂等</p><ul><li>消费者更新前检查版本，有点像</li><li>全局唯一ID + 状态检查 + 分布式锁</li></ul><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924367.png" alt="image-20240912174934128"></p><p><strong>生产者</strong>：发送确认</p><ul><li>刷盘策略   影响<strong>可靠性</strong><ul><li>rocketmq FlushDiskType调整为同步刷盘，刷盘后ack</li></ul></li><li>复制策略  影响<strong>可用性</strong><ul><li>同步复制：也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从节点上时才返回写入成功</strong> 。</li><li>异步复制：<strong>消息写入主节点之后就直接返回写入成功</strong> 。</li><li>DLedger 模式下复制到集群中<strong>半数以上的节点</strong>，才返回ack<ul><li>kafka： acks&#x3D;all  全部、   ack&#x3D;0  发送立即返回、 ack&#x3D;1 主写入成功后返回</li></ul></li></ul></li></ul><p><strong>消费者</strong>：手动提交</p><h2 id="消息挤压"><a href="#消息挤压" class="headerlink" title="消息挤压"></a>消息挤压</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924368.png" alt="image-20240912183318783"></p><p>1.和消息生产者无关</p><p>2.和消息队列本身无关，消息队列可以十万QPS  还可以扩容，性能远高于业务</p><p>突发问题：应急处理 扩容增加消费者数量、降级系统（关闭不重要的业务）以减少发送数据量</p><p>后续：扩充消费者数量以及topic分区数量、消费端代码性能（是不是死锁、资源卡死）</p><h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924369.png" alt="image-20240912183650602"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924370.png" alt="image-20240912184227858"></p><h3 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202409231924371.png" alt="image-20240912184233776"></p><ul><li>消息发送时给一个唯一递增ID，消费时id必须递增；  不保证有序但可以递增</li><li>ID换成时间戳</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TL_ITL_TTL原理</title>
    <link href="/2024/05/10/TechDigest/TL_ITL_TTL%E5%8E%9F%E7%90%86/"/>
    <url>/2024/05/10/TechDigest/TL_ITL_TTL%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>该文章讨论了线程本地存储（ThreadLocal）及其扩展机制，包括InheritableThreadLocal和TransmittableThreadLocal（TTL）的原理与实现，以及它们的应用场景和局限性。以下是核心内容的总结：  1. <strong>ThreadLocal基础</strong>      - ThreadLocal为每个线程分配独立的空间（ThreadLocalMap），存储线程私有变量，确保线程隔离。      - 用途：存储线程链路中的用户信息（如请求上下文），线程间互不干扰。      - 底层通过弱引用（WeakReference）的Entry数组实现，哈希冲突时使用线性探测。  2. <strong>父子线程传递问题</strong>      - <strong>普通ThreadLocal的局限</strong>：子线程无法继承父线程的ThreadLocal变量（子线程读取为null）。      - <strong>InheritableThreadLocal的改进</strong>：        - 通过<code>inheritableThreadLocals</code>空间在子线程创建时复制父线程的Entry，实现继承。        - 但仅支持线程创建时的静态传递，无法应对线程池复用线程的场景（值不会更新）。  3. <strong>线程池场景的解决方案——TransmittableThreadLocal（TTL）</strong>      - <strong>核心思想</strong>：在执行任务时动态拷贝父线程的TTL变量（而非线程创建时）。      - <strong>实现机制</strong>：        - 通过<code>TtlRunnable</code>装饰器在任务执行前备份父线程的TTL值，执行后恢复。        - <code>holder</code>（InheritableThreadLocal集合）记录所有需传递的TTL变量，通过<code>capture</code>、<code>replay</code>和<code>restore</code>完成值传递与还原。      - <strong>优势</strong>：支持线程池等动态线程复用场景，确保任务执行时能获取最新的父线程变量。  4. <strong>应用场景</strong>      - <strong>分布式跟踪</strong>：传递请求链路标识（如TraceID）。      - <strong>日志上下文</strong>：跨线程记录用户会话信息。      - <strong>Session级缓存</strong>：线程安全的用户数据存储。      - <strong>跨框架&#x2F;SDK通信</strong>：上层向下层透传上下文（如租户ID）。    5. …</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul><li>为每一个线程开辟了一个空间Map，用于存储变量</li><li>用额外的空间使得线程之间互不影响</li><li>用途：在一个线程中，存储用户的信息，使得整个线程链路都可以访问到，并且线程之间互不影响</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t); <br>    <span class="hljs-comment">// 当前线程的一个变量t.threadLocals; 本质上是Entry[] table，key是tl的弱引用，值是value</span><br>    <span class="hljs-comment">// index 是int i = key.threadLocalHashCode &amp; (table.length - 1); 冲突了就线性探测</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：当创建子线程时，子线程无法读取到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>log.info(Thread.currentThread() + <span class="hljs-string">&quot;in thread: &quot;</span> + tl.get());<br>&#125;).start();<br><br><span class="hljs-number">2024</span>-08-<span class="hljs-number">12</span> <span class="hljs-number">16</span>:<span class="hljs-number">19</span>:<span class="hljs-number">53</span> INFO  [Thread-<span class="hljs-number">2</span>] c.e.t.ThreadLocalStudyApplicationTests - Thread[Thread-<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]in thread: <span class="hljs-literal">null</span> <br></code></pre></td></tr></table></figure><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><ul><li><p>实现了父子线程间的传递</p></li><li><p>重写了getMap()方法，返回的是<code>t.inheritableThreadLocals</code>，相当于再开辟了一个空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123; <span class="hljs-comment">// childValue是复制，父子会相互影响 想要不影响重写这个方法</span><br>    <span class="hljs-keyword">return</span> parentValue;<br>&#125;<br>  <br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>   <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>&#125;<br>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br>  <br></code></pre></td></tr></table></figure></li><li><p>父传递给子在thread的<strong>创建时</strong>，将父的inheritableThreadLocals中的Entry复制给子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br>            <span class="hljs-built_in">this</span>.inheritableThreadLocals =<br>                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> &#123;<br>    Entry[] parentTable = parentMap.table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> parentTable.length;<br>    setThreshold(len);<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[len];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parentTable[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();<br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> key.childValue(e.value); <span class="hljs-comment">// childValue是复制，会相互影响 想要不影响重写这个方法</span><br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                table[h] = c;<br>                size++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>问题：传递过程只在线程创建时，如果是线程池这种已经创建好的，值就不会传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br>tl.set(<span class="hljs-string">&quot;value1&quot;</span>);<br><br>log.info(<span class="hljs-string">&quot;in main: &quot;</span> + tl.get());<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    service.submit(() -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot;in pool: &quot;</span> + tl.get());<br>    &#125;);<br>&#125;<br>tl.set(<span class="hljs-string">&quot;value2&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    service.submit(() -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot;in pool: &quot;</span> + tl.get()); <span class="hljs-comment">// 值还是value1 不会修改</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><ul><li><p>基本思想：ITL通过在创建时拷贝数据实现传递，更进一步，在执行时提前进行一次拷贝即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TtlCopier</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 使用一个InheritableThreadLocal的Map，记录下全部的TTL，在set时TTL会被添加进holder;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;()&#123;&#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.disableIgnoreNullValueSemantics &amp;&amp; <span class="hljs-literal">null</span> == value) &#123;<br>        <span class="hljs-built_in">this</span>.remove();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.set(value);<br>        <span class="hljs-built_in">this</span>.addThisToHolder();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addThisToHolder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!((WeakHashMap)holder.get()).containsKey(<span class="hljs-built_in">this</span>)) &#123;<br>        ((WeakHashMap)holder.get()).put(<span class="hljs-built_in">this</span>, (Object)<span class="hljs-literal">null</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>TtlRunnable对runable进行一层包裹（装饰器模式），对TTL变量进行备份 赋值 以及恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">captured</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.capturedRef.get();<br>    <span class="hljs-keyword">if</span> (captured != <span class="hljs-literal">null</span> &amp;&amp; (!<span class="hljs-built_in">this</span>.releaseTtlValueReferenceAfterRun || <span class="hljs-built_in">this</span>.capturedRef.compareAndSet(captured, (Object)<span class="hljs-literal">null</span>))) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">backup</span> <span class="hljs-operator">=</span> Transmitter.replay(captured);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.runnable.run();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Transmitter.restore(backup);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;TTL value reference is released after run!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取所有父的ttl</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="hljs-title function_">captureTtlValues</span><span class="hljs-params">()</span> &#123;<br>    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> ((WeakHashMap)TransmittableThreadLocal.holder.get()).keySet().iterator();<br><br>    <span class="hljs-keyword">while</span>(var1.hasNext()) &#123;<br>        TransmittableThreadLocal&lt;Object&gt; threadLocal = (TransmittableThreadLocal)var1.next();<br>        ttl2Value.put(threadLocal, threadLocal.copyValue());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ttl2Value;<br>&#125;<br><br><span class="hljs-comment">// 备份并替换为父的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="hljs-title function_">replayTtlValues</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured)</span> &#123;<br>    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = ((WeakHashMap)TransmittableThreadLocal.holder.get()).keySet().iterator();<br><br>    <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>        TransmittableThreadLocal&lt;Object&gt; threadLocal = (TransmittableThreadLocal)iterator.next();<br>        backup.put(threadLocal, threadLocal.get());<br>        <span class="hljs-keyword">if</span> (!captured.containsKey(threadLocal)) &#123;<br>            iterator.remove();<br>            threadLocal.superRemove();<br>        &#125;<br>    &#125;<br><br>    setTtlValuesTo(captured); <span class="hljs-comment">// 设置值为父的</span><br>    TransmittableThreadLocal.doExecuteCallback(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> backup;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTtlValuesTo</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttlValues)</span> &#123;<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> ttlValues.entrySet().iterator();<br><br>    <span class="hljs-keyword">while</span>(var1.hasNext()) &#123;<br>        Map.Entry&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; entry = (Map.Entry)var1.next();<br>        TransmittableThreadLocal&lt;Object&gt; threadLocal = (TransmittableThreadLocal)entry.getKey();<br>        threadLocal.set(entry.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>至此可以实现父线程传递给子线程信息，可以用来</p><ul><li>分布式跟踪系统 </li><li>日志收集记录系统上下文</li><li><code>Session</code>级<code>Cache</code></li><li>应用容器或上层框架跨应用代码给下层<code>SDK</code>传递信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nas入门</title>
    <link href="/2024/04/22/TechDigest/nas%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/22/TechDigest/nas%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文主要讨论了NAS（网络附加存储）的性能优化、视频编解码技术以及影音服务器的转码功能。    1. <strong>NAS传输速度与硬件选择</strong>：      - 实际传输速度受网口和硬盘速度限制，千兆网络环境下机械硬盘已能满足需求，阵列可提升速度，但随机读写可能较慢。      - WiFi通常无法达到千兆网速，适合有线连接的高带宽场景（如900Mbps视频剪辑）。    2. <strong>影音服务器与转码功能</strong>：      - NAS作为服务器存储视频文件，客户端（手机、电视等）负责播放。      - 常见视频编码标准包括H.264（兼容性好）、H.265（高效压缩，适合4K&#x2F;8K）和AV1（开源但硬件支持有限）。      - <strong>转码作用</strong>：通过解码+重新编码，调整视频格式、分辨率或码率，以适应不同设备或网络条件。例如，将4K视频转为1080p以节省带宽。      - 两种播放方式：        - 直接传输原始文件（需客户端支持解码，依赖高带宽）；        - NAS实时转码（降低客户端性能要求，但需NAS硬件支持）。    3. <strong>图床搭建问题</strong>：      - 通过Docker部署Lsky图床，配合PicGo插件实现图片上传，但异地访问需依赖Cloudflare，可能导致网速下降。    全文涵盖存储性能优化、视频编解码技术及实际应用场景，为NAS用户提供技术参考。</p></blockquote><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul><li><a href="https://www.bilibili.com/video/BV1Yu411274j">硬件选择</a></li><li><a href="https://wp.gxnas.com/11849.html">安装</a></li><li>半洗白：<a href="https://k.sina.com.cn/article_1823348853_6cae187502001dxp7.html">黑群晖激活Advanced Media Extensions（AME）解码HEVC视频和HEIC图片|美的|补丁_新浪新闻 (sina.com.cn)</a></li></ul><h3 id="图片备份"><a href="#图片备份" class="headerlink" title="图片备份"></a>图片备份</h3><ul><li><a href="https://www.bilibili.com/video/BV1vP411g78E">群晖NAS 11期-使用群晖套件Photos进行家庭相册管理</a></li><li>图片备份注意事项：<a href="https://zhuanlan.zhihu.com/p/470986230">dsm7 群晖synology photos备份照片的坑(备份方法 人脸 视频缩略图） - 知乎 (zhihu.com)</a></li><li><a href="https://kb.synology.cn/zh-cn/DSM/help/SynologyPhotos/iPhone?version=7">官网</a></li></ul><h3 id="硬盘选择"><a href="#硬盘选择" class="headerlink" title="硬盘选择"></a>硬盘选择</h3><p>传输速度: min（网口，硬盘）</p><p>常规用户使用场景，千兆足够（900mbps视频剪辑并且倍速时，可能达到瞬时3Gbps）</p><ul><li>对于千兆网口，机械硬盘已经可以支撑了</li><li>阵列可以提升速度</li><li>随机读写可能慢一些</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404212319376.png" alt="image-20240421231953956"></p><p>wifi通常难以达到千兆网卡速度</p><h3 id="影音设备："><a href="#影音设备：" class="headerlink" title="影音设备："></a>影音设备：</h3><p>影音服务器和转码有什么关系？</p><p>nas这里称为服务器，手机、tv、电脑称作客户端</p><h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><p>视频通常都被压缩编码了（节省空间和带宽），我们想播放就需要解码，通常来说压缩效率越高，编解码需要的算力也越大</p><ul><li><strong>H.264&#x2F;AVC</strong>：现在最常用的视频编码标准，适用于从互联网视频流到蓝光光盘等多种场景。兼容性好</li><li><strong>H.265&#x2F;HEVC</strong>：提供比H.264更高的压缩效率，常用于4K和8K视频。对比上面可以降低一半码率，需要更高的计算能力</li><li><strong>AV1</strong>: 开源的，可以在上面的基础上在缩小百分之20，但硬件生态较差，只有最新RTX显卡才支持</li></ul><blockquote><p>编解码的算法有版权的，浏览器、视频提供厂商需要购买</p></blockquote><p>以前新浪规定了视频上传平均码率1000Kbps，所以有的up为了视频清晰度就会在结尾添加黑屏</p><p><strong>解码转码区别：</strong></p><ol><li><strong>解码（Decoding）</strong>：解码是将已编码的视频数据转换成可以直接显示的图像数据的过程。这一步骤通常在播放设备上进行，属于播放过程的一部分。</li><li><strong>转码（Transcoding）</strong>：<strong>解码+编码</strong> 改变视频文件的编码格式或其它媒体参数（如分辨率、比特率等）。转码后，视频文件的数据格式会发生变化，以适应不同的播放需求或设备兼容性。例如，将原始视频从高比特率的4K格式转换为较低比特率的1080p格式，以适应带宽较低的网络环境或设备性能。</li></ol><h4 id="传输类型"><a href="#传输类型" class="headerlink" title="传输类型"></a>传输类型</h4><ol><li>直接将源文件发送给客户端，客户端负责解码  只需要传输速率&gt;视频码率<ul><li>720p（1280x720）：约1.5 Mbps到4 Mbps</li><li>1080p（1920x1080）：通常介于5 Mbps到10 Mbps   （1小时4.5G流量）</li><li>4K（3840x2160）：通常介于15 Mbps到30 Mbps</li><li>8K（7680x4320）：比特率通常在50 Mbps到100 Mbps以上</li></ul></li><li>nas进行<strong>实时转码</strong>后发送转码后的文件给客户端，相当于<strong>预处理了</strong>，需要nas性能 and 转码后码率&gt;传输速率，对nas有要求（软件解码甚至硬件解码）但对客户端较低<ul><li>播放设备<strong>不兼容</strong>源文件的编码，nas负责转为H264</li><li>源文件码率太高，nas转低码率，降低流量、网络要求</li></ul></li></ol><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>通过lsky建立图床，但异地无法访问，需要cloudfare暴露服务，网速比较慢</p><ul><li>nas docker配置lsky图床；配置picgo插件，实现上传到图床<a href="http://202.120.87.24:48215/">Lsky Pro</a>  <a href="https://post.smzdm.com/p/awz4mw7m/">https://post.smzdm.com/p/awz4mw7m/</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1AA4m1c7uv">45 块，把你的群晖 NAS 升级到四万兆</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV19Y4113788">这么多视频编码，为啥就不能统一成一种呢？【差评君】</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1fL411g72a">【新手向】如何让NAS成为家庭影音中心（家庭影音服务器）</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>nas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透技术</title>
    <link href="/2024/04/20/TechDigest/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/04/20/TechDigest/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>网络通信需要目的IP和源IP地址以进行数据往返传输。由于IPv4地址有限，局域网设备使用私有IP，通过路由器NAT（网络地址转换）技术共享公网IP实现外网访问。NAPT（网络地址端口转换）进一步扩展NAT功能，通过转换端口号允许多设备共享同一公网IP。例如，家用路由器将内网设备的HTTP请求映射到不同公网端口以实现并发访问，并记录映射表以便返回数据包正确转发。    私网设备可主动访问公网，但公网访问私网需预先配置端口映射规则。具体方法包括：将光猫设为桥接模式（仅负责信号转换）、向运营商申请动态公网IP（可能变化），再通过路由器设置端口转发。动态DNS（DDNS）可解决公网IP变动问题，需购买服务（如花生壳）并在路由器配置。IPv6虽易申请但兼容性较差且地址冗长。    若无法直接使用公网IP，需借助中转服务器实现内网穿透，例如：   1. <strong>NAS厂商方案</strong>（如群晖QuickConnect）或第三方工具（如蒲公英、DDNS.to），但可能存在速度或功能限制。   2. <strong>虚拟局域网工具</strong>（如ZeroTier或Tailscale），需各设备安装客户端，支持直连或中转，适合多点互联。   3. <strong>反向代理&#x2F;内网穿透工具</strong>：      - <strong>FRP</strong>：需公网服务器，配置灵活但需重启生效。      - <strong>Cloudflare Tunnel</strong>：通过Cloudflare服务器安全转发请求，适合暴露HTTP服务。      - <strong>NPS</strong>：提供友好管理界面，支持动态添加隧道，推荐使用第三方改进版本。      - <strong>NAT类型依赖方案</strong>（如NatMap、Lucky）：需网络为全锥型NAT。    总结：公网访问内网可通过端口映射、DDNS或IPv6实现；否则需依赖中转服务、虚拟局域网或穿透工具，选择依据具体场景（如速度、成本、易用性）。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>网络传输需要知道目的ip地址，并附带上源ip地址使得数据包可以返回</p><p>基本知识：全球的ipv4的数量是有限的，在局域网内并没有一个公网ip，而是局域网的私网IP。在网络到达路由器时，路由器通过NAT分配一个公网ip从而实现网路的传输。</p><ul><li><strong>NAT</strong> 是一种网络技术，用于在私有网络和公共网络之间转换IP地址。它允许多个设备共享一个公共IP地址，是解决IPv4地址耗尽问题的一种方法。<strong>网络层</strong></li><li><strong>NAPT</strong> 是NAT的一种扩展，它不仅转换IP地址，还包括端口号的转换。这允许多个设备不仅共享同一个公共IP地址，还可以通过不同的端口标识，实现更加高效的地址和端口的映射。<strong>传输层</strong></li></ul><blockquote><p>假设家用路由器的公网IP为 <code>12.0.2.1</code>，内网设备分别为 <code>192.168.1.100</code> 和 <code>192.168.1.101</code>。当这两个内网设备同时使用HTTP（假设使用端口80）访问外网时：</p><ul><li>路由器可能会将 <code>192.168.1.100:80</code> 的流量映射到 <code>12.0.2.1:10000</code></li><li>将 <code>192.168.1.101:80</code> 的流量映射到 <code>12.0.2.1:10001</code></li></ul></blockquote><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404221026164.png" alt="image-20240422102615340"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220102520.png" alt="image-20240422010212314"></p><p>同时路由器记录下一个ip端口映射表，根据映射表将8.8.8.8:800再转换回10.10.10.10:1000</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220106320.png" alt="image-20240422010639177"></p><p>所以私网可以轻松访问公网，但公网访问私网的前提是建立好了端口映射规则</p><h3 id="公网IP-DDNS"><a href="#公网IP-DDNS" class="headerlink" title="公网IP+DDNS"></a>公网IP+DDNS</h3><p>手动建立端口映射规则</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220111006.png" alt="image-20240422011135737"></p><ul><li><p>在光猫处，可以设置为<strong>桥接模式</strong>，使得光猫只负责光电信号转换，不负责nat和拨号</p></li><li><p>在运营商处，我们没有操作权限，只能向运营商申请一个<strong>公网ip</strong>（不一定是固定的，重启后可能会变，但一定要是公网ip，而不是10.这种私网ip）</p></li><li><p>最后，手动设置<strong>路由器的端口转发</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220117356.png" alt="image-20240422011754041"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220128322.png" alt="image-20240422012853045"></p></li></ul><h4 id="DDNS"><a href="#DDNS" class="headerlink" title="DDNS"></a>DDNS</h4><p>公网IP：重启后可能跟会变，想要更好的访问需要DDNS</p><p>DNS：记录下域名和ip的对应关系，但无法动态更新</p><p>DDNS：额外引入一个服务器，路由器客户端有一个监控负责监控ip变化，变化后通知DDNS，DDNS通知DNS</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220123730.png" alt="image-20240422012322564"></p><p>需要购买DDNS服务（花生壳、ddns-go、路由器厂商、NAS），并在路由器配置DDNS</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404220126868.png" alt="image-20240422012630536"></p><p>IPV6公网，很容易申请，缺点是难记，并且部分网络可能不支持IPV6</p><ul><li>上面的方案是基于公网实现设备间访问，下面的通常都需要一个中转的服务器（公网）来搭桥</li><li>中转服务器和内网客户端保持连接，使得中转服务器可以找到内网服务</li><li>访问中转服务器就可以间接访问到内网服务</li></ul><h3 id="傻瓜式方案"><a href="#傻瓜式方案" class="headerlink" title="傻瓜式方案"></a>傻瓜式方案</h3><p>如果有nas，可以用nas厂商提供的内网穿透，比如说群晖的qc，这种方案一般只支持转发nas自带的官方套件（威联通可以用自带的browser station实现另类的访问内网其他服务，极空间也在内测自定义端口内网穿透。据个人体验，群晖的内网穿透速度好像是最差的）。便宜又傻瓜的ddns to也是没有nas的良好选择，每七天一签到就可以无限免费续杯，哪怕付费，26元&#x2F;年的价格也很便宜。蒲公英在无法打洞的情况下，也提供中转服务器，但价格有点贵，优点是稳定（同一家公司的花生壳，好像也有内网穿透功能）。</p><p>其实是虚拟局域网的一种</p><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul><li>创建一个全球的虚拟局域网，适合需要多点直接连接的场景</li><li>想加入局域网的都需要安装客户端连接到服务器</li></ul><h4 id="蒲公英："><a href="#蒲公英：" class="headerlink" title="蒲公英："></a><strong>蒲公英</strong>：</h4><p>用起来很简单，打洞成功率不如后两者，但哪怕打洞失败，也有保底的服务器中转，缺点是免费套餐可用设备数量太少</p><p><a href="https://www.bilibili.com/video/BV1Yq4y1c7GU">内网穿透 异地组网 端口映射 蒲公英x1</a></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404221641368.png" alt="image-20240422164122349"></p><h4 id="zerotier："><a href="#zerotier：" class="headerlink" title="zerotier："></a><strong>zerotier</strong>：</h4><ul><li>各方面都不错，但会被部分地区的运营商限制，nas、电脑都需要安装客户端；</li><li><a href="https://www.jianshu.com/p/eac4067b2aa1">Zerotier——免费的虚拟局域网 | 内网穿透 | 解决方案 - 简书 (jianshu.com)</a>  <a href="https://imnks.com/3175.html">群晖DSM7.x使用ZeroTier套件的简单办法 - 我不是矿神 (imnks.com)</a></li><li><a href="https://my.zerotier.com/">https://my.zerotier.com/</a></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404221052439.png" alt="image-20240422105218332"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404221642488.png" alt="image-20240422164157388"></p><p>0.1mbps  太慢了</p><p>③tailscale：基于wg，和zerotier差不多，哪个好用用哪个</p><p>在自己有服务器的情况下，也可以自建其他方案</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li>上面的是建立多点直连，<strong>访问设备</strong>和<strong>被访问设备</strong>都需要安装并配置相应的客户端软件，例如访问面板下载文件</li><li>反向代理使用一个网络服务来接收来自外网的请求，然后将这些请求转发到内网中的服务器，并将服务器的响应返回给外网的客户。这样可以有效地隐藏服务器的真实IP地址。</li><li>暴露特定的内网应用port到互联网上，例如图床服务，相当于暴露给所有人；访问设备不需要安装客户端</li></ul><h4 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h4><p>frp：知名的内网穿透方案，<strong>需要有一个拥有公网IP的服务端</strong>，可以自建，也可以用别人搭好的，比如说樱花frp。缺点是每次更改配置文件都需要重启，在我这里连接效果不如nps</p><p>FRP 的客户端（frpc）在内部网络中运行，与服务器（frps）之间建立连接，用于建立隧道。通过这些隧道，FRP 服务器将接收到的公网请求转发到内部网络中的服务。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404221608170.png" alt="image-20240422160813814"></p><h4 id="CloudFare"><a href="#CloudFare" class="headerlink" title="CloudFare"></a>CloudFare</h4><p><a href="https://zhuanlan.zhihu.com/p/591320825">如何利用Cloudflare实现低成本群辉NAS内网穿透【原创】</a></p><ul><li><strong>建立隧道</strong>：在内部网络中运行 Cloudflare Tunnel 的客户端（<code>cloudflared</code>），该客户端与 Cloudflare 的服务器建立一个安全的长连接。</li><li><strong>配置转发</strong>：（配置域名 -&gt;  内网ip:port）</li><li><strong>请求转发</strong>：所有公网的请求首先到达 Cloudflare，Cloudflare 再通过已建立的安全隧道转发到内网服务。</li></ul><h4 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h4><p>可以使用官方的免费服务器，暴露80端，然后服务器会分配一个域名就可以访问到内网80的服务</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404221650897.png" alt="image-20240422165051957"></p><h4 id="nps"><a href="#nps" class="headerlink" title="nps"></a>nps</h4><p>nps：知名的内网穿透方案，需要有一个拥有公网IP的服务端，可以自建，也可以用别人搭好的。优点是有良好的web管理界面，每次添加穿透的隧道也不需要重启，在我这里的连接效果也比frp更好，官方仓库（<a href="https://github.com/ehang-io/nps%EF%BC%89%E5%A5%BD%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%88%86%E6%94%AF%E5%BA%93%EF%BC%9Ahttps://github.com/yisier/nps%EF%BC%8C%E4%B8%AA%E4%BA%BA%E6%B5%8B%E8%AF%95linux%E4%B8%8B%E6%95%88%E6%9E%9C%E6%AF%94windows%E4%B8%8B%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%89%80%E4%BB%A5%E6%8E%A8%E8%8D%90%E9%83%A8%E7%BD%B2%E5%9C%A8linux%E8%AE%BE%E5%A4%87%E4%B8%8A">https://github.com/ehang-io/nps）好久没更新了，推荐使用第三方分支库：https://github.com/yisier/nps，个人测试linux下效果比windows下更好，所以推荐部署在linux设备上</a></p><h3 id="nat打洞"><a href="#nat打洞" class="headerlink" title="nat打洞"></a>nat打洞</h3><p>natmap，lucky（大吉），natter等，请自行前往github搜索，本方案的所有软件都需要自家网络的nat类型为全锥型（fullcone）</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1NV4y197TX">DDNS 端口映射 内网穿透 NAT 公网IP</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/2364963">群晖NAS配置之自有服务器frp实现内网穿透</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.jianshu.com/p/eac4067b2aa1">Zerotier——免费的虚拟局域网 | 内网穿透 | 解决方案</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/2364963">群晖NAS配置之自有服务器frp实现内网穿透</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://post.smzdm.com/p/a20wwpn7/">FRP内网穿透—轻松实现外网访问群晖</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从FD到socketFD再到epoll原理</title>
    <link href="/2024/04/15/TechDigest/%E4%BB%8EFD%E5%88%B0socketFD%E5%86%8D%E5%88%B0epoll%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/15/TechDigest/%E4%BB%8EFD%E5%88%B0socketFD%E5%86%8D%E5%88%B0epoll%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>fd（文件描述符）是 File descriptor 的缩写，是一个非负整数，本质上是进程相关的索引值。当打开一个文件时，内核通过系统调用（如 <code>open</code>）向进程返回文件描述符，之后通过该描述符进行文件的读写操作。  fd 的取值范围是 0 到 OPEN_MAX-1，其中 0、1、2 已被 POSIX 标准赋予特殊含义，分别是标准输入、标准输出和标准错误。用户可通过 <code>ulimit</code> 命令查看当前系统的文件描述符限制。  文件描述符在进程中通过 <code>task_struct</code> 结构管理，其中 <code>files_struct</code> 结构负责记录进程打开的文件信息。<code>files_struct</code> 包含两个关键部分：静态数组 <code>fd_array</code>（默认 64 个元素）和动态扩容的 <code>fdtable</code>。<code>fd</code> 本质上是数组索引，指向进程的 <code>file</code> 结构。  <code>file</code> 结构记录打开文件的信息，如当前文件偏移量和 <code>inode</code> 指针，可以跨进程共享（如 <code>fork</code> 时）。<code>inode</code> 是虚拟文件系统（VFS）的抽象，管理文件的元数据（如权限、大小、时间戳）和指向具体文件系统（如 ext4）操作的函数指针，不同文件系统通过继承和组合实现差异化支持。  socket（套接字）是网络编程的抽象接口，被视为应用层和传输层之间的桥梁，封装了 TCP&#x2F;UDP 等协议的细节。当 <code>socket()</code> 创建套接字时，内核生成 <code>struct socket</code> 和 <code>struct sock</code> 结构，分别负责文件抽象和协议相关操作。<code>sock</code> 结构包含接收和发送队列、缓冲区大小及数据就绪回调函数（如 <code>sk_data_ready</code>）。  阻塞 IO 中，若无数据可读，进程会挂接到 <code>sock-&gt;sk_wq</code> 等待队列；数据到达时，回调函数唤醒进程。epoll 通过红黑树高效管理大量 socket，将就绪事件放入 <code>rdllist</code> 队列，避免遍历全部连接，并利用回调机制通知用户进程。  总结：fd 是进程访问文件或 socket 的句柄，内核通过多层结构（如 <code>file</code>、<code>inode</code>、<code>socket</code>）实现抽象和高效管理。epoll 则通过事件驱动和红黑树优化，显著提升高并发场景下的 IO 效率。</p></blockquote><h1 id="FD"><a href="#FD" class="headerlink" title="FD"></a>FD</h1><h2 id="fd-是什么？"><a href="#fd-是什么？" class="headerlink" title="fd 是什么？"></a><strong><code>fd</code> 是什么？</strong></h2><p><code>fd</code> 是 <code>File descriptor</code> 的缩写，中文名叫做：<strong>文件描述符</strong>。<strong>文件描述符</strong>是一个非负整数，<strong>本质上是一个进程相关的索引值</strong></p><p><strong>什么时候拿到的 <code>fd</code> ？</strong></p><p>当打开一个文件时，内核向进程返回一个文件描述符（ <code>open</code> 系统调用得到 ），后续 <code>read</code>、<code>write</code> 这个文件时，则只需要用这个<strong>文件描述符</strong>来标识该文件，将其作为参数传入 <code>read</code>、<code>write</code> 。</p><p><strong>fd 的值范围是什么？</strong></p><p>在 POSIX 语义中，0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）。</p><p>文件描述符是有一个范围的：0 ～ OPEN_MAX-1 ，最早期的 UNIX 系统中范围很小，现在的主流系统单就这个值来说，变化范围是几乎不受限制的，只受到系统硬件配置和系统管理员配置的约束。</p><p>你可以通过 <code>ulimit</code> 命令查看当前系统的配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">ulimit -n<br>4864<br></code></pre></td></tr></table></figure><h2 id="窥探-Linux-内核"><a href="#窥探-Linux-内核" class="headerlink" title="窥探 Linux 内核"></a><strong>窥探 Linux 内核</strong></h2><p>用户使用系统调用 <code>open</code> 或者 <code>creat</code> 来打开或创建一个文件，用户态得到的结果值就是 <code>fd</code>；</p><h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a><strong><code>task_struct</code></strong></h3><p>首先，我们知道进程的抽象是基于 <code>struct task_struct</code> 结构体，当创建一个进程，其实也就是 <code>new</code> 一个 <code>struct task_struct</code> 出来，这是 Linux 里面最复杂的结构体之一 ，成员字段非常多，我们今天不需要详解这个结构体，我稍微简化一下，只提取我们今天需要理解的字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Open file information: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span>     *<span class="hljs-title">files</span>;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>files</code> 这个字段就是今天的主角之一, 管理着该进程打开的所有文件</p><h3 id="files-struct"><a href="#files-struct" class="headerlink" title="files_struct"></a><strong><code>files_struct</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">*<br> * Open file table structure<br> */<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><br>    <span class="hljs-comment">// 读相关字段</span><br>    <span class="hljs-type">atomic_t</span> count;<br>    <span class="hljs-type">bool</span> resize_in_progress;<br>    <span class="hljs-type">wait_queue_head_t</span> resize_wait;<br><br>    <span class="hljs-comment">// 打开的文件管理结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">fdt</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> <span class="hljs-title">fdtab</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> // 本质上是 <span class="hljs-title">file</span> __<span class="hljs-title">rcu</span> **<span class="hljs-title">fd</span>;</span>      <span class="hljs-comment">/* current fd array */</span><br><br>    <span class="hljs-comment">// 写相关字段</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> next_fd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> close_on_exec_init[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> open_fds_init[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> full_fds_bits_init[<span class="hljs-number">1</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">fd_array</span>[<span class="hljs-title">NR_OPEN_DEFAULT</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>既然管理进程打开所有的文件，那当然需要一个<strong>数组</strong>，有两个地方存储了数组：</p><ol><li><p><code>struct file * fd_array[NR_OPEN_DEFAULT]</code> 是一个静态数组，随着 <code>files_struct</code> 结构体分配出来的，在 64 位系统上，静态数组大小为 64；</p></li><li><p><code>struct fdtable</code> 也是个数组管理结构，只不过这个是一个动态数组，数组边界是用字段描述的；</p><blockquote><p><strong>思考：为什么会有这种静态 + 动态的方式？</strong></p><p>性能和资源的权衡 ！大部分进程只会打开少量的文件，所以静态数组就够了，这样就不用另外分配内存。如果超过了静态数组的阈值，那么就动态扩展。</p></blockquote></li></ol><p>为什么说fd就是一个索引：**<code>fd</code> 其实就是就是这个数组的索引，也就是数组的槽位编号而已。**</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a><strong><code>file</code></strong></h3><p>也就是fd指向的对象，表示当前进程打开的某个文件；关键信息：<strong>当前文件偏移，inode 结构地址</strong>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span>                     <span class="hljs-title">f_path</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>                    *<span class="hljs-title">f_inode</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>    *<span class="hljs-title">f_op</span>;</span><br><br>    <span class="hljs-type">atomic_long_t</span>                    f_count;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>                     f_flags;<br>    <span class="hljs-type">fmode_t</span>                          f_mode;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>                     <span class="hljs-title">f_pos_lock</span>;</span><br>    <span class="hljs-type">loff_t</span>                           f_pos;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fown_struct</span>               <span class="hljs-title">f_owner</span>;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>f_path</code> ：标识文件名</p></li><li><p><code>f_inode</code> ：非常重要的一个字段，<code>inode</code> 这个是 vfs 的 <code>inode</code> 类型，是基于具体文件系统之上的抽象封装；（文件系统共享）</p></li><li><p><code>f_pos</code> ： 这个字段非常重要，偏移，对，<strong>就是当前文件偏移</strong>。还记得上一篇 IO 基础里也提过偏移对吧，指的就是这个，<code>f_pos</code> 在 <code>open</code> 的时候会设置成默认值，<code>seek</code> 的时候可以更改，从而影响到 <code>write/read</code> 的位置；</p></li><li><p><code>f_op</code>:根据你的“文件”类型赋值的（也就是指向了 <code>struct inode</code> 中的 <code>i_fop</code>），比如 ext2 的文件，那么就是 <code>ext2_file_operations</code></p></li><li><p>file是当前进程打开的某个文件，那会进程间共享吗？  一般不会，但会 fork时</p></li><li><p>在同一个进程中，多个 <code>fd</code> 可能指向同一个 file 结构吗？   <code>dup</code>命令</p></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210932.jpg" alt="v2-1b0afa95e56ddf0cdd95ee2ad1d75d09_r"></p><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a><code>inode</code></h3><p><code>struct file</code> 结构体里面有一个 inode 的指针，这个指向的 inode 并没有直接指向具体文件系统的 inode ，而是操作系统抽象出来的一层虚拟文件系统，叫做 <strong>VFS （ Virtual File System ）</strong>，然后在 VFS 之下才是真正的文件系统，比如 ext4 之类的。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210933.png" alt="image-20240409145416828"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    <span class="hljs-comment">// 文件相关的基本信息（权限，模式，uid，gid等）</span><br>    <span class="hljs-type">umode_t</span>             i_mode;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>      i_opflags;<br>    <span class="hljs-type">kuid_t</span>              i_uid;<br>    <span class="hljs-type">kgid_t</span>              i_gid;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        i_flags;<br>    <span class="hljs-comment">// 回调函数</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span>   *<span class="hljs-title">i_op</span>;</span> <span class="hljs-comment">// 创建、删除、读取inode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>              *<span class="hljs-title">i_sb</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>            *<span class="hljs-title">i_mapping</span>;</span><br>    <span class="hljs-comment">// 文件大小，atime，ctime，mtime等</span><br>    <span class="hljs-type">loff_t</span>              i_size;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span>   <span class="hljs-title">i_atime</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span>   <span class="hljs-title">i_mtime</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec64</span>   <span class="hljs-title">i_ctime</span>;</span><br>    <span class="hljs-comment">// 回调函数</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>    *<span class="hljs-title">i_fop</span>;</span> <span class="hljs-comment">// 读取、写入、定位文件指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>            <span class="hljs-title">i_data</span>;</span><br>    <span class="hljs-comment">// 指向后端具体文件系统的特殊数据</span><br>    <span class="hljs-type">void</span>    *i_private;     <span class="hljs-comment">/* fs or device private pointer */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> <code>i_fop</code> 回调函数在构造 <code>inode</code> 的时候，就注册成了后端的文件系统函数，假设有一个名为 <code>ext4_file_operations</code> 的结构体，它包含了针对 ext4 文件系统的操作函数的指针。那么，<code>i_fop</code> 指针可以被设置为指向这个结构体，从而允许操作 ext4 文件系统中的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>    <span class="hljs-type">int</span> (*open)(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp);<br>    <span class="hljs-type">ssize_t</span> (*read)(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">loff_t</span> *ppos);<br>    <span class="hljs-type">ssize_t</span> (*write)(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">loff_t</span> *ppos);<br>    <span class="hljs-type">int</span> (*release)(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp);<br>    <span class="hljs-comment">// 其他操作函数指针</span><br>&#125;;<br><br><span class="hljs-comment">// 用于 ext4 文件系统的操作函数 每实现一个文件系统的时候，就要实现这个文件调用</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ext4_file_operations</span> =</span> &#123;<br>    .open = ext4_open,<br>    .read = ext4_read,<br>    .write = ext4_write,<br>    .release = ext4_release,<br>    <span class="hljs-comment">// 其他函数指针的初始化</span><br>&#125;;<br><br><span class="hljs-comment">// 然后在使用 inode 结构体时将 i_fop 指向 ext4_file_operations</span><br>inode-&gt;i_fop = &amp;ext4_file_operations;<br></code></pre></td></tr></table></figure><p><code>vfs  inode</code>  是下一层的抽象（如ext4_inode_info）， 所有文件系统共性的东西抽象到 <code>vfs  inode</code> ，不同文件系统差异的东西放在各自的 <code>inode</code> 结构体中。c语言中的继承是通过结构体的组合实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode_info</span> &#123;</span><br>    <span class="hljs-comment">// ext4 inode 特色字段</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 重要！！！</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>    <span class="hljs-title">vfs_inode</span>;</span>  <br>&#125;;<br></code></pre></td></tr></table></figure><p>分配 inode 的时候，其实分配的是 <code>ext4_inode_info</code> 结构体，包含了 vfs inode，然后对外给出去 vfs_inode 字段的地址即可。VFS 层拿 inode 的地址使用，底下文件系统强转类型后<code>(struct ext4_inode_info *)(vfs_inode地址 - vfs_inode在ext4_inode_info中的偏移)</code>，取外层的 ext4_inode_info 地址使用。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><ol><li>用户操作文件时，open会得到一个FD</li><li>FD本质来讲是一个数组索引，结构体 <code>task_struct</code> 对应一个抽象的进程，<code>files_struct</code> 是这个进程管理<strong>该进程打开的文件</strong>数组管理器。也就是fd是进程中的<code>task_struct.files_struct.fd_array</code>的下标，指向file结构体</li><li><code>file</code> 结构：表征一个打开的文件，内部包含关键的字段有：<strong>当前文件偏移，inode 结构地址</strong>；该结构虽然由进程触发创建，但是 <code>file</code>  结构可以在进程间共享；（fork）</li><li><code>inode</code> 属于文件系统级别的概念，只由文件系统管理维护，进程间共享 (当多个进程写同一个文件的时候，由于一个文件最终是落到全局唯一的一个 <code>inode</code> 上，这种并发场景则可能产生用户不可预期的结果；)</li></ol><h1 id="socket-FD"><a href="#socket-FD" class="headerlink" title="socket FD"></a>socket FD</h1><p><code>socket</code> 可能你还没反应过来，中文名：<strong>套接字</strong> </p><p>socket是为了方便网络编程设计出的接口，视为应用程序与传输层之间的桥梁，它为应用程序提供了一个通用的、与底层传输协议无关的接口，使得不同应用程序可以方便地进行网络通信。实现可以是基于TCP、UDP的，使我们不用考虑tcp udp 以及内核网络的传输功能</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210934.png" alt="image-20240409150104889"></p><ol><li>客户端和服务端都用 <code>socket</code> 调用创建套接字；</li><li>服务端用 <code>bind</code> 绑定监听地址，用 <code>listen</code> 把套接字转化为监听套接字，用 <code>accept</code> 捞取一个客户端来的连接；</li><li>客户端用 <code>connect</code> 进行建连，用 <code>write/read</code> 进行网络 IO；（这里connect就像open一个本地文件一样，这就是socket给我们带来的方便）</li></ol><p>我们可以基于socket 构建我们想要的应用层协议 例如<code>http resp</code>, 写一个resp读取redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Void <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>             <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream(), <span class="hljs-literal">true</span>);<br>             <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()))) &#123;<br><br>            out.println(send(<span class="hljs-string">&quot;SET&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>));<br>            System.out.println(parseResponse(in));<br><br><br>            out.println(send(<span class="hljs-string">&quot;SET&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));<br>            System.out.println(parseResponse(in));<br><br><br>            out.println(send(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>));<br>            System.out.println(parseResponse(in));<br><br>            out.println(send(<span class="hljs-string">&quot;MGET&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>));<br>            System.out.println(parseResponse(in));<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String... args)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        command.append(<span class="hljs-string">&quot;*&quot;</span>).append(args.length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>            command.append(<span class="hljs-string">&quot;$&quot;</span>).append(arg.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            command.append(arg).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> command.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">parseResponse</span><span class="hljs-params">(BufferedReader in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> in.readLine();<br>        <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;+&quot;</span>)) &#123; <span class="hljs-comment">// 单行回复</span><br>            <span class="hljs-keyword">return</span> line.substring(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;-&quot;</span>)) &#123; <span class="hljs-comment">// 错误消息</span><br>            <span class="hljs-keyword">return</span> line.substring(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;:&quot;</span>)) &#123; <span class="hljs-comment">// 整数回复</span><br>            <span class="hljs-keyword">return</span> Integer.parseInt(line.substring(<span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;$&quot;</span>)) &#123; <span class="hljs-comment">// 批量字符串回复</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> Integer.parseInt(line.substring(<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span> (length == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;$-1&quot; 表示 null</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> in.readLine(); <span class="hljs-comment">// 这里偷懒直接读取 按道理要按照长度</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">&quot;*&quot;</span>)) &#123; <span class="hljs-comment">// 数组回复</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Integer.parseInt(line.substring(<span class="hljs-number">1</span>));<br>            List&lt;Object&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                array.add(parseResponse(in)); <span class="hljs-comment">// 递归解析数组中的每个元素</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> array;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 未知类型</span><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="socket-fd-的类型"><a href="#socket-fd-的类型" class="headerlink" title="socket fd 的类型"></a><strong>socket fd 的类型</strong></h2><p>上面我们提到了套接字，这是我们网络编程的主体，套接字由 <code>socket()</code> 系统调用创建，但你可知套接字其实可分为两种类型，监听套接字和普通套接字。而监听套接字是由 <code>listen()</code> 把 socket fd 转化而成。</p><h3 id="监听套接字"><a href="#监听套接字" class="headerlink" title="监听套接字"></a><strong>监听套接字</strong></h3><p>对于监听套接字，不走数据流，只管理连接的建立。<code>accept</code> 将从全连接队列获取一个创建好的 socket（ 3 次握手完成），对于监听套接字的可读事件就是全连接队列非空。</p><p>对于监听套接字，我们只在乎可读事件。</p><h3 id="普通套接字"><a href="#普通套接字" class="headerlink" title="普通套接字"></a><strong>普通套接字</strong></h3><p>普通套接字就是走数据流的，也就是网络 IO，针对普通套接字我们关注可读可写事件。在说 socket 的可读可写事件之前，我们先捋顺套接字的读写大概是什么样子吧。</p><p>套接字层是内核提供给程序员用来网络编程的，程序猿读写都是针对套接字而言，那么 <code>write( socketfd, /* 参数 */)</code> 和 <code>read( socketfd, /* 参数 */)</code> 都会发生什么呢？</p><ul><li>write 数据到 socketfd，大部分情况下，数据写到 socket 的内存 buffer，就结束了，并没有发送到对端网络（异步发送）；</li><li>read socketfd 的数据，也只是从 socket 的 内存 buffer 里读数据而已，而不是从网卡读（虽然数据是从网卡一层层递上来的）；</li></ul><p>也就是说，程序猿而言，是跟 socket 打交道，内核屏蔽了底层的细节。</p><p>那说回来 socket 的可读可写事件就很容易理解了。</p><ul><li>socketfd 可读：其实就是 socket buffer 内有数据（超过阈值 SO_RCLOWAT ）；</li><li>socketfd 可写：就是 socket buffer 还有空间让你写（阈值 SO_SNDLOWAT ）；</li></ul><h2 id="sockfs-文件系统"><a href="#sockfs-文件系统" class="headerlink" title="sockfs 文件系统"></a><strong>sockfs 文件系统</strong></h2><p>之前在fd中提到，<strong>vfs 层使用的是 inode，ext4 层使用的是 <code>ext4_inode_info</code> ，不同层次通过地址的强制转化类型来切换结构体。</strong></p><p>那么类似，sockfs 也是如此，sockfs 作为文件系统，也有自己特色的 “inode”，这个类型就是 <code>struct socket_alloc</code> ，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_alloc</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> <span class="hljs-title">socket</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">vfs_inode</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体关联 socket 和 inode 两个角色，是“文件”抽象的核心之一。分配 <code>struct socket</code> 结构体其实是分配了 <code>struct socket_alloc</code> 结构体，然后返回了 <code>socket_alloc-&gt;socket</code>  字段的地址而已。但还是可以通过地址的偏移拿到整个socket_alloc</p><blockquote><p><code>struct socket</code> 是内核抽象出的一个通用结构体，主要作用是放置了一些跟 fs 相关的字段，而真正跟网络通信相关的字段结构体是 <code>struct sock</code> 。它们内部有相互的指针，可以获取到对方的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> &#123;</span><br>    <span class="hljs-type">int</span> type;               <span class="hljs-comment">// 套接字类型 (SOCK_STREAM, SOCK_DGRAM, etc.)</span><br>    <span class="hljs-type">int</span> state;              <span class="hljs-comment">// 套接字状态 (ESTABLISHED, LISTEN, etc.)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span>        <span class="hljs-comment">// 指向关联的底层套接字对象的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span>      <span class="hljs-comment">// 与套接字关联的文件</span><br>    <span class="hljs-comment">// 其他成员...</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sk_socket</span>;</span> <span class="hljs-comment">// 指向上层 socket 结构体的指针</span><br>    <span class="hljs-comment">/* 套接字状态 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> sk_family;  <span class="hljs-comment">// 地址族 (AF_INET, AF_INET6, etc.)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sk_state;    <span class="hljs-comment">// 套接字状态 (TCP: ESTABLISHED, LISTEN, etc.)</span><br>    <br>    <span class="hljs-comment">/* 通用信息 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">sk_prot</span>;</span>     <span class="hljs-comment">// 指向协议特定信息的指针 tcp_prot  udp_prot </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk_peer</span>;</span>      <span class="hljs-comment">// 对等套接字 (用于连接套接字)</span><br><br>    <span class="hljs-comment">/* 地址信息 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">sk_rcvaddr</span>;</span> <span class="hljs-comment">// 接收地址信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">sk_daddr</span>;</span>   <span class="hljs-comment">// 目的地址信息</span><br><br>    <span class="hljs-comment">/* 数据缓冲区 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_head</span> <span class="hljs-title">sk_receive_queue</span>;</span> <span class="hljs-comment">// 接收队列 指向sk_buff </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_head</span> <span class="hljs-title">sk_write_queue</span>;</span>   <span class="hljs-comment">// 发送队列</span><br><br>    <span class="hljs-comment">/* 套接字选项 */</span><br>    <span class="hljs-type">int</span> sk_rcvbuf;  <span class="hljs-comment">// 接收缓冲区大小</span><br>    <span class="hljs-type">int</span> sk_sndbuf;  <span class="hljs-comment">// 发送缓冲区大小</span><br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_wq</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">sk_wq</span>;</span> <span class="hljs-comment">// 新版本通过sk_sleep() 间接访问</span><br><br>    <span class="hljs-comment">/* 其他成员 */</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></blockquote><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210935.png" alt="image-20240409173406945"></p><p><strong>vfs 层用的时候给 inode 字段的地址，socket 层的时候给 socket 字段的地址。不同抽象层面对于同一个内存块的理解不同，强制转化类型，然后各自使用</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210936.png" alt="image-20240409160907186"></p><h2 id="socket创建"><a href="#socket创建" class="headerlink" title="socket创建"></a>socket创建</h2><p>socket 系统调用对应了 <code>__sys_socket</code> 这个函数。这个函数主要做两件事情：</p><ol><li>第一件事：调用 <code>socket_create</code> 函数创建好 socket 相关的结构体，主要是 <code>struct socket</code> ，还有与之关联的 <code>socket sock</code> 结构，再往下就是具体网络协议对应的结构体（旁白：这里实现细节过于复杂，不在文章主干，故略去 10 万字）；</li><li>第二件事：调用 <code>sock_map_fd</code> 函数创建好 <code>struct file</code> 这个结构体，并与第一步创建出的 <code>struct socket</code> 关联起来；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ctext">__sys_socket<br>    // 创建 struct socket 结构体<br>    -&gt; sock_create<br>            // 创建 struct socket 结构，并且关联特殊 inode<br>            -&gt; sock_alloc<br>            // pf 是根据 family 从 net_families 这个全局表中取出的操作函数表，用来创建具体网络协议结构的;  <br>            // 比如 IPv4 对应的 family 就是 AF_INET ，对应的函数是 inet_create<br>            // 在这里面会赋值 sock-&gt;ops 为对应协议族的操作函数表（比如 inet_stream_ops）<br>            -&gt; pf-&gt;create<br>                    // struct sock 结构体的创建（sk-&gt;sk_prot 的赋值就在这里，比如 tcp_prot ）<br>                    -&gt; sk_alloc<br>                    // struct sock 结构体的初始化(比如 sk_receive_queue, sk_write_queue, sk_error_queue 就是在这里初始化的)<br>                    // 可读写的关键函数 sock_def_readable，sock_def_write_space 也是在这里赋值的<br>                    -&gt; sock_init_data<br>    // 创建 struct file 结构体，并且关联 struct socket<br>    -&gt; sock_map_fd<br></code></pre></td></tr></table></figure><ol><li><code>socket( )</code> 函数只负责创建出适配具体网络协议的资源（内存、结构体、队列等），并<strong>没有和具体地址绑定</strong>；</li><li><code>socket( )</code> 返回的是非负整数的 fd，与 <code>struct file</code> 对应，而 <code>struct file</code> 则与具体的 <code>struct socket</code> 关联，从而实现<strong>一切皆文件</strong>的封装的一部分（另一部分 inode 的创建处理在 sock_alloc 的函数里体现）；</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210937.webp" alt="img"></p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a><strong>阻塞IO</strong></h2><p>阻塞IO中用户进程阻塞以及唤醒原理</p><p>用户进程发起系统IO调用时，这里我们拿<code>read</code>举例，用户进程会在<code>内核态</code>查看对应<code>Socket</code>接收缓冲区是否有数据到来。</p><ul><li><code>Socket</code>接收缓冲区有数据，则拷贝数据到<code>用户空间</code>，系统调用返回。</li><li><code>Socket</code>接收缓冲区没有数据，则用户进程让出<code>CPU</code>进入<code>阻塞状态</code>，当数据到达接收缓冲区时，用户进程会被唤醒，从<code>阻塞状态</code>进入<code>就绪状态</code>，等待CPU调度。</li></ul><p>本小节我们就来看下用户进程是如何<code>阻塞</code>在<code>Socket</code>上，又是如何在<code>Socket</code>上被唤醒的。<strong>理解这个过程很重要，对我们理解epoll的事件通知过程很有帮助</strong></p><ul><li>首先我们在用户进程中对<code>Socket</code>进行<code>read</code>系统调用时，用户进程会从<code>用户态</code>转为<code>内核态</code>。</li><li>在进程的<code>struct task_struct</code>结构找到<code>fd_array</code>，并根据<code>Socket</code>的文件描述符<code>fd</code>找到对应的<code>struct file</code>，调用<code>struct file</code>中的文件操作函数结合<code>file_operations</code>，<code>read</code>系统调用对应的是<code>sock_read_iter</code>。</li><li>在<code>sock_read_iter</code>函数中找到<code>struct file</code>指向的<code>struct socket</code>，并调用<code>socket-&gt;ops-&gt;recvmsg</code>，这里我们知道调用的是<code>inet_stream_ops</code>集合中定义的<code>inet_recvmsg</code>。在<code>inet_recvmsg</code>中会找到<code>struct sock</code>，并调用<code>sock-&gt;skprot-&gt;recvmsg</code>,这里调用的是<code>tcp_prot</code>集合中定义的<code>tcp_recvmsg</code>函数。</li></ul><h3 id="进入等待"><a href="#进入等待" class="headerlink" title="进入等待"></a>进入等待</h3><p>当调用fd.read并且没有足够数据时, <strong>创建一个wait_queue_t 对象（包含当前线程，回调函数）挂接到这个 socket 的 <code>sk-&gt;sk_wq</code> 中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tcp_recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-keyword">struct</span> msghdr *msg,</span><br><span class="hljs-params">  <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> nonblock, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> *addr_len)</span><br>&#123;<br>    .................省略非核心代码...............<br>   <span class="hljs-comment">//访问sock对象中定义的接收队列</span><br>  skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) &#123;<br><br>    .................省略非核心代码...............<br><br>  <span class="hljs-comment">//没有收到足够数据，调用sk_wait_data 阻塞当前进程</span><br>  sk_wait_data(sk, &amp;timeo);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sk_wait_data</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">long</span> *timeo)</span><br>&#123;<br> <span class="hljs-comment">//创建struct sock中等待队列上的元素wait_queue_t</span><br> <span class="hljs-comment">//将进程描述符和回调函数autoremove_wake_function关联到wait_queue_t中</span><br> DEFINE_WAIT(wait);<br><br> <span class="hljs-comment">// 调用 sk_sleep 获取 sock 对象下的等待队列的头指针wait_queue_head_t</span><br> <span class="hljs-comment">// 调用prepare_to_wait将新创建的等待项wait_queue_t插入到等待队列中，并将进程状态设置为可打断 INTERRUPTIBLE</span><br> prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);<br> set_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);<br>    <br> ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_WAIT_FUNC(name, function)    \</span><br><span class="hljs-meta"> wait_queue_t name = &#123;      \</span><br><span class="hljs-meta">  .private = current,    \</span><br><span class="hljs-meta">  .func  = function,    \</span><br><span class="hljs-meta">  .task_list</span><br>&#125;<br></code></pre></td></tr></table></figure><p>等待类型<code>wait_queue_t</code>中的<code>private</code>用来关联<code>阻塞</code>在当前<code>socket</code>上的用户进程<code>fd</code>。<code>func</code>用来关联等待项上注册的<a href="https://www.zhihu.com/search?q=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222535104311%22%7D">回调函数</a>。这里注册的是<code>autoremove_wake_function</code>。</p><h3 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h3><ul><li><p>当网络数据包到达网卡时，网卡通过<code>DMA</code>的方式将数据放到<code>RingBuffer</code>中。</p></li><li><p>然后向CPU发起硬中断，在硬中断响应程序中创建<code>sk_buffer</code>，并将网络数据拷贝至<code>sk_buffer</code>中。</p></li><li><p>随后发起<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%B8%AD%E6%96%AD&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222535104311%22%7D">软中断</a>，内核线程<code>ksoftirqd</code>响应软中断，调用<code>poll函数</code>将<code>sk_buffer</code>送往内核协议栈做层层协议处理。</p></li><li><p>在传输层<code>tcp_rcv 函数</code>中，去掉TCP头，根据<code>四元组（源IP，源端口，目的IP，目的端口）</code>查找对应的<code>Socket</code>。</p></li><li><p>最后将<code>sk_buffer</code>放到<code>Socket</code>中的接收队列<code>sk_receive_queue</code>里。</p></li><li><p>接着就会调用<code>数据就绪函数回调指针sk_data_ready</code>，前边我们提到，这个函数指针在初始化的时候指向了<code>sock_def_readable</code>函数。</p><ul><li>获取<code>socket-&gt;sock-&gt;sk_wq</code>等待队列。在<code>wake_up_common</code>函数中从等待队列<code>sk_wq</code>中找出<code>一个</code>等待项<code>wait_queue_t</code>，回调注册在该等待项上的<code>func</code>回调函数（<code>wait_queue_t-&gt;func</code>）,创建等待项<code>wait_queue_t</code>是我们提到，这里注册的回调函数是<code>autoremove_wake_function</code>（等待项<code>wait_queue_t</code>上的<code>private</code>关联的<code>阻塞进程fd</code>调用<code>try_to_wake_up</code>唤醒阻塞在该<code>Socket</code>上的进程）。</li></ul></li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><h3 id="创建epoll对象"><a href="#创建epoll对象" class="headerlink" title="创建epoll对象"></a><strong>创建epoll对象</strong></h3><p><code>epoll_create</code>是内核提供给我们创建<code>epoll</code>对象的一个系统调用，当我们在用户进程中调用<code>epoll_create</code>时，内核会为我们创建一个<code>struct eventpoll</code>对象，并且也有相应的<code>struct file</code>与之关联，同样需要把这个<code>struct eventpoll</code>对象所关联的<code>struct file</code>放入进程打开的文件列表<code>fd_array</code>中管理。</p><blockquote><p>熟悉了<code>Socket</code>的创建逻辑，<code>epoll</code>的创建逻辑也就不难理解了。</p><p><code>struct eventpoll</code>对象关联的<code>struct file</code>中的<code>file_operations 指针</code>指向的是<code>eventpoll_fops</code>操作函数集合。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">static const struct file_operations eventpoll_fops = &#123;<br>     .release = ep_eventpoll_release;<br>     .poll = ep_eventpoll_poll,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br><br>    <span class="hljs-comment">//等待队列，阻塞在epoll上的进程会放在这里</span><br>    <span class="hljs-type">wait_queue_head_t</span> wq;<br><br>    <span class="hljs-comment">//就绪队列，IO就绪的socket连接会放在这里</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span><br><br>    <span class="hljs-comment">//红黑树用来管理所有监听的socket连接</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span><br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>wait_queue_head_t wq：</code>epoll中的等待队列，队列里存放的是<code>阻塞</code>在<code>epoll</code>上的用户进程。在<code>IO就绪</code>的时候<code>epoll</code>可以通过这个队列找到这些<code>阻塞</code>的进程并唤醒它们，从而执行<code>IO调用</code>读写<code>Socket</code>上的数据。</li></ul><blockquote><p>这里注意与<code>Socket</code>中的等待队列区分！！！</p></blockquote><ul><li><code>struct list_head rdllist：</code>epoll中的就绪队列，队列里存放的是都是<code>IO就绪</code>的<code>Socket</code>，被唤醒的用户进程可以直接读取这个队列获取<code>IO活跃</code>的<code>Socket</code>。无需再次遍历整个<code>Socket</code>集合。</li></ul><blockquote><p>这里正是<code>epoll</code>比<code>select ，poll</code>高效之处，<code>select ，poll</code>返回的是全部的<code>socket</code>连接，我们需要在<code>用户空间</code>再次遍历找出真正<code>IO活跃</code>的<code>Socket</code>连接。 而<code>epoll</code>只是返回<code>IO活跃</code>的<code>Socket</code>连接。用户进程可以直接进行IO操作。</p></blockquote><ul><li><code>struct rb_root rbr :</code> 由于红黑树在<code>查找</code>，<code>插入</code>，<code>删除</code>等综合性能方面是最优的，所以epoll内部使用一颗红黑树来管理海量的<code>Socket</code>连接。</li></ul><blockquote><p><code>select</code>用<code>数组</code>管理连接，<code>poll</code>用<code>链表</code>管理连接。</p></blockquote><h3 id="添加socket"><a href="#添加socket" class="headerlink" title="添加socket"></a>添加socket</h3><p>首先要在epoll内核中创建一个表示<code>Socket连接</code>的数据结构<code>struct epitem</code>，而在<code>epoll</code>中为了综合性能的考虑，采用一颗红黑树来管理这些海量<code>socket连接</code>。所以<code>struct epitem</code>是一个红黑树节点。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210938.png" alt="image-20240409204207268"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span></span><br><span class="hljs-class">&#123;</span><br>      <span class="hljs-comment">//指向所属epoll对象</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span> <br>      <span class="hljs-comment">//注册的感兴趣的事件,也就是用户空间的epoll_event     </span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span> <br>      <span class="hljs-comment">//指向epoll对象中的就绪队列</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllink</span>;</span>  <br>      <span class="hljs-comment">//指向epoll中对应的红黑树节点</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rbn</span>;</span>     <br>      <span class="hljs-comment">//指向epitem所表示的socket-&gt;file结构以及对应的fd</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span>                  <br>  &#125;<br></code></pre></td></tr></table></figure><p>在内核中创建完表示<code>Socket连接</code>的数据结构<code>struct epitem</code>后，我们就需要在<code>Socket</code>中的等待队列上创建等待项<code>wait_queue_t</code>并且注册<code>epoll的回调函数ep_poll_callback</code>。</p><blockquote><p>通过<code>《阻塞IO中用户进程阻塞以及唤醒原理》</code>小节的铺垫，我想大家已经猜到这一步的意义所在了吧！当时在等待项<code>wait_queue_t</code>中注册的是<code>autoremove_wake_function</code>回调函数。而在这里注册的就是epoll的回调函数<code>ep_poll_callback</code></p><ul><li>之前如果当前socket就绪了，会根据wq中<code>autoremove_wake_function</code>激活private 也就是被阻塞的线程</li><li>现在是<code>ep_poll_callback</code>：找到当前当前socket的<code>epitem</code>，放入<code>epoll</code>中的就绪队列中。</li></ul></blockquote><p>如何找到epitem呢？<code>wait_queue_t</code>只有一个回调函数和一个null指针</p><blockquote><p><strong>为什么private为null</strong></p><p>因为这里<code>Socket</code>是交给<code>epoll</code>来管理的，阻塞在<code>Socket</code>上的进程是也由<code>epoll</code>来唤醒。在等待项<code>wait_queue_t</code>注册的<code>func</code>是<code>ep_poll_callback</code>而不是<code>autoremove_wake_function</code>，<code>阻塞进程</code>并不需要<code>autoremove_wake_function</code>来唤醒，所以这里设置<code>private</code>为<code>null</code></p></blockquote><blockquote><p><strong>如何找到epitem呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> &#123;</span> <br>   <span class="hljs-comment">//指向关联的epitem</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">base</span>;</span> <br><br>  <span class="hljs-comment">// 关联监听socket中等待队列中的等待项 (private = null  func = ep_poll_callback)</span><br>   <span class="hljs-type">wait_queue_t</span> wait;   <br><br>   <span class="hljs-comment">// 监听socket中等待队列头指针</span><br>   <span class="hljs-type">wait_queue_head_t</span> *whead; <br>    .........<br>  &#125;;<br></code></pre></td></tr></table></figure><p>引入一个eppoll_entry包裹住wait_queue_t，通过<code>container_of宏</code>找到<code>eppoll_entry</code>，继而找到<code>epitem</code>了。</p><p>（<code>container_of</code>在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个<strong>成员的首地址-偏移量</strong>进而获得整个结构体变量的首地址。）</p></blockquote><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210939.png" alt="image-20240409205353996"></p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a><strong>epoll_wait</strong></h3><p>用户程序调用<code>epoll_wait</code>后，内核首先会查找epoll中的就绪队列<code>eventpoll-&gt;rdllist</code>是否有<code>IO就绪</code>的<code>epitem</code>。<code>epitem</code>里封装了<code>socket</code>的信息。如果就绪队列中有就绪的<code>epitem</code>，就将<code>就绪的socket</code>信息封装到<code>epoll_event</code>返回。</p><p>如果<code>eventpoll-&gt;rdllist</code>就绪队列中没有<code>IO就绪</code>的<code>epitem</code>，则会创建等待项<code>wait_queue_t</code>，将用户进程的<code>fd</code>关联到<code>wait_queue_t-&gt;private</code>上，并在等待项<code>wait_queue_t-&gt;func</code>上注册回调函数<code>default_wake_function</code>。最后将等待项添加到<code>epoll</code>中的等待队列中。用户进程让出CPU，进入<code>阻塞状态</code>。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210940.png" alt="image-20240409211435167"></p><blockquote><p>这里和<code>阻塞IO模型</code>中的阻塞原理是一样的，只不过在<code>阻塞IO模型</code>中注册到等待项<code>wait_queue_t-&gt;func</code>上的是<code>autoremove_wake_function</code>，并将等待项添加到<code>socket</code>中的等待队列中。这里注册的是<code>default_wake_function</code>，将等待项添加到<code>epoll</code>中的等待队列上。</p></blockquote><p>至此，整个epoll变成了：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210941.png" alt="image-20240409211543969"></p><p>当网络数据包在软中断中经过内核协议栈的处理到达<code>socket</code>的接收缓冲区时，紧接着会调用socket的数据就绪回调指针<code>sk_data_ready</code>，回调函数为<code>sock_def_readable</code>。在<code>socket</code>的等待队列中找出等待项，其中等待项中注册的回调函数为<code>ep_poll_callback</code>。</p><p>在回调函数<code>ep_poll_callback</code>中，根据<code>struct eppoll_entry</code>中的<code>struct wait_queue_t wait</code>通过<code>container_of宏</code>找到<code>eppoll_entry</code>对象并通过它的<code>base</code>指针找到封装<code>socket</code>的数据结构<code>struct epitem</code>，并将它加入到<code>epoll</code>中的就绪队列<code>rdllist</code>中。</p><p>随后查看<code>epoll</code>中的等待队列中是否有等待项，也就是说查看是否有进程阻塞在<code>epoll_wait</code>上等待<code>IO就绪</code>的<code>socket</code>。如果没有等待项，则软<a href="https://www.zhihu.com/search?q=%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222535104311%22%7D">中断处理</a>完成</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p><code>sk_wq</code>是<code>sock</code>结构中的一个重要部分，表示的是socket等待队列。代表着有哪些对象（线程读、epoll_ctl）关注着当前的socket，当前socket可读或可写时，就要通知wq上的对象，通知的方法挂载时设置的回调函数</p><p><code>sk_wq</code>主要用于以下几种情形：</p><ul><li><strong>发送操作时的阻塞管理</strong>：当发送缓冲区不够用时，试图发送数据的进程将会被放入等待队列</li><li><strong>接收操作时的阻塞管理</strong>：当接收缓冲区没有数据时，试图读取数据的进程将会被放入等待队列</li><li><strong>异步IO和事件通知</strong>：<code>sk_wq</code>也与异步IO操作和某些类型的事件通知机制（如<code>epoll</code>）相关，使得应用程序能够有效地等待多个IO事件。</li></ul></li><li><p>在阻塞io中，如果数据没有就绪，创建<code>wait_queue_t</code>{当前线程、唤醒的回调}加入到<code>socket-&gt;sock-&gt;sk_wq</code>，在就绪时会调用回调唤醒该线程</p></li><li><p>在epoll中，创建了一个epoll同时对象管理多个socket，epoll对象也是文件，也包含<code>wq</code>，记录着所有<strong>epoll_wait</strong>等待的线程以及<code>default_wake_function</code>；</p></li><li><p>epoll对象使用红黑树管理全部socket，<code>rdllist</code>为就序列表，当添加一个socket时</p><ol><li>添加到红黑树中<code>epitem</code>节点</li><li>在<code>Socket</code>中的等待队列上创建等待项<code>wait_queue_t</code>并且注册<code>epoll的回调函数ep_poll_callback</code>, 这里之前代表着被阻塞的进程，就绪时需要去唤醒；现在代表着你就绪了来通知我epoll就行（把<code>epitem</code>加入到<code>rdllist</code>，同时检查epoll的<code>wq</code>，有就回调唤醒）</li></ol></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zhihu.com/question/486578358/answer/2535104311"><em>epoll</em> 原理是如何实现的？</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/364617329">存储基础 — 文件描述符 fd 究竟是什么？</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/399651675">Linux fd 系列 — socket fd 是什么？</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/393747291">深入理解 Linux 的 epoll 机制</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>操作系统</tag>
      
      <tag>文章精读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型介绍</title>
    <link href="/2024/04/14/TechDigest/IO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/04/14/TechDigest/IO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>文章主要介绍了I&#x2F;O（输入输出）模型及其实现方式，涵盖阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O（select&#x2F;poll&#x2F;epoll）、信号驱动I&#x2F;O和异步I&#x2F;O的基本概念与工作机制。    摘要内容如下：    I&#x2F;O（输入输出）模型包括磁盘I&#x2F;O和网络I&#x2F;O，其核心过程分为两步：应用程序向操作系统发起I&#x2F;O请求，等待数据就绪（如网卡数据到达内核缓冲区）；操作系统将数据从内核缓冲区拷贝到用户空间。I&#x2F;O模型分为同步和异步两类，同步要求调用者等待结果，而异步无需参与等待过程。    传统阻塞I&#x2F;O在数据未就绪时会挂起线程，导致单线程无法处理多文件描述符（FD），需多线程解决，但线程切换开销大。非阻塞I&#x2F;O通过轮询检查FD状态，减少了线程等待，但CPU空转开销高。    多路复用模型（select&#x2F;poll&#x2F;epoll）利用内核机制监控多个FD，由内核通知程序就绪状态，避免用户态轮询。select和poll仍有FD数量限制和拷贝开销，而epoll通过事件驱动和红黑树优化，解决了这些问题。信号驱动I&#x2F;O通过信号通知数据就绪，减少无效轮询。    异步I&#x2F;O则由内核完成数据准备与拷贝后通知应用，完全不阻塞调用线程。文章对比了各种机制的优缺点，并附代码示例说明实现流程。</p></blockquote><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>什么是IO？：输入输出模型，常见包含磁盘IO、网络IO</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>一次IO包含以下过程：</p><ol><li>应用程序向操作系统发起IO请求，等待数据就绪（等待到网卡&amp;网卡到达内核缓冲区）</li><li>操作系统拷贝内核数据到用户缓冲区</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141018257.png" alt="image-20240414090911822"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314153236150.png" alt="img"></p><p>同步和异步关注的是消息通信机制.</p><ul><li>同步：就是在发出一个调用时，自己需要参与等待结果的过程,则为同步,前面四个 IO 都自己参与了,所以也称为同步 IO.</li><li>异步：则指出发出调用以后,到数据准备完成,自己都未参与,则为异步 IO。</li></ul><h2 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="1.阻塞IO"></a>1.阻塞IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">listenfd = socket();   <span class="hljs-comment">// 打开一个网络通信套接字</span><br>bind(listenfd);        <span class="hljs-comment">// 绑定</span><br>listen(listenfd);      <span class="hljs-comment">// 监听</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  buf = new buf[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 读取数据容器</span><br>  connfd = accept(listenfd);  <span class="hljs-comment">// 阻塞 等待建立连接</span><br>  <span class="hljs-type">int</span> n = read(connfd, buf);  <span class="hljs-comment">// 阻塞 读数据</span><br>  doSomeThing(buf);  <span class="hljs-comment">// 处理数据</span><br>  close(connfd);     <span class="hljs-comment">// 关闭连接</span><br>&#125;<br></code></pre></td></tr></table></figure><p>流程如下：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141014720.png" alt="image-20240414091402977"></p><ol><li>第一阶段如果阻塞了，当前线程会进入睡眠状态，直到数据就绪后唤醒</li><li>没有cpu空转，但一个线程只能处理一个fd</li></ol><p>缺点：单一线程无法同时处理多个FD，如果需要处理多个FD需要开启多个线程，线程消耗比较大，线程切换开销也大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-keyword">for</span> each 句柄数组 &#123;<br>        read/write(fd, <span class="hljs-comment">/* 参数 */</span>) <span class="hljs-comment">// 如果由一个卡住  其他的就绪也不能执行</span><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="2.非阻塞IO"></a>2.非阻塞IO</h2><p>提供一个read函数，在数据未就绪时返回-1，因此可以通过轮询来处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">arr = new Arr[];<br>listenfd = socket();   <span class="hljs-comment">// 打开一个网络通信套接字</span><br>bind(listenfd);        <span class="hljs-comment">// 绑定</span><br>listen(listenfd);      <span class="hljs-comment">// 监听</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  connfd = accept(listenfd);  <span class="hljs-comment">// 阻塞 等待建立连接</span><br>  arr.add(connfd);<br>&#125;<br><br><span class="hljs-comment">// 异步线程检测 连接是否可读</span><br>new Tread()&#123;<br>  <span class="hljs-keyword">for</span>(connfd : arr)&#123;<br>    buf = new buf[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 读取数据容器</span><br>    <span class="hljs-comment">// 非阻塞 read 最重要的是提供了我们在一个线程内管理多个文件描述符的能力</span><br>    <span class="hljs-type">int</span> n = read(connfd, buf);  <span class="hljs-comment">// 检测 connfd 是否可读</span><br>    <span class="hljs-keyword">if</span>(n != <span class="hljs-number">-1</span>)&#123;<br>       newThreadDeal(buf);   <span class="hljs-comment">// 创建新线程处理</span><br>       close(connfd);        <span class="hljs-comment">// 关闭连接 </span><br>       arr.remove(connfd);   <span class="hljs-comment">// 移除已处理的连接</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>newTheadDeal(buf)&#123;<br>  doSomeThing(buf);  <span class="hljs-comment">// 处理数据</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>非阻塞IO不会等待数据到达内核的这个阶段，<strong>提供了我们在一个线程内管理多个FD的能力</strong></li><li><strong>for轮询会消耗大量的CPU</strong>，read进行系统调用也十分消耗资源</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141014440.png" alt="image-20240414091804160"></p><h2 id="多路IO复用"><a href="#多路IO复用" class="headerlink" title="多路IO复用"></a><strong>多路IO复用</strong></h2><p> 1 个线程处理 多个 fd 的模式，并且避免无效的工作，<strong>要把所有的时间都用在处理句柄的 IO 上，不能有任何空转，sleep 的时间浪费。</strong> </p><p><strong>如何实现？</strong>：  依靠内核，把想要处理的fd告诉内核，然后线程就休眠，之后只要有一个fd就绪，线程就被唤醒处理</p><h2 id="3-select"><a href="#3-select" class="headerlink" title="3.select"></a>3.select</h2><p>select 是操作系统提供的系统函数，通过它我们可以将文件描述符发送给系统，让<strong>系统内核帮我们遍历检测是否可读</strong>，并告诉我们进行读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">arr = new Arr[];<br>listenfd = socket();   <span class="hljs-comment">// 打开一个网络通信套接字</span><br>bind(listenfd);        <span class="hljs-comment">// 绑定</span><br>listen(listenfd);      <span class="hljs-comment">// 监听</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  connfd = accept(listenfd);  <span class="hljs-comment">// 阻塞 等待建立连接</span><br>  arr.add(connfd);<br>&#125;<br><br><span class="hljs-comment">// 异步线程检测 通过 select 判断是否有连接可读</span><br>new Tread()&#123;<br>  <span class="hljs-keyword">while</span>(select(arr) &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">for</span>(connfd : arr)&#123;<br>      <span class="hljs-keyword">if</span>(connfd can read)&#123;<br>        <span class="hljs-comment">// 如果套接字可读 创建新线程处理</span><br>        newTheadDeal(connfd);<br>        arr.remove(connfd);   <span class="hljs-comment">// 移除已处理的连接</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>newTheadDeal(connfd)&#123;<br>    buf = new buf[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 读取数据容器</span><br>    <span class="hljs-type">int</span> n = read(connfd, buf);  <span class="hljs-comment">// 阻塞读取数据</span><br>    doSomeThing(buf);  <span class="hljs-comment">// 处理数据</span><br>    close(connfd);        <span class="hljs-comment">// 关闭连接 </span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141015031.png" alt="image-20240414092920920"></p><p><strong>优点：</strong></p><ol><li>同时给操作系统多个fd，然后自己阻塞休眠，由操作系统负责检查是否可读，并通知唤醒我们</li></ol><p><strong>缺点：</strong></p><ol><li>fd_set需要拷贝两次，用户-&gt;内核-&gt;用户</li><li>内核检测文件描述符可读还是通过遍历实现，当文件描述符数组很长时，遍历操作耗时也很长。</li><li>内核检测完文件描述符数组后，当存在可读的文件描述符数组时，用户态需要再遍历检测一遍。</li><li>最多1024个</li></ol><h2 id="4-poll"><a href="#4-poll" class="headerlink" title="4.poll"></a><strong>4.poll</strong></h2><p>去掉了最大 1024 个文件描述符的限制</p><ol><li>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。</li><li>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</li></ol><h2 id="5-epoll"><a href="#5-epoll" class="headerlink" title="5.epoll"></a>5.epoll</h2><blockquote><p>1.每次调用需要在用户态和内核态之间拷贝文件描述符数组，但高并发场景下这个拷贝的消耗是很大的。<br>方案：内核中保存一份文件描述符，无需用户每次传入，而是仅同步修改部分。</p><p>2.内核检测文件描述符可读还是通过遍历实现，当文件描述符数组很长时，遍历操作耗时也很长。<br>方案：通过事件唤醒机制唤醒替代遍历。</p><p>3.内核检测完文件描述符数组后，当存在可读的文件描述符数组时，用户态需要再遍历检测一遍。<br>方案：仅将可读部分文件描述符同步给用户态，不需要用户态再次遍历。</p></blockquote><h3 id="epoll-create："><a href="#epoll-create：" class="headerlink" title="epoll_create："></a><strong>epoll_create：</strong></h3><p>用于创建 epoll 文件描述符，该文件描述符用于后续的 epoll 操作，参数 size 目前还没有实际用处，我们只要填一个大于 0 的数就行。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141015207.png" alt="image-20240414100233473"></p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl:"></a><strong>epoll_ctl:</strong></h3><p>epoll_ctl 函数用于增加，删除，修改 epoll 事件，epoll 事件会存储于内核 epoll 结构体红黑树中.</p><p>会注册fd的就绪回调函数为<code>ep_poll_callback</code>，就绪时添加到<code>rdllist</code>，并唤醒<code>wq</code>中等待的线程</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141019114.png" alt="image-20240414100247696"></p><h3 id="epoll-wait-："><a href="#epoll-wait-：" class="headerlink" title="epoll_wait ："></a><strong>epoll_wait ：</strong></h3><p>epoll_wait 用于监听套接字事件，可以通过设置超时时间 timeout 来控制监听的行为为阻塞模式还是超时模式。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404092210940.png" alt="img"></p><p>详细的原理实现可以看另一篇文章：从FD到socketFD再到epoll原理</p><h2 id="信号驱动-IO"><a href="#信号驱动-IO" class="headerlink" title="信号驱动 IO:"></a><strong>信号驱动 IO:</strong></h2><p>多路转接解决了一个线程可以监控多个 fd 的问题，但是 select 采用无脑的轮询就显得有点暴力，因为大部分情况下的轮询都是无效的，所以有人就想，别让我总去问数据是否准备就绪，而是等你准备就绪后主动通知我,这边是信号驱动 IO。</p><p>信号驱动 IO 是在调用 sigaction 时候建立一个 SIGIO 的信号联系，当内核准备好数据之后再通过 SIGIO 信号通知线程,此 fd 准备就绪，当线程收到可读信号后，此时再向内核发起 recvfrom 读取数据的请求，因为信号驱动 IO 的模型下,应用线程在发出信号监控后即可返回，不会阻塞，所以一个应用线程也可以同时监控多个 fd。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141012304.png"></p><h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a><strong>异步 IO</strong></h2><p>应用只需要向内核发送一个读取请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种模式为异步 IO 模型。</p><p>异步 IO 的优化思路是解决应用程序需要先后发送询问请求、接收数据请求两个阶段的模式，在异步 IO 的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404141012805.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断原理</title>
    <link href="/2024/04/12/TechDigest/linux%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/12/TechDigest/linux%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>中断是操作系统中关键机制，允许处理器暂停当前任务，转而执行另一特定程序，处理完成后恢复原任务。中断解决了顺序执行的局限性，使系统能够响应外部事件（如键盘输入）并支持多任务并发。它分为硬件中断和软件中断两类。  <strong>硬件中断</strong>包括外部设备触发的异步中断（如I&#x2F;O事件）和CPU内部同步产生的异常（如缺页或非法指令）。CPU通过可编程中断控制器管理外部中断，其中控制器的IRQ引脚与中断号关联，设备触发时通知CPU读取中断号。异常则由CPU直接生成或通过指令（如INT n）主动触发（如系统调用）。  中断处理依赖<strong>中断描述符表（IDT）</strong>，其中存储中断号对应的处理函数地址。操作系统初始化时填充IDT（如设置缺页、系统调用等入口），CPU通过IDTR寄存器定位IDT，检测到中断后保存现场、跳转到处理函数，最后恢复现场继续原任务。  <strong>软件中断</strong>由内核守护进程（如ksoftirqd）轮询内存中的中断标志位触发，通过软中断向量表调用对应函数，常用于网络接收等延迟敏感场景。例如，网卡通过硬中断通知数据到达后，由软中断实际处理数据包，避免长时间占用CPU。  总结：   1. <strong>触发</strong>：硬中断通过物理信号或指令，软中断通过内存标志位。   2. <strong>响应</strong>：硬中断立即处理，软中断由内核线程轮询执行。   3. <strong>应用</strong>：硬中断处理紧急事件，软中断实现复杂任务分解（如网络协议栈）。  该机制平衡了实时性与效率，是操作系统多任务和外部响应的核心基础。</p></blockquote><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>什么是中断？ 为什么需要中断？</p><p>中断是操作系统中一种重要的机制，可以让处理器中断当前的执行程序，转向另外一个特定的程序，并在处理完成后返回当前执行程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-built_in">dosomething</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有中断，处理器只能完全处理完一个任务后，才能处理下一个任务，无法实现任务切换和多任务并发(我如果键盘按下一个按钮，系统可能很久后才能反应)</p><p>中断根据实现的方式可以分为硬中断和软中断，注意是os实现的方式，而不是触发的方式</p><ul><li>硬中断<ul><li>异常  （<strong>同步</strong>事件，执行指令过程中）<ul><li>故障 faults  缺页</li><li>陷阱 traps   <code>INT n</code>  </li><li>中止 abort</li></ul></li><li>中断    （<strong>异步</strong>事件，io设备 敲击键盘）</li></ul></li><li>软中断 执行复杂逻辑</li></ul><h3 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h3><p>具体来说是如何中断的执行包含两部分：</p><ol><li>如何让cpu知道中断了呢？并且是哪个中断？也就是如何让cpu知道中断号</li><li>中断号和中断处理函数的对应关系如何知道</li></ol><h4 id="告知中断"><a href="#告知中断" class="headerlink" title="告知中断"></a>告知中断</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>在硬中断的中断中，cpu通过<strong>可编程中断控制器</strong>来管理中断</p><ul><li>控制器提前设置好了<strong>IRQ引脚和中断号</strong>的对应关系，IRQ引脚连接外部设备</li><li>当外部设备触发中断时，中断控制器将<strong>对应中断号</strong>保存到端口上，并给CPU的INTR引脚一个信号（有中断来咯快来读取）。</li><li>CPU在执行完当前指令后发现INTR有信号，说明产生了中断，就去端口读取中断号</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121729555.png" alt="image-20240412172932052"></p><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><ul><li><strong>faults</strong> ：在faults场景中，就更简单了，cpu当前就在执行指令，如果检测到了一些异常，直接自己给自己一个中断号就好了（异常对应的中断号是提前写死的）</li><li><strong>traps</strong> ：CPU在指令中给自己一个中断号 <code>INT n</code>  , <code>INT 0x80</code> 执行系统调用（执行前会设置系统调用号）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">mov eax, <span class="hljs-number">3</span>      ; 系统调用号，<span class="hljs-number">3</span>是read的调用号<br>mov ebx, <span class="hljs-number">0</span>      ; 第一个参数，文件描述符<br>mov ecx, buffer ; 第二个参数，缓冲区地址<br>mov edx, <span class="hljs-number">128</span>    ; 第三个参数，读取的字节数<br><span class="hljs-type">int</span> <span class="hljs-number">0x80</span>        ; 执行系统调用  在x86<span class="hljs-number">-64</span> 中等价于syscall <br></code></pre></td></tr></table></figure><h4 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h4><p>在知道了中断号后，如何去响应并处理中断呢，其实就是一个<strong>中断向量表</strong>管理这个对应关系</p><p>实际上就是一个数组：<strong>中断描述符表</strong><code>IDT</code>，主要就包含<strong>处理函数地址</strong>以及中断函数类型（中断门（禁止中断嵌套）、陷阱门）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// IDT条目的结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">idt_entry</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> offset_low;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> selector;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> zero;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> type_attr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> offset_high;<br>&#125; __attribute__((packed));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">idt_entry</span> <span class="hljs-title">idt</span>[256];</span><br></code></pre></td></tr></table></figure><p>中断描述符表在哪CPU如何知道：IDTR寄存器保存该地址</p><h4 id="IDT谁负责写？"><a href="#IDT谁负责写？" class="headerlink" title="IDT谁负责写？"></a>IDT谁负责写？</h4><p>也就是初始化工作谁做的，操作系统！  <code>traps.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化异常处理函数</span><br><span class="hljs-type">void</span> __init <span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    set_idt_entry(<span class="hljs-number">0</span>, divide_error);    <span class="hljs-comment">// 除法错误</span><br>    set_idt_entry(<span class="hljs-number">6</span>, invalid_op)      <span class="hljs-comment">// 非法操作码</span><br>    set_idt_entry(<span class="hljs-number">14</span>, page_fault);     <span class="hljs-comment">// 页面错误</span><br>    <br>    set_idt_entry(<span class="hljs-number">0x80</span>, system_call, .., ..);     <span class="hljs-comment">// 系统调用</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h4><ol><li>push保存当前现场：EFLAGS、CS IP等</li><li>CS IP设置为IDT对应的处理函数地址，实现跳转</li><li>开始执行中断处理函数</li><li>pop恢复现场</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>如何触发中断？<ol><li>外部设备INTR引脚触发</li><li>CPU执行过程中触发</li><li><code>INT n</code>强制触发（包括系统调用）</li></ol></li><li>如何找到中断处理函数：一个数组，保存函数入口，加载时初始化</li><li>找到入口后，保存状态跳转执行，执行完成后pop状态</li></ol><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>前面的都是硬中断，当CPU发现中断时，就会立即执行中断向量表中的处理函数（硬件实现）；</p><p><strong>软中断</strong>（Linux-0.11中并没有实现），纯粹由<strong>软件</strong>实现的一种类似中断的机制，模仿硬件，在内存中某个地方存储中断标志为，然后由内核中一个<strong>守护进程</strong>不断轮询标志，存在中断就查询软中断向量数组并执行</p><p>软中断可以配和硬中断一起实现复杂需求</p><ul><li><p>宏观上：CPU不再执行当前程序，转向另外的程序</p></li><li><p>微观上：CPU每次执行完指令，都去检测一下内存标记是否有中断的发生</p></li><li><p><code>ksoftirqd</code>负责轮询并执行中断，在操作系统启动时创建并开始执行<code>kernel/smpboot.c</code></p></li><li><p>标志位为1代表触发中断，执行<code>softirq_vec[i]</code>中对应的函数</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __softirq_entry __do_softirq(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> *<span class="hljs-title">h</span> =</span> softirq_vec;<br><br>    <span class="hljs-keyword">while</span> ((softirq_bit = ffs(pending))) &#123; <span class="hljs-comment">// 找到最右边的1的位置</span><br>        h += softirq_bit - <span class="hljs-number">1</span>;<br>        h-&gt;action(h); <span class="hljs-comment">// 执行中断处理程序</span><br>        h++;<br>        pending &gt;&gt;= softirq_bit;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>softirq_vec</code>在初始化时被设置，例如想要网络收发，就需要注册网络的中断处理函数 <code>net_dev_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// file: kernel/softirg</span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">open_softirg</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirg_action *))</span><br> &#123;<br>     softirq_vec[nr].action = action;<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121647174.png" alt="image-20240412164734608"></p><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><ul><li>⽹卡收到数据以后，以DMA的⽅式把⽹卡收到的帧写到内存⾥，再向CPU发起⼀ 个中断，以通知CPU有数据到达。</li><li>当CPU收到中断请求后，会去调⽤⽹络设备驱动注册 的中断处理函数。⽹卡的中断处理函数并 不做过多⼯作（查数据包完整性），发出软中断请求，然后尽快释 放CPU资源。</li><li>ksoftirad内核线程检测到有软中断请求到达，调⽤poll开始轮询收包，收到后交由各级协议栈处理。对于TCP包来说，会被放到⽤户socker的接收队列中。</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121642365.png" alt="image-20240412164216556"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>硬中断是通过给CPU物理引脚施加电压变化实现的，而软中断是通过给内存中的⼀个变量赋予⼆进制值以标记有软中断发⽣。</li><li>硬中断表：<code>IDT</code>，软中断表：<code>softirq_vec</code></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/80371745">Linux的中断处理机制</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>深入理解Linux网络<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Linux源码趣读<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见加密算法</title>
    <link href="/2024/04/08/TechDigest/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2024/04/08/TechDigest/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>文章摘要：  本文系统介绍了非可逆加密与可逆加密两大加密体系的原理及应用。非可逆加密部分重点解析了MD5和SHA系列哈希算法，包括MD5的128位哈希值生成过程及其已被攻破的安全缺陷，以及SHA-1、SHA-2、SHA-3算法的演进。这类算法通过生成数字指纹应用于密码存储（配合盐值防御彩虹表攻击）、文件完整性校验和秒传功能。同时阐述了HMAC通过密钥增强哈希值的安全性，在SSL&#x2F;TLS和JWT等场景实现防篡改。  可逆加密部分涵盖对称与非对称加密：从古典的凯撒密码、enigma机到现代AES对称算法，详细描述了enigma机的转子工作原理及同盟国破解方法；重点剖析RSA非对称算法的模数生成流程，以及DH密钥交换的前向安全问题。文章通过HTTPS握手案例，说明如何结合非对称加密建立安全通道（ECDHE算法实现密钥协商）和对称加密传输数据，并指出CA证书体系在公钥可信分发中的关键作用。最后对比了密码学攻击手段，包括对MD5的碰撞攻击和针对弱密码的暴力破解防御策略。全文通过技术原理与实战案例的结合，展现了现代加密技术在数据安全保障中的系统应用。</p></blockquote><blockquote><p><strong>GPT摘要</strong></p><p>文章主要介绍了非可逆加密算法和可逆加密算法的原理和应用。在非可逆加密算法部分，介绍了MD5和SHA系列算法，以及它们在密码保存、文件完整性校验等方面的应用。同时提到了MAC和HMAC-SHA-256在确认消息完整性和身份认证中的作用。在可逆加密算法部分，介绍了凯撒密码和enigma机的原理，以及对称加密算法AES和非对称加密算法RSA的基本原理和应用场景。文章还简要讨论了密码攻击方法和SSL&#x2F;TLS中非对称加密的应用。</p></blockquote><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>非可逆加密（hash function）：密码保存、文件<strong>完整性</strong>正确性校验、文件秒上传<ul><li>hash</li><li>md5（Message Digest Algorithm 5） 128bit</li><li>SHA（Secure Hash Algorithm）</li></ul></li><li>可逆加密<ul><li>对称加密<ul><li>DES (Data Encryption Standard) 不安全</li><li>AES (Advanced Encryption Standard)</li></ul></li><li>非对称加密<ul><li>RSA（Rivest-Shamir-Adleman）</li></ul></li></ul></li></ul><p>可逆加密是从传统意义上的加密，而非可逆加密通常用于签名</p><h2 id="非可逆加密算法"><a href="#非可逆加密算法" class="headerlink" title="非可逆加密算法"></a>非可逆加密算法</h2><ul><li><p>并不是真正意义上的加密，通常被称作hash算法（加密）或者摘要digest算法</p><ul><li><strong>非加密哈希函数</strong>：用于散列（Hash）数据，速度快；hash表、长链转短链：<code>MurmurHash</code></li><li><strong>加密哈希函数</strong>：并具有一些特性，如<strong>抗碰撞性</strong>（即难以找到两个不同的输入，它们的哈希值相同）、困难性（难以计算出满足特定条件的输入，例如找到一个特定哈希值的输入），以及提供杂凑（Hash）的伪随机性。</li></ul></li><li><p>主要用一个较短的字符串（<strong>数字指纹</strong>）代表原来的信息，<strong>不可逆</strong></p></li></ul><p>密码保存、文件<strong>完整性</strong>正确性校验、文件秒上传（该文件MD5存在，说明大概率上传过）</p><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>将任意长度消息  转为  32个16进制数（16B），4个幻数  （信息是减少的，不可逆）</p><ol><li><p>补齐到512bit（64B）整数，并且最后64位存放原始长度</p></li><li><p>每512bit为一个块，再拆分成4B一小块（16块）<code>X[i]</code>，更新幻数64次；更新函数每次更新第一个数</p></li><li><p>重复N轮512bit，最后4个幻数就是结果 </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141875.png" alt="image-20240227194554575"></p></li></ol><h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><ol><li>原像攻击：给出一个MD5，如何得到生成该MD5的消息</li><li>第二原像攻击：给出消息，如何得到生成MD5相同的消息</li><li>扛碰撞性：找出两个MD相同的消息<ul><li>王小云2004年已经被打破，消息内容是乱码</li><li>MarcStevens：<ul><li>相同前缀碰撞：从内容 生成两个内容不同但MD5相同的数据（前缀保留图片或程序但后缀不同）；</li><li>选择前缀碰撞：前缀不一样（一个正常程序一个死循环）然后构造后缀使得MD5相同</li></ul></li><li>至此签名<strong>并不安全</strong>：攻击者可以创造出两个内容不同但签名相同的支票；文件校验从用户端是正常的，但如果用MD5检测软件，会导致正常版本通过检测，然后替换异常版本上架软件商店</li></ul></li></ol><h3 id="SHA系列："><a href="#SHA系列：" class="headerlink" title="SHA系列："></a><strong>SHA系列</strong>：</h3><ul><li><strong>SHA-1</strong>：产生160位的哈希值，比MD5更安全，但它也已被发现有安全弱点。</li><li><strong>SHA-2</strong>：包含多个版本（如SHA-224, SHA-256, SHA-384, 和SHA-512），相比于SHA-1提供了更高的安全性。</li><li><strong>SHA-3</strong>：最新的SHA版本，使用不同的哈希算法（Keccak），提供了与SHA-2不同的安全性和效率。</li></ul><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>message authentication code：确认完整性并进行身份认证，密钥+hash</p><p>HMAC：Hash-based</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141879.png" alt="image-20240408212345680"></p><ul><li>非可逆加密可以验证文件的完整性，例如从官网下载文件，但前提是官网提供了正确文件的md5</li><li>a、b之间通信，如果a发送的消息被替换了，单纯使用hash b并不知道消息是否被替换，因为hash也能同时被替换</li><li>如果ab之间提前约定了一个密钥，基于该密钥生成HMAC，别人就无法生成替换后的hash值，这就实现了签名。因此想要实现数据不被篡改，需要提前约定一个密钥</li><li>在ssl&#x2F;tls握手时，CA就会用私钥对内容进行签名，用户用公钥解密并对比来查看内容是否被篡改</li><li>https中，除了生成一个密钥用于加密通信以外，还可以生成一个密钥用于生成HMAC确认消息防止被篡改（其实就算被篡改了，由于中间人不知道加密密钥，篡改的内容也是无意义的）</li></ul><h3 id="HMAC-SHA-256"><a href="#HMAC-SHA-256" class="headerlink" title="HMAC-SHA-256"></a>HMAC-SHA-256</h3><p>JWT中用的，hash(密钥1+hash(密钥2+消息))</p><p>密钥只有服务器知道，因此只有服务器能够生成 token，并验证token是否有效</p><h3 id="密码攻击"><a href="#密码攻击" class="headerlink" title="密码攻击"></a>密码攻击</h3><p>黑客知道盐s，hash值，算法f(p,s) &#x3D; hash，但不知道原密码p<br>他的目的是通过hash值，盐s和算法f，求得密码p，使f(p,s) &#x3D; hash</p><p>暴力破解：也就是原像攻击，暴力找原密码，不可能</p><ul><li>方法一：遍历原文为 12345678，meiyoumuma，iloveyou这样的常见密码字典，使用盐和密码作为参数调用算法得到 hash，在数据库中查找 hash 相同的用户，那么他的密码就被知道了。但是如果每个用户盐值不一样，就需要每个用户生成一个字典去攻击，该方法失效</li><li>查表攻击（空间大）：事先计算出所有<strong>常见密码</strong>字典(<strong>明文</strong>)的<code>hash</code>结果(<strong>密文</strong>)，然后将其存入数据库中，通过建立<strong>索引</strong>等方式，当我们拿到一个<strong>密文</strong>(<code>hash</code>)时，我们去数据库通过索引将其快速查出对应的<strong>明文</strong>，如果数据库中不存在，则破解失败。加盐后简单密码就变成了123456+salt复杂密码，不在常见密码中，失效；</li><li>彩虹表：<a href="https://zhuanlan.zhihu.com/p/105578739">彩虹表 rainbow-tables - 知乎 (zhihu.com)</a></li></ul><p><strong>实践</strong>：强hash函数（SHA-256） + 盐 + 循环hash</p><p>现在主流密码处理方式的算法是PBKDF2，流程简述起来是随机生成一个高熵（意思是真的随机而且复杂）Salt，把你的密码和这个Salt连接在一起当作一个整体做一次哈希运算，哈希算法为安全的SHA-256，可以避免哈希碰撞，得到的这个哈希值和你的密码连接在一起再做一次哈希运算，以此类推，重复非常多次，次数越多越安全，但是服务器负担也就越重，一般在10万次以上。最后服务器存储Salt和最后一次得出的哈希值，这样服务器不知道你的密码，但是可以验证你输入的密码是否正确，即使被拖库也不用担心密码被暴力破解，因为随机Salt的引入让彩虹表攻击失效，单独针对你的密码暴力破解要付出遍历密码空间（比如说4位纯数字密码的密码空间是10000，指所有可能的密码组合的个数）所需时间的10万倍以上，比普通的算法要安全许多。在安全性更高的服务器上甚至还会结合硬件密钥来进一步增强安全性，那就是在以上的基础上得出的最后一次哈希值再和硬件密钥作为PBKDF2算法的输入，最终只存储Salt和结合了硬件密钥的最终哈希值，这样子就不给一点暴力攻击的机会了，因为硬件密钥永远不会脱离安全硬件，把相应的硬件断电就一点办法也没有了</p><h2 id="可逆加密算法"><a href="#可逆加密算法" class="headerlink" title="可逆加密算法"></a>可逆加密算法</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><h4 id="移位替换"><a href="#移位替换" class="headerlink" title="移位替换"></a>移位替换</h4><p>公元前1世纪，移位替换<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141880.png" alt="image-20240408104931318"></p><h4 id="随机替换"><a href="#随机替换" class="headerlink" title="随机替换"></a>随机替换</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141881.png" alt="image-20240408105059470"></p><p>用统计的方法就可以破解，出现最多的e倍替换成了l</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141882.png" alt="image-20240408105137344"></p><h4 id="多替换表"><a href="#多替换表" class="headerlink" title="多替换表"></a>多替换表</h4><p>增加字母替换表，轮换使用替换表进行加密，加密表越多，统计特征慢慢消失</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141884.png" alt="image-20240408105310020"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141885.png" alt="image-20240408113434326"></p><p>麻烦，enigma就是自动实现了字母表的替换</p><h3 id="enigma"><a href="#enigma" class="headerlink" title="enigma"></a>enigma</h3><p>1926年开始，德国升级了加密系统，enigma机</p><ul><li><strong>字母替换</strong>的加密方法，输入o，输出c；再次输入时，输出会不同</li><li>解密时直接输入密码可以得到原文，也就是自反的</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141886.png" alt="image-20240408104801371"></p><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><ul><li><p>一个转子相当于一个替换表，内部的接线是出厂固定的，但是按下后会转动转动，转动后替换表变了 <code>26*26*26</code>个</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141887.png" alt="image-20240408112159790"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141888.png" alt="image-20240408112219190"></p></li><li><p>反射板将信号反射回去（两两连接），使得型号可以<strong>自反</strong> + <strong>排己</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141889.png" alt="image-20240408111708118"></p></li><li><p>解密时转轮的初始位置需要一样，这个相当于是密钥（德军每天更新），也就是破解必须要<strong>密钥+同一批次机器</strong></p></li><li><p>最后是接线板，可以实现交换两个字母 如果12对  有一千多亿种</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141890.png" alt="image-20240408112439109"></p></li></ul><h4 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h4><p><strong>密钥+同一批次机器+接线板</strong>  机器可以被缴获，密钥每天都更新</p><p>德军加密方法：随机密钥SCA，统一密钥DAB</p><ul><li>先用统一密钥加密随机密钥两次，放到开头，再用随机密钥加密内容</li><li>解密时用统一密钥解密开头，获取随机密钥，再用随机密钥解密内容</li></ul><p>大量的内容都是用不同的密钥加密的（减少重复），少量的无意义信息是用统一密钥加密的</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141891.png" alt="image-20240408113818917"></p><p>前六个字符是破译的关键！重复输入的<strong>随机密钥相当于漏洞</strong></p><h5 id="破解初始密钥"><a href="#破解初始密钥" class="headerlink" title="破解初始密钥"></a>破解初始密钥</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141892.png" alt="image-20240408140327786"></p><p>又因为自反性，D(A(F)) &#x3D; G  把DA（EB、FG）看成一个整体函数 ，使得F-&gt;G</p><p>当天的密文有很多，可以把3个函数的26个字母的映射关系都列出</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141893.png" alt="image-20240408140625913"></p><ol><li>这些映射存在环</li><li>环的数量集合就是一个**特征(指纹)**，代表着转子的初始位子</li><li>特征集合很少重复，如果构造了特征目录，就可以得到转子的初始位置</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141894.png" alt="image-20240408140914606"></p><h5 id="构造目录表"><a href="#构造目录表" class="headerlink" title="构造目录表"></a>构造目录表</h5><p>一对函数的映射存在环，一次循环的数量2x代表一对环特征x,x</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141895.png" alt="image-20240408141100019"></p><p><strong>循环测定仪</strong></p><p>现在想构建AAA的特征</p><ol><li>设置AAA，另一个设置为AAD（相差3）  用于输出DA函数的特征<ul><li>随便从一个开始</li><li>循环后结束，点亮的数量2x就是当前两个环的数量和，也就是特征为x,x</li><li>电亮没有亮过的开关，又得到一组特征y, y  循环执行</li></ul></li><li>设置AAB，另一个设置为AAE   用于输出EB函数特征</li><li>设置AAC，另一个设置为AAF   用于输出FC函数特征</li><li>结合三个特征，组合成AAA转子的特征</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141896.png" alt="image-20240408141257098"></p><h5 id="目录表数量"><a href="#目录表数量" class="headerlink" title="目录表数量"></a>目录表数量</h5><ul><li>三个随机排列：<code>26*26*26  *  A33</code>  大概10w，构造需要1年</li><li>五个随机选择3个：10年！</li><li>要用机器打败机器，Bomba！</li></ul><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><ul><li>基于 crib（一些常用特殊的词汇，例如每天早上的天气预报、生日快乐、甚至是故意的陷阱）</li><li>bombe machine</li><li><a href="https://www.bilibili.com/video/BV1PL4y1H77Z">https://www.bilibili.com/video/BV1PL4y1H77Z</a></li></ul><h3 id="对称加密AES"><a href="#对称加密AES" class="headerlink" title="对称加密AES"></a>对称加密AES</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141897.png" alt="image-20240408204133847"></p><ul><li><p>对称加密用一个相同的密钥进行加密解密，适合1对1的加密方式，但浏览器和服务器之间不能单纯使用同一个密钥，否者大家都一样用户之间相当于没有加密。（握手后随机生成一个传输也不行，因为会被中间人窃取）</p></li><li><p>因此<strong>双方确定密钥</strong>过程是关键</p></li><li><p><strong>预先共享密钥</strong>：面对面交换、安全信封或安全通信渠道</p></li><li><p><strong>密钥分发中心（Key Distribution Center，KDC）</strong>：KDC是一个可信的第三方实体，负责生成和分发密钥。发送方和接收方可以向KDC请求密钥，KDC会安全地将密钥发送给它们。这种方法需要发送方和接收方信任KDC的安全性。</p></li><li><p><strong>通过公钥密码体系配送共享密钥</strong>  https</p></li><li><p><strong>Diffie-Hellman密钥交换协议</strong>  详情见ECDHE中</p></li></ul><h3 id="非对称加密RSA"><a href="#非对称加密RSA" class="headerlink" title="非对称加密RSA"></a>非对称加密RSA</h3><ul><li>公钥加密只能私钥解密</li><li>私钥加密只能公钥解密</li><li><strong>计算复杂度高</strong></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141898.png" alt="image-20240408160753423"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404082141900.png" alt="image-20240408161058177"></p><ol><li><strong>选择两个大质数p和q</strong>：这两个质数需要足够大，以确保其乘积n的位数可以满足安全需求。通常，p和q的位数应该在100位以上。</li><li>**计算n和φ(n)**：n是p和q的乘积，φ(n)是n的欧拉函数，对于n&#x3D;pq，φ(n)&#x3D;(p-1)(q-1)。</li><li><strong>选择公钥e</strong>：e需要满足1 &lt; e &lt; φ(n)，且e和φ(n)互质。通常，e可以选择为65537（这是一个常用的公钥，因为它有很好的性质，如二进制表示中只有两个1，计算效率高）。</li><li><strong>计算私钥d</strong>：d是e关于φ(n)的模逆元，即满足ed ≡ 1 (mod φ(n))。这个可以通过扩展欧几里得算法来计算。</li><li><strong>输出公钥和私钥</strong>：公钥是(n, e)，私钥是(n, d)。</li></ol><p>n的因数分解（即找出p和q）是一个已知的困难问题，这就是所谓的”大数因数分解问题”，保证RSA的安全性</p><h3 id="ssl-tls"><a href="#ssl-tls" class="headerlink" title="ssl&#x2F;tls"></a>ssl&#x2F;tls</h3><p>有了非对称加密，就可以使得浏览器和服务器终极那的通信安全。非对称+对称加密</p><ul><li>服务器发公钥给浏览器，浏览器随机数（传输密钥）加密后传给服务器，服务器再私钥解密得到 传输密钥（<code>非对称+对称加密</code>  、如果只非对称加密，服务器的数据会被窃取）</li><li>问题：如果中间人用窃取公钥并拦截，并生成自己的公钥发给浏览器，作为中间商，就会出问题</li><li>如何确定浏览器收到的公钥是服务器给的：（域名、第三方机构、服务器公钥）给CA，CA添加数字签名（内容-&gt;hash-&gt;私钥加密）后给浏览器。浏览器解密（CA的公钥浏览器中保存了，浏览器信任的CA机构）看是否和明文hash一致</li></ul><p>握手过程</p><ol><li>Client Hello：TLS 版本号、支持的密码套件列表，以及生成的随机数</li><li>Server Hello：确认TLS版本，发送证书（包含公钥），随机数，密码套件（密钥交换、签名RSA；AES通信加密）</li><li>随机数（传输密钥）通过公钥加密后传给服务器（不考虑后续验证的化，其实这里可以携带加密数据，但RFC 标准不允许）</li><li><strong>Finishd</strong>：私钥解密获得传说密钥，最后对握手数据进行摘要并且加密，用于验证加密是否可用以及是否被篡改</li></ol><h3 id="ECDHE握手"><a href="#ECDHE握手" class="headerlink" title="ECDHE握手"></a>ECDHE握手</h3><p>RSA不具备前向安全！</p><h4 id="Diffie-Hellman密钥交换协议"><a href="#Diffie-Hellman密钥交换协议" class="headerlink" title="Diffie-Hellman密钥交换协议"></a><strong>Diffie-Hellman密钥交换协议</strong></h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404111615446.png" alt="image-20240411161319844"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404111616886.png" alt="image-20240411161548610"></p><p>根据私钥生成的方式，DH 算法分为两种实现：</p><ul><li>static DH 算法，这个是已经被废弃了；可能被暴力破解, 不具备前向安全性</li><li>DHE 算法，现在常用的；</li></ul><h4 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h4><p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。</p><p>小红和小明使用 ECDHE 密钥交换算法的过程：</p><ul><li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li><li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li><li>双方交换各自的公钥，最后小红计算点（x1，y1） &#x3D; d1Q2，小明计算点（x2，y2） &#x3D; d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 &#x3D; d1d2G &#x3D; d2d1G &#x3D; d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li></ul><ol><li><strong>Client Hello</strong>:客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（Client Random）</strong>。</li><li><strong>Server Hello</strong>: 随机数（Server Random） 密码套件（密钥协商ECDHE + 签名RSA+通信AES）、证书、选择椭圆曲线基点 G ，生成本地私钥d1，G*d1&#x3D;Q1 发送公钥 Q1 给客户端</li><li>生成本地私钥d2，G*d2&#x3D;Q2 发送公钥Q2给服务器；会话密钥为d2Q1；本次通信携带加密数据</li><li>最终验证一下</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1DS4y1R7hM">https://www.bilibili.com/video/BV1DS4y1R7hM</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1M34y1o7ca">https://www.bilibili.com/video/BV1M34y1o7ca</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1PL4y1H77Z">https://www.bilibili.com/video/BV1PL4y1H77Z</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1S541127qR">MD5为何不再安全</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html#dh-%E7%AE%97%E6%B3%95">3.4 HTTPS ECDHE 握手解析 | 小林coding (xiaolincoding.com)</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404111616886.png">DH算法</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考试压测及瓶颈排查</title>
    <link href="/2024/03/01/%E8%80%83%E8%AF%95%E5%8E%8B%E6%B5%8B%E5%8F%8A%E7%93%B6%E9%A2%88%E6%8E%92%E6%9F%A5/"/>
    <url>/2024/03/01/%E8%80%83%E8%AF%95%E5%8E%8B%E6%B5%8B%E5%8F%8A%E7%93%B6%E9%A2%88%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本次压测针对考试系统的瓶颈进行了全面排查与优化，主要包括以下内容和结果：    1. <strong>压测条件与问题发现</strong>      - 测试规模为6k<del>10k用户，预热100秒，题目响应延迟5</del>195秒（平均100秒），初始仅使用1个Exam Pod（1核1G）。      - 进入考试阶段的峰值QPS为40（每1k用户），稳定后降至10（每1k用户）。      - 发现交卷时Exam Pod崩溃，内存持续上升，怀疑内存泄漏。CPU在考试阶段利用率达40%，MySQL为20%。    2. <strong>内存泄漏排查与修复</strong>      - 通过<code>jmap</code>和MAT工具分析，发现<code>org.apache.catalina.session.StandardManager</code>占用了76%的内存，根源在于Spring Security默认使用HTTP Session存储用户认证信息（JSESSIONID），导致Session对象堆积。      - 解决：修改<code>ResourceServerConfig</code>，强制使用无状态策略（<code>SessionCreationPolicy.STATELESS</code>），完全依赖JWT鉴权。优化后内存泄漏问题消失。    3. <strong>MySQL瓶颈与缓存优化</strong>      - Gateway在每次请求中均会查询用户详情，导致MySQL负载过高（8k用户时RT爆炸）。      - 优化：在鉴权后通过Guava缓存用户信息，减少数据库查询。优化后MySQL负载趋稳，P95响应时间降至130ms。    4. <strong>资源分配与扩展性结论</strong>      - 最终配置：Exam Pod、UserCenter（3 Pod）、Gateway（5 Pod）。      - 系统性能提升显著，扩展性验证表明：只需水平扩展机器即可进一步提升并发能力。      - 注意：压测在本地环境进行，可能受限于带宽和硬件，建议后续使用云服务器标准化测试。    <strong>总结</strong>：通过修复内存泄漏、优化无状态设计、引入本地缓存，系统成功解决了OOM和高延迟问题，MySQL不再是瓶颈，整体并发能力大幅提升。</p></blockquote><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>对整个考试系统再次进行压测，并给出排查瓶颈以及不断优化的过程</p><h3 id="可能影响性能因素"><a href="#可能影响性能因素" class="headerlink" title="可能影响性能因素"></a><strong>可能影响性能因素</strong></h3><ul><li>代码（设计缓存是否命中）</li><li>exam pod数量，pod的Xmx</li><li>gateway 、usercenter 数量 </li><li>redis </li><li>mysql</li><li>索引</li><li>本地网速</li></ul><p>最简单查看是否是瓶颈的方式：<strong>cpu</strong>利用率</p><h3 id="压测参数"><a href="#压测参数" class="headerlink" title="压测参数"></a><strong>压测参数</strong></h3><ul><li><p>人数x&#x3D;6k~10k</p></li><li><p>warm-up&#x3D;100s</p></li><li><p>题目延时5~195s，平均delay &#x3D; 100s</p></li><li><p>只测exam 1pod  1核1G，并对比两次优化前后的提升</p></li></ul><p><strong>QPS</strong>:</p><ol><li>进入峰值QPS &#x3D; 在进入考试warm结尾：x&#x2F;warm * 3(notices\startExam\getExamInfo) + x&#x2F;delay &#x3D;  <strong>40QPS &#x2F; 1k人</strong></li><li>稳定QPS &#x3D;  x&#x2F;delay &#x3D; <strong>10QPS &#x2F; 1k人</strong></li></ol><h3 id="2K人"><a href="#2K人" class="headerlink" title="2K人"></a>2K人</h3><ol><li>进入考试exam 40%利用率，mysql20%利用率  平稳后降到一半</li><li>交卷时exam突然崩溃，内存在考试阶段一直在上升，怀疑有内存泄漏？</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636009.png" alt="image-20240325161104757"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636013.png" alt="image-20240325161034693"></p><h4 id="内存泄露排查"><a href="#内存泄露排查" class="headerlink" title="内存泄露排查"></a>内存泄露排查</h4><p>慢慢给请求，老年代占用率一直上升</p><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><ol><li>修改dockerfile为jdk</li><li>使用arthas分析查看，发现当内存过高时，GC开始活动占用大量CPU</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636014.png" alt="0bc927b3-147f-4b59-a742-0c133f71e440"></p><p>不停慢慢压测，老年代一直上升到极限  为什么？理论上没有对象一直被引用</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636015.png" alt="image-20240325161230411"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636016.png" alt="image-20240325161246988"></p><p>一段时间后自动下降（后来推断原因：session过期）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636017.png" alt="image-20240325161326735"></p><p>再压测</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636018.png" alt="image-20240325161339492"></p><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h5><p>输出占用高的对象  <code>jmap -histo:live pid | head -20</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash"> num     <span class="hljs-comment">#instances         #bytes  class name</span><br>----------------------------------------------<br>   1:        631231       59534632  [C<br>   2:       1458946       58357840  java.util.LinkedHashMap<span class="hljs-variable">$Entry</span><br>   3:        127056       17386296  [Ljava.util.HashMap<span class="hljs-variable">$Node</span>;<br>   4:        628938       15094512  java.lang.String<br>   5:         11921       11836728  [B<br>   6:        149746        8385776  java.util.LinkedHashMap<br>   7:        145070        7148200  [Ljava.lang.Object;<br>   8:        113038        5425824  java.util.HashMap<br>   9:        157285        3774840  java.util.ArrayList<br>  10:        116809        3737888  java.util.concurrent.ConcurrentHashMap<span class="hljs-variable">$Node</span><br>  11:         37082        3263216  java.lang.reflect.Method<br>  12:         24981        2762304  java.lang.Class<br>  13:         11159        1845112  [I<br>  14:         10436        1682984  [Ljava.util.concurrent.ConcurrentHashMap<span class="hljs-variable">$Node</span>;<br>  15:         44592        1426944  java.util.HashMap<span class="hljs-variable">$Node</span><br>  16:         57008         912128  java.lang.Object<br>  17:          9932         874016  org.apache.catalina.session.StandardSession<br></code></pre></td></tr></table></figure><ol><li><p><code>jmap -dump:live,format=b,file=heapdump.hprof  pid </code>   dump</p></li><li><p>MAT定位为org.apache.catalina.session.StandardManager</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">One</span> <span class="hljs-string">instance</span> <span class="hljs-string">of</span> <span class="hljs-string">&quot;org.apache.catalina.session.StandardManager&quot;</span> <span class="hljs-string">loaded</span> <span class="hljs-string">by</span> <span class="hljs-string">&quot;org.springframework.boot.loader.LaunchedURLClassLoader @ 0xe0620e30&quot;</span> <span class="hljs-string">occupies</span> <span class="hljs-number">306</span><span class="hljs-string">,798,192</span> <span class="hljs-string">(76.02%)</span> <span class="hljs-string">bytes.</span> <span class="hljs-string">The</span> <span class="hljs-string">memory</span> <span class="hljs-string">is</span> <span class="hljs-string">accumulated</span> <span class="hljs-string">in</span> <span class="hljs-string">one</span> <span class="hljs-string">instance</span> <span class="hljs-string">of</span> <span class="hljs-string">&quot;java.util.concurrent.ConcurrentHashMap$Node[]&quot;</span> <span class="hljs-string">loaded</span> <span class="hljs-string">by</span> <span class="hljs-string">&quot;&lt;system class loader&gt;&quot;</span><span class="hljs-string">.</span><br><br><span class="hljs-string">Keywords</span><br><span class="hljs-string">java.util.concurrent.ConcurrentHashMap$Node[]</span><br><span class="hljs-string">org.springframework.boot.loader.LaunchedURLClassLoader</span> <span class="hljs-string">@</span> <span class="hljs-number">0xe0620e30</span><br><span class="hljs-string">org.apache.catalina.session.StandardManager</span><br></code></pre></td></tr></table></figure></li><li><p>查看http返回确实返回了JSESSIONID,此外本地debug打开security日志也可也看到</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.student.exam.mapper:</span> <span class="hljs-string">debug</span><br>    <span class="hljs-attr">org:</span><br>      <span class="hljs-attr">springframework:</span><br>        <span class="hljs-attr">security:</span> <span class="hljs-string">DEBUG</span><br>        <br><span class="hljs-attr">o.s.s.w.c.HttpSessionSecurityContextRepository 91 :</span> <span class="hljs-string">SecurityContext</span> <span class="hljs-string">&#x27;org.springframework.security.core.context.SecurityContextImpl@ae3cc182: Authentication: org.springframework.security.oauth2.provider.OAuth2Authentication@ae3cc182: Principal: 51255903044; Credentials: [PROTECTED]; Authenticated: true; Details: remoteAddress=127.0.0.1, tokenType=BearertokenValue=&lt;TOKEN&gt;; Granted Authorities: ROLE_student&#x27;</span> <span class="hljs-attr">stored to HttpSession:</span> <span class="hljs-string">&#x27;org.apache.catalina.session.StandardSessionFacade@72a3d742</span><br></code></pre></td></tr></table></figure></li><li><p>修改EXAM下 ResourceServerConfig：session策略（登录使用JWT方式，整体微服务应该都需要满足<strong>无状态</strong>的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);<br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://www.cnblogs.com/qmfsun/p/7445325.html">一次压测中tomcat生成session释放不及时导致的频繁fullgc性能优化案例 - Agoly - 博客园 (cnblogs.com)</a></p><p>优化后无内存持续上升问题，内存泄漏解决。</p><h3 id="6-8k"><a href="#6-8k" class="headerlink" title="6~8k"></a>6~8k</h3><p>整体能够运行，但rt较高</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636019.png" alt="2b31fee5-364d-46a7-bedd-713ee2fd3e77"></p><p>mysql直接打满（上次压测已经发现，gateway在每一个接口都会去根据用户id拿用户的详情信息，导致mysql打满），符合预期</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636020.png" alt="image-20240325162040056"></p><p>如果8k人直接系统rt爆炸</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636021.png" alt="eb369f59-afb1-457f-8e47-bef45cbfa1b0"></p><p><strong>优化：将JWT在鉴权后用户id转化为用户信息的查询使用本地缓存（guava）</strong></p><h3 id="10k-（缓存-MQ）"><a href="#10k-（缓存-MQ）" class="headerlink" title="10k （缓存+MQ）"></a>10k （缓存+MQ）</h3><p><strong>P95 130MS</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636022.png" alt="image-20240325162434988"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636023.png" alt="image-20240325162453353"></p><p>exam pod<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636024.png" alt="image-20240325162511530"></p><p>Mysql（整体几乎平稳，因为代码基本上只操作数据库，但注意用户信息是缓存了，如果缓存刚好集体失效会有一个小峰值）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636025.png" alt="image-20240325162531512"></p><p>usercenter 3pod</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636026.png" alt="image-20240325162655144"></p><p>gateway 5pod</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403251636027.png" alt="image-20240325162709332"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>在强行不使用session后，系统不再OOM，恢复正常</li><li>对查询用户信息缓存后，mysql不再是瓶颈，整体系统并发大幅度上升</li><li>如果想增加系统的并发，扩展机器即可</li><li>本次压测是在本地个人机器上，使用jmeter命令行进行，可能会受到本地带宽、性能影响；标准做法应该使用专门的云服务器进行压测</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
      <tag>优化</tag>
      
      <tag>水杉</tag>
      
      <tag>压测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>趣学架构</title>
    <link href="/2024/01/25/%E8%B6%A3%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/01/25/%E8%B6%A3%E5%AD%A6%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要围绕软件开发中的设计模式、系统架构优化和故障处理展开，以下是摘要内容：  1. <strong>学习能力与代码优化</strong>      - 知识更新快、需求变化多，需通过优化代码结构应对（如避免重复代码）。提出两种方案：        - 方案1：工具类统一逻辑，标准化流程        - 方案2：模板方法模式（Java示例），固定调用顺序，集中处理日志&#x2F;错误    2. <strong>领域驱动设计（DDD）与流程引擎</strong>      - 通过事件风暴建模划分业务边界（如电商场景），抽象核心领域模型（订单、支付）。      - 分层架构：接口层（校验格式）、服务层（编排流程）、领域层（规则实现）、数据层（单纯CRUD）。      - 流程引擎实践：将业务拆分为处理器（Processor），通过模板或JSON配置驱动流程（如转账、风控）。    3. <strong>设计模式应用</strong>      - <strong>责任链模式</strong>：处理参数校验（如多条件依次验证）。      - <strong>策略模式</strong>：动态选择通知方式（短信&#x2F;邮件）。      - <strong>观察者模式</strong>：异步处理非主链路操作（如打点监控）。      - <strong>状态编排</strong>：通过事件驱动状态机（如订单状态流转）。    4. <strong>高并发与扩展性</strong>      - 读优化：多级缓存（本地+Redis）、缓存策略（延迟双删）。      - 写优化：批量操作、缓冲记账（先写文件再同步DB）。      - 分库分表：按用户ID哈希路由，隔离资源。    5. <strong>容错与稳定性</strong>      - 幂等设计：唯一ID+流水表防重。      - 降级策略：非核心依赖熔断（如查询余额忽略账单服务）。      - 监控：日志采集、链路追踪、定时对账。    6. <strong>故障预防与发布</strong>      - 灰度发布：按用户ID分段生效。      - 回滚机制：兼容性设计（新旧代码并存）。      - 全链路压测：模拟真实流量验证性能。    7. <strong>异常处理规范</strong>      - 系统内用异常中断流程，RPC接口返回错误码。      - 区分业务异常（如余额不足）与系统异常（如DB超时）。    总结：通过设计模式解耦、领域建模明确边界、分层架构隔离变化，结合流程引擎提升扩展性，再辅以缓存&#x2F;容错&#x2F;监控保障稳定性，最终实现高内聚低耦合的系统设计。</p></blockquote><p><a href="https://www.bilibili.com/video/BV1pz4y1j72C">https://www.bilibili.com/video/BV1pz4y1j72C</a></p><h2 id="1-大学学点啥"><a href="#1-大学学点啥" class="headerlink" title="1.大学学点啥"></a>1.大学学点啥</h2><p>学习能力</p><ul><li>知识多</li><li>更新换代快</li><li>时间约束</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202402292125524.png" alt="image-20240118150913790"></p><h2 id="2-搭建系统先搭架子"><a href="#2-搭建系统先搭架子" class="headerlink" title="2.搭建系统先搭架子"></a>2.搭建系统先搭架子</h2><h3 id="1-用户首页"><a href="#1-用户首页" class="headerlink" title="1.用户首页"></a>1.用户首页</h3><p>（用户信息、余额、消费等）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202402292125135.png" alt="image-20240118152725304"></p><h3 id="2-新需求"><a href="#2-新需求" class="headerlink" title="2.新需求"></a>2.新需求</h3><p>需要添加用户修改功能；<strong>存在许多重复代码</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403151317860.png" alt="image-20240118152826760"></p><p>解决方案1：添加工具类</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403151413979.png" alt="image-20240118152927534"></p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>统一逻辑，标准化流程</p><p>解决方案2：<strong>模板方法模式</strong>；保证必须要调用以及调用顺序；通用部分直接一起升级（log、error）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202403151413316.png" alt="image-20240118152954535"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Stopwatch;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;T, R&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggerImpl</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模板统一暴露执行入口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">process</span><span class="hljs-params">(T request)</span> &#123;<br>        <span class="hljs-comment">// 1.打印入口日志</span><br>        logger.info(<span class="hljs-string">&quot;start invoke, request=&quot;</span> + request);<br>        <span class="hljs-comment">// 开始计时，用于日志记录耗时</span><br>        <span class="hljs-type">Stopwatch</span> <span class="hljs-variable">stopwatch</span> <span class="hljs-operator">=</span> Stopwatch.createStarted();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 2. 校验参数</span><br>            validParam(request);<br>            <span class="hljs-comment">// 3. 子类实现逻辑</span><br>            <span class="hljs-type">R</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> doProcess(request);<br>            <span class="hljs-comment">// 4.打印出口日志</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timeCost</span> <span class="hljs-operator">=</span> stopwatch.elapsed(TimeUnit.MILLISECONDS);<br>            logger.info(<span class="hljs-string">&quot;end invoke, response=&quot;</span> + response + <span class="hljs-string">&quot;, costTime=&quot;</span> + timeCost);<br>            <span class="hljs-keyword">return</span> response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 打印异常日志</span><br>            logger.error(<span class="hljs-string">&quot;error invoke, exception:&quot;</span> + Arrays.toString(e.getStackTrace()));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数校验(交给子类实现)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(T request)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行业务逻辑(交给子类实现)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> R <span class="hljs-title function_">doProcess</span><span class="hljs-params">(T request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模拟的Logger类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;INFO: &quot;</span> + msg);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ERROR: &quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">get</span><span class="hljs-params">(Integer userId)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(Integer request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (request == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Request cannot be null&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">doProcess</span><span class="hljs-params">(Integer request)</span> &#123;<br>        <span class="hljs-comment">// 具体业务 获取用户信息、消费情况、余额</span><br>        <span class="hljs-keyword">return</span> request * request;<br>    &#125;<br>&#125;.process(userId);<br></code></pre></td></tr></table></figure><p>再进一步：如果子需求再次变化，例如添加优惠券信息、消费记录查询限制时间、只有授权才返回余额</p><p>这样代码越来越长，并且子业务之间相互影响；<strong>耦合</strong></p><h2 id="3-搭完架子串珠子"><a href="#3-搭完架子串珠子" class="headerlink" title="3.搭完架子串珠子"></a>3.搭完架子串珠子</h2><h3 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h3><p>逻辑拆分、边界组装</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118161401411.png" alt="image-20240118161401411"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118155403367.png" alt="image-20240118155403367"></p><p>其实就是实习中遇到的模板引擎玩法</p><p>在活动中，就是处理器就是 获取活动信息  过活动人群  过任务人群  过风控  处理业务  （首次进入任务就是添加一次任务记录，然后发一次抽奖机会；抽奖就是消耗抽奖机会，然后执行抽奖流程）</p><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><h4 id="造珠子（定义组件）"><a href="#造珠子（定义组件）" class="headerlink" title="造珠子（定义组件）"></a>造珠子（定义组件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-comment">// 包含两个参数  </span><br>    <span class="hljs-comment">// 1.入参 本次请求需要的参数，这个也可也定义一个函数来获取</span><br>    <span class="hljs-comment">// 2.上下文 处理器之间的信息传递 也是最后结果的返回数据源</span><br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>; <span class="hljs-comment">// 灰度</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoQueryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserBaseInfoRepository userBaseInfoRepository; <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserSpecialInfoRepository userSpecialInfoRepository;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的判断逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 示例，默认总是执行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的处理逻辑</span><br>        <span class="hljs-type">UserBaseInfoVO</span> <span class="hljs-variable">userBaseInfoVo</span> <span class="hljs-operator">=</span> userBaseInfoRepository.getUserBaseInfo(request.getUserId());<br>        <span class="hljs-type">UserSpecialInfoVO</span> <span class="hljs-variable">userSpecialInfoVo</span> <span class="hljs-operator">=</span> userSpecialInfoRepository.getUserSpecialInfo(request.getUserId());<br>        <br>        <span class="hljs-comment">// ... 更新context状态或处理其他业务逻辑</span><br>        context.setUserBaseInfo(userBaseInfoVo);<br>        context.setUserSpecialInfo(userSpecialInfoVo);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="串珠子（编排组件）"><a href="#串珠子（编排组件）" class="headerlink" title="串珠子（编排组件）"></a>串珠子（编排组件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引擎接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProcessEngine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>;<br>&#125;<br><br><span class="hljs-comment">// 引擎核心</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProcessEngineImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProcessEngine</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Logger logger;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;ProcessEngine start, request:&quot;</span> + request);<br>        <br>        <span class="hljs-comment">// 获取执行器列表</span><br>        List&lt;ProcessNameEnum&gt; processors = getProcessors();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 逐个运行执行器</span><br>            <span class="hljs-keyword">for</span> (ProcessNameEnum processorName : processors) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(processorName.getName());<br>                <span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> Processor)) &#123;<br>                    logger.error(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; not exist or type is incorrect&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 执行器开始日志标注</span><br>                logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; start&quot;</span>);<br>                <br>                <span class="hljs-type">Processor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> (Processor) bean;<br>                <span class="hljs-comment">// 判断执行器是否符合执行条件</span><br>                <span class="hljs-keyword">if</span> (!processor.needExecute(request, context)) &#123;<br>                    logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; skipped&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 执行器执行</span><br>                processor.execute(request, context);<br>                <br>                <span class="hljs-comment">// 执行器结束日志标注</span><br>                logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + processorName + <span class="hljs-string">&quot; end&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 执行异常中断日志打印</span><br>            logger.error(<span class="hljs-string">&quot;ProcessEngine interrupted, exception: &quot;</span> + Arrays.toString(e.getStackTrace()));<br>            <span class="hljs-comment">// 继续抛出异常</span><br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 打印引擎执行完成日志</span><br>        logger.info(<span class="hljs-string">&quot;ProcessEngine end, context: &quot;</span> + context);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> List&lt;ProcessNameEnum&gt; <span class="hljs-title function_">getProcessors</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体引擎</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoQueryProcessEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessEngineImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;ProcessNameEnum&gt; processorList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        processorList.add(ProcessNameEnum.USER_INFO_QUERY_PROCESSOR);<br>        processorList.add(ProcessNameEnum.MONEY_PROCESSOR);<br>        processorList.add(ProcessNameEnum.CONSUME_RECORD_PROCESSOR);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> List&lt;ProcessNameEnum&gt; <span class="hljs-title function_">getProcessors</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> processorList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用（启动流程）"><a href="#调用（启动流程）" class="headerlink" title="调用（启动流程）"></a>调用（启动流程）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> UserInfoDTO <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> String userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;String, UserInfoDTO&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(String request)</span> &#123;<br>            <span class="hljs-comment">// ... 参数校验逻辑</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> UserInfoDTO <span class="hljs-title function_">doProcess</span><span class="hljs-params">(String request)</span> &#123;<br>            <span class="hljs-comment">// ... 初始化请求和上下文对象</span><br>            <span class="hljs-type">ProcessRequest</span> <span class="hljs-variable">processRequest</span> <span class="hljs-operator">=</span> ProcessRequest.builder().userId(userId).build();<br>            <span class="hljs-type">ProcessContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> ProcessContext.builder().build();<br>            <br>            <span class="hljs-comment">// 启动引擎</span><br>            userInfoQueryProcessEngine.start(processRequest, ctx);<br>            <br>            <span class="hljs-comment">// 从上下文对象中获取数据并填充返回对象</span><br>            <span class="hljs-keyword">return</span> UserInfoDTO.builder()<br>                              .totalMoney(ctx.getTotalMoney())<br>                              .maxAmount(ctx.getMaxAmount())<br>                              .build();<br>        &#125;<br>    &#125;).process(userId);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="复杂流程编排"><a href="#复杂流程编排" class="headerlink" title="复杂流程编排"></a>复杂流程编排</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118162350908.png" alt="image-20240118162350908"></p><p>amunda, JBPM, 或Activiti  轻量级框架：LiteFlow</p><p>0.JSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;initialProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UserInfoQueryProcessor&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;processMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;UserInfoQueryProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MoneyProcessor&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;failed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ErrorHandlingProcessor&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;MoneyProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ConsumeRecordProcessor&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;failed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ErrorHandlingProcessor&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ConsumeRecordProcessor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;failed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ErrorHandlingProcessor&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>1.返回string，决定着next</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span>;<br>    String <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoQueryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserBaseInfoRepository userBaseInfoRepository; <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserSpecialInfoRepository userSpecialInfoRepository;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">needExecute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的判断逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 示例，默认总是执行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-comment">// 实现具体的处理逻辑</span><br>        <span class="hljs-type">UserBaseInfoVO</span> <span class="hljs-variable">userBaseInfoVo</span> <span class="hljs-operator">=</span> userBaseInfoRepository.getUserBaseInfo(request.getUserId());<br>        <span class="hljs-type">UserSpecialInfoVO</span> <span class="hljs-variable">userSpecialInfoVo</span> <span class="hljs-operator">=</span> userSpecialInfoRepository.getUserSpecialInfo(request.getUserId());<br>        <br>        <span class="hljs-comment">// 业务异常返回失败状态</span><br>        <span class="hljs-keyword">if</span> (userSpecialInfoVo == <span class="hljs-literal">null</span>)&#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failed&quot;</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// ... 更新context状态或处理其他业务逻辑</span><br>        context.setUserBaseInfo(userBaseInfoVo);<br>        context.setUserSpecialInfo(userSpecialInfoVo);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.编排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurableProcessEngineImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProcessEngine</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Logger logger;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, String&gt;&gt; processMap;<br>    <span class="hljs-keyword">private</span> String initialProcessorName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigurableProcessEngineImpl</span><span class="hljs-params">(String jsonFilePath)</span> &#123;<br>        init(jsonFilePath);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(String jsonFilePath)</span> &#123;<br>        <span class="hljs-comment">// 读取JSON文件并解析为processMap和initialProcessorName</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Files.readAllBytes(Paths.get(jsonFilePath)));<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonConfig</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonContent);<br>        <span class="hljs-built_in">this</span>.initialProcessorName = jsonConfig.getString(<span class="hljs-string">&quot;initialProcessor&quot;</span>);<br>        <span class="hljs-built_in">this</span>.processMap = parseProcessMap(jsonConfig.getJSONObject(<span class="hljs-string">&quot;processMap&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(ProcessRequest request, ProcessContext context)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">currentProcessorName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.initialProcessorName;<br>        Processor currentProcessor;<br><br>        <span class="hljs-keyword">while</span> (currentProcessorName != <span class="hljs-literal">null</span>) &#123;<br>            currentProcessor = (Processor) applicationContext.getBean(currentProcessorName);<br>            String result;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (currentProcessor.needExecute(request, context)) &#123;<br>                    result = currentProcessor.execute(request, context);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    logger.info(<span class="hljs-string">&quot;Processor: &quot;</span> + currentProcessorName + <span class="hljs-string">&quot; skipped&quot;</span>);<br>                    result = <span class="hljs-string">&quot;Skipped&quot;</span>; <span class="hljs-comment">// 或者其他表示跳过的结果</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                result = <span class="hljs-string">&quot;Failed&quot;</span>; <span class="hljs-comment">// 或者其他表示失败的结果</span><br>                logger.error(<span class="hljs-string">&quot;Processor: &quot;</span> + currentProcessorName + <span class="hljs-string">&quot; failed, exception: &quot;</span> + Arrays.toString(e.getStackTrace()));<br>            &#125;<br><br>            currentProcessorName = determineNextProcessor(currentProcessorName, result);<br>        &#125;<br><br>        logger.info(<span class="hljs-string">&quot;ProcessEngine end, context: &quot;</span> + context);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">determineNextProcessor</span><span class="hljs-params">(String currentProcessorName, String result)</span> &#123;<br>        Map&lt;String, String&gt; decisionMap = processMap.get(currentProcessorName);<br>        <span class="hljs-keyword">if</span> (decisionMap == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> decisionMap.get(result);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析processMap</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, String&gt;&gt; <span class="hljs-title function_">parseProcessMap</span><span class="hljs-params">(JsonObject processMapJson)</span> &#123;<br>        <span class="hljs-comment">// 实现processMap的解析逻辑</span><br>        <span class="hljs-keyword">return</span> JSONObject.parseObject(processMapJson.toJSONString(),<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt;() &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> UserInfoDTO <span class="hljs-title function_">doProcess</span><span class="hljs-params">(String request)</span> &#123;<br>    <span class="hljs-comment">// 创建流程引擎</span><br>    <span class="hljs-type">ConfigurableProcessEngineImpl</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurableProcessEngineImpl</span>(<span class="hljs-string">&quot;/path/to/your/process-flow.json&quot;</span>);<br><br>    <span class="hljs-comment">// 启动流程引擎</span><br>    processEngine.start(request, context);<br><br><br>    <span class="hljs-comment">// ... 初始化请求和上下文对象</span><br>    <span class="hljs-type">ProcessRequest</span> <span class="hljs-variable">processRequest</span> <span class="hljs-operator">=</span> ProcessRequest.builder().userId(userId).build();<br>    <span class="hljs-type">ProcessContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> ProcessContext.builder().build();<br><br>    <span class="hljs-comment">// 启动引擎</span><br>    processEngine.start(processRequest, ctx);<br><br>    <span class="hljs-comment">// 从上下文对象中获取数据并填充返回对象</span><br>    <span class="hljs-keyword">return</span> UserInfoDTO.builder()<br>        .totalMoney(ctx.getTotalMoney())<br>        .maxAmount(ctx.getMaxAmount())<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118172157467.png" alt="image-20240118172157467"></p><p>责任链：沿着这条链传递请求，直到有一个对象处理它为止，具体由哪个对象处理则在运行时动态决定的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> Handler successor;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;No discount applied.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Low discount applied. Amount: &quot;</span> + amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt;= <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;High discount applied. Amount: &quot;</span> + amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler head;<br>    <span class="hljs-keyword">private</span> Handler tail;<br><br>    <span class="hljs-keyword">public</span> HandlerChain <span class="hljs-title function_">add</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.setSuccessor(handler);<br>            tail = handler;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LowDiscountHandler</span>())<br>             .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HighDiscountHandler</span>())<br>             .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoDiscountHandler</span>());<br><br>        <span class="hljs-comment">// Making requests</span><br>        chain.handleRequest(<span class="hljs-number">500</span>);<br>        chain.handleRequest(<span class="hljs-number">1500</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-系统是个三明治"><a href="#4-系统是个三明治" class="headerlink" title="4.系统是个三明治"></a>4.系统是个三明治</h2><ul><li>提高复用性</li><li>降低耦合</li><li>提高可读性</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118195836506.png" alt="image-20240118195836506" style="zoom:50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118195851875.png" alt="image-20240118195851875" style="zoom:50%;" /></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118200142854.png" alt="image-20240118200142854"></p><ul><li>[接口层] :对出入参仅做格式上的校验，不能涉及“例如用户是否在黑名单中”这样的校验。</li><li>[服务层] :负责编排流程、处理rpc请求、控制同异步。不能涉及领域概念。</li><li>[领域层] :针对领域规则来实现具体的能力。</li><li>[数据层] :仅对数据做CRUD,不能涉及对数据的额外加工。</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119160910358.png" alt="image-20240119160910358"></p><h2 id="5-DDD"><a href="#5-DDD" class="headerlink" title="5.DDD"></a>5.DDD</h2><p>复杂度提升</p><ul><li>满足基本需求</li><li>良好的扩展性</li><li>稳定性、性能</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119171329282.png" alt="image-20240119171329282"></p><p>设计策略：</p><ul><li>搞清功能</li><li>分析建模</li><li>便于拆分</li></ul><p><strong>case</strong>：卖家可以在网上挂商品售卖，买家可以选择商品并购买，购买后卖家会发快递，买家收到货后确认收货，网站把款项结算给卖家。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172529042.png" alt="image-20240119172529042"></p><h3 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h3><p>解释业务，建立业务模型，划分业务边界</p><h4 id="事件风暴"><a href="#事件风暴" class="headerlink" title="事件风暴"></a>事件风暴</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119165000678.png" alt="image-20240119165000678"></p><p>事件：行为的结果（业务的重点），再通过事件反推整个流程</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119164946344.png" alt="image-20240119164946344"></p><h4 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a><strong>领域建模</strong></h4><h5 id="分析领域模型"><a href="#分析领域模型" class="headerlink" title="分析领域模型"></a><strong>分析领域模型</strong></h5><ul><li><p>找出事件风暴中的名词</p></li><li><p>连接名词</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172209854.png" alt="image-20240119172209854" style="zoom:50%;" /></li></ul><h5 id="找聚合："><a href="#找聚合：" class="headerlink" title="找聚合："></a><strong>找聚合</strong>：</h5><p>直接关系最多的节点</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172306137.png" alt="image-20240119172306137"></p><h5 id="划分（限界上下文）"><a href="#划分（限界上下文）" class="headerlink" title="划分（限界上下文）"></a><strong>划分（限界上下文）</strong></h5><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119172428922.png" alt="image-20240119172428922" style="zoom: 67%;" /><p>1.整理出了重要的业务概念和规则.<br>2.所有角色都对概念对齐了认知<br>3.识别了重要的领域模型，继而指导了系统模型<br>4.做了系统划分</p><p>丛业务嘴里的模糊描述 -&gt;清晰的业务概念(多方认知)具体系统建设的内容</p><h3 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119173515013.png" alt="image-20240119173515013"></p><p><strong>领域模型</strong>：提供了基本的能力，包含业务规则（如类文件对外暴露的方法） </p><p><strong>领域服务</strong>：就是<strong>命令</strong>（动作），由多个领域模型聚合</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119173056903.png" alt="image-20240119173056903"></p><p>应用层：编排领域服务；同时需要处理消息（例如下单后的邮件通知通过事件驱动实现）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119173900690.png" alt="image-20240119173900690"></p><p>目录结构：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240119174138306.png" alt="image-20240119174138306"></p><h2 id="6-0铁三角"><a href="#6-0铁三角" class="headerlink" title="6.0铁三角"></a>6.0铁三角</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120125313890.png" alt="image-20240120125313890"></p><h2 id="6-还得是设计模式（扩展-功能扩展）"><a href="#6-还得是设计模式（扩展-功能扩展）" class="headerlink" title="6.还得是设计模式（扩展-功能扩展）"></a>6.还得是设计模式（扩展-功能扩展）</h2><ul><li>功能扩展</li><li>流量扩展</li></ul><p>看不懂 改不动 风险高</p><p>会写代码的人很多，写好的代码的人少</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120125646682.png" alt="image-20240120125646682" style="zoom:67%;" /><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转账服务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> payer 付款方</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> payee 收款方</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> money 转账金额</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 是否转账成功</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String payer, String payee, String money)</span> &#123;<br>    Log.info(<span class="hljs-string">&quot;transfer start, payer=&#123;&#125;, payee=&#123;&#125;, money=&#123;&#125;&quot;</span>, payer, payee, money);<br><br>    <span class="hljs-comment">// 1.检查参数</span><br>    <span class="hljs-keyword">if</span> (!isValidUser(payer) || !isValidUser(payee) || !isValidMoney(money)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.调用转账服务</span><br>    <span class="hljs-type">TransferResult</span> <span class="hljs-variable">transferResult</span> <span class="hljs-operator">=</span> transferService.transfer(payer, payee, money);<br>    <span class="hljs-keyword">if</span> (!transferResult.isSuccess()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.查询用户通知方式</span><br>    <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> userInfoService.getUserInfo(payee);<br>    <span class="hljs-keyword">if</span> (userInfo.getNotifyType() == NotifyTypeEnum.SMS) &#123;<br>        <span class="hljs-comment">// smsNotifyService是第三方jar包</span><br>        smsClient.sendSms(payee, NOTIFY_CONTENT);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userInfo.getNotifyType() == NotifyTypeEnum.MAIL) &#123;<br>        <span class="hljs-comment">// mailNotifyService是第三方jar包</span><br>        mailClient.sendMail(payee, NOTIFY_CONTENT);<br>    &#125;<br><br>    <span class="hljs-comment">// 记录转账账单(发送事件给转账系统)</span><br>    billService.sendBill(transferResult);<br>    <span class="hljs-comment">// 转账监控打点(调用监控jdk)</span><br>    monitorService.sendRecord(transferResult);<br>    <span class="hljs-comment">// 记录转账额度(调用额度中心)</span><br>    quotaService.recordQuota(transferResult);<br><br>    Log.info(<span class="hljs-string">&quot;transfer success&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>入参出参不具备扩展性，可以考虑使用对象参数</p></li><li><p>参数的校验可以使用<strong>责任链</strong>优化，所有校验方法都添加到一个list中 <code>context.getBeansOfTypeParamValidator.class)</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120150550932.png" alt="image-20240120150550932"></p></li><li><p>通知方式，使用<strong>多态替换条件表达式</strong>  策略模式或适配器；和上面最大区别在于只执行一个而不是都执行 所以要一个一个添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotifyServiceManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SmsNotifyService smsNotifyService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MailNotifyService mailNotifyService;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;NotifyTypeEnum, NotifyService&gt; notifyServiceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 注册通知类型到通知服务的映射关系</span><br>        notifyServiceMap.put(NotifyTypeEnum.SMS, smsNotifyService);<br>        notifyServiceMap.put(NotifyTypeEnum.MAIL, mailNotifyService);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotifyTypeEnum notifyTypeEnum, String userId, String content)</span> &#123;<br>        <span class="hljs-type">NotifyService</span> <span class="hljs-variable">notifyService</span> <span class="hljs-operator">=</span> notifyServiceMap.get(notifyTypeEnum);<br>        <span class="hljs-keyword">if</span> (notifyService == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Notify service not exist for type: &quot;</span> + notifyTypeEnum);<br>        &#125;<br>        notifyService.notifyMessage(userId, content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后<strong>非主链路</strong>的统计、打点，使用<strong>观察者模式</strong>实现；并结合线<strong>程池加速及错误隔离</strong>；和校验器区别在于这是非主链路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransferObserver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(TransferResult transferResult)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BillServiceObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferObserver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(TransferResult transferResult)</span> &#123;<br>        billService.sendBill(transferResult);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorServiceObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferObserver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(TransferResult transferResult)</span> &#123;<br>        monitorService.sendRecord(transferResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TransferObserver&gt; transferObserverList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 异步线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Map&lt;String, TransferObserver&gt; transferObserverMap = applicationContext.getBeansOfType(TransferObserver.class);<br>        transferObserverMap.values().forEach(<span class="hljs-built_in">this</span>::addObserver);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 触发观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(TransferResult transferResult)</span> &#123;<br>        transferObserverList.forEach(transferObserver -&gt; &#123;<br>            <span class="hljs-comment">// 异步执行</span><br>            executorService.execute(() -&gt; transferObserver.update(transferResult));<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加观察者</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(TransferObserver transferObserver)</span> &#123;<br>        transferObserverList.add(transferObserver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>至此新增参数校验、通知类型、后处理等，<code>transfer</code>方法不用修改</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120153221074.png" alt="image-20240120153221074"></p><h2 id="7-没有扛不住的流量（扩展-流量扩展）"><a href="#7-没有扛不住的流量（扩展-流量扩展）" class="headerlink" title="7.没有扛不住的流量（扩展-流量扩展）"></a>7.没有扛不住的流量（扩展-流量扩展）</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>可能存在的问题： </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120180511652.png" alt="image-20240120180511652"></p><p>此外，还需要拦截恶意的流量，并在特殊情况下对部分有效流量进行降级</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120180655965.png" alt="image-20240120180655965"></p><h3 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h3><ul><li><p>流量的路由（负载均衡，直接平均或者按照机器性能，实际上机器同样，所以直接平均，降低负载均衡时的复杂度）</p><ol><li>DNS</li><li>NGINX  没有自动服务发现的能力</li><li>Eueka Nacos Consul</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120181702521.png" alt="image-20240120181702521"></p></li><li><p>服务器间的数据共享问题（实现无状态）</p><ol><li><p>最简单的方式：复制或者拆分；；引入额外的效率 复杂度 一致性问题</p></li><li><p>数据中心化：缓存以及磁盘都放到中心化的服务上</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120182017970.png" alt="image-20240120182017970"></p></li></ol></li></ul><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120182133557.png" alt="image-20240120182133557" style="zoom:50%;" /><p>也就是微服务拆分，使得服务间不受到影响，隔离风险；灵活配置合理分配资源</p><h3 id="单元化部署"><a href="#单元化部署" class="headerlink" title="单元化部署"></a>单元化部署</h3><p>通常情况下前两种够了，但：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120183320165.png" alt="image-20240120183320165"></p><p>根据用户的id，在服务上以及数据（sharding）上都进行拆分</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120183309123.png" alt="image-20240120183309123"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120183359206.png" alt="image-20240120183359206" style="zoom: 67%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120184018167.png" alt="image-20240120184018167"></p><h2 id="8-读的慢有妙招（性能）"><a href="#8-读的慢有妙招（性能）" class="headerlink" title="8.读的慢有妙招（性能）"></a>8.读的慢有妙招（性能）</h2><p><a href="https://www.toutiao.com/article/7094098101773828645">后台服务高性能设计之道</a></p><p>性能：</p><ul><li>读性能</li><li>写性能</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120192800027.png" alt="image-20240120192800027"></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="使用层面"><a href="#使用层面" class="headerlink" title="使用层面"></a>使用层面</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120185031580.png" alt="image-20240120185031580"></p><h4 id="本地-vs-中心"><a href="#本地-vs-中心" class="headerlink" title="本地 vs 中心"></a>本地 vs 中心</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120185122795.png" alt="image-20240120185122795"></p><p>甚至于同时使用多级缓存</p><h4 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h4><ol><li>添加过期时间</li><li><strong>先更新DB再删除缓存</strong>cache aside pattern（小概率：B来的时候没有缓存，B读取数据库，A更新数据并删除redis，B写脏数据到redis）<ul><li><strong>更新DB再更新缓存、更新缓存再更新db</strong>：<ol><li>同时更新时顺序问题  </li><li>多次更新时重复无效的更新</li><li>此外更新缓存再更新db，如果更新db失败，缓存不好回滚</li></ol></li><li><strong>删除缓存再更新db</strong>：A删完缓存来了查询B，B查询完成后写入脏数据到redis</li></ul></li><li>延时双删：先更新DB再删除缓存，再异步删除   （实际上网上资料都是先删除缓存再更新DB，再异步删除）</li><li>缓存永不过期，并且周期性全量刷新</li></ol><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>DB的访问做读写分离，写在主，binlog等方式同步到从</p><p><strong>一致性问题</strong>：</p><ul><li><p>大部分时间忽略</p></li><li><p>前端直接短暂延时</p></li><li><p>强一致场景强制读主</p></li><li><p>路由标记，引入了一个标记（过期时间大于同步时间）作为同步标记，会导致多一次读缓存，巧妙但不推荐</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120191525962.png" alt="image-20240120191525962" style="zoom:67%;" /></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>一个通用的思路，针对性能问题通用解决方案</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120191900959.png" alt="image-20240120191900959"></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240120192137793.png" alt="image-20240120192137793"></p><p>其实就是之前提到的转载后的打点使用异步线程池实现，主线程直接返回</p><h3 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h3><ul><li>分页</li><li>递进展示</li><li>降低极致的准确性要求，允许短暂的不一致</li><li>峰值流量降级非重要功能</li><li>控制主动（点击重试）或被动（超时重试）重试</li></ul><p>其他    优化协议、流量拦截、静态缓存、数据压缩等等</p><h2 id="9-写性能难提升（性能）"><a href="#9-写性能难提升（性能）" class="headerlink" title="9.写性能难提升（性能）"></a>9.写性能难提升（性能）</h2><p>为什么难？</p><ol><li>写的<strong>丢失代价</strong>大</li><li>写<strong>必须要磁盘</strong>（可靠性场景），而读可以是缓存</li><li>写时常需要<strong>加锁</strong></li><li><strong>资损</strong></li></ol><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121204714055.png" alt="image-20240121204714055"></p><h3 id="合理加锁"><a href="#合理加锁" class="headerlink" title="合理加锁"></a>合理加锁</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121205243774.png" alt="image-20240121205243774"></p><h3 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121222045378.png" alt="image-20240121222045378"></p><p>优化方案的轮询是查询缓存的，放置数据库压力过大</p><p>TODO：添加一个<strong>缓存标记</strong>，可以用在判题请求中，这样轮询时就不用查询数据库</p><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><ul><li><p>db批量操作快、减少加锁释放锁时间</p></li><li><p>缺点：更新存在延时<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121222926648.png" alt="image-20240121222926648"></p></li><li><p>方案二（<strong>缓冲记账</strong>）引入了流水数据库表，实现持久化了数据但不用加锁</p></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>文件系统的写入通常比数据库写入要快</strong>，之后再把文件同步到db，同步时可以使用拆分思想并发处理</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121223503832.png" alt="image-20240121223503832"></p><h3 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h3><p>并不需要百分百正确，缓存挂了就捞取redis自带的持久化数据，或者自己定时任务捞取缓存持久化到数据库</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121223646419.png" alt="image-20240121223646419"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121224327937.png" alt="image-20240121224327937"></p><h2 id="10-稳定性引入"><a href="#10-稳定性引入" class="headerlink" title="10.稳定性引入"></a>10.稳定性引入</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121225347286.png" alt="image-20240121225347286"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121225544326.png" alt="image-20240121225544326"></p><p>核心服务4个9：52.6 mins 一年不可用时间</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121231622560.png" alt="image-20240121231622560"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121231642209.png" alt="image-20240121231642209"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121231724254.png" alt="image-20240121231724254"></p><h3 id="总结引入"><a href="#总结引入" class="headerlink" title="总结引入"></a>总结引入</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240121232021199.png" alt="image-20240121232021199"></p><h2 id="11-稳定性之设计时"><a href="#11-稳定性之设计时" class="headerlink" title="11.稳定性之设计时"></a>11.稳定性之设计时</h2><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><ol><li><p>请求携带唯一ID（可以前端生成也可也后端生成返回）</p></li><li><p>后端流水数据库唯一ID key，业务前需要先落库流水数据库实现幂等</p></li><li><p>更进一步，添加分布式锁</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122122058300.png" alt="image-20240122122058300"></p></li></ol><h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122123053045.png" alt="image-20240122123053045"></p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>避免被下游影响；强依赖变成弱依赖，账单服务失败不能影响查询余额接口；</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122123255388.png" alt="image-20240122123255388"></p><ol><li>前端直接拆分成两个请求</li><li>直接try catch，这里还是会对下游发起请求，如果下游返回时间比较长，还需要等待</li><li>通过配置中心（一般会缓存到本地，配置变更再推送），根据配置决定是否请求</li></ol><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p>避免被上游影响</p><ul><li>限制流量</li><li>控制速度</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122123755636.png" alt="image-20240122123755636"></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122124816983.png" alt="image-20240122124816983"></p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>旧接口进行了改造，字段发生了变化</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122124959078.png" alt="image-20240122124959078"></p><p><strong>标准方法</strong>：后端逻辑需要<strong>兼容旧逻辑</strong>，前端字段冗余，新旧逻辑都要传递；之后定时清理</p><p>因此在该变更场景中，实际上是先新增一个字段，再清理时删除原字段</p><h3 id="打日志"><a href="#打日志" class="headerlink" title="打日志"></a>打日志</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122130621494.png" alt="image-20240122130621494"></p><ul><li>可以接受的错误，存在降级策略：warn</li><li>预期之外、会终端流程：error</li><li>大厂最佳实践通常是异步打印日志：磁盘 -&gt; 发送到队列，由别的线程负责</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240124152012901.png" alt="image-20240124152012901"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240124154346120.png" alt="image-20240124154346120"></p><h4 id="摘要日志"><a href="#摘要日志" class="headerlink" title="摘要日志"></a>摘要日志</h4><p>可以结合工具做统计，可视化等</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240124154157858.png" alt="image-20240124154157858"></p><h2 id="12-稳定性之变更时"><a href="#12-稳定性之变更时" class="headerlink" title="12.稳定性之变更时"></a>12.稳定性之变更时</h2><p>升级产品功能、修复产品缺陷；80%故障</p><ul><li>代码发布</li><li>配置变更</li><li>数据库修改</li><li>库表变化</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122132115071.png" alt="image-20240122132115071"></p><p>兼容性和前面说的类似，<strong>下游同时兼容上游新旧代码</strong>  a调用b：a旧-b新、a新-b新、甚至于a新-b旧</p><h3 id="对比流量"><a href="#对比流量" class="headerlink" title="对比流量"></a>对比流量</h3><h4 id="流量复制"><a href="#流量复制" class="headerlink" title="流量复制"></a>流量复制</h4><p>预发布环境DB、Cache相同，因此只能针对读服务</p><ul><li>方法1. 线上在业务执行完成后转发到预发布环境，存在入侵</li><li>方法2. 在网关同时转发到两个环境</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122133710703.png" alt="image-20240122133710703"></p><h4 id="线下环境流量回放"><a href="#线下环境流量回放" class="headerlink" title="线下环境流量回放"></a>线下环境流量回放</h4><ul><li>将请求、RPC、中间件、DB都录制（框架实现线上录制功能，如果让你设计这个框架，如何实现？）</li><li>回放时全部mock掉</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122134112992.png" alt="image-20240122134112992"></p><h3 id="发布顺序"><a href="#发布顺序" class="headerlink" title="发布顺序"></a>发布顺序</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122134845701.png" alt="image-20240122134845701"></p><h3 id="容量评估（压测）"><a href="#容量评估（压测）" class="headerlink" title="容量评估（压测）"></a>容量评估（压测）</h3><p>唯一方法：压测</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122135140022.png" alt="image-20240122135140022"></p><h3 id="可监控"><a href="#可监控" class="headerlink" title="可监控"></a>可监控</h3><p>埋点、日志、异常、机器指标、成功率、RT</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122135710503.png" alt="image-20240122135710503"></p><h3 id="可灰度"><a href="#可灰度" class="headerlink" title="可灰度"></a>可灰度</h3><p>变更逐步生效</p><p>实现灰度：用户ID后两位</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122140351961.png" alt="image-20240122140351961"></p><h4 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h4><p>开关变量实现灰度，多次请求中途变更了开关</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122140557705.png" alt="image-20240122140557705"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122140708294.png" alt="image-20240122140708294"></p><h3 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h3><p>回滚不难，如何快速回滚，并且有时候存在新数据了，旧代码是否能够兼容或者数据回滚</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122141222095.png" alt="image-20240122141222095"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122141402267.png" alt="image-20240122141402267"></p><h2 id="13-稳定性之运行时"><a href="#13-稳定性之运行时" class="headerlink" title="13.稳定性之运行时"></a>13.稳定性之运行时</h2><p>跑着跑着出错了；真正故障时能做的事情很少，重点需要前期准备好</p><h3 id="监控-报警"><a href="#监控-报警" class="headerlink" title="监控+报警"></a>监控+报警</h3><p>包含日志的采集 &amp; 报警</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122163959159.png" alt="image-20240122163959159"></p><h3 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h3><p>主动模拟请求，周期性执行</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164316168.png" alt="image-20240122164316168"></p><h3 id="对账系统"><a href="#对账系统" class="headerlink" title="对账系统"></a>对账系统</h3><p><a href="https://tech.meituan.com/2018/03/21/balance-accounts.html">美团配送资金安全治理之对账体系建设 - 美团技术团队 (meituan.com)</a></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164445756.png" alt="image-20240122164445756"></p><h4 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h4><ul><li>植入到链路中，失败立马进行拦截</li><li>影响核心链路性能</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164531241.png" alt="image-20240122164531241"></p><h4 id="准实时"><a href="#准实时" class="headerlink" title="准实时"></a>准实时</h4><ul><li>通过异步发送消息或者监听binlog</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164731540.png" alt="image-20240122164731540"></p><h4 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h4><p>定时拉取数据并做校验</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122164920770.png" alt="image-20240122164920770"></p><h3 id="分布式trance"><a href="#分布式trance" class="headerlink" title="分布式trance"></a>分布式trance</h3><p>还原链路的调用关系</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240122165049137.png" alt="image-20240122165049137"></h3><h2 id="14-错误处理显真功（细节）"><a href="#14-错误处理显真功（细节）" class="headerlink" title="14.错误处理显真功（细节）"></a>14.错误处理显真功（细节）</h2><p>某些因素导致流程没有按照预期执行完成</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123151905647.png" alt="image-20240123151905647"></p><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><ul><li>入参校验（电话、金额）</li><li>中间用户信息结果判断</li><li>业务返回判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TransferResponse <span class="hljs-title function_">transfer</span><span class="hljs-params">(Transferparam transferparam)</span> &#123;<br>    <span class="hljs-comment">// 1.查询用户信息并校验</span><br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payerUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(transferParam.getPayerPhoneNo());<br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payeeUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(transferParam.getPayeePhoneNo());<br><br>    <span class="hljs-comment">// 2.转账</span><br>    <span class="hljs-type">TransferRequest</span> <span class="hljs-variable">transferRequest</span> <span class="hljs-operator">=</span> TransferRequest.builder()<br>        .payerId(payerUserInfoResult.getData().getUserId())<br>        .payeeId(payeeUserInfoResult.getData().getUserId())<br>        .money(transferParam.getMoney())<br>        .build(); <br>    transferService.transfer(transferRequest);<br><br>    <span class="hljs-comment">// 3. 记录额度</span><br>    quatoService.recordQuato(payerUserInfoResult.getData().getUserId(), transferParam.getMoney());<br><br>    <span class="hljs-keyword">return</span> TransferResponse.builder().retCode(SUCCESS_CODE).build();<br>&#125;<br><br><span class="hljs-keyword">public</span> TransferResponse <span class="hljs-title function_">transfer</span><span class="hljs-params">(Transferparam transferparam)</span> &#123;<br>    <span class="hljs-comment">// 输入参数校验</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">payerPhoneNo</span> <span class="hljs-operator">=</span> transferParam.getPayerPhoneNo();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">payeePhoneNo</span> <span class="hljs-operator">=</span> transferParam.getPayeePhoneNo();<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> transferParam.getMoney();<br><br>    <span class="hljs-keyword">if</span> (!isValidPhoneNo(payerPhoneNo) || !isValidPhoneNo(payeePhoneNo)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid phone number&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (money == <span class="hljs-literal">null</span> || money.compareTo(BigDecimal.ZERO) &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid transfer amount&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 1.查询用户信息并校验</span><br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payerUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(payerPhoneNo);<br>    <span class="hljs-type">UserInfoResult</span> <span class="hljs-variable">payeeUserInfoResult</span> <span class="hljs-operator">=</span> userInfoService.queryUserInfo(payeePhoneNo);<br><br>    <span class="hljs-keyword">if</span> (payerUserInfoResult == <span class="hljs-literal">null</span> || payerUserInfoResult.getData() == <span class="hljs-literal">null</span> || payeeUserInfoResult == <span class="hljs-literal">null</span> || payeeUserInfoResult.getData() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid user information&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.转账</span><br>    <span class="hljs-type">TransferRequest</span> <span class="hljs-variable">transferRequest</span> <span class="hljs-operator">=</span> TransferRequest.builder()<br>        .payerId(payerUserInfoResult.getData().getUserId())<br>        .payeeId(payeeUserInfoResult.getData().getUserId())<br>        .money(money)<br>        .build(); <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">transferResult</span> <span class="hljs-operator">=</span> transferService.transfer(transferRequest);<br><br>    <span class="hljs-keyword">if</span> (!transferResult) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Transfer failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 记录额度</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">recordResult</span> <span class="hljs-operator">=</span> quatoService.recordQuato(payerUserInfoResult.getData().getUserId(), money);<br><br>    <span class="hljs-keyword">if</span> (!recordResult) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failed to record quota&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TransferResponse.builder().retCode(SUCCESS_CODE).build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误处理方式"><a href="#错误处理方式" class="headerlink" title="错误处理方式"></a>错误处理方式</h3><ul><li>返回<strong>错误码</strong> 可以包含更加复杂的信息；无性能损耗</li><li><strong>抛出异常</strong>  写起来简单 （目前主流rpc都支持异常传递）</li><li>都无法用于异步场景！</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123144451520.png" alt="image-20240123144451520"></p><p><strong>推荐</strong>：系统内使用中断，PRC接口交互错误码</p><h3 id="异步异常"><a href="#异步异常" class="headerlink" title="异步异常"></a>异步异常</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123145901501.png" alt="image-20240123145901501"></p><h3 id="错误码设计"><a href="#错误码设计" class="headerlink" title="错误码设计"></a>错误码设计</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123152917587.png" alt="image-20240123152917587"></p><p>这里是代码写死，也可也配置中心配置</p><h3 id="异常设计方式"><a href="#异常设计方式" class="headerlink" title="异常设计方式"></a>异常设计方式</h3><p>CommonException+枚举</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123152134856.png" alt="image-20240123152134856"></p><p>各种不同异常+上面：可以通过异常类型进行不同处理（降级等）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123152341699.png" alt="image-20240123152341699"></p><h3 id="异常映射错误码"><a href="#异常映射错误码" class="headerlink" title="异常映射错误码"></a>异常映射错误码</h3><p>由于内部是使用异常，返回给上游是状态码，最后需要catch将异常转换为外部状态码</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123153212173.png" alt="image-20240123153212173"></p><ul><li><p>不要吃掉异常，一定要打日志</p></li><li><p>调用方不要感知错误码，否则沟通更新成本高，需要和全部上游对齐</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240123153725656.png" alt="image-20240123153725656"></p></li></ul><h2 id="15-打日志是技术活"><a href="#15-打日志是技术活" class="headerlink" title="15.打日志是技术活"></a>15.打日志是技术活</h2><p><a href="#%E6%89%93%E6%97%A5%E5%BF%97">打日志</a></p><h2 id="16-技术文档"><a href="#16-技术文档" class="headerlink" title="16.技术文档"></a>16.技术文档</h2><p>目的：</p><ul><li>确保方案可行</li><li>提早识别风险</li><li>对齐系统修改</li><li>评估工时投入</li></ul><h3 id="金币提现场景"><a href="#金币提现场景" class="headerlink" title="金币提现场景"></a>金币提现场景</h3><p><a href="https://www.yuque.com/codingbetterlife/lession/pka2nhb3yqoiqbhl?singleDoc">https://www.yuque.com/codingbetterlife/lession/pka2nhb3yqoiqbhl?singleDoc</a><br>密码：wsg3</p><h4 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h4><p>功能点：用户提现金币到银行卡，有每天的限额</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240125134907012.png" alt="image-20240125134907012"></p><ul><li>页面展示：总金币、可提现金币、额度、银行卡</li><li>准备提现：输入金额，并调取后端查询收费</li><li>确认提现：扣减金币到银行卡</li></ul><h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240125134931139.png" alt="image-20240125134931139"></p><p>其中具体的每一个具体服务使用流程引擎实现</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240125135035515.png" alt="image-20240125135035515"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>系统架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能短链设计</title>
    <link href="/2023/12/27/TechDigest/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9F%AD%E9%93%BE%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/12/27/TechDigest/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9F%AD%E9%93%BE%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要讨论了短链接服务的实现原理和技术方案。以下是关键内容总结：  1. <strong>短链接的作用</strong>：在文字限制场景（如微博）节省空间，生成的二维码更易识别；通过302重定向实现跳转并统计点击数。  2. <strong>生成短链接的核心方法</strong>：      - 使用非加密哈希函数（如MurmurHash的32位版本）将长链转为数字，再通过62进制编码缩短字符长度。      - 为长链的MD5建立数据库唯一索引，避免重复生成；若哈希冲突则添加标识符重新计算。  3. <strong>存储设计</strong>：      - MySQL表中存储长短链映射关系，包含长链MD5字段加速查询。      - 配合布隆过滤器快速判断是否存在，减少数据库查询压力。  4. <strong>分布式ID生成方案对比</strong>：      - <strong>UUID</strong>：无需中心化但可能影响插入性能。      - <strong>Redis INCR</strong>：性能高但需考虑持久化成本。      - <strong>Snowflake</strong>：需处理时钟回拨问题。      - <strong>MySQL自增ID</strong>：通过预分配号段（如区间步长+版本号控制并发）缓解高并发写入压力。  整体流程：用户访问短链→查询数据库获取长链→302跳转。技术关键点在于高效无冲突的哈希转换、唯一ID分配及高并发存储优化。</p></blockquote><p>原文链接：<a href="https://juejin.cn/post/6844904090602848270">高性能短链设计 - 掘金 (juejin.cn)</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>将长连接转为一个短连接，并且再访问时再转换回来</p><p>短链：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318150323802.png" alt="image-20240318150323802" style="zoom:50%;" /><p>最终长链</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318150335744.png" alt="image-20240318150335744"></p><p>可以看到，短信中的是短链，但最后变成了长链；使用短链的好处</p><ol><li>再具有文字限制的地方（微博），用短链可以占据更少的文字</li><li>短链对应转的二维码不密集，更容易识别</li></ol><p>跳转的基本实现：请求短链时，会返回状态码302（临时重定向：每次都使用短链请求，易于点击数统计）以及长链的地址</p><h2 id="生成算法"><a href="#生成算法" class="headerlink" title="生成算法"></a>生成算法</h2><h3 id="1-HASH"><a href="#1-HASH" class="headerlink" title="1.HASH"></a>1.HASH</h3><h4 id="生成hash"><a href="#生成hash" class="headerlink" title="生成hash"></a>生成hash</h4><p>将长信息转为断信息，最简单有效的方式就是hash</p><ol><li><strong>加密哈希函数（Cryptographic Hash Functions）</strong>：这些函数被设计为具有一系列加密属性，包括抗碰撞性（collision-resistant）、隐藏性（hiding）和抗篡改性（tamper-evident）。它们用于密码学安全、数据完整性验证等场合。常见的加密哈希算法有SHA-256、SHA-3、MD5（现在被认为是不安全的）等。</li><li><strong>非加密哈希函数（Non-cryptographic Hash Functions）</strong>：这些函数主要用于数据结构（如哈希表）中快速数据检索、数据压缩、负载均衡等非安全相关的场合。它们的设计重点在于速度和效率，而不是安全性。常见的非加密哈希函数包括MurmurHash、CityHash等。</li></ol><p>这里我们当然选择非加密的Hash算法，例如MurmurHash</p><p>MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，32 bit 能表示的最大值近 43 亿，对于中小型公司的业务而言绰绰有余。对上文提到的极客长链做 MurmurHash 计算，得到的哈希值为 3002604296</p><h4 id="缩短长度："><a href="#缩短长度：" class="headerlink" title="缩短长度："></a>缩短长度：</h4><p>这里的数字都是十进制的表示，我们可以将10进制转为62进制（10+26+26；比base64少 + 和 &#x2F;，以及填充字符&#x3D;）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318151541698.png" alt="image-20240318151541698"></p><h4 id="解决哈希冲突并存储"><a href="#解决哈希冲突并存储" class="headerlink" title="解决哈希冲突并存储"></a>解决哈希冲突并存储</h4><p>短链映射长链：使用mysql 或 redis，配合唯一索引</p><p>此外，为了同一个长链不重复生成短链，需要将长链建议索引，为了索引不要太长使用长链的MD5建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `short_url_map` (<br>  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,<br>  `lurl` varchar(160) DEFAULT NULL COMMENT &#x27;长地址&#x27;,<br>   `md5` char(32) DEFAULT NULL COMMENT &#x27;长链md5&#x27;,<br>  `surl` varchar(10) DEFAULT NULL COMMENT &#x27;短地址&#x27;,<br>  `gmt_create` int(11) DEFAULT NULL COMMENT &#x27;创建时间&#x27;,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><ol><li><p>查询长链的MD5是否已经存在，存在直接返回</p></li><li><p>将长链（lurl）经过 MurmurHash 后得到短链。</p></li><li><p>将长短链对应关系插入 db 中，如果 db 里不含有此短链的记录，则插入，如果包含了，说明违反了唯一性索引，此时只要给长链再加上我们上文说的自定义字段「DUPLICATE」,重新 hash 再插入即可，看起来在违反唯一性索引的情况下是多执行了步骤，但我们要知道 MurmurHash 发生冲突的概率是非常低的，基本上不太可能发生，所以这种方案是可以接受的。</p></li></ol><p>此外，快速有效判断一个元素是否存在可以使用布隆过滤器，先经过布隆过滤器再插入数据库</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318152646488.png" alt="image-20240318152646488" style="zoom:67%;" /><h3 id="2-自增序列"><a href="#2-自增序列" class="headerlink" title="2.自增序列"></a>2.自增序列</h3><h4 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318154514607.png" alt="image-20240318154514607" style="zoom:67%;" /><ol><li><p><strong>uuid</strong></p><p>UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，但这种方式生成的 id 比较长，且无序，在插入 db 时可能会频繁导致<strong>页分裂</strong>，影响插入性能。<strong>无需中心化管理</strong></p></li><li><p><strong>redis</strong></p><p><code>INCR</code>：性能好，单机可支撑 10 w+ 请求，还可以做分布式</p><p>缺点：需要考虑持久化（短链 ID 总不能一样吧），灾备，成本有点高。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318153824226.png" alt="image-20240318153824226"></p></li><li><p><strong>Snowflake</strong></p><p>时钟回拨：抛出异常；延时等待（阻塞3ms）；序列号（增加序列号避免冲突）</p></li><li><p><strong>Mysql</strong> 自增</p><p>简单方便</p></li></ol><h4 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h4><p>如果用 Mysql 自增 id 作为短链 ID，在高并发下，db 的写压力会很大，这种情况该怎么办呢。</p><p>考虑一下，一定要在用到的时候去生成 id 吗，是否可以提前生成这些自增 id ?</p><p>发号表：代表已经发出去的id，每行为一个区间，给一台机器</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318154839222.png" alt="image-20240318154839222"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240318155037597.png" alt="image-20240318155037597"></p><p>或者直接一行为一个业务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `sequence_id_generator` (<br>  `id` int(10) NOT NULL,<br>  `current_max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,<br>  `step` int(10) NOT NULL COMMENT &#x27;号段的长度&#x27;,<br>  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,<br>  `biz_type`    int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,<br>   PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;<br><br>current_max_id ~ current_max_id + step已经被取走了<br></code></pre></td></tr></table></figure><p>获取唯一ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101<br></code></pre></td></tr></table></figure><p>分配新的区间，version实现并发管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0  AND `biz_type` = 101<br>SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844904090602848270">高性能短链设计今天，我们来谈谈如何设计一个高性能短链系统，短链系统设计看起来很简单，但每个点都能展开很多知识点，也是在面 - 掘金 (juejin.cn)</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/user/1926000099501934/posts">高性能短链设计</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://javaguide.cn/distributed-system/distributed-id.html">分布式ID介绍&amp;实现方案总结 | JavaGuide</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章精读</tag>
      
      <tag>系统架构</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU故障排查</title>
    <link href="/2023/12/17/CPU%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/"/>
    <url>/2023/12/17/CPU%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>在压测考试期间，作者发现resource、teacher-admin等微服务的CPU利用率达到100%，但相关负责同学并不了解原因。经过排查，作者发现需要进入pod内部使用jstack等工具进行线程分析，但pod基于jre镜像构建，缺少jdk工具，因此通过配置阿里云镜像源并安装procps、openjdk-11-jdk等工具解决了环境问题。    作者通过TOP命令定位进程pid，结合ps和jstack命令分析线程执行情况，但未能获取具体代码信息，转而使用arthas工具。通过arthas最终定位到问题代码——一段为nacos添加配置监听器的逻辑。开发同学误解了官方文档中while(true)的作用，错误地认为需要保持线程存活以防止守护线程退出（实际nacos会自动维护监听线程）。这段冗余代码导致CPU持续满载，若多次调用甚至会使CPU占用达200%。    问题代码位于公共模块的静态代码块中，当类被加载时会触发，导致部分pod出现高CPU现象。此外，该问题引发k8s集群动态扩容，加剧了资源消耗。修复后，集群CPU使用率显著下降，并缩减了3台4核16G的机器资源。作者强调，正式代码中无需保留while循环，仅需正确使用addListener即可，同时指出即使保留Thread.sleep(1000)也不会导致CPU满载。最终问题根源在于对守护线程机制的误解和冗余代码的设计。</p></blockquote><h1 id="CPU故障排查"><a href="#CPU故障排查" class="headerlink" title="CPU故障排查"></a>CPU故障排查</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在压测考试的时候，无意间看到resource、teacher-admin等微服务CPU利用率百分之百，询问相关负责同学并不了解，于是自己寻找了一下原因。</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312251349397.png" alt="image-20231225130326585" style="zoom:50%;" /><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>​jstack可以定位线程的执行情况，因此直接进入pod内部执行，发现并没有找到此命令，查看dockerfile打包文件发现打包时是基于jre镜像构建的，并没有jdk中的其他工具，因此需要先安装工具。此外TOP等命令也没有，需要安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">// 先配置镜像<br><span class="hljs-keyword">echo</span> <span class="hljs-comment">&quot;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib</span><br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster main non-free contrib<br><span class="hljs-keyword">deb</span> http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian-security buster/updates main<br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian-security buster/updates main<br><span class="hljs-keyword">deb</span> http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-updates main non-free contrib<br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-updates main non-free contrib<br><span class="hljs-keyword">deb</span> http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-backports main non-free contrib<br><span class="hljs-keyword">deb</span>-src http://mirrors.aliyun.<span class="hljs-keyword">com</span>/debian/ buster-backports main non-free contrib<span class="hljs-comment">&quot; &gt; /etc/apt/sources.list</span><br><br><br>apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br><br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> procps<br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> curl<br><br><span class="hljs-built_in">mkdir</span> -<span class="hljs-keyword">p</span> /usr/share/man/man1<br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> openjdk-<span class="hljs-number">11</span>-jdk<br></code></pre></td></tr></table></figure><ul><li>执行TOP命令，定位微服务pid</li><li>执行 <code>ps H -eo pid, tid, %cpu | grep pid</code>  搜索出线程id以及cpu</li><li><code>printf &#39;0x%x\n&#39; pid</code>  将线程id转为16进制</li><li><code>jstack pid | grep  线程id</code>  查看线程执行的情况</li></ul><p>最后jstack定位发现该线程为守护进程，并没有给出具体的代码行以及其他信息，因此转向其他工具</p><h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -O https:<span class="hljs-regexp">//</span>arthas.aliyun.com/arthas-boot.jar<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java-<span class="hljs-number">1.11</span>.<span class="hljs-number">0</span>-openjdk-amd64<span class="hljs-regexp">/bin/</span>java -jar arthas-boot.jar <span class="hljs-comment"># 这里执行需要指定刚刚安装的jdk，否则默认只有jre会报错</span><br></code></pre></td></tr></table></figure><p>arthas给出了线程执行的代码行，直接定位到了错误代码，如下图</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312251349398.png" alt="image-20231225133834955"></p><p>至此错误的原因找到了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这段代码的目的是为nacos添加一个推送变更配置，当dataid发生变化时，执行listener保存下最新的配置，官方文档如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;serverAddr&#125;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;dataId&#125;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;group&#125;&quot;</span>;<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.put(<span class="hljs-string">&quot;serverAddr&quot;</span>, serverAddr);<br><span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> NacosFactory.createConfigService(properties);<br><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br>System.out.println(content);<br>configService.addListener(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;recieve1:&quot;</span> + configInfo);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 测试让主线程不退出，因为订阅配置是守护线程，主线程退出守护线程就会退出。 正式代码中无需下面代码</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​但编码的同学理解错误了文档中while true的作用，当执行完<code>addListener</code>后，nacos会自动创建守护进程监听配置变化，如果<strong>所有非守护进程结束该守护进程才会结束</strong>，所以正式部署中并不需要执行<code>addListener</code>的线程一直存活，整个微服务当然会有非守护进程在执行，这段代码直接删去即可。</p><p>​此外，如果没有删除官方文档中的<code>Thread.sleep(1000);</code> 即便编码是错误的方式，其实也不会导致cpu直接占满</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>该段代码是在某些类的static代码块中调用，只有类被加载时才会导致该bug触发，所以可以看到图中有少部分pod并没有占满cpu</li><li>这个bug直接导致pod上cpu利用率占满（如果addListener两次，CPU直接会到200%），并且会触发动态扩容策略，导致第一张图中的一群pod中cpu都占满；</li><li>该代码编写在common中，导致用到的所有微服务（如resource、course）都会触发</li><li>修复后k8s集群整体cpu大幅度下降，弹性伸缩关闭了3台4核16G机器<br><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312251349400.png" alt="image-20231225133944117"></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
      <tag>优化</tag>
      
      <tag>水杉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>订单超时处理</title>
    <link href="/2023/12/15/TechDigest/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/"/>
    <url>/2023/12/15/TechDigest/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>在电商场景中，订单超时自动处理（如未付款取消、未发货关闭、自动收货等）是一个核心需求。文章分析了多种技术实现方案及其优缺点：  1. <strong>DelayQueue方案</strong>      - 通过延迟队列按超时时间排序，单线程轮询处理。启动时需从数据库加载未完成订单。      - 优点：实现简单，无第三方依赖。      - 缺点：内存占用高，无法分布式扩展，仅适合小规模场景。  2. <strong>RabbitMQ延迟队列</strong>      - 利用死信交换机和TTL实现固定延时等级（如5s、10s）。需预定义多级延时队列。      - 优点：支持海量消息与分布式处理。      - 缺点：延时时间不灵活，配置复杂。  3. <strong>时间轮算法</strong>      - 通过循环队列和层级时间轮处理大范围延时（如24小时内），支持任意时刻精度。      - 优点：延时精度高，使用简单。      - 缺点：同一时刻大量消息易导致延迟，MQ存储成本高。  4. <strong>Redis过期监听</strong>      - 基于键空间通知实现过期回调，需配置<code>notify-keyspace-events</code>。      - 问题：Redis的惰性删除策略可能导致延时不准。  5. <strong>定时任务批处理</strong>      - 通过分布式调度周期性扫描数据库处理超时订单，需隔离超时库以降低主库压力。      - 优点：稳定性高，适合大规模场景（如阿里超时中心SLA达30秒内）。      - 缺点：精度依赖调度周期，高频扫描可能影响数据库性能。  总结：小规模场景可选DelayQueue；中大规模推荐RabbitMQ固定延时或时间轮算法（需权衡灵活性）；超大流量下定时任务批处理（如超时中心）是更优解，但需独立部署资源。</p></blockquote><p>原文链接：<a href="https://developer.aliyun.com/article/1161311">订单超时处理的几种方案及分析-阿里云开发者社区 (aliyun.com)</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在电商场景下，买卖双方没有面对面交易，许多情况下需要通过超时处理自动关闭订单，如：</p><ul><li>买家超时未付款</li><li>卖家超时未发货</li><li>买家超时自动收货</li></ul><h2 id="JDK自带DelayQueue"><a href="#JDK自带DelayQueue" class="headerlink" title="JDK自带DelayQueue"></a>JDK自带DelayQueue</h2><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240319124145733.png" alt="image-20240319124145733"></p><ol><li>把订单插入DelayQueue中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。</li><li>起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。</li><li>为了防止机器重启导致内存中的DelayQueue数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到DelayQueue中。</li></ol><ul><li><p><strong>优点</strong>：简单，不需要借助其他第三方组件，成本低。</p></li><li><p><strong>缺点：</strong></p></li><li><ul><li>所有超时处理订单都要加入到DelayQueue中，占用内存大。</li><li>没法做到分布式处理，只能在集群中选一台leader专门处理，效率低。</li><li>不适合订单量比较大的场景。</li></ul></li><li></li></ul><h3 id="DelayQueue原理："><a href="#DelayQueue原理：" class="headerlink" title="DelayQueue原理："></a>DelayQueue原理：</h3><ul><li>PriorityQueue(按照超时时间排序) + 锁</li><li>每次取出队头，并且判断是否已经超时，如果没有超时需要等待；为了只有一个消费者等待队头，添加了一个leader</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>                available.await();<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> q.poll();<br>                first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>                    available.await(); <span class="hljs-comment">// 非leader一直等待</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay); <span class="hljs-comment">// leader只等待队头元素过期时间</span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; q.peek() != <span class="hljs-literal">null</span>)<br>            available.signal();<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            q.offer(e);<br>            <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>                leader = <span class="hljs-literal">null</span>;<br>                available.signal();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="RabbitMQ的延时消息"><a href="#RabbitMQ的延时消息" class="headerlink" title="RabbitMQ的延时消息"></a>RabbitMQ的延时消息</h2><ul><li>RabbitMQ Delayed Message Plugin（非高可用）</li><li>消息的TTL+死信Exchange</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240319124838271.png" alt="image-20240319124838271"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240326121154965.png" alt="image-20240326121154965"></p><ol><li>定义一个BizQueue，用来接收死信消息，并进行业务消费。</li><li>定义一个死信交换机(DLXExchange)，绑定BizQueue，接收延时队列的消息，并转发给BizQueue。</li><li>定义一组延时队列DelayQueue_xx，分别配置不同的TTL，用来处理固定延时5s、10s、30s等延时等级，并绑定到DLXExchange。</li><li>定义DelayExchange，用来接收业务发过来的延时消息，并根据延时时间转发到不同的延时队列中。</li></ol><ul><li><p>优点：可以支持海量延时消息，支持分布式处理。</p></li><li><p>缺点：</p></li><li><ul><li>不灵活，只能支持固定延时等级。</li><li>使用复杂，要配置一堆延时队列。</li></ul></li><li></li></ul><h2 id="RocketMQ的定时消息"><a href="#RocketMQ的定时消息" class="headerlink" title="RocketMQ的定时消息"></a>RocketMQ的定时消息</h2><h3 id="时间轮算法"><a href="#时间轮算法" class="headerlink" title="时间轮算法"></a>时间轮算法</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240319130800851.png" alt="image-20240319130800851"></p><p>指针代表当前时刻，slot上有每个时刻上等待的任务，链表串起来</p><ul><li>时间转一下代表过去1s</li><li>遍历slot上的链表，if round &gt; 0   round –   否则开始处理消息</li><li>新消息到达 Slot&#x3D;(curTime + delay) mod total_slot，round &#x3D; (curTime + delay) &#x2F; total_slot</li></ul><h3 id="延时最大限制"><a href="#延时最大限制" class="headerlink" title="延时最大限制"></a>延时最大限制</h3><p>定时时长最大值24小时，使用循环处理实现大延时</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240319131311872.png" alt="image-20240319131311872"></p><ul><li><p>优点</p></li><li><ul><li>精度高，支持任意时刻。</li><li>使用门槛低，和使用普通消息一样。</li></ul></li><li><p>缺点</p></li><li><ul><li>成本高：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。</li><li>同一个时刻大量消息会导致消息延迟：定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</li><li></li></ul></li></ul><h2 id="Redis的过期监听"><a href="#Redis的过期监听" class="headerlink" title="Redis的过期监听"></a>Redis的过期监听</h2><ol><li>redis配置文件开启”notify-keyspace-events Ex”</li><li>配置过期回调</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisListenerConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    RedisMessageListenerContainer <span class="hljs-title function_">container</span><span class="hljs-params">(RedisConnectionFactory factory)</span>&#123;<br>        RedisMessageListenerContainer container=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisMessageListenerContainer</span>();<br>        container.setConnectionFactory(factory);<br>        <span class="hljs-keyword">return</span> container;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisKeyExpirationListerner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KeyExpirationEventMessageListener</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisKeyExpirationListerner</span><span class="hljs-params">(RedisMessageListenerContainer listenerContainer)</span> &#123;<br>        <span class="hljs-built_in">super</span>(listenerContainer);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">byte</span>[] pattern)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">keyExpira</span> <span class="hljs-operator">=</span> message.toString();<br>        System.out.println(<span class="hljs-string">&quot;监听到key：&quot;</span> + expiredKey + <span class="hljs-string">&quot;已过期&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题：</strong>redis的key是惰性删除+定期删除，延时不正确</p><h2 id="定时任务分布式批处理"><a href="#定时任务分布式批处理" class="headerlink" title="定时任务分布式批处理"></a>定时任务分布式批处理</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240319135208503.png" alt="image-20240319135208503"></p><ul><li>稳定性强：没有引入额外中间件</li><li>效率高：批处理</li></ul><p>但是使用<strong>定时任务</strong>有个天然的<strong>缺点</strong>：没法做到精度很高。定时任务的延迟时间，由定时任务的调度周期决定。如果把频率设置很小，就会导致数据库的qps比较高，容易造成数据库压力过大，从而影响线上的正常业务。</p><p>所以一般需要抽离出超时中心和超时库来单独做订单的超时调度，在阿里内部，几乎所有的业务都使用<strong>基于定时任务分布式批处理的超时中心来做订单超时处理</strong>，SLA可以做到30秒以内：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240319135535171.png" alt="image-20240319135535171"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构</category>
      
      <category>设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章精读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考试重构-压测</title>
    <link href="/2023/11/23/%E8%80%83%E8%AF%95%E9%87%8D%E6%9E%84-%E5%8E%8B%E6%B5%8B/"/>
    <url>/2023/11/23/%E8%80%83%E8%AF%95%E9%87%8D%E6%9E%84-%E5%8E%8B%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>文章摘要：    该技术文档描述了在线考试系统的优化过程，主要解决原有系统在高并发场景下的性能问题。原系统存在Redis缓存使用不合理、代码耦合度高、考试模式分散等问题，导致30人并发就可能出现无法进入考试或提交失败的情况。优化措施包括：    1. <strong>Redis缓存重构</strong>：区分共享数据（题目、考试信息）和个人答题数据，调整缓存时间；删除冗余的预热和判活逻辑，将定时缓存改为上下题切换时触发，减少无效负载。   2. <strong>代码结构优化</strong>：通过多态设计（如工厂模式）统一处理练习、考试、模拟考试等不同模式，替换原有的条件表达式逻辑，降低耦合性。   3. <strong>缓存策略改进</strong>：采用一个Redis key存储全部答案列表（而非每题一个key），避免考试开始&#x2F;结束时遍历插入和读取的开销。   4. <strong>引入消息队列</strong>：通过MQ异步处理交卷请求，先更新Redis确保快速响应，再异步持久化到数据库，缓解并发压力。   5. <strong>性能压测与瓶颈分析</strong>：      - 测试发现动态扩容会瞬间导致系统崩溃，需提前预扩容Pod。      - 高并发下数据库成为瓶颈（非预期SQL查询），需优化全链路监控（如SkyWalking）以定位慢查询。    关键结论：系统优化需兼顾自身代码和全链路资源（如MySQL、Gateway），CPU利用率和可观测性工具是排查性能瓶颈的核心手段。</p></blockquote><p>11&#x2F;10 ~ 11&#x2F;23</p><h3 id="重构原因"><a href="#重构原因" class="headerlink" title="重构原因"></a>重构原因</h3><ul><li>原来考试系统bug很多，redis使用也不合理，30人的考试就可能存在有人进不去考试、交不了卷的情况</li><li>原来的代码耦合性高，练习模式、考试模式可能开始考试用的不同函数、进入考试用的不同的函数，有时候改一个地方的功能影响到了另外的地方</li></ul><h3 id="重构基本思想"><a href="#重构基本思想" class="headerlink" title="重构基本思想"></a>重构基本思想</h3><ul><li>考试数据分为共享数据（题目、考试等）和个人做题数据，共享数据使用redis进行缓存，缓存时间可以小一点，个人做题数据时间需要改大一些，至少要超过考试的时间，防止学生答案丢失</li><li>原来代码做了预热逻辑，该部分对系统整体提升不大，删去；redis判活部分没有必要，redis可靠性还是很高的，如果想做redis开关也不应该用threadlocal，应该是一个统一开关</li><li>原来缓存答案逻辑是定时缓存，定时缓存系统负载很大，很多请求都是无效的请求，改成上下题切换时进行缓存</li><li>目前系统支持的考试类型包含：练习、考试、模拟考试、课程评价。不同的模式有不同的处理，使用多态来优化代码结构；《以多态取代条件表达式》</li><li>缓存答案有两种思想：一题一个key-value，一个key保存一个answerList，最终选择方案为answerList，可以避免进入考试时对redis的遍历插入以及考试结束时的遍历读取</li></ul><h3 id="重构步骤"><a href="#重构步骤" class="headerlink" title="重构步骤"></a>重构步骤</h3><ol><li>删除原来所有有关redis缓存的全部代码，测试</li><li>编写redis缓存通用类，将 （redis缓存不存在时，自动取数据库读取并插回redis）封装</li><li>编写公共缓存管理类，全部有关缓存的代码都在此进行，包括缓存不存在时的mybatisplus数据库读取操作，service必须使用这里暴露的公共方法（使用缓存），禁止在service中直接查询数据库。</li><li>在考试模式跑通测试后，编写多态代码扩展到（练习、考试、模拟考试、课程评价）模式</li><li>引入消息队列对交卷进行优化</li></ol><h4 id="redis通用类"><a href="#redis通用类" class="headerlink" title="redis通用类"></a>redis通用类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 序列化方式 GenericFastJsonRedisSerializer 可以直接强转</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCache</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> defaultExpiration;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimeUnit defaultExpirationUnit;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCache</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate, <span class="hljs-type">long</span> defaultExpiration, TimeUnit defaultExpirationUnit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.defaultExpiration = defaultExpiration;<br>        <span class="hljs-built_in">this</span>.defaultExpirationUnit = defaultExpirationUnit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) redisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(String key, Supplier&lt;T&gt; supplier, <span class="hljs-type">long</span> expiration, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (T) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            value = supplier.get();<br>            put(key, value, expiration, unit);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公共缓存管理类"><a href="#公共缓存管理类" class="headerlink" title="公共缓存管理类"></a>公共缓存管理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonRedisCacheBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXAM_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;v2Exam:resourceId:%s&quot;</span>;<br><br>RedisTemplate&lt;String, Object&gt; objectRedisTemplate;<br>    <br>    <span class="hljs-keyword">public</span> RedisCache&lt;Exam&gt; EXAM_CACHE;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommonRedisCacheBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;objectRedisTemplate&quot;)</span> RedisTemplate&lt;String, Object&gt; objectRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.objectRedisTemplate = objectRedisTemplate;<br>        <span class="hljs-built_in">this</span>.EXAM_CACHE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCache</span>&lt;&gt;(objectRedisTemplate, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Exam <span class="hljs-title function_">getExam</span><span class="hljs-params">(String resourceId)</span>&#123;<br>        <span class="hljs-keyword">return</span> EXAM_CACHE.get(String.format(EXAM_KEY, resourceId),<br>                () -&gt; examMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;Exam&gt;().eq(Exam::getResourceId, resourceId)));<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseExamHandler</span> &#123;<br>    <span class="hljs-comment">// 获取提示getNotice 不实现，交给子类</span><br> <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getNotice</span><span class="hljs-params">(Exam exam)</span>&#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;This method is not implemented&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 很多都一样，定义在父类</span><br>    <span class="hljs-keyword">public</span> ExamDataRes <span class="hljs-title function_">getExamInfo</span><span class="hljs-params">(String resourceId)</span> &#123;<br><span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExerciseHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseExamHandler</span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 具体自己的实现</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getNotice</span><span class="hljs-params">(Exam exam)</span> &#123;<br>        Map&lt;String, Object&gt; noticeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> noticeMap;<br>    &#125;<br><span class="hljs-comment">// 直接调用父</span><br>    <span class="hljs-keyword">public</span> ExamDataRes <span class="hljs-title function_">getExamInfo</span><span class="hljs-params">(String resourceId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getExamInfo(resourceId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamHandlerFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, BaseExamHandler&gt; handlerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExamHandlerFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">            ExerciseHandler exerciseHandler,</span><br><span class="hljs-params">            ExamHandler examHandler,</span><br><span class="hljs-params">            SimulationHandler simulationHandler,</span><br><span class="hljs-params">            EvaluateHandler evaluateHandler)</span> &#123;<br>        handlerMap.put(ExamType.EXERCISE, exerciseHandler);<br>        handlerMap.put(ExamType.EXAM, examHandler);<br>        handlerMap.put(ExamType.EXAM_SIMULATION, simulationHandler);<br>        handlerMap.put(ExamType.Evaluate, evaluateHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BaseExamHandler <span class="hljs-title function_">getHandler</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>        <span class="hljs-type">BaseExamHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> handlerMap.get(type);<br>        <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid exam type&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BaseExamHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> examHandlerFactory.getHandler(exam.getType());<br>handler.startExam(resourceId, exam);<br></code></pre></td></tr></table></figure><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>​引入原因：考试有两个并发峰值：进入考试阶段以及交卷阶段，进入考试阶段设计数据库的读取操作（考生是否进入过考试，进入过需要取出答案），提交阶段涉及数据库的插入操作。海量的数据库插入操作会影响系统的并发，使用mq来优化可以减轻系统压力，削峰</p><p>mq使用逻辑</p><ul><li>在学生提交交卷请求时，立马更新redis，之后直接返回。redis更新成功代表考试交卷成功，并同时发送一个mq请求</li><li>mq消费者消费该消息，将数据从redis插入到数据库</li><li>mq消费函数是幂等的，mq需要保证至少一次消费</li></ul><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><p>查看系统的负载</p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p><strong>可能的影响因素：</strong></p><ul><li>代码质量，是否使用缓存，缓存命中率</li><li>exam pod数量，pod的Xmx</li><li>gateway 、usercenter pod数量</li><li>redis </li><li>mysql</li></ul><p><strong>注意：</strong></p><ol><li>pod扩容应该在考试前进行，动态扩容瞬间系统会炸</li><li>每次压测前注意清理oom的pod</li></ol><p><strong>参数：</strong></p><ul><li>人数x&#x3D;6k~10k</li><li>warm-up&#x3D;100s</li><li>题目延时5~180s，平均delay &#x3D; 92.5s</li></ul><p>进入峰值QPS &#x3D; 在进入考试warm结尾：x&#x2F;warm * 3(notices\startExam\getExamInfo) + x&#x2F;delay </p><p>另外当交卷开始时会达到第二个峰值</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>3pod压2k人，无压力</li><li>开启动态扩容，压4k人，扩容瞬间系统崩溃</li><li>提前给开好10pod 6k人，不使用mq，峰值在进入考试结尾以及交卷，尤其是交卷。交卷90%达到了10sRT。<ol><li>分析：exam-pod的cpu利用率不高，推测是gateway usercenter的原因（第一时间运维同学不在没有找到mysql的pod），扩容gateway usercenter发现还是没有用</li><li>rt:<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202311232119135.png" alt="image-20231122140548390"></li></ol></li><li>在找到<strong>mysql</strong>机器后发现mysql负载很高，理论上如果同一场考试同一批人连续压测，不应该有任何mysql请求，全部数据都进入了缓存，回到本地机器调试开启gateway usercenter的debug发现，任何一个请求都进行了额外数据库的查询，该查询不合理需要优化掉，因此本次压测暂时到此结束。</li><li>此外skywalking也给出了慢SQL，但是第一时间没有关注到</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>在系统中，除了要关注自己写的代码外， 还需要注意整条链路；自己写的代码再好有别的瓶颈也没有用</li><li>cpu利用率是最简单的查看瓶颈的方式</li><li>可观测的重要性</li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
      <tag>优化</tag>
      
      <tag>水杉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对账体系建设</title>
    <link href="/2023/11/15/TechDigest/%E5%AF%B9%E8%B4%A6%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE/"/>
    <url>/2023/11/15/TechDigest/%E5%AF%B9%E8%B4%A6%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>文章主要讨论了清结算系统中因业务复杂度高（场景多、链路长、数据量大）导致的一致性挑战，并重点阐述了对账系统在保障资金安全中的作用。    <strong>核心问题</strong>：70%的系统问题源于上下游交互的“一致性问题”，具体表现为漏结、重复结、错结三类数据不一致场景。尽管可通过强一致性协议（如TCC）或最终一致性方案（如消息事务）在事中降低风险，但因环境故障、代码缺陷等因素，完全预防不可行，需依赖事后对账机制发现问题并修复。    <strong>对账系统设计</strong>：   1. <strong>数据准备</strong>：支持拉取、推送、文件上传等方式接入多源数据；   2. <strong>数据核对</strong>（核心环节）：      - <strong>目标</strong>：覆盖漏&#x2F;重&#x2F;错结问题，确保核对覆盖度与准确性。      - <strong>方式</strong>：优先双向对账（全面性）结合单向对账；按场景选择明细对账（精准定位）或总数对账（效率）。      - <strong>逻辑模板</strong>：标准化两方比对（条目&#x2F;金额匹配）与自身异常检测（重复&#x2F;状态异常）。   3. <strong>差错处理</strong>：通过离线（T+1周期）和在线（实时&#x2F;准实时）对账结合，实时拦截高风险问题（如付款前拦截异常账单）。    <strong>技术实现</strong>：在线对账平台分管理层（策略配置）与执行层，通过监听Binlog、MQ等实现异步（如Kafka-Storm架构检测漏结算）和同步对账（结算链路内实时拦截）。最终形成以周期对账为主、实时为辅的多层次防护体系。</p></blockquote><p>原文链接：<a href="https://tech.meituan.com/2018/03/21/balance-accounts.html">https://tech.meituan.com/2018/03/21/balance-accounts.html</a></p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>业务复杂性高：场景多、链路长、数据量大，给资金安全带来了巨大挑战</p><p>可能出现问题的场景：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325141416774.png" alt="image-20240325141416774"></p><p>可以看出，这些都是一些上下游交互的边界场景，以及遇到的问题。当然不仅限于这些场景，凡是有系统交互、数据交互边界的场景，都会出现此类问题，我们称之为“一致性问题”。经粗略统计，我们清结算系统建立以来有70%左右的问题都属于一致性问题。</p><p>解决一致性问题的方法：目标都是在<strong>事中</strong>避免问题的发生。</p><blockquote><ul><li>强一致性协议: 两阶段提交、三阶段提交、TCC (Try-Confirm-Cancel)等</li><li>最终一致性: 主动轮询、异步确保、可靠消息、消息事务等</li></ul></blockquote><p>但是在实际场景中，导致一致性问题的原因有很多，无论是系统的内部逻辑还是外部环境都十分复杂多变、不可预知，我们很难完全避免问题：</p><ul><li>幂等、并发控制不当。</li><li>基础环境故障：比如网络、数据库、消息中间将发生故障。</li><li>其他代码bug。</li></ul><p>因此事后对于问题数据的<strong>发现</strong>以及<strong>修复</strong>就显得尤为重要。这就是对账系统</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li>数据准备</li><li>数据核对（轧账）</li><li>差错处理（平账）</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325142044925.png" alt="image-20240325142044925"></p><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>将对账所需的全部数据，接入到我们的对账系统</p><ul><li>数据拉取：我们主动拉取数据，并通过数据适配的方式，将数据存储到对账数据池中。</li><li>数据推送：由数据接入方将数据通过ETL（Extract-Transform-Load）等方式直接推送到我们的对账数据池中，数据格式由数据接入方自行适配。</li><li>文件上传：我们会提供标准的文件模板，由数据接入方填充数据，通过文件上传的方式将数据接入到我们的数据池。</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325151242152.png" alt="image-20240325151242152"></p><p>此外，也可用使用同一个数据源</p><h3 id="数据核对（轧账）"><a href="#数据核对（轧账）" class="headerlink" title="数据核对（轧账）"></a>数据核对（轧账）</h3><p>核心！其目标是发现问题数据。数据核对阶段我们的两个目标是保障数据核对的**<em>覆盖度*<strong>和</strong></em>准确性***。经过总结和梳理，数据核对过程可以分为以下5个环节。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325153926427.png" alt="image-20240325153926427"></p><h4 id="1-问题梳理"><a href="#1-问题梳理" class="headerlink" title="1. 问题梳理"></a><strong>1. 问题梳理</strong></h4><p>由于数据核对的目标是发现问题，那么我们进行数据核对就要从问题出发，首先明确我们要通过对账发现哪些问题，只有这样才能保证数据核对的覆盖度。经过梳理，我们发现在数据流转中过程中数据的不一致问题可以统一归结为三类，分别是*<strong>漏结*<strong>、</strong>*重复结**<em>、</em></strong>错结***。</p><ul><li>漏结：发起方有数据，而接收方没有数据。举个例子，目前清结算系统会在订单送达时给骑手结算。如果订单的状态是送达，而没有给骑手生成对应的结算数据。就是一种典型的漏结算场景。</li><li>重复结：接收方重复处理。还是上面的例子，如果订单送达，给骑手结算了两次，产生了重复的结算数据，就是重复结算。</li><li>错结：发起方和接受方数据不一致。一般会发生在金额和状态两个字段。比如说订单上的数据是用户加小费3元。结算这边只产生了2元的小费结算数据，就是错结。</li></ul><h4 id="2-对账方式"><a href="#2-对账方式" class="headerlink" title="2. 对账方式"></a><strong>2. 对账方式</strong></h4><p>对账方式主要分为两种，**<em>单向对账*<strong>和</strong></em>双向对账***。</p><ul><li>单向对账：以一方数据为基准进行对账。比如结算跟支付平台，以结算数据为基准和支付平台核对，用来发现结算数据为支付成功，支付平台支付失败等问题。</li><li>双向对账：以双方的数据互为基准对账。既要保证结算数据为成功的，支付平台也要成功，又要保证支付平台数据为成功的，结算数据也要成功。</li></ul><p>显而易见，双向对账更能够全面的发现问题。因此在条件允许的情况下，我们会优先选择双向对账。</p><h4 id="3-对账粒度"><a href="#3-对账粒度" class="headerlink" title="3. 对账粒度"></a><strong>3. 对账粒度</strong></h4><p>对账粒度也分为两种，分别是**<em>明细对账*<strong>和</strong></em>总数对账***。</p><ul><li>明细对账：对双方的每条数据依次进行比对。<ul><li>优点是可以准确定位问题数据。</li><li>缺点是对账口径的设计比较复杂。因为我们需要同时针对漏、重、错三种错误类别设计不同的对账口径，同时还要考虑到业务的边缘场景。稍有不慎，就会影响对账的准确性。</li></ul></li><li>总数对账：选择一个维度，进行总数级别的对账。优缺点和上面相反</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154126578.png" alt="image-20240325154126578"></p><h4 id="4-对账口径"><a href="#4-对账口径" class="headerlink" title="4. 对账口径"></a><strong>4. 对账口径</strong></h4><p>对账口径，也就是具体的对账逻辑的设计。我们会提供固定的**<em>对账模板*<strong>，供不同的对账场景选取。如果某些特殊场景对账模板不能覆盖，也可以采取对账逻辑</strong></em>自定义***的方式进行对账。</p><p>经过总结我们发现，对账的形式无非就是两方比对和自身异常检测两种。两方比对又可以细分为一对一、多对一、一对多。比对方法也主要是分为条目匹配和金额匹配。自身异常检测主要是重复性和异常状态的检测。我们把这些通用的对账逻辑模板化，减少重复的开发工作。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154156166.png" alt="image-20240325154156166"></p><h4 id="5-对账时机"><a href="#5-对账时机" class="headerlink" title="5. 对账时机"></a><strong>5. 对账时机</strong></h4><p>分为<strong><em>离线对账*<strong>和</strong></em>在线对账*</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154327968.png" alt="image-20240325154327968"></p><ul><li><p>离线对账主要是通过固定的周期进行对账。最短周期为Ｔ＋１。它的好处是适用性较强，基本可以覆盖所有的对账场景。</p></li><li><p>在线对账又分为**<em>实时对账*<strong>和</strong></em>准实时对账***。</p><ul><li><p>实时对账和准实时对账的区别主要是<strong>实时对账耦合在结算链路中</strong>，可以在发现问题数据时，对结算流程进行拦截</p></li><li><p>准实时对账是异步进行的，不具备拦截能力。在线对账有一定的局限性，一方面它依赖于对账数据是否能实时的准备好，另一方面也比较占用系统资源。</p></li></ul></li></ul><p>我们的做法应该是以周期对账为主，在某些实时性要求比较高，且条件满足的场景使用在线对账。</p><h3 id="差错处理（平账）"><a href="#差错处理（平账）" class="headerlink" title="差错处理（平账）"></a>差错处理（平账）</h3><p>对问题数据的处理</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154405239.png" alt="image-20240325154405239"></p><h3 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154600192.png" alt="image-20240325154600192"></p><h4 id="离线对账"><a href="#离线对账" class="headerlink" title="离线对账"></a>离线对账</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154706582.png" alt="image-20240325154706582"></p><h4 id="在线对账"><a href="#在线对账" class="headerlink" title="在线对账"></a>在线对账</h4><p>通过RPC、监听消息队列(MQ)、监听数据库binlog三种方式进行对账接入。在线对账平台分为管理层和执行层。管理层主要是承担策略编辑、策略绑定和拦截管理的相关工作。而执行层分为异步（准实时）对账和同步（实时）对账两个模块。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325154846323.png" alt="image-20240325154846323"></p><p>①异步对账：我们分别监听运单和结算单元的Binlog，通过Kafka-&gt;Storm的经典架构，进行对账策略的执行。实际的流程比较复杂，这里只是一张简图，大概就是：（细节可以忽略）</p><blockquote><p>结算单元是 清结算系统内部的模型，和运单是一对一关系，记录运单各个节点的结算状态。收到运单消息后，我们会把对于的运单以List的形式存储到Squirrel(Redis)中，当结算消息来了以后，就把对应运单记录Delete掉。如果有运单记录一直停留在List当中，也就是说明结算消息没有来，应该是发生了漏结算。我们通过过定时任务轮询运单List将问题数据输出。</p></blockquote><blockquote><p>补充：这里在实习时接触到的是监听奖励表binlog，然后MQ发起一个对账请求，核对发奖信息和数据库配置信息是否一致</p></blockquote><p>②同步对账：示例中是结算内部的流程，经历结算单、账单、付款几个流程。因为付款是最后一个流程，如果这个时候数据存在问题，那么就会造成实际的资金损失。因此我们会在付款环节之前，对前面的数据进行对账。如果发现账单和结算单的数据不一致，我们就会进行数据拦截。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构</category>
      
      <category>稳定性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章精读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP数据粘包</title>
    <link href="/2023/10/09/TechDigest/TCP%E6%95%B0%E6%8D%AE%E7%B2%98%E5%8C%85/"/>
    <url>/2023/10/09/TechDigest/TCP%E6%95%B0%E6%8D%AE%E7%B2%98%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>网络层协议通常分为四层，数据以数据包形式传输，每经过一层，数据包头部会增加特定信息（如TCP头含端口号和序列号，IP头含IP地址和长度，MAC头含MAC地址）。数据链路层限制传输包大小（MTU），若数据超过MTU，TCP会将数据分段为MSS（最大分段大小）。MTU一般为1500字节，MSS为1460字节（扣除IP和TCP头部）。    对于小数据包，TCP的Nagle算法优化网络IO效率：若数据未达MSS，则等待后续数据或超时（200ms）后再发送。TCP是基于字节流的协议，发送无边界二进制数据，需依赖应用层协议（如HTTP的Content-Length或分块编码）界定数据边界。    UDP则基于数据报，不合并或拆分应用层数据包，发送和接收保持数据报边界，避免粘包问题。IP层通过分片（利用Identification、Flags和偏移量）重组大数据包，确保数据按序传输。    粘包问题本质是数据边界问题，TCP不处理边界，需应用层解决；UDP自带长度信息，无粘包问题。IP层负责路由和寻址，不关注数据内容；TCP确保可靠性；HTTP等应用层协议定义消息边界。</p></blockquote><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>网络层通常四层协议,数据以一个个包在网络中传输，从上到下每经过一层，数据包头部就多出一些信息；</p><ul><li>TCP头：序列号和确认号、源端口和目的端口</li><li>IP头：源IP和目的IP、长度、偏移</li><li>mac头：源mac和目的mac</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329150618349.png" alt="image-20240329150618349"></p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><p>数据链路层提供给IP层每次传输的包大小有限制MTU，如果超过这个大小TCP 中把消息分成 MSS</p><ul><li><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>最大一次传输数据的大小；一般 MTU&#x3D;<strong>1500 Byte</strong>。<br>假设IP层有 &lt;&#x3D; 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。</li><li><strong>MSS：Maximum Segment Size</strong> 。TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和  TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU&#x3D; 1500 byte，那么 <strong>MSS &#x3D; 1500- 20(IP Header) -20 (TCP Header) &#x3D; 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 &#x3D; 1460，第二个 TCP 切片 &#x3D; 540。</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329150640215.png" alt="image-20240329150640215"></p><h3 id="Nagle-合并"><a href="#Nagle-合并" class="headerlink" title="Nagle 合并"></a><strong>Nagle</strong> 合并</h3><p>上面的情况是拆分包，还有存在相反的情况</p><p>如果每次要传输的报文长度远小于MSS，每次单独发送小包比较浪费网络IO</p><p><code>TCP</code>的 <strong>Nagle 算法</strong>优化，目的是为了避免发送小的数据包。</p><p>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到<code>MSS</code>（或含有<code>Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为<code>200ms</code>），第一个包没到<code>MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329152909877.png" alt="image-20240329152909877"></p><h2 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h2><p><strong>TCP，Transmission Control Protocol</strong>。传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。也就是发送一大堆没有边界的01串，而如何理解这些01是应用层的事情，TCP只负责传输。</p><p>当发送两个msg时，”李东“ ”亚健康终结者“，接收端收到的可能是这样的信息：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329152631380.png" alt="image-20240329152631380"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329153105546.png" alt="image-20240329153105546"></p><h2 id="如何处理粘包"><a href="#如何处理粘包" class="headerlink" title="如何处理粘包"></a>如何处理粘包</h2><ol><li>基于标准的应用层协议（http：content-length、chunked）</li><li>在每条数据包结尾添加一个特殊字符（chunked）</li><li>数据包额外添加包头，用于记录长度（content-length）</li></ol><h2 id="UDP会粘包吗"><a href="#UDP会粘包吗" class="headerlink" title="UDP会粘包吗"></a>UDP会粘包吗</h2><p>不会，UDP是基于数据报的，而不是字节流的；大的UDP数据包会被分成几个小的IP包，这些包在到达目的地后会被重新组装成原始的数据包。分片和重组是在IP层自动进行的，对UDP来说是透明的。</p><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329155317884.png" alt="image-20240329155317884"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329155324080.png" alt="image-20240329155324080"></p><h3 id="IP层拆包重组"><a href="#IP层拆包重组" class="headerlink" title="IP层拆包重组"></a>IP层拆包重组</h3><p>IP层利用<strong>Identification（相同）</strong>、<strong>标志（Flags）和片偏移（Fragment Offset）</strong> 保存片段能够按顺序重组</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">假设主机 ① 出口 MTU 是<span class="hljs-number"> 1500 </span>，它准备发一个长度为<span class="hljs-number"> 4000 </span>字节的 IP 包给主机 ②。<br><br>分片包最大长度为<span class="hljs-number"> 1500 </span>，除去头部的<span class="hljs-number"> 20 </span>字节，数据部分只剩<span class="hljs-number"> 1480 </span>。这意味着，原包<span class="hljs-number"> 3980 </span>字节至少需要分为<span class="hljs-number"> 3 </span>片。<br><br>由于偏移量字段以<span class="hljs-number"> 8 </span>字节为单位，因此每个分片的数据长度必须为<span class="hljs-number"> 8 </span>的倍数，最后一片除外。由于<span class="hljs-number"> 1480 </span>刚好可以被<span class="hljs-number"> 8 </span>整除，因此分片数据长度可以选择<span class="hljs-number"> 1480 </span>。<br><br>第一个分片，包含原包前<span class="hljs-number"> 1480 </span>字节数据，因此偏移量 offset=0 ；而 MF=1 表示后面还有其他分片。第二个分片，包含原包紧接着的<span class="hljs-number"> 1480 </span>字节数据，偏移量 offset = 1480/8 =185 ；同样 MF=1 表示后面还有其他分片。最后一个分片，包含原包最后<span class="hljs-number"> 1020 </span>字节数据，偏移量 offset = 2960/8 =<span class="hljs-number"> 370 </span>；而 MF=0 表示它是最后一片了。<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329160718949.png" alt="image-20240329160718949"></p><h3 id="长度信息冗余吗？"><a href="#长度信息冗余吗？" class="headerlink" title="长度信息冗余吗？"></a>长度信息冗余吗？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">UDP</span> <span class="hljs-meta">Data</span> 的长度 = <span class="hljs-built_in">IP</span> 总长度 - <span class="hljs-built_in">IP</span> Header 长度 - UDP Header 长度<br></code></pre></td></tr></table></figure><ol><li>允许它在除了IP之外的其他网络层协议上运行，不依赖下层协议</li><li>长度信息使得在应用层也避免了粘包的发生</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240329155537898.png" alt="image-20240329155537898"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>粘包问题其实就是数据包的边界问题，length是最简单的解决方式</li><li><code>IP 层</code>：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。任务是路由和寻址</li><li><code>UDP层</code> 是基于数据报的传输协议，不会有粘包问题（有length）。</li><li><code>TCP层</code>：任务是完整性和可靠性，但也不管数据的边界，想要确定边界需要添加标识或者直接交给应用层做</li><li><code>http层</code>：关注消息的边界（length），tcp层只需要帮我把数据可靠的送到就行</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[<a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492768&idx=1&sn=686087613bf6689e899b2cdb606ea780">网络坦白局] TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 (qq.com)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
      <tag>文章精读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂 Redis 架构演化之路(腾讯技术工程)</title>
    <link href="/2023/09/10/TechDigest/Redis%20%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    <url>/2023/09/10/TechDigest/Redis%20%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>Redis是目前最流行的缓存中间件，其稳定性和高性能的实现经历了多方面的优化和架构演进。文章从单机版Redis的问题出发，逐步分析了如何通过持久化、主从集群、哨兵机制和分片集群来解决缓存系统面临的各类挑战。  单机版Redis的主要问题是宕机后数据丢失，影响读取性能并可能导致数据永久丢失。为了解决数据丢失问题，Redis引入了两种持久化机制：AOF（记录每条命令）和RDB（数据快照）。AOF保证了数据完整性但文件体积较大，而RDB体积小但可能丢失部分数据。混合持久化（RDB嵌入AOF）综合了两者的优点。  为了缩短宕机恢复时间并提升读性能，Redis采用主从复制机制，即多个副本实时同步数据。然而，主节点宕机后需手动切换从节点，因此引入哨兵集群实现自动故障转移。哨兵通过共识算法（如Raft）选举领导者，确保高效自动切换。  针对写压力和数据容量瓶颈，Redis分片集群方案应运而生。客户端分片和中间代理（如Twemproxy、Codis）使得路由规则脱离业务代码。官方Redis Cluster方案进一步简化，节点间通过Gossip协议通信，无需单独部署哨兵。为了降低业务侧升级成本，Proxy层的引入实现了对客户端的透明访问。  总结来说，Redis的高可用架构演进路径如下：持久化解决数据丢失问题，主从复制缩短恢复时间，哨兵实现自动故障转移，分片集群应对写压力和容量瓶颈，最后通过Proxy优化客户端接入体验。这一系列优化确保了Redis能够长期稳定、高性能地提供服务。</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>redis是目前最流行的缓存中间件，但他是如何保证实现稳定并且高性能的提供服务的？</p><ol><li>如果只是单机版redis，有什么问题？</li><li>宕机后，如何快速恢复？</li><li>主从集群以及sentinel可以带来怎样的优势？</li><li>分片集群作用？</li></ol><p>这篇文章从0到1，一步步构建出当前的redis</p><h2 id="单机redis"><a href="#单机redis" class="headerlink" title="单机redis"></a>单机redis</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422103.png" alt="image-20240402113405372"></p><p>如上图所示，项目的数据最简单的就是直接从mysql读取，现在多了一个redis缓存，并使用cache aside pattern。</p><p>在服务不断运行中，项目中redis存储的数据越来越多，如果突然<strong>redis宕机</strong>，由于redis是内存数据库，全部的数据都会丢失。</p><ol><li><strong>读数据</strong>：就算redis重启了，数据丢失了，构建缓存的过程中数据库压力很大</li><li><strong>写数据</strong>：如果有写数据还没有写入到数据库，数据就永久丢失了</li></ol><h2 id="持久化：有备无患"><a href="#持久化：有备无患" class="headerlink" title="持久化：有备无患"></a>持久化：有备无患</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422958.png" alt="image-20240402113736587"></p><p>最简单的持久化操作就是：每执行一个命令，除了更新redis内存外，还写入磁盘，也就是磁盘和redis始终同步。</p><p>问题：<strong>写磁盘的速度肯定是跟不上redis，如果希望强一致性，那磁盘的读写速度就是redis的性能极限，性能急剧下降。</strong></p><p>数据从内存到磁盘分两步：</p><ol><li>程序写文件的 PageCache（write）</li><li>把 PageCache 刷到磁盘（fsync）</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422753.png" alt="image-20240402114411870"></p><p>刚才是每次都执行这两步，现在可以只执行第一步，然后让后台线程去执行fsync操作</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422229.png" alt="image-20240402114515651"></p><p>其实这就是AOF，（Append Only File）。</p><p>Redis AOF 持久化提供了 3 种刷盘机制：对应着fsync的不同时机</p><ol><li>appendfsync always：主线程同步 fsync</li><li>appendfsync no：由 OS fsync</li><li>appendfsync everysec：后台线程每间隔1秒 fsync；大大减小了io的频率</li></ol><p>​随着时间推移，AOF文件可能越来越大，redis还提供了AOF rewrite使得AOF【瘦身】，如 <code>set k1 v1，set k1 v2</code>，其实我们只需要记录后一条命令就好了（最终版本）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422401.png" alt="image-20240402114719479"></p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>除了使用基于命令的方式，还可以使用最常用的基于<strong>数据快照</strong>实现数据的备份</p><p>快照的备份时机可以定时的，也可也是最近一段时间数据的修改量 <code>save 300 10   # 100s内有10个key修改了则触发bgsave</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422389.png" alt="image-20240402115227024"></p><p>优点</p><ol><li>持久化体积小（二进制+压缩）</li><li>写盘频率</li></ol><p>缺点也很明显，因为是定时持久化，数据肯定没有 AOF 实时持久化完整。</p><p>如果你的 Redis 只当做缓存，对于丢失数据不敏感（可从后端的数据库查询），那这种持久化方式是非常合适的。</p><p>如果让你来选择持久化方案，你可以这样选择：</p><ol><li>业务对于数据丢失不敏感，选 RDB</li><li>业务对数据完整性要求比较高，选 AOF 但文件体积更大、恢复更慢</li></ol><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>如何保证数据完整性，又可以让文件更小（恢复更快）呢？</p><p>数据完整性：想要保住数据完整性，就需要从AOF下手（记录下每条命令），还想要体积更小，就将RDB快照（二进制+压缩）嵌入到AOF中</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021424560.png" alt="image-20240402142442717"></p><p>当 AOF 在做 rewrite 时，<strong>Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422942.png" alt="image-20240402130926543"></p><p>数据恢复时，先加载AOF中的RDB，再执行命令</p><p>现在已经实现单机的恢复，但恢复启动的过程中服务还是宕机的，解决方法：引入多个 Redis 实例，这些实例实时进行同步，当一个宕机后剩下的立马可以补救【主从复制：多副本】</p><h2 id="主从复制：多副本"><a href="#主从复制：多副本" class="headerlink" title="主从复制：多副本"></a>主从复制：多副本</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021422670.png" alt="img"></p><ol><li><strong>缩短不可用时间</strong>：master 发生宕机，我们可以<strong>手动</strong>把 slave 提升为 master 继续提供服务</li><li><strong>提升读性能</strong>：让 slave 分担一部分读请求，提升应用的整体性能</li></ol><p>但它的问题在于：<strong>当 master 宕机时，我们需要「手动」把 slave 提升为 master，这个过程也是需要花费时间的。</strong></p><p>优化：切换的过程，变成自动化？</p><h2 id="哨兵：故障自动切换"><a href="#哨兵：故障自动切换" class="headerlink" title="哨兵：故障自动切换"></a>哨兵：故障自动切换</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021423319.png" alt="image-20240402132002932"></p><ol><li>引入哨兵实现服务的监控</li><li>多个哨兵避免网络问题引起的波动</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">哨兵协商判定 <span class="hljs-keyword">master</span> <span class="hljs-title">异常后，这里还有一个问题：由哪个哨兵来发起主从切换呢？</span><br><span class="hljs-title"></span><br><span class="hljs-title">答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。</span><br><span class="hljs-title"></span><br><span class="hljs-title">问题又来了，这个领导者怎么选？</span><br><span class="hljs-title"></span><br><span class="hljs-title">想象一下，在现实生活中，选举是怎么做的？</span><br><span class="hljs-title"></span><br><span class="hljs-title">是的，投票。</span><br><span class="hljs-title"></span><br><span class="hljs-title">在选举哨兵领导者时，我们可以制定这样一个选举规则：</span><br><span class="hljs-title"></span><br><span class="hljs-title">每个哨兵都询问其它哨兵，请求对方为自己投票</span><br><span class="hljs-title">每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次</span><br><span class="hljs-title">首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换</span><br><span class="hljs-title">这个选举的过程就是我们经常听到的：分布式系统领域中的「共识算法」。</span><br><span class="hljs-title"></span><br><span class="hljs-title">什么是共识算法？</span><br><span class="hljs-title"></span><br><span class="hljs-title">我们在多个机器部署哨兵，它们需要共同协作完成一项任务，所以它们就组成了一个「分布式系统」。</span><br><span class="hljs-title"></span><br><span class="hljs-title">在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法。</span><br><span class="hljs-title"></span><br><span class="hljs-title">在这个场景下，多个哨兵共同协商，选举出一个都认可的领导者，就是使用共识算法完成的。</span><br><span class="hljs-title"></span><br><span class="hljs-title">这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。</p>          </div><p>目前解决的问题：</p><ol><li><strong>数据怕丢失</strong>：持久化（RDB&#x2F;AOF）</li><li><strong>恢复时间久</strong>：主从副本（副本随时可切）</li><li><strong>手动切换时间长</strong>：哨兵集群（自动切换）</li><li><strong>读存在压力</strong>：扩容副本（读写分离）</li><li><strong>写存在压力</strong>：<strong>一个 mater 扛不住怎么办？</strong></li></ol><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021425239.png" alt="image-20240402133049163"></p><p>引入多个master分担压力</p><p>我们制定规则如下：</p><ol><li>每个节点各自存储一部分数据，所有节点数据之和才是全量数据</li><li>制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写</li></ol><p>需要一个路由</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021423759.png" alt="image-20240402133114498"></p><p>这种方案也叫做「客户端分片」，这个方案的缺点是，<strong>客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。</strong></p><p>如何做到不把路由规则耦合在客户端业务代码中呢？</p><p>继续优化，我们可以在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy，路由转发规则，放在这个 Proxy 层来维护。使得proxy后面的一切对客户端来说都是透明无感知的</p><p>业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021425312.png" alt="image-20240402133147080"></p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>官方方案更加简单，无需路由以及哨兵</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021423629.png" alt="image-20240402133237153"></p><ol><li>故障监控：<strong>Redis Cluster 无需部署哨兵集群，集群内 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可发起自动切换。</strong></li><li>路由：访问集群的任意节点，会自动转发到正确节点</li></ol><p>虽然省去了哨兵集群的部署，维护成本降低了不少，但对于客户端升级 SDK，对于新业务应用来说，可能成本不高，但对于老业务来讲，「升级成本」还是比较高的，这对于切换官方 Redis Cluster 方案有不少阻力。</p><p>于是，各个公司有开始自研针对 Redis Cluster 的 Proxy，降低客户端的升级成本，架构就变成了这样：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404021424113" alt="Image"></p><p>这样，客户端无需做任何变更，只需把连接地址切到 Proxy 上即可，由 Proxy 负责转发数据，以及应对后面集群增删节点带来的路由变更。</p><p>至此，业界主流的 Redis 分片架构已经成型，当你使用分片集群后，对于未来更大的流量压力，也都可以从容面对了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，我们是如何从 0 到 1，再从 1 到 N 构建一个稳定、高性能的 Redis 集群的，从这之中你可以清晰地看到 Redis 架构演进的整个过程。</p><ol><li><strong>数据怕丢失</strong> -&gt; 持久化（RDB&#x2F;AOF）</li><li><strong>恢复时间久</strong> -&gt; 主从副本（副本随时可切）</li><li><strong>故障手动切换慢</strong> -&gt; 哨兵集群（自动切换）</li><li><strong>读存在压力</strong> -&gt; 扩容副本（读写分离）</li><li><strong>写存在压力&#x2F;容量瓶颈</strong> -&gt; 分片集群</li><li><strong>分片集群社区方案</strong> -&gt;  Twemproxy、Codis（Redis 节点之间无通信，需要部署哨兵，可横向扩容）</li><li><strong>分片集群官方方案</strong> -&gt;  Redis Cluster （Redis 节点之间 Gossip 协议，无需部署哨兵，可横向扩容）</li><li><strong>业务侧升级困难</strong> -&gt; Proxy + Redis Cluster（不侵入业务侧）</li></ol><p>至此，我们的 Redis 集群才得以长期稳定、高性能的为我们的业务提供服务。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/QssILJLna_v7XQWtV5UMzA">一文搞懂 Redis 架构演化之路</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>系统架构</category>
      
      <category>高性能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章精读</tag>
      
      <tag>redis</tag>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个新进程的诞生[linux源码趣读]</title>
    <link href="/2023/07/07/book/%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F%5Blinux%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB%5D/"/>
    <url>/2023/07/07/book/%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F%5Blinux%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB%5D/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要讲解了以下内容：  1. <strong>内核态切换到用户态</strong>：通过 <code>move_to_user_mode</code> 函数从内核态切换到用户态，利用中断返回机制模拟切换过程，确保代码在用户态下运行。  2. <strong>进程创建（fork）</strong>：通过 <code>fork</code> 系统调用创建新进程：    - <code>find_empty_process</code> 找到空闲的进程槽位。    - <code>copy_process</code> 复制当前进程的上下文（task_struct）、内存管理信息（页表、段表）以及寄存器状态。    - 新进程与父进程共享相同的物理内存，但通过写时复制（Copy-On-Write）机制确保修改时分配新内存。  3. <strong>进程调度机制</strong>：    - <strong>时间片轮转</strong>：每个进程有一个时间片计数器（counter），时钟中断（10ms一次）减少计数器，归零时触发调度。    - <strong>优先级调度</strong>：进程的初始时间片由优先级（priority）决定，空闲时重新分配时间片。    - <strong>任务状态</strong>：进程可以是运行（TASK_RUNNING）、不可中断（TASK_UNINTERRUPTIBLE）等状态，确保合理调度。  4. <strong>内存管理</strong>：    - <strong>段式管理</strong>：每个进程通过 LDT（局部描述符表）映射到独立的线性地址空间。    - <strong>页式管理</strong>：通过页表将线性地址映射到物理地址，fork 时复制父进程页表，但设置为只读以实现写时复制。    - <strong>缺页中断</strong>：写操作触发缺页中断，处理程序 <code>do_wp_page</code> 分配新物理页并更新页表。  5. <strong>系统调用与中断</strong>：    - <strong>int 0x80</strong>：用户态通过软中断进入内核，由 <code>sys_call_table</code> 根据 eax 调用处理函数（如 <code>sys_fork</code>）。    - <strong>中断上下文切换</strong>：保存寄存器状态并通过 TSS（任务状态段）恢复新进程的上下文。  <strong>总结</strong>：文章详细描述了进程创建（fork）的完整流程，包括权限切换、内存复制、调度策略以及写时复制的实现机制，展示了操作系统如何管理多进程的并发执行和内存隔离。</p></blockquote><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>第一部分和第二部分，为我们这个第三部分做了充足的铺垫工作。</p><p><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247499882&idx=1&sn=68fd16c5aeae15084be58afb1e5bd9e8&chksm=c2c5bac7f5b233d1c486fa57e9e3a2bc907a92ab69ff0344babab4d50bdaf76e7766b4b42914&scene=21#wechat_redirect">第一部分 进入内核前的苦力活</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500983&idx=1&sn=ad4c430823c975df97f13de3fbe8c66e&chksm=c2c5be1af5b2370cad4ce3218c5294feee4ae2e4d28804398c1dc8ac252c8dfafbe419ccf58c&scene=21#wechat_redirect">第二部分 大战前期的初始化工作</a></p><p>到了第三部分，简单说就是从内核态切换到用户态，然后通过 fork 创建出一个新的进程，再之后老进程进入死循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 第二部分的内容，各种初始化工作</span><br>    ...<br>    <span class="hljs-comment">// 第三部分的内容，一个新进程的诞生</span><br>    move_to_user_mode();<br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        <span class="hljs-comment">// 新进程里干了啥，是第四部分的内容</span><br>        init();<br>    &#125;<br>    <span class="hljs-comment">// 死循环，操作系统怠速状态</span><br>    <span class="hljs-keyword">for</span>(;;) pause();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>move_to_user_mode</strong>: 转为用户态，之后需要通过中断转为内核态</li><li><strong>fork</strong>：从进程0创建进程1</li><li><strong>init</strong>： 进程1加载根文件系统任务，创建进程2，进程2加载shell</li><li><strong>pause</strong>：暂停</li></ul><h3 id="从内核态切换到用户态"><a href="#从内核态切换到用户态" class="headerlink" title="从内核态切换到用户态"></a><a href="https://mp.weixin.qq.com/s/AVl6R2N9d_sldkhfvC6aEw">从内核态切换到用户态</a></h3><p><strong>move_to_user_mode</strong></p><h4 id="特权级的实现"><a href="#特权级的实现" class="headerlink" title="特权级的实现"></a>特权级的实现</h4><ul><li>首先从一个最大的视角来看，这一切都源于 CPU 的保护机制。CPU 为了配合操作系统完成保护机制这一特性，分别设计了<strong>分段保护机制</strong>与<strong>分页保护机制</strong>。</li><li>当我们在 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247499699&idx=1&sn=000d83798b0158dbdf48d76e49d3ff96&chksm=c2c5851ef5b20c08bc641d4b118db78a3af5a4f90a057d1ce9f9b68f04b529124f466c743bc5&scene=21#wechat_redirect">第七回 | 六行代码就进入了保护模式</a> 将 cr0 寄存器的 PE 位开启时，就开启了保护模式，也即开启了<strong>分段保护机制</strong>。</li></ul><p><strong>如何保护的？</strong></p><p>cs代码段选择子的最后几位</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404181748003.png" alt="image-20240418174750677"></p><ul><li>CPL代表当前的特权级别：11代表用户态</li><li>代码的跳转执行jmp时，yyy : xxx，这里的 yyy 就是q请求跳转的段选择子</li><li>在GDT中保存了yyy 的段描述符，其中定义了DPL指明了<strong>目标代码段特权级</strong></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404181753857.png" alt="image-20240418175345418"></p><ul><li>在代码跳转时：<strong>CPL</strong>必须等于<strong>DPL</strong></li><li>在内存数据访问时：<strong>处于内核态的代码可以访问任何特权级的数据段，处于用户态的代码则只可以访问用户态的数据段</strong></li><li>发送中断时，指向新的CS IP，CS中的CPL通常是0</li></ul><h4 id="转化方式"><a href="#转化方式" class="headerlink" title="转化方式"></a>转化方式</h4><p>中断和中断返回：<strong>int 0x80</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404181756186.png" alt="image-20240418175639704"></p><p>没有中断也可也返回？</p><p>中断前通常会保存当前的cs ip，并在return时pop，所以这里我们return前先push，假装发生了中断，push的cs ip就是等下想去的位置</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404181758084.png" alt="image-20240418175822567"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">void main(void) &#123;<br>    ...    <br>    move_to_user_mode();<br>    ...<br>&#125;<br><br>#define move_to_user_mode() \<br>_asm &#123; \<br>    _asm mov eax,esp \<br>    _asm push 00000017h \  SS 赋值<br>    _asm push eax \<br>    _asm pushfd \<br>    _asm push 0000000fh \  CS 赋值<br>    _asm push offset l1 \<br>    _asm iretd /* 执行中断返回指令*/ \<br>_asm l1: mov eax,17h \<br>    _asm mov ds,ax \<br>    _asm mov es,ax \<br>    _asm mov fs,ax \<br>    _asm mov gs,ax \<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意SS、CS最后两位为1，代表<strong>切换到用户态</strong></li><li>从<strong>LDT</strong>拿转换关系：倒数第三位 TI 表示从 GDT 还是 LDT 中取，1 表示 LDT，也就是从局部描述符表中取。局部描述符具体是哪一个？也就是lldt 指向的是谁？</li></ul><blockquote><p>在 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500496&idx=1&sn=3bddde6c68c2b03d9721ba74e949cfa8&chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的</a> 中，将 0 号 LDT 作为当前的 LDT 索引，记录在了 CPU 的 lldt 寄存器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lldt(n) __asm__(<span class="hljs-string">&quot;lldt %%ax&quot;</span>::<span class="hljs-string">&quot;a&quot;</span> (_LDT(n)))</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sched_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    lldt(<span class="hljs-number">0</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>特权的区别通过cs中的CPL和段描述符中的DPL定义，跳转时需要检查，使得用户下的代码和数据和内核下的区分开来</li><li>什么时候特权会转变：中断以及中断返回时</li></ul><h3 id="如果让你来设计进程调度"><a href="#如果让你来设计进程调度" class="headerlink" title="如果让你来设计进程调度"></a><a href="https://mp.weixin.qq.com/s/Sf9vV7RCnVDlBKXx5jXs1Q">如果让你来设计进程调度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...    <br>    move_to_user_mode();<br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(;;) pause();<br>&#125;<br></code></pre></td></tr></table></figure><p>上一节中，成功切换到了用户态，现在我们先不考虑fork，先讲讲如何实现进程调度？</p><p>如何实现cpu一下运行这个线程，一下另外一个？</p><blockquote><p>由一个不受任何程序控制的，第三方的不可抗力，每隔一段时间就中断一下 CPU 的运行，然后跳转到一个特殊的程序那里，这个程序通过某种方式获取到 CPU 下一个要运行的程序的地址，然后跳转过去。</p><p>这个每隔一段时间就中断 CPU 的不可抗力，就是由定时器触发的<strong>时钟中断</strong>。</p></blockquote><p>当前线程被换下去后，肯定需要保存当前任务的现场，比如它上一次执行到哪里了，要不 CPU 就算决定好了要跳转到你这个进程上运行，具体跳到哪一行运行，总得有个地方存吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ?<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>每个程序最终的本质就是执行指令。这个过程会涉及<strong>寄存器</strong>，<strong>内存</strong>和<strong>外设端口</strong>。</p><p>内存还有可能设计成相互错开的，互不干扰，比如进程 1 你就用 0<del>1K 的内存空间，进程 2 就用 1K</del>2K 的内存空间，咱谁也别影响谁。</p><p>但寄存器只有那么多，如果当前线程切换掉了，切换前就要存储下来，否者就别别人删了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> &#123;</span><br>    <span class="hljs-type">long</span>    back_link;  <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    esp0;<br>    <span class="hljs-type">long</span>    ss0;        <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    esp1;<br>    <span class="hljs-type">long</span>    ss1;        <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    esp2;<br>    <span class="hljs-type">long</span>    ss2;        <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    cr3;<br>    <span class="hljs-type">long</span>    eip;<br>    <span class="hljs-type">long</span>    eflags;<br>    <span class="hljs-type">long</span>    eax,ecx,edx,ebx;<br>    <span class="hljs-type">long</span>    esp;<br>    <span class="hljs-type">long</span>    ebp;<br>    <span class="hljs-type">long</span>    esi;<br>    <span class="hljs-type">long</span>    edi;<br>    <span class="hljs-type">long</span>    es;     <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    cs;     <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    ss;     <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    ds;     <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    fs;     <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    gs;     <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    ldt;        <span class="hljs-comment">/* 16 high bits zero */</span><br>    <span class="hljs-type">long</span>    trace_bitmap;   <span class="hljs-comment">/* bits: trace 0, bitmap 16-31 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i387_struct</span> <span class="hljs-title">i387</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>cr3</strong> ： cr3 寄存器是指向页目录表首地址的，每一个进程不同，说明了线性地址到物理地址的映射关系不同。当前进程来了，就把当前进程的cr3设置上，代表当前线程在运行</p><p>操作系统来复制<strong>建立不同的页目录表</strong>并替换 cr3 寄存器即可，可以实现内存的不冲突或者共享</p><h4 id="什么时候切换"><a href="#什么时候切换" class="headerlink" title="什么时候切换"></a>什么时候切换</h4><p>每次时钟都切换？太频繁了</p><p>给进程一个属性，叫<strong>剩余时间片</strong>，每次时钟中断来了之后都 <strong>-1</strong>，如果减到 0 了，就触发切换进程的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-type">long</span> counter;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每次中断都–，并检查一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_timer</span><span class="hljs-params">(<span class="hljs-type">long</span> cpl)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 当前线程还有剩余时间片，直接返回</span><br>    <span class="hljs-keyword">if</span> ((--current-&gt;counter)&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 若没有剩余时间片，调度</span><br>    schedule(); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><strong>优先级</strong></h4><p>如何区分进程的优先级，其实就是counter的初始值，用一个priority保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-type">long</span> counter;<br>    <span class="hljs-type">long</span> priority;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>刚才的进程是都要运行的，有没有不在运行的情况？</p><p>一个进程读取磁盘，需要阻塞好久，这个时候调度cpu给他也没用，就需要主动<strong>放弃CPU执行权力</strong>，用<strong>state</strong>记录下进程的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-type">long</span> state;<br>    <span class="hljs-type">long</span> counter;<br>    <span class="hljs-type">long</span> priority;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_RUNNING          0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_INTERRUPTIBLE    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_UNINTERRUPTIBLE  2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_ZOMBIE           3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_STOPPED          4</span><br></code></pre></td></tr></table></figure><p>现在就可以完成简单的任务了：表示状态的 <strong>state</strong>，表示剩余时间片的 <strong>counter</strong>，表示优先级的 <strong>priority</strong>，和表示上下文信息的 <strong>tss</strong>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-comment">/* these are hardcoded - don&#x27;t touch */</span><br>    <span class="hljs-type">long</span> state; <span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br>    <span class="hljs-type">long</span> counter;<br>    <span class="hljs-type">long</span> priority;<br>    <span class="hljs-type">long</span> signal;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sigaction</span>[32];</span><br>    <span class="hljs-type">long</span> blocked;   <span class="hljs-comment">/* bitmap of masked signals */</span><br><span class="hljs-comment">/* various fields */</span><br>    <span class="hljs-type">int</span> exit_code;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code,end_code,end_data,brk,start_stack;<br>    <span class="hljs-type">long</span> pid,father,pgrp,session,leader;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> uid,euid,suid;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gid,egid,sgid;<br>    <span class="hljs-type">long</span> alarm;<br>    <span class="hljs-type">long</span> utime,stime,cutime,cstime,start_time;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> used_math;<br><span class="hljs-comment">/* file system info */</span><br>    <span class="hljs-type">int</span> tty;        <span class="hljs-comment">/* -1 if no tty, so it must be signed */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> umask;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">pwd</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">root</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">executable</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> close_on_exec;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">filp</span>[<span class="hljs-title">NR_OPEN</span>];</span><br><span class="hljs-comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> <span class="hljs-title">ldt</span>[3];</span><br><span class="hljs-comment">/* tss for this task */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>进程调度的开始，要从一次定时器滴答来触发，通过时钟中断处理函数走到进程调度函数，然后去进程的结构 task_struct 中取出所需的数据，进行策略计算，并挑选出下一个可以得到 CPU 运行的进程，跳转过去。</p></blockquote><h3 id="从一次定时器滴答来看进程调度"><a href="#从一次定时器滴答来看进程调度" class="headerlink" title="从一次定时器滴答来看进程调度"></a><a href="https://mp.weixin.qq.com/s/yFre8Qv_ZCtjRkTS49n6rw">从一次定时器滴答来看进程调度</a></h3><p>上回我们说了进程调度需要的数据结构，现在我们来看下具体的调度过程</p><p>还记得我们在 <a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500496&idx=1&sn=3bddde6c68c2b03d9721ba74e949cfa8&chksm=c2c5b87df5b2316b083015a4fdba2df29211f38fcfd1cdb040e02ab410432608e26383a43ef5&scene=21#wechat_redirect">第18回 | 大名鼎鼎的进程调度就是从这里开始的</a> <strong>sched_init</strong> 的时候，开启了<strong>定时器</strong>吧？这个定时器每隔一段时间就会向 CPU 发起一个中断信号。</p><p> <img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404181957483.png" alt="image-20240418195753302"></p><p>这个间隔时间被设置为 10 ms，也就是 100 Hz。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">schedule.c<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HZ 100</span><br></code></pre></td></tr></table></figure><p>发起的中断叫<strong>时钟中断</strong>，其中断向量号被设置为了 <strong>0x20</strong>。</p><p>同时我们在 <strong>sched_init</strong> 里设置的时钟中断和对应的中断处理函数吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">schedule.c<br><span class="hljs-title function_">set_intr_gate</span><span class="hljs-params">(<span class="hljs-number">0x20</span>, &amp;timer_interrupt)</span>;<br><br>system_call.s<br><br>_timer_interrupt:<br>    ...<br>    <span class="hljs-comment">// 增加系统滴答数</span><br>    incl _jiffies<br>    ...<br>    <span class="hljs-comment">// 调用函数 do_timer</span><br>    call _do_timer<br>    ...<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_timer</span><span class="hljs-params">(<span class="hljs-type">long</span> cpl)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 当前线程还有剩余时间片，直接返回</span><br>    <span class="hljs-keyword">if</span> ((--current-&gt;counter)&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 若没有剩余时间片，调度</span><br>    schedule();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><p>找出剩余时间片最大的线程（<code>state=TASK_RUNNING</code> ），如果都没有时间就<code>counter = counter/2 + priority</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> i, next, c;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> ** <span class="hljs-title">p</span>;</span><br>    ...<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        c = <span class="hljs-number">-1</span>;<br>        next = <span class="hljs-number">0</span>;<br>        i = NR_TASKS;<br>        p = &amp;task[NR_TASKS];<br>        <span class="hljs-keyword">while</span> (--i) &#123;<br>            <span class="hljs-keyword">if</span> (!*--p)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>                c = (*p)-&gt;counter, next = i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)<br>            <span class="hljs-keyword">if</span> (*p)<br>                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="hljs-number">1</span>) +<br>                        (*p)-&gt;priority;<br>    &#125;<br>    switch_to(next);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch-to"><a href="#switch-to" class="headerlink" title="switch_to"></a>switch_to</h4><p>进程切换，其实就是切换上一章中我们定义的数据结构，我们需要保存当前的上下文到tss中，并将新的线程的上下文加载</p><p><strong>ljmp</strong> ：指令后面跟的是一个 tss 段，那么，会由硬件将当前各个寄存器的值保存在当前进程的 tss 中，并将新进程的 tss 信息加载到各个寄存器。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182001401.png" alt="image-20240418200148268"></p><h3 id="通过-fork-看一次系统调用流程"><a href="#通过-fork-看一次系统调用流程" class="headerlink" title="通过 fork 看一次系统调用流程"></a><a href="https://mp.weixin.qq.com/s/rYBSH_AZDwgc8knSKDSSxA">通过 fork 看一次系统调用流程</a></h3><p>回到我们的fork命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...    <br>    move_to_user_mode();<br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(;;) pause();<br>&#125;<br></code></pre></td></tr></table></figure><p>伪代码：这里其实是触发了一次中断，具体处理函数由eax决定，并去<code>sys_call_table</code>（操作系统提供给用户全部的系统调用功能）找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>     <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> __res;<br>    _asm &#123;<br>        _asm mov eax,__NR_fork  <span class="hljs-comment">// 宏定义，值是 2</span><br>        _asm <span class="hljs-type">int</span> <span class="hljs-number">80</span>h<br>        _asm mov __res,eax<br>    &#125;<br>    <span class="hljs-keyword">if</span> (__res &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>) __res;<br>    errno = -__res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">set_system_gate(<span class="hljs-number">0x80</span>, &amp;system_call);<br><br>fn_ptr sys_call_table[] = &#123; sys_setup, sys_exit, sys_fork, sys_read,<br>  sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,<br>  sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,<br>  sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,<br>  sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,<br>  sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,<br>  sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,<br>  sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,<br>  sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,<br>  sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,<br>  sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,<br>  sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,<br>  sys_setreuid, sys_setregid<br>&#125;;<br><br>_system_call:<br>    ...<br>    call [_sys_call_table + eax*<span class="hljs-number">4</span>]<br>    ...<br><br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182006030.png" alt="image-20240418200635408"></p><blockquote><p>系统调用也可能有参数，刚刚产生哪个系统调用是通过<strong>eax</strong>传递，其他的参数可以通过<code>ebx ecx edx</code> 传递</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall0(type,name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall1(type,name,atype,a)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall2(type,name,atype,a,btype,b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c)</span><br></code></pre></td></tr></table></figure></blockquote><p>全貌：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">_system_call:<br>    cmpl $nr_system_calls<span class="hljs-number">-1</span>,%eax<br>    ja bad_sys_call<br>    push %ds<br>    push %es<br>    push %fs<br>    pushl %edx<br>    pushl %ecx      <span class="hljs-meta"># push %ebx,%ecx,%edx as parameters</span><br>    pushl %ebx      <span class="hljs-meta"># to the system call</span><br>    movl $<span class="hljs-number">0x10</span>,%edx     <span class="hljs-meta"># set up ds,es to kernel space</span><br>    mov %dx,%ds<br>    mov %dx,%es<br>    movl $<span class="hljs-number">0x17</span>,%edx     <span class="hljs-meta"># fs points to local data space</span><br>    mov %dx,%fs<br>    call _sys_call_table(,%eax,<span class="hljs-number">4</span>)<br>    pushl %eax<br>    movl _current,%eax<br>    cmpl $<span class="hljs-number">0</span>,state(%eax)     <span class="hljs-meta"># state</span><br>    jne reschedule<br>    cmpl $<span class="hljs-number">0</span>,counter(%eax)       <span class="hljs-meta"># counter</span><br>    je reschedule<br>ret_from_sys_call:<br>    movl _current,%eax      <span class="hljs-meta"># task[0] cannot have signals</span><br>    cmpl _task,%eax<br>    je <span class="hljs-number">3f</span><br>    cmpw $<span class="hljs-number">0x0f</span>,CS(%esp)     <span class="hljs-meta"># was old code segment supervisor ?</span><br>    jne <span class="hljs-number">3f</span><br>    cmpw $<span class="hljs-number">0x17</span>,OLDSS(%esp)      <span class="hljs-meta"># was stack segment = 0x17 ?</span><br>    jne <span class="hljs-number">3f</span><br>    movl <span class="hljs-title function_">signal</span><span class="hljs-params">(%eax)</span>,%ebx<br>    movl <span class="hljs-title function_">blocked</span><span class="hljs-params">(%eax)</span>,%ecx<br>    notl %ecx<br>    andl %ebx,%ecx<br>    bsfl %ecx,%ecx<br>    je 3f<br>    btrl %ecx,%ebx<br>    movl %ebx,<span class="hljs-title function_">signal</span><span class="hljs-params">(%eax)</span><br>    incl %ecx<br>    pushl %ecx<br>    call _do_signal<br>    popl %eax<br>3:  popl %eax<br>    popl %ebx<br>    popl %ecx<br>    popl %edx<br>    pop %fs<br>    pop %es<br>    pop %ds<br>    iret<br></code></pre></td></tr></table></figure><p>因为 system_call 是通过 int 80h 这个软中断进来的，所以也属于中断的一种，具体说是属于特权级发生变化的，且没有错误码情况的中断，所以在这之前栈已经被压了 <strong>SS、ESP、EFLAGS、CS、EIP</strong> 这些值。</p><p>接下来 system_call 又压入了一些值，具体说来有 <strong>ds、es、fs、edx、ecx、ebx、eax</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Stack layout in &#x27;ret_from_system_call&#x27;:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   0(%esp) - %eax</span><br><span class="hljs-comment"> *   4(%esp) - %ebx</span><br><span class="hljs-comment"> *   8(%esp) - %ecx</span><br><span class="hljs-comment"> *   C(%esp) - %edx</span><br><span class="hljs-comment"> *  10(%esp) - %fs</span><br><span class="hljs-comment"> *  14(%esp) - %es</span><br><span class="hljs-comment"> *  18(%esp) - %ds</span><br><span class="hljs-comment"> *  1C(%esp) - %eip</span><br><span class="hljs-comment"> *  20(%esp) - %cs</span><br><span class="hljs-comment"> *  24(%esp) - %eflags</span><br><span class="hljs-comment"> *  28(%esp) - %oldesp</span><br><span class="hljs-comment"> *  2C(%esp) - %oldss</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>所以之后，中断处理程序如果有需要的话，就可以从这里取出它想要的值，包括 CPU 压入的那五个值，或者 system_call 手动压入的 7 个值。</p><p>比如 <strong>sys_execve</strong> 这个中断处理函数，一开始就取走了位于栈顶 0x1C 位置处的 EIP 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">EIP = <span class="hljs-number">0x1C</span><br>_sys_execve:<br>    lea EIP(%esp),%eax<br>    pushl %eax<br>    call _do_execve<br>    addl $<span class="hljs-number">4</span>,%esp<br>    ret<br></code></pre></td></tr></table></figure><p>随后在 <strong>do_execve</strong> 函数中，又通过 C 语言函数调用的约定，取走了 <strong>filename，argv，envp</strong> 等参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">do_execve</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * eip,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> tmp,</span><br><span class="hljs-params">        <span class="hljs-type">char</span> * filename,</span><br><span class="hljs-params">        <span class="hljs-type">char</span> ** argv,</span><br><span class="hljs-params">        <span class="hljs-type">char</span> ** envp)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fork-中进程基本信息的复制"><a href="#fork-中进程基本信息的复制" class="headerlink" title="fork 中进程基本信息的复制"></a><a href="https://mp.weixin.qq.com/s/8cy-xX3ekeqHelrFcYFkvw">fork 中进程基本信息的复制</a></h3><p>回到<code>fork</code>函数，<code>sys_fork</code> 具体干了什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">_sys_fork:<br>    call _find_empty_process<br>    testl %eax,%eax<br>    js 1f<br>    push %gs<br>    pushl %esi<br>    pushl %edi<br>    pushl %ebp<br>    pushl %eax<br>    call _copy_process<br>    addl $20,%esp<br></code></pre></td></tr></table></figure><ol><li><strong>find_empty_process</strong>，就是找到空闲的进程槽位。 <code>task[64]</code></li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> last_pid = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">find_empty_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    repeat:<br>        <span class="hljs-keyword">if</span> ((++last_pid)&lt;<span class="hljs-number">0</span>) last_pid=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">64</span> ; i++)<br>            <span class="hljs-keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) <span class="hljs-keyword">goto</span> repeat;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span> ; i&lt;<span class="hljs-number">64</span>; i++)<br>        <span class="hljs-keyword">if</span> (!task[i])<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>copy_process</strong>，就是复制进程。</li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_process</span><span class="hljs-params">(<span class="hljs-type">int</span> nr,<span class="hljs-type">long</span> ebp,<span class="hljs-type">long</span> edi,<span class="hljs-type">long</span> esi,<span class="hljs-type">long</span> gs,<span class="hljs-type">long</span> none,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> ebx,<span class="hljs-type">long</span> ecx,<span class="hljs-type">long</span> edx,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> fs,<span class="hljs-type">long</span> es,<span class="hljs-type">long</span> ds,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> eip,<span class="hljs-type">long</span> cs,<span class="hljs-type">long</span> eflags,<span class="hljs-type">long</span> esp,<span class="hljs-type">long</span> ss)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> <span class="hljs-title">p</span> =</span> <br>        (<span class="hljs-keyword">struct</span> task_struct *) get_free_page();<br>    task[nr] = p;<br>    *p = *current; <span class="hljs-comment">// 复制当前当前进程 使得完全一样</span><br><br>    p-&gt;state = TASK_UNINTERRUPTIBLE;<br>    p-&gt;pid = last_pid;<br>    p-&gt;counter = p-&gt;priority;<br>    ..<br>    p-&gt;tss.edx = edx;<br>    p-&gt;tss.ebx = ebx;<br>    p-&gt;tss.esp = esp;<br>    ...<br>    copy_mem(nr,p);<br>    ...<br>    set_tss_desc(gdt+(nr&lt;&lt;<span class="hljs-number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));<br>    set_ldt_desc(gdt+(nr&lt;&lt;<span class="hljs-number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));<br>    p-&gt;state = TASK_RUNNING;<br>    <span class="hljs-keyword">return</span> last_pid;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>get_free_page</strong> : 遍历mem_map[]，找到一个空闲的区域，空间给<code>task_struct p</code></p></li><li><p>将这个 p 记录在进程管理结构 task[nr] 中</p></li><li><p>复制当前进程的task</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182024339.png" alt="image-20240418202432064"></p></li></ul><p>设置独特值：一部分是 <strong>state</strong>，<strong>pid</strong>，<strong>counter</strong> 这种<strong>进程的元信息</strong>，另一部分是 <strong>tss</strong> 里面保存的各种寄存器的信息，即<strong>上下文</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_process</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, ...)</span> &#123;<br>    ...<br>    p-&gt;state = TASK_UNINTERRUPTIBLE;<br>    p-&gt;pid = last_pid;<br>    p-&gt;counter = p-&gt;priority;<br>    ..<br>    p-&gt;tss.edx = edx;<br>    p-&gt;tss.ebx = ebx;<br>    p-&gt;tss.esp = esp;<br>    ...<br>    p-&gt;tss.esp0 = PAGE_SIZE + (<span class="hljs-type">long</span>) p;<br>    p-&gt;tss.ss0 = <span class="hljs-number">0x10</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p> ss0 和 esp0，这个表示 0 特权级也就是内核态时的 ss:esp 的指向。</p><p>根据代码我们得知，其含义是将代码在内核态时使用的堆栈栈顶指针指向进程 task_struct 所在的 4K 内存页的最顶端，而且之后的每个进程都是这样被设置的。</p><p>接下来将是进程页表和段表的复制，这将会决定进程之间的内存规划问题，很是精彩，也是 fork 真正的难点所在。</p><h3 id="透过-fork-来看进程的内存规划"><a href="#透过-fork-来看进程的内存规划" class="headerlink" title="透过 fork 来看进程的内存规划"></a><a href="https://mp.weixin.qq.com/s/d2pHFSbTLb-nv2C_RfKlVA">透过 fork 来看进程的内存规划</a></h3><p>上一节中完成了task内存分配以及基本信息的复制，这里讲<code>copy_mem</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_mem</span><span class="hljs-params">(<span class="hljs-type">int</span> nr,<span class="hljs-keyword">struct</span> task_struct * p)</span> &#123;<br>    <span class="hljs-comment">// 局部描述符表 LDT 赋值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_data_base,new_data_base,data_limit;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_code_base,new_code_base,code_limit;<br>    code_limit = get_limit(<span class="hljs-number">0x0f</span>);<br>    data_limit = get_limit(<span class="hljs-number">0x17</span>);<br>    new_code_base = nr * <span class="hljs-number">0x4000000</span>;<br>    new_data_base = nr * <span class="hljs-number">0x4000000</span>;<br>    set_base(p-&gt;ldt[<span class="hljs-number">1</span>],new_code_base);<br>    set_base(p-&gt;ldt[<span class="hljs-number">2</span>],new_data_base);<br>    <span class="hljs-comment">// 拷贝页表</span><br>    old_code_base = get_base(current-&gt;ldt[<span class="hljs-number">1</span>]);<br>    old_data_base = get_base(current-&gt;ldt[<span class="hljs-number">2</span>]);<br>    copy_page_tables(old_data_base,new_data_base,data_limit);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>地址转换过程：需要进过分段和分页</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182033099.png" alt="image-20240418203259106"></p><h4 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a><strong>LDT</strong></h4><p>分段查看的就是当前进程的LDT，我们给进程 0 准备的 LDT 的代码段和数据段，段基址都是 0，段限长是 640K。给进程 1，也就是我们现在正在 fork 的这个进程，其代码段和数据段还没有设置。</p><p>所以第一步，<strong>局部描述符表 LDT 的赋值</strong>，就是给上图中那两个还未设置的代码段和数据段赋值。</p><p>其中<strong>段限长</strong>，就是取自进程 0 设置好的段限长，也就是 640K。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_mem</span><span class="hljs-params">(<span class="hljs-type">int</span> nr,<span class="hljs-keyword">struct</span> task_struct * p)</span> &#123;<br>    ...<br>    code_limit = get_limit(<span class="hljs-number">0x0f</span>);<br>    data_limit = get_limit(<span class="hljs-number">0x17</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>而<strong>段基址</strong>有点意思，是取决于当前是几号进程，也就是 nr 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_mem</span><span class="hljs-params">(<span class="hljs-type">int</span> nr,<span class="hljs-keyword">struct</span> task_struct * p)</span> &#123;<br>    ...<br>    new_code_base = nr * <span class="hljs-number">0x4000000</span>; <span class="hljs-comment">//（64M）</span><br>    new_data_base = nr * <span class="hljs-number">0x4000000</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。</p><p>接着就把 LDT 设置进了 LDT 表里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_mem</span><span class="hljs-params">(<span class="hljs-type">int</span> nr,<span class="hljs-keyword">struct</span> task_struct * p)</span> &#123;<br>    ...<br>    set_base(p-&gt;ldt[<span class="hljs-number">1</span>],new_code_base);<br>    set_base(p-&gt;ldt[<span class="hljs-number">2</span>],new_data_base);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182033003.png" alt="image-20240418203254546"></p><p>进程0的线性地址空间是0<del>64M，1 是64</del>128M</p><p>经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是<strong>段式</strong>管理。</p><h4 id="页表的复制"><a href="#页表的复制" class="headerlink" title="页表的复制"></a><strong>页表的复制</strong></h4><p>页表项</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182211547.png" alt="image-20240418221102280"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Well, here is one of the most complicated functions in mm. It</span><br><span class="hljs-comment"> * copies a range of linerar addresses by copying only the pages.</span><br><span class="hljs-comment"> * Let&#x27;s hope this is bug-free, &#x27;cause this one I don&#x27;t want to debug :-)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * from_page_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * to_page_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * from_dir, * to_dir;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr;<br><br>    from_dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((from&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);<br>    to_dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((to&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);<br>    size = ((<span class="hljs-type">unsigned</span>) (size+<span class="hljs-number">0x3fffff</span>)) &gt;&gt; <span class="hljs-number">22</span>;<br>    <span class="hljs-keyword">for</span>( ; size--&gt;<span class="hljs-number">0</span> ; from_dir++,to_dir++) &#123;<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; *from_dir))<br>            <span class="hljs-keyword">continue</span>;<br>        from_page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *from_dir);<br>        to_page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) get_free_page() <span class="hljs-comment">//页表也是申请的空间</span><br>        *to_dir = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) to_page_table) | <span class="hljs-number">7</span>;<br>        nr = (from==<span class="hljs-number">0</span>)?<span class="hljs-number">0xA0</span>:<span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">for</span> ( ; nr-- &gt; <span class="hljs-number">0</span> ; from_page_table++,to_page_table++) &#123;<br>            this_page = *from_page_table;<br>            <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; this_page))<br>                <span class="hljs-keyword">continue</span>;<br>            this_page &amp;= ~<span class="hljs-number">2</span>;  <span class="hljs-comment">// 只读</span><br>            *to_page_table = this_page;<br>            <span class="hljs-keyword">if</span> (this_page &gt; LOW_MEM) &#123;<br>                *from_page_table = this_page;<br>                this_page -= LOW_MEM;<br>                this_page &gt;&gt;= <span class="hljs-number">12</span>;<br>                mem_map[this_page]++; <span class="hljs-comment">// 计数++  地址到idx需要右移12</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    invalidate(); <span class="hljs-comment">// 刷新转换后援缓冲器（TLB）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在进程 0 的线性地址空间是 0 - 64M，进程 1 的线性地址空间是 64M - 128M。<strong>我们现在要造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间都是 0 - 64M</strong>，这样进程 1 才能顺利运行起来，不然就乱套了。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182051201.png" alt="image-20240418205101695"></p><p>假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。</p><p>假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。</p><p><strong>即，进程 0 和进程 1 目前共同映射物理内存的前 640K 的空间。</strong></p><p>至于如何将不同地址通过不同页表映射到相同物理地址空间，很简单，举个刚刚的例子。</p><p>刚刚的进程 1 的线性地址 64M + 0x03 用二进制表示是：</p><p>0000010000_0000000000_000000000011</p><p>刚刚的进程 0 的线性地址 0x03 用二进制表示是：</p><p>0000000000_0000000000_000000000011</p><p>根据分页机制的转化规则，<strong>前 10 位表示页目录项，中间 10 位表示页表项，后 12 位表页内偏移。</strong></p><p>进程 1 要找的是页目录项 16 中的第 0 号页表</p><p>进程 0 要找的是页目录项 0 中的第 0 号页表</p><p>那只要让这俩最终找到的两个页表里的数据一模一样即可。<code>*from_page_table = this_page</code>;</p><blockquote><p>~2 表示取反，2 用二进制表示是 10，取反就是 01，其目的是把 this_page 也就是当前的页表的 RW 位置零，也就是是<strong>把该页变成只读</strong>。</p><p>而 *from_page_table &#x3D; this_page 表示<strong>又把源页表也变成只读</strong>。</p><p>也就是说，经过 fork创建出的新进程，其页表项都是只读的，而且导致源进程的页表项也变成了只读。</p><p>这个就是<strong>写时复制</strong>的基础，新老进程一开始共享同一个物理内存空间，如果只有读，那就相安无事，但如果任何一方有写操作，由于页面是只读的，将触发缺页中断，然后就会分配一块新的物理内存给产生写操作的那个进程，此时这一块内存就不再共享了。</p></blockquote><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182201513.png" alt="image-20240418220124431"></p><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p><strong>缺页中断</strong>：</p><p>包含缺页<code>do_no_page</code>，和只读页<code>do_wp_page</code>  两种情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_page_fault</span><span class="hljs-params">(..., <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code)</span> &#123;<br>    ...   <br>    <span class="hljs-keyword">if</span> (error_code &amp; <span class="hljs-number">1</span>)<br>        do_wp_page(error_code, address, current, user_esp);<br>    <span class="hljs-keyword">else</span><br>        do_no_page(error_code, address, current, user_esp);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> &#123;<br>    <span class="hljs-comment">// 后面这一大坨计算了 address 在页表项的指针</span><br>    un_wp_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)<br>        (((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>) + (<span class="hljs-number">0xfffff000</span> &amp;<br>        *((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp;<span class="hljs-number">0xffc</span>)))));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_page,new_page;<br>    old_page = <span class="hljs-number">0xfffff000</span> &amp; *table_entry;<br>    <span class="hljs-comment">// 只被引用一次，说明没有被共享，那只改下读写属性就行了</span><br>    <span class="hljs-keyword">if</span> (mem_map[MAP_NR(old_page)]==<span class="hljs-number">1</span>) &#123;<br>        *table_entry |= <span class="hljs-number">2</span>;<br>        invalidate();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 被引用多次，就需要复制页表了</span><br>    new_page=get_free_page()；<br>    mem_map[MAP_NR(old_page)]--;<br>    *table_entry = new_page | <span class="hljs-number">7</span>; <span class="hljs-comment">// 更新可读可写</span><br>    invalidate();<br>    copy_page(old_page,new_page);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182219235.png" alt="image-20240418221905176"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182148396.png" alt="image-20240418214828462"></p><ul><li><p><strong>第一</strong>，原封不动复制了一下 task_struct。</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20240418214853270.png" alt="image-20240418214853270"></p></li><li><p><strong>第二</strong>，LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182149395.png" alt="image-20240418214916017"></p></li><li><p><strong>第三</strong>，页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182149210.png" alt="image-20240418214928175"></p><p>最后，将新老进程的页表都变成只读状态，为后面<strong>写时复制</strong>的<strong>缺页中断</strong>做准备。</p></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404182200350.png" alt="image-20240418220017599"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
      <category>linux源码趣读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDoS技术鉴赏</title>
    <link href="/2023/07/01/TechDigest/DDoS%E6%8A%80%E6%9C%AF%E9%89%B4%E8%B5%8F/"/>
    <url>/2023/07/01/TechDigest/DDoS%E6%8A%80%E6%9C%AF%E9%89%B4%E8%B5%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>分布式拒绝服务（DDoS）攻击通过僵尸网络（如木马感染或直接购买受控设备）发起，其特点在于利用网络协议的每一层进行攻击，属于“阳谋”——攻击原理公开但防御困难。典型攻击方式包括：    1. <strong>带宽耗尽型攻击</strong>：      - <strong>ICMP&#x2F;UDP洪泛</strong>：伪造大量数据包占用目标带宽。      - <strong>DNS放大攻击</strong>：利用DNS协议反射和放大流量。      - <strong>IP伪造反射攻击</strong>：将源IP设为受害者，诱使中间服务器（如DNS）向目标回送响应流量。    2. <strong>资源耗尽型攻击</strong>：      - <strong>TCP SYN Flood</strong>：伪造IP发送大量半连接请求，耗尽服务器队列资源（半连接超时需63秒）。      - <strong>TCP连接耗尽</strong>：建立大量完整连接（需三次握手，无法伪造IP）。      - <strong>HTTP请求攻击</strong>：直接消耗服务器计算和I&#x2F;O资源。    <strong>防御措施</strong>：   - 路由器检测源IP（实际较难实现）。   - 使用CDN分散流量。   - 部署流量清洗设备，结合IP信誉库与算法识别异常流量。    历史案例：1999年明尼苏达大学遭200台受感染服务器攻击，早期暴露了DDoS的威胁性。攻击本质是资源消耗与协议漏洞利用的博弈。</p></blockquote><ul><li>DDos：Distributed Denial of Service</li><li>阳谋，大家都知道怎么发生的，但难以防治</li></ul><p>发起攻击的为僵尸网络</p><ul><li>木马感染</li><li>直接购买</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121750241.png" alt="image-20240409112426739"></p><p>1999年8月17日明尼苏达大学服务器被200多台服务器攻击，攻击设备是被感染了</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>在网络协议的每一层，都可能遭受到攻击</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121750243.png" alt="image-20240409112945083"></p><h3 id="ICMP-Flood"><a href="#ICMP-Flood" class="headerlink" title="ICMP Flood:"></a><strong>ICMP Flood</strong>:</h3><p>攻击者发送大量的 ICMP（互联网控制消息协议）数据包到目标服务器，消耗其带宽和处理能力，使得服务器无法响应合法的请求。</p><h3 id="UDP-Flood"><a href="#UDP-Flood" class="headerlink" title="UDP Flood:"></a><strong>UDP Flood</strong>:</h3><p>攻击者发送大量的UDP（用户数据报协议）数据包到目标服务器，占用其带宽和处理能力，导致服务不可用。</p><h3 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h3><p>将源ip填写为被攻击目标，将信息发送到中间人后，中间人会回信给被攻击者，实现攻击</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121750244.png" alt="image-20240409113134854"></p><h3 id="放大攻击"><a href="#放大攻击" class="headerlink" title="放大攻击"></a>放大攻击</h3><p>DNS服务器可以实现放大，再利用DNS作为反射即可放大攻击</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121750245.png" alt="image-20240409113400376"></p><h3 id="TCP-Connection-Exhaustion-Attack"><a href="#TCP-Connection-Exhaustion-Attack" class="headerlink" title="TCP Connection Exhaustion Attack"></a>TCP Connection Exhaustion Attack</h3><p><strong>TCP连接耗尽攻击</strong>： 攻击者尝试建立大量的TCP连接，耗尽服务器资源。<strong>无法伪造ip，因为要三次握手</strong></p><h3 id="TCP-SYN-Flood"><a href="#TCP-SYN-Flood" class="headerlink" title="TCP SYN Flood:"></a><strong>TCP SYN Flood</strong>:</h3><p>攻击者发送大量的TCP SYN（同步）连接请求到目标服务器，但不完成三次握手过程，占用服务器资源（<strong>半连接队列</strong>），使得服务器无法处理合法的连接请求。  <strong>可以伪造ip</strong></p><p>正常请求中 Client 发送 SYN 包给 Server 后挂了，Server 回给 Client 的 SYN-ACK 一直没收到 Client 的 ACK 确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让 Server 将这个连接断开，否则这个连接就会一直占用 Server 的 SYN 连接队列（半连接队列）中的一个位置，大量这样的连接就会将 Server 的 SYN 连接队列耗尽，让正常的连接无法得到处理。目前，Linux 下默认会进行 5 次重发 SYN-ACK 包，重试的间隔时间从 1s 开始，下次的重试间隔时间是前一次的双倍，5 次的重试时间间隔为 1s,2s, 4s, 8s,16s，总共 31s，第 5 次发出后还要等 32s 都知道第 5 次也超时了，所以，总共需要 1s + 2s +4s+ 8s+ 16s + 32s &#x3D;63s，TCP 才会把断开这个连接。</p><p>由于，SYN 超时需要 63 秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的 SYN 包给 Server(俗称 SYN flood 攻击)，用于耗尽 Server 的 SYN 队列。对于应对 SYN 过多的问题，linux 提供了几个 TCP 参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><p>同样这里也可也反射，对发射器发送syn，然后让大量重试的syn+ack打到目标机器，攻击宽带但不能攻击连接队列</p><h3 id="HTTP-洪水"><a href="#HTTP-洪水" class="headerlink" title="HTTP 洪水"></a>HTTP 洪水</h3><p>以上都是针对网络和连接资源，还有消耗计算和IO的，例如直接发起http的查询请求，消耗服务器资源（需要三次握手，不能伪造ip）</p><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><ol><li>路由器检测源IP（比较难实现）</li><li>CND</li><li>流量清洗机器（强大的IP信用库、算法识别流量）</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121750246.png" alt="image-20240412174907912"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404121746892.png">DDos攻击鉴赏</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大战前的初始化工作[linux源码趣读]</title>
    <link href="/2023/07/01/book/%E5%A4%A7%E6%88%98%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C%5Blinux%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB%5D/"/>
    <url>/2023/07/01/book/%E5%A4%A7%E6%88%98%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C%5Blinux%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB%5D/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章详细介绍了操作系统启动过程中 <code>main.c</code> 中的 <code>main</code> 方法的执行流程。主要内容如下：  1. <strong>内存边界设置</strong>：根据内存大小设置 <code>memory_end</code> 和 <code>buffer_memory_end</code>，标记内存使用的范围。 2. <strong>内存管理初始化</strong>：<code>mem_init</code> 初始化内存分页管理，使用 <code>mem_map</code> 表记录内存页使用状态，方便后续的内存申请与释放。 3. <strong>中断初始化</strong>：<code>trap_init</code> 设置了各类中断处理函数，包括时钟中断（<code>timer_interrupt</code>）和键盘中断（<code>keyboard_interrupt</code>），并通过 <code>sti()</code> 开启中断响应。 4. <strong>进程调度初始化</strong>：<code>sched_init</code> 设置任务状态段（TSS）和局部描述符表（LDT），初始化 <code>task_struct</code> 数组，并为时钟中断和系统调用（<code>0x80</code> 中断）配置处理函数，为多进程调度奠定基础。 5. <strong>字符设备与块设备初始化</strong>：<code>tty_init</code> 负责控制台初始化（显存映射、光标设置），<code>blk_dev_init</code> 初始化块设备请求队列，<code>hd_init</code> 配置硬盘读写相关中断与请求处理函数。 6. <strong>缓冲管理</strong>：<code>buffer_init</code> 建立缓冲区与哈希表，作为用户进程与硬盘间的桥梁，优化数据读取效率。 7. <strong>切换到用户态</strong>：<code>move_to_user_mode</code> 创建第一个进程（<code>init</code>），最终进入 <code>shell</code> 等待用户输入。  文章通过源码逐层解析，展示了操作系统如何通过中断驱动、内存管理和进程调度等核心机制逐步启动，并最终为用户提供交互环境。</p></blockquote><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在上一回中，跳转到操作系统的骨架代码main.c中的main方法了, 数一数看，总共也就 20 几行代码。但这的确是操作系统启动流程的全部秘密了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 一些参数的取值和计算。包括根设备 ROOT_DEV，之前在汇编语言中获取的各个设备的参数信息 drive_info，以及通过计算得到的内存边界  在上一回中setup.s调用BIOS中断获取并放到约定好的0x90000 </span><br>    ROOT_DEV = ORIG_ROOT_DEV;<br>    drive_info = DRIVE_INFO;<br>    memory_end = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="hljs-number">10</span>);<br>    memory_end &amp;= <span class="hljs-number">0xfffff000</span>;<br>    <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)<br>        memory_end = <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">12</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>) <br>        buffer_memory_end = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">6</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)<br>        buffer_memory_end = <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">else</span><br>        buffer_memory_end = <span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    main_memory_start = buffer_memory_end;<br>    <br><span class="hljs-comment">// 内存初始化 mem_init，中断初始化 trap_init、进程调度初始化 sched_init 等等。我们知道学操作系统知识的时候，其实就分成这么几块来学的，看来在操作系统源码上看，也确实是这么划分的，那我们之后照着源码慢慢品，就好了。</span><br>    mem_init(main_memory_start,memory_end);<br>    trap_init();<br>    blk_dev_init();<br>    chr_dev_init();<br>    tty_init();<br>    time_init();<br>    sched_init();<br>    buffer_init(buffer_memory_end);<br>    hd_init();<br>    floppy_init();<br>    <br><span class="hljs-comment">// 切换到用户态模式 这个 init 函数里会创建出一个进程，设置终端的标准 IO，并且再创建出一个执行 shell 程序的进程用来接受用户的命令，到这里其实就出现了我们熟悉的shell画面</span><br>    sti();<br>    move_to_user_mode();<br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        init();<br>    &#125;<br>    <br><span class="hljs-comment">// 死循环，如果没有任何任务可以运行，操作系统会一直陷入这个死循环无法自拔。</span><br>    <span class="hljs-keyword">for</span>(;;) pause();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主内存初始化mem-init"><a href="#主内存初始化mem-init" class="headerlink" title="主内存初始化mem_init"></a>主内存初始化mem_init</h3><p>首先设置了内存的边界，包含memory和buffer，边界的设置是根据不同的内存大小设置的</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151113208.png" alt="image-20240415111315159"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOW_MEM 0x100000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGING_MEMORY (15*1024*1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USED 100</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> HIGH_MEMORY = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mem_map[PAGING_PAGES] = &#123; <span class="hljs-number">0</span>, &#125;;<br><br><span class="hljs-comment">// start_mem = 2 * 1024 * 1024</span><br><span class="hljs-comment">// end_mem = 8 * 1024 * 1024</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    HIGH_MEMORY = end_mem;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;PAGING_PAGES ; i++)<br>        mem_map[i] = USED;<br>    i = MAP_NR(start_mem);<br>    end_mem -= start_mem;<br>    end_mem &gt;&gt;= <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">while</span> (end_mem--&gt;<span class="hljs-number">0</span>)<br>        mem_map[i++]=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如何管理内存？"><a href="#如何管理内存？" class="headerlink" title="如何管理内存？"></a>如何管理内存？</h4><ul><li><p>分页管理，一个页4k，页号就是 <code>MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)</code></p></li><li><p><strong>mem_map</strong>  记录下是否使用</p><ul><li>1M一下无管理权限</li><li>1M到2M为Buffer，标记为已经使用</li><li>2M以上标记未使用</li></ul></li><li><p>之后的内存申请与释放等骚操作，统统是跟着张大表 <strong>mem_map</strong> 打交道而已</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151115737.png" alt="image-20240415111529580"></p></li></ul><h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>比如我们在 fork 子进程的时候，会调用 <strong>copy_process</strong> 函数来复制进程的结构信息，其中有一个步骤就是要<strong>申请一页内存</strong>，用于存放进程结构信息 task_struct。该内存的申请就是选择 mem_map 中首个空闲页面，并标记为已使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_process</span><span class="hljs-params">(...)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span><br>    ...<br>    p = (<span class="hljs-keyword">struct</span> task_struct *) get_free_page();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中断初始化trap-init"><a href="#中断初始化trap-init" class="headerlink" title="中断初始化trap_init"></a>中断初始化trap_init</h3><p>当你的计算机刚刚启动时，你按下键盘是不生效的，但是过了一段时间后，再按下键盘就有效果了。如何首先的呢，多久会生效呢？</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151122735.png" alt="image-20240415112231509"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>   <span class="hljs-comment">// set 了一堆 trap_gate</span><br><br>    set_trap_gate(<span class="hljs-number">0</span>,&amp;divide_error);<br>    set_trap_gate(<span class="hljs-number">1</span>,&amp;debug);<br>    set_trap_gate(<span class="hljs-number">2</span>,&amp;nmi);<br>    <span class="hljs-comment">// 又 set 了一堆 system_gate</span><br>    set_system_gate(<span class="hljs-number">3</span>,&amp;int3);   <span class="hljs-comment">/* int3-5 can be called from all */</span><br>    set_system_gate(<span class="hljs-number">4</span>,&amp;overflow);<br>    set_system_gate(<span class="hljs-number">5</span>,&amp;bounds);<br>    set_trap_gate(<span class="hljs-number">6</span>,&amp;invalid_op);<br>    set_trap_gate(<span class="hljs-number">7</span>,&amp;device_not_available);<br>    set_trap_gate(<span class="hljs-number">8</span>,&amp;double_fault);<br>    set_trap_gate(<span class="hljs-number">9</span>,&amp;coprocessor_segment_overrun);<br>    set_trap_gate(<span class="hljs-number">10</span>,&amp;invalid_TSS);<br>    set_trap_gate(<span class="hljs-number">11</span>,&amp;segment_not_present);<br>    set_trap_gate(<span class="hljs-number">12</span>,&amp;stack_segment);<br>    set_trap_gate(<span class="hljs-number">13</span>,&amp;general_protection);<br>    set_trap_gate(<span class="hljs-number">14</span>,&amp;page_fault);<br>    set_trap_gate(<span class="hljs-number">15</span>,&amp;reserved);<br>    set_trap_gate(<span class="hljs-number">16</span>,&amp;coprocessor_error);<br>    <span class="hljs-comment">// 又又批量 set 了一堆 trap_gate  暂时的，后面各个硬件初始化时要重新设置好这些中断，把暂时的这个给覆盖掉  例如键盘中断0x21会在tty_init设置</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">17</span>;i&lt;<span class="hljs-number">48</span>;i++)<br>        set_trap_gate(i,&amp;reserved);<br>    set_trap_gate(<span class="hljs-number">45</span>,&amp;irq13);<br>    set_trap_gate(<span class="hljs-number">39</span>,&amp;parallel_interrupt);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>TIPS：<code>set_trap_gate</code>和<code>set_system_gate</code>什么关系？</strong></p><p>这个 trap 与 system 的区别仅仅在于，设置的中断描述符的特权级不同，前者是 0（内核态），后者是 3（用户态），这块展开将会是非常严谨的、绕口的、复杂的特权级相关的知识，不明白的话先不用管，就理解为都是设置一个中断号和中断处理程序的对应关系就好了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_trap_gate(n,addr) \</span><br><span class="hljs-meta">    _set_gate(&amp;idt[n],15,0,addr)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_system_gate(n,addr) \</span><br><span class="hljs-meta">    _set_gate(&amp;idt[n],15,3,addr)</span><br></code></pre></td></tr></table></figure></blockquote><p>_set_gate就是设置一些列的硬中断处理函数，执行过后，IDT指向的结构变成了：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151127654.png" alt="image-20240415112744376"></p><p>什么时候开始中断呢？<code>sti();</code>  也就是这时候开始，按下键盘可以有反应了。</p><h3 id="块设备请求项初始化-blk-dev-init"><a href="#块设备请求项初始化-blk-dev-init" class="headerlink" title="块设备请求项初始化 blk_dev_init"></a>块设备请求项初始化 blk_dev_init</h3><p>用于让我们能够从硬盘读取数据到磁盘，读取块设备与内存缓冲区之间的桥梁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">blk_dev_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++) &#123;<br>        request[i].dev = <span class="hljs-number">-1</span>;<br>        request[i].next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中request请求，代表着一次读盘请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> &#123;</span><br>    <span class="hljs-type">int</span> dev;        <span class="hljs-comment">// 表示设备号，-1 就表示空闲。</span><br>    <span class="hljs-type">int</span> cmd;        <span class="hljs-comment">/* READ or WRITE */</span><br>    <span class="hljs-type">int</span> errors;<span class="hljs-comment">// 表示操作时产生的错误次数。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sector;<span class="hljs-comment">// 表示起始扇区。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_sectors; <span class="hljs-comment">// 表示扇区数。</span><br>    <span class="hljs-type">char</span> * buffer;<span class="hljs-comment">// 表示数据缓冲区，也就是读盘之后的数据放在内存中的什么位置。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">waiting</span>;</span> <span class="hljs-comment">// 是个 task_struct 结构，这可以表示一个进程，也就表示是哪个进程发起了这个请求。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span> <span class="hljs-comment">// 是缓冲区头指针，这个后面讲完缓冲区就懂了，因为这个 request 是需要与缓冲区挂钩的</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> * <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向了下一个请求项</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这个 request 结构可以完整描述一个读盘操作。然后那个 request 数组就是把它们都放在一起，并且它们又通过 next 指针串成链表。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151133356.png" alt="image-20240415113321223"></p><h4 id="如何添加到request链"><a href="#如何添加到request链" class="headerlink" title="如何添加到request链"></a>如何添加到request链</h4><p><strong>sys_read</strong>核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 读哪个fd(可以找到inode，进而找到磁盘位置)下多少数据count，buf:读到哪里</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd,<span class="hljs-type">char</span> * buf,<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span> =</span> current-&gt;filp[fd];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span> =</span> file-&gt;f_inode;<br>    <span class="hljs-comment">// 校验 buf 区域的内存限制</span><br>    verify_area(buf,count);<br>    <span class="hljs-comment">// 仅关注目录文件或普通文件</span><br>    <span class="hljs-keyword">return</span> file_read(inode,file,buf,count);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151134683.png" alt="image-20240415113402051"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">file_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> m_inode * inode, <span class="hljs-keyword">struct</span> file * filp, <span class="hljs-type">char</span> * buf, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-type">int</span> left,chars,nr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span><br>    left = count;<br>    <span class="hljs-keyword">while</span> (left) &#123;<br>        <span class="hljs-keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;<br>            <span class="hljs-keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))<br>                <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            bh = <span class="hljs-literal">NULL</span>;<br>        nr = filp-&gt;f_pos % BLOCK_SIZE;<br>        chars = MIN( BLOCK_SIZE-nr , left );<br>        filp-&gt;f_pos += chars;<br>        left -= chars;<br>        <span class="hljs-keyword">if</span> (bh) &#123;<br>            <span class="hljs-type">char</span> * p = nr + bh-&gt;b_data;<br>            <span class="hljs-keyword">while</span> (chars--&gt;<span class="hljs-number">0</span>)<br>                put_fs_byte(*(p++),buf++);<br>            brelse(bh);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (chars--&gt;<span class="hljs-number">0</span>)<br>                put_fs_byte(<span class="hljs-number">0</span>,buf++);<br>        &#125;<br>    &#125;<br>    inode-&gt;i_atime = CURRENT_TIME;<br>    <span class="hljs-keyword">return</span> (count-left)?(count-left):-ERROR;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是不断的读取数据到我们的buf中，从代码中可以看到是从<code>buffer_head * bh</code>中读的，这是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buffer_head * <span class="hljs-title function_">bread</span><span class="hljs-params">(<span class="hljs-type">int</span> dev,<span class="hljs-type">int</span> block)</span> &#123; <span class="hljs-comment">// block read</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span> =</span> getblk(dev,block);<span class="hljs-comment">// 申请了一个内存中的缓冲块</span><br>    <span class="hljs-keyword">if</span> (bh-&gt;b_uptodate)<br>        <span class="hljs-keyword">return</span> bh;<br>    ll_rw_block(READ,bh); <span class="hljs-comment">// 读取数据到内存： 创建一个request，添加到queue</span><br>    wait_on_buffer(bh); <span class="hljs-comment">// 阻塞到一直读取完成</span><br>    <span class="hljs-keyword">if</span> (bh-&gt;b_uptodate)<br>        <span class="hljs-keyword">return</span> bh;<br>    brelse(bh);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 getblk 先申请了一个内存中的缓冲块，然后 ll_rw_block 负责把数据读入这个缓冲块，进去继续看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ll_rw_block</span><span class="hljs-params">(<span class="hljs-type">int</span> rw, <span class="hljs-keyword">struct</span> buffer_head * bh)</span> &#123;<br>    ...<br>    make_request(major,rw,bh);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">make_request</span><span class="hljs-params">(<span class="hljs-type">int</span> major,<span class="hljs-type">int</span> rw, <span class="hljs-keyword">struct</span> buffer_head * bh)</span> &#123;<br>    ...<br><span class="hljs-keyword">if</span> (rw == READ)<br>        req = request+NR_REQUEST;<br>    <span class="hljs-keyword">else</span><br>        req = request+((NR_REQUEST*<span class="hljs-number">2</span>)/<span class="hljs-number">3</span>);<br><span class="hljs-comment">/* find an empty request */</span><br>    <span class="hljs-keyword">while</span> (--req &gt;= request)<br>        <span class="hljs-keyword">if</span> (req-&gt;dev&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-comment">// 创建一个读请求，我要读哪个磁盘哪个扇区 读到哪</span><br><span class="hljs-comment">/* fill up the request-info, and add it to the queue */</span><br>    req-&gt;dev = bh-&gt;b_dev;<br>    req-&gt;cmd = rw;<br>    req-&gt;errors=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 块是逻辑概念  扇区是最小物理存储单位 假设每个块占用2个扇区</span><br>    req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="hljs-number">1</span>;  <br>    req-&gt;nr_sectors = <span class="hljs-number">2</span>;<br>    req-&gt;buffer = bh-&gt;b_data;<br>    req-&gt;waiting = <span class="hljs-literal">NULL</span>;<br>    req-&gt;bh = bh;<br>    req-&gt;next = <span class="hljs-literal">NULL</span>;<br>    add_request(major+blk_dev,req);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ll_rw_block会往刚刚的设备的请求项链表 request[32] 中添加一个请求项,作为访问块设备和内存缓冲区之间的桥梁</li><li>请求队列中的请求由I&#x2F;O调度器进行管理。I&#x2F;O调度器负责确定请求的执行顺序，优化整体的磁盘性能和响应时间。Linux提供了多种I&#x2F;O调度器，如CFQ（完全公平队列）、Deadline、NOOP等，不同的调度器适用于不同类型的工作负载和硬件配置。</li></ul><h3 id="控制台初始化-tty-init"><a href="#控制台初始化-tty-init" class="headerlink" title="控制台初始化 tty_init"></a>控制台初始化 tty_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tty_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    rs_init(); <span class="hljs-comment">// 串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC机上很少用到</span><br>    con_init();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">con_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (ORIG_VIDEO_MODE == <span class="hljs-number">7</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0x10</span>) &#123;...&#125;<br>        <span class="hljs-keyword">else</span> &#123;...&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0x10</span>) &#123;...&#125;<br>        <span class="hljs-keyword">else</span> &#123;...&#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>非常多的 if else。为了应对不同的显示模式，来分配不同的变量值，那如果我们仅仅找出一个显示模式，这些分支就可以只看一个了。</p><h4 id="如何显示一个字符"><a href="#如何显示一个字符" class="headerlink" title="如何显示一个字符"></a>如何显示一个字符</h4><p>啥是显示模式呢？那我们得简单说说显示，<strong>一个字符是如何显示在屏幕上的呢</strong>？换句话说，如果你可以随意操作内存和 CPU 等设备，你如何操作才能使得你的显示器上，显示一个字符‘a’呢？</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151150914" alt="Image"></p><p>内存中有这样一部分区域，是和显存映射的。啥意思，就是你往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。<code>mov [0xB8000],&#39;h&#39;</code> </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151152141.png" alt="image-20240415115222575"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>假设显示模式是我们现在的这种文本模式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ORIG_X          (*(unsigned char *)0x90000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ORIG_Y          (*(unsigned char *)0x90001)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">con_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a;<br>    <span class="hljs-comment">// 第一部分 获取显示模式相关信息 之前BIOS中断获取了放到0x90000</span><br>    video_num_columns = (((*(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)<span class="hljs-number">0x90006</span>) &amp; <span class="hljs-number">0xff00</span>) &gt;&gt; <span class="hljs-number">8</span>); <br>    video_size_row = video_num_columns * <span class="hljs-number">2</span>;<br>    video_num_lines = <span class="hljs-number">25</span>;<br>    video_page = (*(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)<span class="hljs-number">0x90004</span>);<br>    video_erase_char = <span class="hljs-number">0x0720</span>;<br>    <span class="hljs-comment">// 第二部分 显存映射的内存区域 </span><br>    video_mem_start = <span class="hljs-number">0xb8000</span>;<br>    video_port_reg  = <span class="hljs-number">0x3d4</span>;<br>    video_port_val  = <span class="hljs-number">0x3d5</span>;<br>    video_mem_end = <span class="hljs-number">0xba000</span>;<br>    <span class="hljs-comment">// 第三部分 滚动屏幕操作时的信息</span><br>    origin  = video_mem_start;<br>    scr_end = video_mem_start + video_num_lines * video_size_row;<br>    top = <span class="hljs-number">0</span>;<br>    bottom  = video_num_lines;<br>    <span class="hljs-comment">// 第四部分 定位光标（同样是0x90000）并开启键盘中断</span><br>    gotoxy(ORIG_X, ORIG_Y);<br>    set_trap_gate(<span class="hljs-number">0x21</span>,&amp;keyboard_interrupt); <span class="hljs-comment">// 键盘中断函数</span><br>    outb_p(inb_p(<span class="hljs-number">0x21</span>)&amp;<span class="hljs-number">0xfd</span>,<span class="hljs-number">0x21</span>);<br>    a=inb_p(<span class="hljs-number">0x61</span>);<br>    outb_p(a|<span class="hljs-number">0x80</span>,<span class="hljs-number">0x61</span>);<br>    outb(a,<span class="hljs-number">0x61</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gotoxy</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> new_x,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> new_y)</span> &#123;<br>   ...<br>   x = new_x;<br>   y = new_y;<br>   pos = origin + y*video_size_row + (x&lt;&lt;<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>x</strong> 表示光标在哪一列，<strong>y</strong> 表示光标在哪一行，<strong>pos</strong> 表示根据列号和行号计算出来的内存指针，也就是往这个 pos 指向的地址处写数据，就相当于往控制台的 x 列 y 行处写入字符了</p></blockquote><h4 id="键盘中断"><a href="#键盘中断" class="headerlink" title="键盘中断"></a>键盘中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">_keyboard_interrupt:<br>    ...<br>    call _do_tty_interrupt<br>    ...<br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">do_tty_interrupt</span><span class="hljs-params">(<span class="hljs-type">int</span> tty)</span> &#123;<br>   copy_to_cooked(tty_table+tty);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">copy_to_cooked</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct * tty)</span> &#123;<br>    ...<br>    tty-&gt;write(tty);<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 控制台时 tty 的 write 为 con_write 函数  就是往pos写值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">con_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct * tty)</span> &#123;<br>    ...<br>    __asm__(<span class="hljs-string">&quot;movb _attr,%%ah\n\t&quot;</span><br>      <span class="hljs-string">&quot;movw %%ax,%1\n\t&quot;</span><br>      ::<span class="hljs-string">&quot;a&quot;</span> (c),<span class="hljs-string">&quot;m&quot;</span> (*(<span class="hljs-type">short</span> *)pos)<br>      :<span class="hljs-string">&quot;ax&quot;</span>);<br>     pos += <span class="hljs-number">2</span>;<br>     x++; <span class="hljs-comment">// 当然这里后面还需要判断x是否到达video_num_columns进行其他处理</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们可以实现显示功能了，本质就是往内存中pos位置写值，那<strong>回车</strong>、<strong>换行</strong>、<strong>删除</strong>、<strong>滚屏</strong>、<strong>清屏</strong>等操作，其实底层都操作x y pos，然后修改内存就行，并对外暴露小功能函数</p><p>在此之后，内核代码就可以用它来方便地在控制台输出字符啦！这在之后内核想要在启动过程中告诉用户一些信息，以及后面内核完全建立起来之后，由用户用 shell 进行操作时手动输入命令，都是可以用到这里的代码的！</p><p>printf 这样的库函数，在屏幕上输出信息，同时支持换行和滚屏等友好设计，这些都是 tty_init 初始化，以及其对外封装的小功能函数，来实现的。</p><h3 id="时间初始化-time-init"><a href="#时间初始化-time-init" class="headerlink" title="时间初始化 time_init"></a>时间初始化 time_init</h3><ul><li>直接联网</li><li>如果没有网呢？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMOS_READ(addr) (&#123; \</span><br><span class="hljs-meta">    outb_p(0x80|addr,0x70); \</span><br><span class="hljs-meta">    inb_p(0x71); \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">time_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">time</span>;</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        time.tm_sec = CMOS_READ(<span class="hljs-number">0</span>);<br>        time.tm_min = CMOS_READ(<span class="hljs-number">2</span>);<br>        time.tm_hour = CMOS_READ(<span class="hljs-number">4</span>);<br>        time.tm_mday = CMOS_READ(<span class="hljs-number">7</span>);<br>        time.tm_mon = CMOS_READ(<span class="hljs-number">8</span>);<br>        time.tm_year = CMOS_READ(<span class="hljs-number">9</span>);<br>    &#125; <span class="hljs-keyword">while</span> (time.tm_sec != CMOS_READ(<span class="hljs-number">0</span>));<br>    BCD_TO_BIN(time.tm_sec); <span class="hljs-comment">// BCD编码转二进制编码</span><br>    BCD_TO_BIN(time.tm_min);<br>    BCD_TO_BIN(time.tm_hour);<br>    BCD_TO_BIN(time.tm_mday);<br>    BCD_TO_BIN(time.tm_mon);<br>    BCD_TO_BIN(time.tm_year);<br>    time.tm_mon--;<br>    startup_time = kernel_mktime(&amp;time);  <span class="hljs-comment">// 计算从1970年1月1日到现在的秒数 作为开机时间</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对一个端口先 out 写一下，再 in 读一下。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMOS_READ(addr) (&#123; \</span><br><span class="hljs-meta">    outb_p(0x80|addr,0x70); \</span><br><span class="hljs-meta">    inb_p(0x71); \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>这是 CPU 与外设交互的一个基本玩法，CPU 与外设打交道基本是通过端口，往某些端口写值来表示要这个外设干嘛，然后从另一些端口读值来接受外设的反馈。</p><p>以磁盘为例：读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151341483.png" alt="image-20240415134102265"></p><ol><li>在 0x1F2 写入要读取的扇区数</li><li>在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</li><li>在 0x1F7 处写入读命令的指令号</li><li>不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</li><li>如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</li></ol><p>当然，读取硬盘的这个无脑循环，可以 <strong>CPU</strong> 直接读取并做写入内存的操作，这样就会占用 CPU 的计算资源。</p><p>也可以交给 <strong>DMA</strong> 设备去读，解放 CPU，但和硬盘的交互，通通都是按照硬件手册上的端口说明，来操作的，实际上也是做了一层封装。</p><p>而在时间读取中，就是和<strong>CMOS</strong>（主板上的一个可读写的 RAM）这个外设打交道，让他告诉我们时间</p><blockquote><p>CMOS:计算机主板上的一小块芯片，这块芯片使用CMOS技术来存储BIOS（基本输入输出系统）设置等基础系统信息。这些信息包括系统时间、硬件配置设置等，这部分内存被称为CMOS  RAM或非易失性BIOS内存。由于CMOS技术的低功耗特点，即使在计算机断电后，CMOS内存也能通过一个小电池供电维持数据存储。这使得计算机在下一次开机时可以记住之前的配置设置。</p></blockquote><h3 id="进程调度初始化-sched-init"><a href="#进程调度初始化-sched-init" class="headerlink" title="进程调度初始化 sched_init"></a><a href="https://mp.weixin.qq.com/s/j4FYWUSX_2gpDb_h4vEFqQ">进程调度初始化 sched_init</a></h3><p>这方法可了不起，因为它就是多进程的基石！</p><p>终于来到了兴奋的时刻，是不是很激动？不过先别激动，这里只是进程调度的初始化，也就是为进程调度所需要用到的数据结构做个准备，真正的进程调度还需要调度算法、时钟中断等机制的配合。</p><p>当然，对于理解操作系统，流程和数据结构最为重要了，而这一段作为整个流程的起点，以及建立数据结构的地方，就显得格外重要了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    set_tss_desc(gdt+<span class="hljs-number">4</span>, &amp;(init_task.task.tss));<br>    set_ldt_desc(gdt+<span class="hljs-number">5</span>, &amp;(init_task.task.ldt));<br>    ...<br>&#125;<br>往后加了两项：TSS和LDT 这是代表一个线程<span class="hljs-number">0</span>，如果由其他线程还要继续加<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151347960.png" alt="image-20240415134738723"></p><h4 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h4><p>TSS 在计算机中代表任务状态段 (Task State  Segment)。它是一种数据结构，用于存储处理器在任务切换时必须保存的特定任务的状态信息（寄存器的值）。每个任务都有一个对应的  TSS。当操作系统执行任务切换时，它会使用 TSS 来保存当前任务的状态，并加载新任务的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span>&#123;</span><br>    <span class="hljs-type">long</span> back_link;<br>    <span class="hljs-type">long</span> esp0;<br>    <span class="hljs-type">long</span> ss0;<br>    <span class="hljs-type">long</span> esp1;<br>    <span class="hljs-type">long</span> ss1;<br>    <span class="hljs-type">long</span> esp2;<br>    <span class="hljs-type">long</span> ss2;<br>    <span class="hljs-type">long</span> cr3;<br>    <span class="hljs-type">long</span> eip;<br>    <span class="hljs-type">long</span> eflags;<br>    <span class="hljs-type">long</span> eax, ecx, edx, ebx;<br>    <span class="hljs-type">long</span> esp;<br>    <span class="hljs-type">long</span> ebp;<br>    <span class="hljs-type">long</span> esi;<br>    <span class="hljs-type">long</span> edi;<br>    <span class="hljs-type">long</span> es;<br>    <span class="hljs-type">long</span> cs;<br>    <span class="hljs-type">long</span> ss;<br>    <span class="hljs-type">long</span> ds;<br>    <span class="hljs-type">long</span> fs;<br>    <span class="hljs-type">long</span> gs;<br>    <span class="hljs-type">long</span> ldt;<br>    <span class="hljs-type">long</span> trace_bitmap;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i387_struct</span> <span class="hljs-title">i387</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h4><p>LDT 叫<strong>局部描述符表</strong>（Local Descriptor Table），是与 GDT 全局描述符表相对应的，内核态的代码用 GDT 里的数据段和代码段，而用户进程的代码用每个用户进程自己的 LDT 里得数据段和代码段。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151351835.png" alt="image-20240415135055576"></p><h4 id="task"><a href="#task" class="headerlink" title="task[]"></a><strong>task[]</strong></h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151413486.png" alt="image-20240415141329918"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> a,b; <span class="hljs-comment">// 段的基址、段的界限（大小）、类型（如代码段、数据段）、特权级（DPL）、存在位（P）、以及其他一些硬件和操作系统使用的标志。</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">task</span>[64] =</span> &#123;&amp;(init_task.task), &#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sched_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> * <span class="hljs-title">p</span>;</span><br>        p = gdt+<span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">64</span>;i++) &#123;<br>        task[i] = <span class="hljs-literal">NULL</span>;<br>        p-&gt;a=p-&gt;b=<span class="hljs-number">0</span>;<br>        p++;<br>        p-&gt;a=p-&gt;b=<span class="hljs-number">0</span>;<br>        p++;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 task_struct 结构就是代表<strong>每一个进程的信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-comment">/* these are hardcoded - don&#x27;t touch */</span><br>    <span class="hljs-type">long</span> state; <span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br>    <span class="hljs-type">long</span> counter;<br>    <span class="hljs-type">long</span> priority;<br>    <span class="hljs-type">long</span> signal;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sigaction</span>[32];</span><br>    <span class="hljs-type">long</span> blocked; <span class="hljs-comment">/* bitmap of masked signals */</span><br>  <span class="hljs-comment">/* various fields */</span><br>    <span class="hljs-type">int</span> exit_code;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code,end_code,end_data,brk,start_stack;<br>    <span class="hljs-type">long</span> pid,father,pgrp,session,leader;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> uid,euid,suid;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gid,egid,sgid;<br>    <span class="hljs-type">long</span> alarm;<br>    <span class="hljs-type">long</span> utime,stime,cutime,cstime,start_time;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> used_math;<br>  <span class="hljs-comment">/* file system info */</span><br>    <span class="hljs-type">int</span> tty;  <span class="hljs-comment">/* -1 if no tty, so it must be signed */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> umask;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">pwd</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">root</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">executable</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> close_on_exec;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">filp</span>[<span class="hljs-title">NR_OPEN</span>];</span><br>  <span class="hljs-comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> <span class="hljs-title">ldt</span>[3];</span>  <span class="hljs-comment">// 上面的LDT指向这里</span><br>  <span class="hljs-comment">/* tss for this task */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> <span class="hljs-title">tss</span>;</span>      <span class="hljs-comment">// 上面的LDT指向这里</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来告诉通过寄存器告诉系统当前任务的LDT，TSS的位置（内存里每个线程都有LDT，TSS，当前线程的是哪一个），初始指向了第0个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    ltr(<span class="hljs-number">0</span>);<br>    lldt(<span class="hljs-number">0</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151359074.png" alt="image-20240415135915887"></p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    outb_p(<span class="hljs-number">0x36</span>,<span class="hljs-number">0x43</span>);      <span class="hljs-comment">/* binary, mode 3, LSB/MSB, ch 0 */</span><br>    outb_p(LATCH &amp; <span class="hljs-number">0xff</span> , <span class="hljs-number">0x40</span>);    <span class="hljs-comment">/* LSB */</span><br>    outb(LATCH &gt;&gt; <span class="hljs-number">8</span> , <span class="hljs-number">0x40</span>);    <span class="hljs-comment">/* MSB */</span><br>    set_intr_gate(<span class="hljs-number">0x20</span>,&amp;timer_interrupt);  <span class="hljs-comment">// 时钟中断</span><br>    <br><br>    outb(inb_p(<span class="hljs-number">0x21</span>)&amp;~<span class="hljs-number">0x01</span>,<span class="hljs-number">0x21</span>);<br>    set_system_gate(<span class="hljs-number">0x80</span>,&amp;system_call); <span class="hljs-comment">// 系统调用</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>四行端口读写代码，两行设置中断代码。</p><p>端口读写我们已经很熟悉了，就是 CPU 与外设交互的一种方式，之前讲硬盘读写以及 CMOS 读写时，已经接触过了。</p><p>而这次交互的外设是一个<strong>可编程定时器</strong>的芯片，这四行代码就开启了这个定时器，之后这个定时器变会<strong>持续的、以一定频率的向 CPU 发出中断信号</strong>。</p><ol><li><p>第一个就是<strong>时钟中断</strong>，中断号为 <strong>0x20</strong>，中断处理程序为 <strong>timer_interrupt</strong>。那么每次定时器向 CPU 发出中断后，便会执行这个函数。</p><blockquote><ul><li>更新系统时间或运行时间计数器。</li><li>检查和执行定时任务或超时事件(网络通信和用户交互)。</li><li>对当前运行的进程或线程的运行时间进行计量，以便进行任务调度。</li></ul><p>是操作系统主导进程调度的一个关键！</p></blockquote></li><li><p>第二个设置的中断叫系统调用 <strong>system_call</strong>，中断号是 <strong>0x80</strong>，这个中断又是个非常非常非常非常非常非常非常重要的中断，所有用户态程序想要调用内核提供的方法，都需要基于这个系统调用来进行。</p><blockquote><p>Java 程序员写一个 read，底层会执行汇编指令 <strong>int 0x80</strong>，这就会触发系统调用这个中断，最终调用到 Linux 里的 sys_read 方法。</p></blockquote></li></ol><table><thead><tr><th>中断号</th><th>中断处理函数</th></tr></thead><tbody><tr><td>0 ~ 0x10 (trap_init)</td><td>trap_init 里设置的一堆</td></tr><tr><td>0x20</td><td>timer_interrupt</td></tr><tr><td>0x21 (tty_init)</td><td>keyboard_interrupt</td></tr><tr><td>0x80</td><td>system_call</td></tr></tbody></table><blockquote><p>找到些感觉没，有没有越来越发现，操作系统有点靠中断驱动的意思，各个模块不断初始化各种中断处理函数，并且开启指定的外设开关，让操作系统自己慢慢“活”了起来，逐渐通过中断忙碌于各种事情中，无法自拔。</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>我们往GDT中写入了TSS和LDT，作为每一个线程的任务状态和局部描述符表 初始： <code>init_task.task.tss init_task.task.ldt</code></li><li>初始化了task_struct [] ，并且第一个位置<code>init_task.task</code></li><li>设置了时钟中断0x20和系统调用0x80</li></ol><h3 id="缓冲区初始化-buffer-init"><a href="#缓冲区初始化-buffer-init" class="headerlink" title="缓冲区初始化 buffer_init"></a><a href="https://mp.weixin.qq.com/s/X8BSbf1qShS11_fzfyOhTg">缓冲区初始化 buffer_init</a></h3><p>在讲通过文件系统来读取硬盘文件时，都需要使用和弃用这个缓冲区里的内容，缓冲区即是用户进程的内存和硬盘之间的桥梁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> end; <span class="hljs-comment">// 内核的结束 缓冲区的开始</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">start_buffer</span> =</span> (<span class="hljs-keyword">struct</span> buffer_head *) &amp;end;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> &#123;</span><br>    <span class="hljs-comment">// 缓冲区的状态</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> b_state;<br>    <span class="hljs-comment">// 缓冲区的数据指针</span><br>    <span class="hljs-type">char</span> *b_data;<br>    <span class="hljs-comment">// 块设备指针 + 块号是hash的key</span><br>    <span class="hljs-comment">// 块设备指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">b_dev</span>;</span>    <br>    <span class="hljs-comment">// 块号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> b_blocknr;       <br>    <span class="hljs-comment">// 用于连接缓冲区链表的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">b_this_page</span>;</span><br>    <span class="hljs-comment">// 用于连接空闲缓冲区链表的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">b_this_free</span>;</span><br>    <span class="hljs-comment">// 用于连接 hash 链表的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">b_next</span>;</span><br>    <span class="hljs-comment">// 缓冲区的引用计数</span><br>    <span class="hljs-type">atomic_t</span> b_count;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buffer_init</span><span class="hljs-params">(<span class="hljs-type">long</span> buffer_end)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">h</span> =</span> start_buffer;<br>    <span class="hljs-type">void</span> * b = (<span class="hljs-type">void</span> *) buffer_end;<br>    <span class="hljs-keyword">while</span> ( (b -= <span class="hljs-number">1024</span>) &gt;= ((<span class="hljs-type">void</span> *) (h+<span class="hljs-number">1</span>)) ) &#123;<br>        h-&gt;b_dev = <span class="hljs-number">0</span>;<br>        h-&gt;b_dirt = <span class="hljs-number">0</span>;<br>        h-&gt;b_count = <span class="hljs-number">0</span>;<br>        h-&gt;b_lock = <span class="hljs-number">0</span>;<br>        h-&gt;b_uptodate = <span class="hljs-number">0</span>;<br>        h-&gt;b_wait = <span class="hljs-literal">NULL</span>;<br>        h-&gt;b_next = <span class="hljs-literal">NULL</span>;<br>        h-&gt;b_prev = <span class="hljs-literal">NULL</span>;<br>        h-&gt;b_data = (<span class="hljs-type">char</span> *) b;<br>        h-&gt;b_prev_free = h<span class="hljs-number">-1</span>;<br>        h-&gt;b_next_free = h+<span class="hljs-number">1</span>;<br>        h++;<br>    &#125;<br>    h--;<br>    free_list = start_buffer;<br>    free_list-&gt;b_prev_free = h;<br>    h-&gt;b_next_free = free_list;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">307</span>;i++)<br>        hash_table[i]=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>缓冲头记录下头信息，并通过pre next串联起来</li><li>b_data指向真正的数据区</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151428201.png" alt="image-20240415142819120"></p><ul><li>读取块设备的数据（硬盘中的数据），需要先读到缓冲区中，如果缓冲区已有了，就不用从块设备读取了，直接取走</li><li>怎么知道缓冲区已经有了要读取的块设备中的数据呢？ 遍历效率太低，直接hash</li><li>key是什么？ <code>(设备号^逻辑块号) Mod 307</code>   冲突用链表解决</li><li>如何实现淘汰呢？<strong>哈希表 + 双向链表</strong>实现<strong>LRU</strong></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151430714.png" alt="image-20240415143025425"></p><h3 id="硬盘初始化-hd-init"><a href="#硬盘初始化-hd-init" class="headerlink" title="硬盘初始化 hd_init"></a><a href="https://mp.weixin.qq.com/s/803C9jHxIe42i9BrNzEvPA">硬盘初始化 hd_init</a></h3><ul><li><strong>hd_init</strong> 是<strong>硬盘初始化</strong>，我们不得不看</li><li><strong>floppy_init</strong> 是<strong>软盘初始化</strong>，现在软盘几乎都被淘汰了，计算机中也没有软盘驱动器了，所以这个我们完全可以不看</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_dev_struct</span> <span class="hljs-title">blk_dev</span>[<span class="hljs-title">NR_BLK_DEV</span>] =</span> &#123;<br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;,     <span class="hljs-comment">/* no_dev */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;,     <span class="hljs-comment">/* dev mem */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;,     <span class="hljs-comment">/* dev fd */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;,     <span class="hljs-comment">/* dev hd */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;,     <span class="hljs-comment">/* dev ttyx */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;,     <span class="hljs-comment">/* dev tty */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;      <span class="hljs-comment">/* dev lp */</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">//每个块设备执行读写请求都有自己的函数实现，在上层看来都是一个统一函数 request_fn 即可，具体实现各有不同，对于硬盘来说，这个实现就是 do_hd_request 函数</span><br>    blk_dev[<span class="hljs-number">3</span>].request_fn = do_hd_request; <br>    set_intr_gate(<span class="hljs-number">0x2E</span>,&amp;hd_interrupt); <span class="hljs-comment">// 硬盘中断的处理函数  </span><br>    <br>    <span class="hljs-comment">// 允许硬盘控制器发送中断请求信号 </span><br>    <span class="hljs-comment">// 我们向来是不深入硬件细节，知道往这个端口里写上这些数据，导致硬盘开启了中断，即可</span><br>    outb_p(inb_p(<span class="hljs-number">0x21</span>)&amp;<span class="hljs-number">0xfb</span>,<span class="hljs-number">0x21</span>);<br>    outb(inb_p(<span class="hljs-number">0xA1</span>)&amp;<span class="hljs-number">0xbf</span>,<span class="hljs-number">0xA1</span>); <br>&#125;<br></code></pre></td></tr></table></figure><ol><li>往某些 IO 端口上读写一些数据，表示开启它；</li><li>然后再向中断向量表中添加一个中断，使得 CPU 能够响应这个硬件设备的动作；</li><li>最后再初始化一些数据结构来管理。不过像是内存管理可能结构复杂些，外设的管理，相对就简单很多了。</li></ol><blockquote><p><strong>操作系统就是一个靠中断驱动的死循环而已</strong>，如果不发生任何中断，操作系统会一直在一个死循环里等待。换句话说，让操作系统工作的唯一方式，就是触发中断。</p></blockquote><h4 id="硬盘端口"><a href="#硬盘端口" class="headerlink" title="硬盘端口"></a>硬盘端口</h4><p>端口对应硬盘控制器上的寄存器</p><table><thead><tr><th align="left">端口</th><th align="left">读</th><th align="left">写</th></tr></thead><tbody><tr><td align="left">0x1F0</td><td align="left">数据寄存器</td><td align="left">数据寄存器</td></tr><tr><td align="left">0x1F1</td><td align="left">错误寄存器</td><td align="left">特征寄存器</td></tr><tr><td align="left">0x1F2</td><td align="left">扇区计数寄存器</td><td align="left">扇区计数寄存器</td></tr><tr><td align="left">0x1F3</td><td align="left">扇区号寄存器或 LBA 块地址 0~7</td><td align="left">扇区号或 LBA 块地址 0~7</td></tr><tr><td align="left">0x1F4</td><td align="left">磁道数低 8 位或 LBA 块地址 8~15</td><td align="left">磁道数低 8 位或 LBA 块地址 8~15</td></tr><tr><td align="left">0x1F5</td><td align="left">磁道数高 8 位或 LBA 块地址 16~23</td><td align="left">磁道数高 8 位或 LBA 块地址 16~23</td></tr><tr><td align="left">0x1F6</td><td align="left">驱动器&#x2F;磁头或 LBA 块地址 24~27</td><td align="left">驱动器&#x2F;磁头或 LBA 块地址 24~27</td></tr><tr><td align="left">0x1F7</td><td align="left">命令寄存器或状态寄存器</td><td align="left">命令寄存器</td></tr></tbody></table><p>那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 <code>0x1F0</code> 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。</p><p>如果觉得不够具体，那来个具体的版本。</p><ul><li><p><strong>1</strong>. 在 <code>0x1F2</code> 写入要读取的扇区数</p></li><li><p><strong>2</strong>. 在 <code>0x1F3 ~ 0x1F6</code> 这四个端口写入计算好的起始 LBA 地址</p></li><li><p><strong>3</strong>. 在 <code>0x1F7</code> 处写入读命令的指令号</p></li><li><p><strong>4</strong>. 不断检测 <code>0x1F7</code> （此时已成为状态寄存器的含义）的忙位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">hd_out</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> drive,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nsect,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sect,</span><br><span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cyl,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,</span><br><span class="hljs-params">        <span class="hljs-type">void</span> (*intr_addr)(<span class="hljs-type">void</span>))</span> &#123;<br>    ...<br>    do_hd = intr_addr;<br>    outb_p(hd_info[drive].ctl,HD_CMD);<br>    port = <span class="hljs-number">0x1f0</span>;<br>    outb_p(hd_info[drive].wpcom&gt;&gt;<span class="hljs-number">2</span>,++port);<br>    outb_p(nsect,++port);<br>    outb_p(sect,++port);<br>    outb_p(cyl,++port);<br>    outb_p(cyl&gt;&gt;<span class="hljs-number">8</span>,++port);<br>    outb_p(<span class="hljs-number">0xA0</span>|(drive&lt;&lt;<span class="hljs-number">4</span>)|head,++port);<br>    outb(cmd,++port);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
      <category>linux源码趣读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进入内核前的苦力活[linux源码趣读]</title>
    <link href="/2023/06/23/book/%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB%5Blinux%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB%5D/"/>
    <url>/2023/06/23/book/%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB%5Blinux%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB%5D/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>计算机系统启动及内存管理流程主要包括以下几个关键步骤：    1. <strong>初始启动阶段</strong>      - CPU从ROM的<code>0xFFFF0</code>地址（BIOS入口）开始执行。      - BIOS加载硬盘第一个扇区的代码（bootsect）到内存的<code>0x7C00</code>地址，随后将其复制到<code>0x90000</code>。      - 跳转到<code>go</code>代码，设置<code>cs</code>、<code>ds</code>、<code>ss</code>、<code>sp</code>等寄存器，完成早期初始化。      - 将操作系统核心代码（setup.s和head.s）加载到内存，bootsect.s的使命结束。    2. <strong>setup.s阶段</strong>      - 通过<code>int</code>指令初始化硬件（如光标、内存、显卡、磁盘信息），并存储到原先bootsect.s所在的位置。      - 将system代码复制到内存的<code>0x0</code>地址，准备后续切换至保护模式。    3. <strong>实模式与保护模式</strong>      - <strong>实模式</strong>：早期8086处理器的基本工作模式，直接访问物理内存，无内存保护或分页机制。      - <strong>保护模式</strong>（<code>cr0.PE=1</code>）：现代处理器模式，支持分页、虚拟内存和内存保护。特权级（CPL）通过CS段选择子确定，分为Ring 0（内核态）至Ring 3（用户态）。    4. <strong>保护模式初始化（setup.s完成）</strong>      - 设置IDT（初始化键盘、时钟等中断）和GDT（定义代码段、数据段描述符）。      - 将<code>cr0.PE</code>置1，切换到保护模式后，地址转换通过段选择子从GDT获取段基址。      - 跳转到<code>cs\:ip 0\:0</code>（system代码入口）。      - 重新设置IDT和GDT，指向新内存空间。    5. <strong>分页机制启用</strong>      - 设置<code>cr0.PG=1</code>开启分页，MMU通过二级页表（页目录表PDE和页表PTE）将线性地址转为物理地址。      - Linux 0.11设计支持最大16MB内存，通过1个页目录表和4个页表管理。      - 分页机制实现内存隔离和按需分配，而分段机制（保护模式必需）主要用于权限控制和逻辑地址转换。    6. <strong>关键寄存器作用</strong>      - <strong>CR3</strong>：指向页目录表，进程切换时更新。      - <strong>分段机制</strong>：CS&#x2F;EIP（代码执行）、DS（数据访问…</p></blockquote><h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101381.png" alt="image-20240413113503285"></p><h3 id="加载代码"><a href="#加载代码" class="headerlink" title="加载代码"></a>加载代码</h3><ul><li>pc指针初始指向0xFFFF0（ROM）  代表BIOS的地址</li><li>加载硬盘第一扇区代码（bootsetct）到0x7c00</li><li>复制到0x90000</li><li>跳转到go代码，设置好cs ds ss sp</li><li>把全部os代码搬入内存（setup.s  2~5； head.s 240扇区），至此bootsect.s使命完成</li><li>setup.s  使用<code>int</code> 指令初始化光标、内存、显卡、磁盘等信息放到bootsect.s的位置，并把system代码复制到0位置</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101383.png" alt="image-20240413122232858"></p><h3 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h3><ul><li><p>实模式：</p><ul><li>处理器基本工作模式,主要用于兼容早期的8086处理器</li><li>直接访问物理内存,没有内存保护机制， 没有虚拟内存和分页机制</li></ul></li><li><p>保护模式  cr0中PE&#x3D;1</p><ul><li><p>现代处理器</p></li><li><p>支持分页以及虚拟内存以及内存保护机制</p></li><li><pre><code class="hljs">保护模式 CS下最后两位 代表CPL   此外倒数第三位决定从GDT还是LDT  ├── Ring 0 --&gt; 内核态  ├── Ring 1 --&gt; 设备驱动(较少使用)  ├── Ring 2 --&gt; 设备驱动(较少使用)  └── Ring 3 --&gt; 用户态<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>setup.s<br><br><span class="hljs-bullet">1.</span> 设置初始化IDT(键盘、时钟、串口、鼠标)，GDT（包含代码段、数据段描述符）并设置寄存器指向他们的地址<br><br><span class="hljs-bullet">2.</span> 将cr0中PE置为1，切换到保护模式（地址转换也响应变换）<br><br><span class="hljs-bullet">   -</span> 原来实模式下地址转换的方法![<span class="hljs-string">image-20240413114140760</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101384.png</span>)<br><br><span class="hljs-bullet">   -</span> 保护模式下转换方法：需要转换一下段基址（<span class="hljs-strong">**段寄存器（比如 ds、ss、cs）里存储的是段选择子，段选择子去全局描述符表中寻找段描述符，从中取出段基址**</span>）<br><br><span class="hljs-code">     ![image-20240413114229120](https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101385.png)</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">3.</span> 跳转到cs：ip 0:0位置，<span class="hljs-strong">**从现在开始进入system代码**</span><br><br><span class="hljs-bullet">4.</span> 重新设置idt、gdt，指向新的空间<br><br>![<span class="hljs-string">image-20240413113535007</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101386.png</span>)<br><br><br><br><span class="hljs-section">### 开启分页</span><br><br><span class="hljs-section">#### 地址转换</span><br><br><span class="hljs-strong">**cr0**</span>中的PG设置为1<br><br>没有开启分页机制的时候，只需要经过这一步转换即可得到最终的物理地址了，但是在开启了分页机制后，又会<span class="hljs-strong">**多一步转换**</span>。<br><br>![<span class="hljs-string">image-20240413115624426</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101387.png</span>)<br><br>二级页表线性地址转物理地址（第一级叫<span class="hljs-strong">**页目录表 PDE**</span>，第二级叫<span class="hljs-strong">**页表 PTE**</span>），<span class="hljs-strong">**MMU**</span>负责转换<br><br>0000000011<span class="hljs-emphasis">_0100000000_</span>000000000000<br><br>![<span class="hljs-string">image-20240413115734998</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101388.png</span>)<br><br><span class="hljs-quote">&gt; 当时 linux-0.11 认为，总共可以使用的内存不会超过 <span class="hljs-strong">**16M**</span>，也即最大地址空间为 <span class="hljs-strong">**0xFFFFFF**</span>。</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 而按照当前的页目录表和页表这种机制，1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），1 个页表最多包含 1024 个页表项（也就是 1024 个页），1 页为 4KB（因为有 12 位偏移地址），因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB</span><br><br><br><br><span class="hljs-quote">&gt; 在早期的x86保护模式中，分段机制用于控制内存访问，给不同段分配不同的权限级别。但在现代操作系统中，分段机制主要用于基础的内存地址分段，而特权控制和内存保护主要依赖分页机制。因此，Linux等操作系统通常将分段简化为“扁平模式”（flat model），即所有段的基地址设为0，段限长覆盖整个虚拟地址空间，这样就可以忽略分段的复杂性，专注于分页。</span><br><br><span class="hljs-section">#### 全局结构</span><br><br>![<span class="hljs-string">image-20240413120123983</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101389.png</span>)<br><br>CR3寄存器是虚拟内存管理的核心部分，与操作系统的内存管理紧密相关。当操作系统需要切换当前的内存映射时（如进程切换时），它会更新CR3寄存器的值来指向新的页目录表。<br><br><br><br><span class="hljs-section">#### 小结</span><br><br>Intel 体系结构的<span class="hljs-strong">**内存管理**</span>可以分成两大部分，也就是标题中的两板斧，<span class="hljs-strong">**分段**</span>和<span class="hljs-strong">**分页**</span>。<br><br><span class="hljs-strong">**分段机制**</span>在之前几回已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。(保护模式必须开启)<br><br><span class="hljs-strong">**分页机制**</span>是本回讲的内容，开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。其目的在于可以<span class="hljs-strong">**按需使用**</span>物理内存，同时也可以在<span class="hljs-strong">**多任务时起到隔离**</span>的作用，这个在后面将多任务时将会有所体会。<br><br><span class="hljs-bullet">-</span>  <span class="hljs-strong">**逻辑地址**</span>：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**线性地址**</span>：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**物理地址**</span>：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。<br><br>最后进入main函数是利用ret指令，ret会将栈顶作为下一条指令的地址，所以只需要将main函数提前入栈即可<br><br><br><br><span class="hljs-section">### 总结</span><br><br>前五节：载入代码<br><br>![<span class="hljs-string">image-20240413122908367</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151101390.png</span>)<br><br>之后包含进入保护模式（分段）以及开启分页，初始化了IDT、GDT、页表，并且设置响应寄存器指向他们：idtr 寄存器指向了 idt，这个就是中断的设置；gdtr 寄存器指向了 gdt，这个就是全局描述符表的设置，可以简单理解为分段机制的设置；cr3 寄存器指向了页目录表的位置<br><br>![<span class="hljs-string">image-20240415111114132</span>](<span class="hljs-link">https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202404151111119.png</span>)<br><br><span class="hljs-quote">&gt;  Intel 本身对于访问内存就分成三类：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**代码**</span></span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**数据**</span></span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**栈**</span></span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 而 Intel 也提供了三个段寄存器来分别对应着三类内存：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**代码段寄存器（cs）**</span></span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**数据段寄存器（ds）**</span></span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**栈段寄存器（ss）**</span></span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 具体来说：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**cs:eip**</span> 表示了我们要执行哪里的代码。</span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**ds:xxx**</span> 表示了我们要访问哪里的数据。</span><br><span class="hljs-quote">&gt; - <span class="hljs-strong">**ss:esp**</span> 表示了我们的栈顶地址在哪里。</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; 而第一部分的代码，也做了如下工作：</span><br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&gt; - 将 <span class="hljs-strong">**ds**</span> 设置为了 0x10，表示指向了索引值为 2 的全局描述符，即数据段描述符。</span><br><span class="hljs-quote">&gt; - 将 <span class="hljs-strong">**cs**</span> 通过一次长跳转指令设置为了 8，表示指向了索引值为 1 的全局描述符，即代码段描述符。</span><br><span class="hljs-quote">&gt; - 将 <span class="hljs-strong">**ss:esp**</span> 这个栈顶地址设置为 user<span class="hljs-emphasis">_stack 数组的末端。</span></span><br><span class="hljs-emphasis"><span class="hljs-quote">&gt;</span></span><br><span class="hljs-emphasis"><span class="hljs-quote">&gt; 你看，分段和分页，以及这几个寄存器的设置，其实本质上就是安排我们今后访问内存的方式，做了一个初步规划，<span class="hljs-strong">**包括去哪找代码、去哪找数据、去哪找栈，以及如何通过分段和分页机制将逻辑地址转换为最终的物理地址**</span>。</span></span><br><span class="hljs-emphasis"><span class="hljs-quote">&gt;</span></span><br><span class="hljs-emphasis"><span class="hljs-quote">&gt; 而所有上面说的这一切，和 Intel CPU 这个硬件打交道比较多，设置了一些最最最最基础的环境和内存布局，为之后进入 main 函数做了充分的准备，因为 c 语言虽然很底层了，但也有其不擅长的事情，就交给第一部分的汇编语言来做，所以我称第一部分为<span class="hljs-strong">**进入内核前的苦力活**</span>。</span></span><br><span class="hljs-emphasis"><span class="hljs-quote"></span></span><br><span class="hljs-emphasis"><span class="hljs-quote">```c</span></span><br><span class="hljs-emphasis"><span class="hljs-quote">void main(void) &#123;</span></span><br><span class="hljs-emphasis"><span class="hljs-quote">    ROOT_</span>DEV = ORIG<span class="hljs-emphasis">_ROOT_</span>DEV;</span><br><span class="hljs-code">    drive_info = DRIVE_INFO;</span><br><span class="hljs-code">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="hljs-code">    memory_end &amp;= 0xfffff000;</span><br><span class="hljs-code">    if (memory_end &gt; 16*1024*1024)</span><br><span class="hljs-code">        memory_end = 16*1024*1024;</span><br><span class="hljs-code">    if (memory_end &gt; 12*1024*1024) </span><br><span class="hljs-code">        buffer_memory_end = 4*1024*1024;</span><br><span class="hljs-code">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="hljs-code">        buffer_memory_end = 2*1024*1024;</span><br><span class="hljs-code">    else</span><br><span class="hljs-code">        buffer_memory_end = 1*1024*1024;</span><br><span class="hljs-code">    main_memory_start = buffer_memory_end;</span><br><span class="hljs-code">    mem_init(main_memory_start,memory_end);</span><br><span class="hljs-code">    trap_init();</span><br><span class="hljs-code">    blk_dev_init();</span><br><span class="hljs-code">    chr_dev_init();</span><br><span class="hljs-code">    tty_init();</span><br><span class="hljs-code">    time_init();</span><br><span class="hljs-code">    sched_init();</span><br><span class="hljs-code">    buffer_init(buffer_memory_end);</span><br><span class="hljs-code">    hd_init();</span><br><span class="hljs-code">    floppy_init();</span><br><span class="hljs-code">    sti();</span><br><span class="hljs-code">    move_to_user_mode();</span><br><span class="hljs-code">    if (!fork()) &#123;</span><br><span class="hljs-code">        init();</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    for(;;) pause();</span><br><span class="hljs-code">&#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
      <category>linux源码趣读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>simple-db</title>
    <link href="/2023/06/20/simple-db/"/>
    <url>/2023/06/20/simple-db/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文介绍了一个基于Java实现的支持事务的简易关系型数据库系统。该系统主要包含以下核心功能：  1. <strong>数据库基本操作</strong>：    - 实现了包括遍历(Scan)、连接(Join)、聚合(Aggregation)和增删改查等基本数据库操作算子    - 使用直方图统计信息进行查询优化，估算查询成本并确定最优的连接顺序  2. <strong>存储管理</strong>：    - 设计了三级存储结构：HeapPage(存储元组)、HeapFile(管理数据文件)和BufferPool(缓存管理)    - 实现了基于LRU的页面淘汰机制  3. <strong>事务与并发控制</strong>：    - 实现了页面级的共享锁、排他锁和锁升级    - 采用严格两阶段锁协议保证可串行化    - 实现了三种死锁检测算法：超时检测、等待图检测和全局优先级检测(wait-die)  4. <strong>恢复机制</strong>：    - 基于UNDO日志实现STEAL&#x2F;NO-FORCE缓冲区管理策略    - 实现预写日志(WAL)机制，支持事务回滚与恢复    - 通过日志记录数据修改的前后镜像，确保事务的原子性和持久性  系统采用模块化设计，包含完整的数据库组件：表结构管理(Catalog)、查询处理(Operator)、存储管理(HeapFile&#x2F;Page)和事务管理(LockManager&#x2F;LogFile)，是一个教学性质但功能完备的数据库系统实现。</p></blockquote><h1 id="simple-db"><a href="#simple-db" class="headerlink" title="simple-db"></a>simple-db</h1><p>code：<a href="https://github.com/Goinggoinggoing/simple-db-hw-2021">Goinggoinggoing&#x2F;simple-db-hw-2021 (github.com)</a></p><p>基于java语言，实现一个简易事务支持的关系型数据库</p><p>难度：lab4 &#x3D; lab5 &gt; lab6 &gt;&gt;&gt;&gt;&gt;&gt; lab3 &gt; lab2 &gt; lab1 </p><ul><li><p>lab1 实现基本的数据结构<br>tuple, page, tupleDesc, iterator等等，难度不大</p></li><li><p>lab2 实现scan iterator</p><p>​基于scan iterator 来实现各种聚合函数，比如avg，count，sum，join等</p></li><li><p>lab3 join 优化</p><p>​建立一个优化模型， 按照主键，非主键，scan 表代价，直方图等进行成本估计，根据估计值来确定多表join的顺序</p></li><li><p>lab 4 事务以及锁</p><p>​这一章相对较难，要自己实现一个简单的读写锁，但是6.830中简化了，实现了page-level的锁，粒度比较粗，还有多种死锁的情况，test很给力，建议在写的时候一定要看清楚是哪个transaction 拿到了哪些page的哪些lock，而且这里的代码会影响到后面的lab 5、6，这里主要是按照两阶段锁协议并且no steal &#x2F; force 的策略</p><p>​代码中实现基于<strong>Timeout</strong>、<strong>Wait-for Graph</strong> 、 <strong>Global Orderings</strong>(wait-die)死锁检测算法</p></li><li><p>lab 5 B+ 树索引（TODO）</p><p>​实现B+树索引，插入、删除、修改，难点在于要把B+树结构以及这三种操作逻辑要捋清楚，还有父节点，子节点；叶子兄弟节点，非叶子节点的指针问题，以及一些边界条件。</p></li><li><p>lab 6 实现基于 log的rollback 和 recover</p><p>​lab中并没有真正存在undo log 和redo log，日志结构比较简单，只需要根据偏移处理即可，可以理解成是逻辑上的undo log 和 redo log。基于UNDO日志实现<strong>STEAL&#x2F;NO FORCE</strong>策略，提供更灵活的缓冲区管理；实现基本的WAL(Write-Ahead Logging)策略实现<strong>事务回滚与恢复</strong></p></li></ul><h3 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h3><p>Database Catalog Table(DbFile，多个page)  HeapPage( []Tuple ) Tuple( []Field) Field    </p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653182.png" alt="image-20230601175517493" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java">Tuple：一行记录的内容<br><span class="hljs-keyword">private</span> TupleDesc tupleDesc;<br><span class="hljs-keyword">private</span> Field[] fields;<br><span class="hljs-keyword">private</span> RecordId recordId; table-page-slot<br><br>TupleDesc： 单表或单行每列的类别信息<br>    <span class="hljs-keyword">private</span> List&lt;TDItem&gt; tdItems;   TDItem（fieldType, fieldName）<br><br>Catalog: 所有表信息，加载时载入内存<br>    <span class="hljs-keyword">public</span> HashMap&lt;Integer, Table&gt; tables;  key是DbFile.getId() 也就是tableid，hash(path)<br>Table：DbFile file, String name, String pkeyField   文件、表名、主键<br>             DbFile（HeapFile）: tableid 、TupleDesc、File(文件路径)<br>                  HeapFile：单张表 <br>                 包含多个page, readPage(pid)获得;读入单个page时，seek跳过前面<br><br><br><br>BufferPool: 缓存的page<br>    <span class="hljs-keyword">private</span> Map&lt;PageId, Page&gt; pageCache;<br>PageId：tableId、pgNo  哪张表的第几个page<br>         map中没有则调用dbFile.readPage(pid);  dbFile被catalog存下了<br>                   <br>            <br>            <br>HeapPageId： tableId pgNo 哪个表的第几page<br>            <br>RecordId： PageId tupleno 哪个page哪一个slot<br>            <br>HeapPage： (HeapPageId, data[])  从data[]中读取数据,转为一个page，data包含header data来自HeapFile.read<br>         HeapPageId 哪个表的第几page<br>         header[getHeaderSize()] 每个slot是否有数据<br>Tuple[numSlots]  每一行内容，每一行包含rid ,也就是(pid, slotId)<br>         td 行结构<br>            <br>     f:<br>getNumTuples(): floor((_page size_ * <span class="hljs-number">8</span>) / (_tuple size_ * <span class="hljs-number">8</span> + <span class="hljs-number">1</span>))<br>         getHeaderSize(): Math.ceil(getNumTuples() * <span class="hljs-number">1.0</span> / <span class="hljs-number">8</span>);<br><br>iterator() 返回数据tuple的迭代，基于List的Iterator<br>            <br>ex5       <br>HeapFile <span class="hljs-title function_">HeapFile</span><span class="hljs-params">(File f, TupleDesc td)</span>;<br>readPage(PageId pid) BufferPool会调用<br>            randomAccess.seek(pageSize * pageNumber);<br>            randomAccess.read(buffer);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapPage</span>((HeapPageId) pid, buffer);<br><br>writePage(page) 修改磁盘内容，写入page，如果pagenum&gt;当前则相当于插入<br>iterator(tid)返回整个表的迭代，一页一页从bufferpool中读，每页内部会调用heappage.iterator<br>            <br><br><br>ex6<br>SeqScan <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OpIterator</span>  对HeapFile包装, 为最基础的select * <br>TransactionId tid, <span class="hljs-type">int</span> tableid, String tableAlias;   包含别名,<br>之后的操作都是这样的，包含next hashnext  每次取出tuple<br><br>运算符是基于迭代器的；每个运算符都实现了 DbIterator 接口。<br>较低级别的运算符传递到较高级别运算符的构造函数中,使他们串联起来。叶子节点<br>Operators are connected together into a plan by passing lower-level operators into the constructors of higher-level operators, i.e., by <span class="hljs-string">&#x27;chaining them together.&#x27;</span> Special access method operators at the leaves of the plan are responsible <span class="hljs-keyword">for</span> reading data from the <span class="hljs-title function_">disk</span> <span class="hljs-params">(and hence <span class="hljs-keyword">do</span> not have any operators below them)</span>.<br><br>At the top of the plan, the program interacting with SimpleDB simply calls getNext on the root operator; <span class="hljs-built_in">this</span> operator then calls getNext on its children, and so on, until these leaf operators are called. They fetch tuples from disk and pass them up the <span class="hljs-title function_">tree</span> <span class="hljs-params">(as return arguments to getNext)</span>; tuples propagate up the plan in <span class="hljs-built_in">this</span> way until they are output at the root or combined or rejected by another operator in the plan.<br><br>For <span class="hljs-built_in">this</span> lab, you will only need to implement one SimpleDB operator.<br></code></pre></td></tr></table></figure><p>HeapPage:</p><p>对于一个只有两个int的表，单个page中，共4096B的数据，Tuple行数为4096* 8 &#x2F; 8*8+1 &#x3D; 504行，headsize&#x3D;504&#x2F;8&#x3D; 63B</p><p>也就是前63B都是head(484个空)，数据为00007cbd、7fffffff。创建过程在<code>HeapPageReadTest.java</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653183.png" alt="image-20230420143257673"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数据获取，txt转为HeapPage可读取的文件格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">4066</span><span class="hljs-string">*8/3*4*8+1</span> <span class="hljs-string">=</span> <span class="hljs-number">337</span>   <span class="hljs-number">337</span><span class="hljs-string">/8</span> <span class="hljs-string">=</span> <span class="hljs-string">43B</span><br><span class="hljs-string">原始数据</span> <span class="hljs-string">java</span> <span class="hljs-string">-jar</span> <span class="hljs-string">dist/simpledb.jar</span> <span class="hljs-string">convert</span> <span class="hljs-string">some_data_file.txt</span> <span class="hljs-number">3</span>  <br><span class="hljs-number">1</span><span class="hljs-string">,1,1</span><br><span class="hljs-number">2</span><span class="hljs-string">,2,2</span> <br><span class="hljs-number">3</span><span class="hljs-string">,4,4</span><br><br><span class="hljs-string">.bat</span> <span class="hljs-number">0000 </span><span class="hljs-number">0111</span> <span class="hljs-string">第一个byte低三位代表有三个tuple</span><br><span class="hljs-number">0700 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">00</span><span class="hljs-string">|00</span> <span class="hljs-number">0000 </span><span class="hljs-number">0100</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0100 </span><span class="hljs-number">0000 </span><span class="hljs-number">0100 </span><span class="hljs-number">0000 </span><span class="hljs-number">0200 </span><span class="hljs-number">0000 </span><span class="hljs-number">0200</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0200 </span><span class="hljs-number">0000 </span><span class="hljs-number">0300 </span><span class="hljs-number">0000 </span><span class="hljs-number">0400 </span><span class="hljs-number">0000 </span><span class="hljs-number">0400</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> &#123;<br>    <span class="hljs-comment">// construct a 3-column table schema</span><br>    Type types[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>[]&#123; Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE &#125;;<br>    String names[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123; <span class="hljs-string">&quot;field0&quot;</span>, <span class="hljs-string">&quot;field1&quot;</span>, <span class="hljs-string">&quot;field2&quot;</span> &#125;;<br>    <span class="hljs-type">TupleDesc</span> <span class="hljs-variable">descriptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TupleDesc</span>(types, names);<br><br>    <span class="hljs-comment">// create the table, associate it with some_data_file.dat</span><br>    <span class="hljs-comment">// and tell the catalog about the schema of this table.</span><br>    <span class="hljs-type">HeapFile</span> <span class="hljs-variable">table1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;some_data_file.dat&quot;</span>), descriptor);<br>    Database.getCatalog().addTable(table1, <span class="hljs-string">&quot;test&quot;</span>);<br><br>    <span class="hljs-comment">// construct the query: we use a simple SeqScan, which spoonfeeds</span><br>    <span class="hljs-comment">// tuples via its iterator.</span><br>    <span class="hljs-type">TransactionId</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionId</span>();<br>    <span class="hljs-type">SeqScan</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table1.getId());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// and run it</span><br>        f.open();<br>        <span class="hljs-keyword">while</span> (f.hasNext()) &#123;<br>            <span class="hljs-type">Tuple</span> <span class="hljs-variable">tup</span> <span class="hljs-operator">=</span> f.next();<br>            System.out.println(tup);<br>        &#125;<br>        f.close();<br>        Database.getBufferPool().transactionComplete(tid);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println (<span class="hljs-string">&quot;Exception : &quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h3><p>基本操作，需要继承Operator，实现<code>fetchNext</code>， Operator implements OpIterator</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653184.png" alt="image-20230426164343396"></p><p>基于装饰器模式，</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>和某个field比较，并过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate(<span class="hljs-type">int</span> field, Op op, Field operand)<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(Tuple t)</span>  将传入的tuple和构造函数中的值比较<br><br>Filter(Predicate p, OpIterator child)  对child(SeqScan)进行predicte过滤，只保留<span class="hljs-literal">true</span><br>    <span class="hljs-title function_">next</span><span class="hljs-params">()</span>方法获取下一个，依靠fetchNext，需要重写<br>    fetchNext:<br>            <span class="hljs-keyword">while</span> (child.hasNext())&#123;<br>                <span class="hljs-type">Tuple</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> child.next();<br>                <span class="hljs-keyword">if</span> (predicate.filter(next))&#123;<br>                    <span class="hljs-keyword">return</span> next;<br>                &#125;<br>            &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Test</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filterSomeLessThan</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-built_in">this</span>.scan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUtil</span>.MockScan(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, testWidth); <span class="hljs-comment">// -5~5</span><br>    Predicate pred;<br>    pred = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>(<span class="hljs-number">0</span>, Predicate.Op.LESS_THAN, TestUtil.getField(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 过滤到-5~2</span><br>    <span class="hljs-type">Filter</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>(pred, scan);<br>    TestUtil.<span class="hljs-type">MockScan</span> <span class="hljs-variable">expectedOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUtil</span>.MockScan(-<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, testWidth);<br>    op.open();<br>    TestUtil.compareDbIterators(op, expectedOut);<br>    op.close();<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><p>根据JoinPredicate规定的列是否满足op</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">JoinPredicate(<span class="hljs-type">int</span> field1, Predicate.Op op, <span class="hljs-type">int</span> field2)<br>filter(Tuple t1, Tuple t2); 用于判断两个tuple的特定field是否相等（满足op），join时需要<br><br>Join(JoinPredicate p, OpIterator child1, OpIterator child2)<br>    fetchNext:<br>双重<span class="hljs-keyword">for</span>遍历child1 child2，留下满足条件的。为了配合实现迭代器，需要额外记录下外层tuple1<br>        <span class="hljs-title function_">while</span><span class="hljs-params">(child1.hasNext()</span> || tuple1 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (tuple1 == <span class="hljs-literal">null</span>)&#123;<br>                tuple1 = child1.next();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(child2.hasNext())&#123;<br>                <span class="hljs-type">Tuple</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> child2.next();<br>                <span class="hljs-keyword">if</span>(joinPredicate.filter(tuple1, t2))&#123;<br>                    <span class="hljs-type">Tuple</span> <span class="hljs-variable">tuple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tuple</span>(getTupleDesc());<br>                    Iterator&lt;Field&gt; fields = tuple1.fields();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>(fields.hasNext())&#123;<br>                        tuple.setField(i++, fields.next());<br>                    &#125;<br>                    fields = t2.fields();<br>                    <span class="hljs-keyword">while</span>(fields.hasNext())&#123;<br>                        tuple.setField(i++, fields.next());<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> tuple;<br>                &#125;<br>            &#125;<br>            child2.rewind();<br>            tuple1 = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>scancost(t1) + ntups(t1) x <span class="hljs-title function_">scancost</span><span class="hljs-params">(t2)</span> <span class="hljs-comment">//IO cost </span><br>+ ntups(t1) x <span class="hljs-title function_">ntups</span><span class="hljs-params">(t2)</span>  <span class="hljs-comment">//CPU cost</span><br></code></pre></td></tr></table></figure><h4 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h4><p>min max sum count  avg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">IntegerAggregator(<span class="hljs-type">int</span> gbfield, Type gbfieldtype, <span class="hljs-type">int</span> afield, Op what) 分组idx 分组类型 聚合idx<br>    HashMap&lt;Field, Tuple&gt; aggregate;   Field是分组的，映射到结果tuple<br>       <span class="hljs-string">&#x27;male&#x27;</span> -&gt; (<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">10</span>)<br>       <span class="hljs-string">&#x27;female&#x27;</span> -&gt; (<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-number">8</span>)<br>    min max sum count 直接在上面的映射里修改<br>    avg 需要额外维护sum count<br>        HashMap&lt;Field, Integer&gt; countsMap;<br>        HashMap&lt;Field, Integer&gt; sumMap;<br><br><span class="hljs-comment">// 不断传入tuple，并在agg中计算，iterator返回计算结果</span><br><span class="hljs-type">IntegerAggregator</span> <span class="hljs-variable">agg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntegerAggregator</span>(<span class="hljs-number">0</span>, Type.INT_TYPE, <span class="hljs-number">1</span>, Aggregator.Op.SUM);<br>agg.mergeTupleIntoGroup(scan1.next());<br>agg.iterator();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Aggregate(OpIterator child, <span class="hljs-type">int</span> afield, <span class="hljs-type">int</span> gfield, Aggregator.Op aop);<br>调用Aggregator的聚合 实现基本的Operator，策略模式<br><span class="hljs-type">Aggregate</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aggregate</span>(scan1, afield=<span class="hljs-number">0</span>, gfield=<span class="hljs-number">0</span>,<br>            Aggregator.Op.MIN);<br></code></pre></td></tr></table></figure><h4 id="insert-delete"><a href="#insert-delete" class="headerlink" title="insert delete"></a>insert delete</h4><p>共HeapPage HeapFile BufferPool三层</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sas">HeapPage: Tuple<br>Tuple t 插入当前<span class="hljs-keyword">page</span>，所以pid要改成当前HeapPage的，slot按插入的位置来<br><br>HeapFile: tid Tuple   返回被操作的DirtyPage ArrayList&lt;<span class="hljs-keyword">Page</span>&gt;  (注意操作的<span class="hljs-keyword">page</span>是从pool中拿，会修改pool 但不修改文件)<br>删除：直接调用HeapPage  <br>插入：先选择一个插入，都满了就增加一个<span class="hljs-keyword">page</span>(需要修改<span class="hljs-keyword">file</span>文件的大小，也就是写入空数据，然后再从pool中拿)    实验中tuple2int，一个page504条，超出后自动增一<span class="hljs-keyword">page</span><br><br>BufferPool: tid Tuple。  去Catalog拿表信息 Database.getCata<span class="hljs-meta">log</span>().getDatabaseFile(tableid);   需要把设置返回的为dirty 事务层面<br>删除：直接调用<br>插入：需要额外tableId代表插入到哪个表<br><br><br>Database.getBufferPool().insertTuple(tid, empty.getId(), t);<br><br>HeapWriteTest 2个int一个<span class="hljs-keyword">page</span>可以写504条数据<br></code></pre></td></tr></table></figure><h4 id="Page-eviction"><a href="#Page-eviction" class="headerlink" title="Page eviction"></a>Page eviction</h4><p>对于一个2个int的表，共1024*504条数据，也就是1024个page，没有eviction全部存入时<code>63MB</code> ，50pages <code>3MB</code></p><p>evictPage：扔掉前flush</p><h5 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">evictPage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> DbException &#123;<br>Iterator&lt;Map.Entry&lt;PageId, Page&gt;&gt; iterator = pageCache.entrySet().iterator();<br>    <span class="hljs-keyword">if</span> (iterator.hasNext())&#123;<br>        Map.Entry&lt;PageId, Page&gt; next = iterator.next();<br>        <span class="hljs-type">PageId</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> next.getKey();<br>        <span class="hljs-type">Page</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> next.getValue();<br>        <span class="hljs-keyword">if</span> (page.isDirty() != <span class="hljs-literal">null</span>)&#123;<br>            flushPage(pid);<br>        &#125;<br>        iterator.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyData</span><span class="hljs-params">(PageId pageId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(pageId)) <span class="hljs-keyword">return</span> ;<br>        queue.offer(pageId);<br>        set.add(pageId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PageId <span class="hljs-title function_">getEvictPageId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">PageId</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> queue.poll();<br>        set.remove(peek);<br>        <span class="hljs-keyword">return</span> peek;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="LRU："><a href="#LRU：" class="headerlink" title="LRU："></a>LRU：</h5><p>双向链表+Hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUEvict</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EvictStrategy</span>&#123;<br><br>    Node tail;<br>    Node head;<br>    HashMap&lt;PageId, Node&gt; hashMap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">LRUEvict</span><span class="hljs-params">()</span>&#123;<br>        hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>);<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyData</span><span class="hljs-params">(PageId pageId)</span> &#123;<br>        <span class="hljs-keyword">if</span>(hashMap.containsKey(pageId))&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> hashMap.get(pageId);<br>            moveToHead(node);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(pageId);<br>            addHead(node);<br>            hashMap.put(pageId, node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PageId <span class="hljs-title function_">getEvictPageId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail.prev;<br>        hashMap.remove(prev.pageId);<br>        removeNode(prev);<br><br>        <span class="hljs-keyword">return</span> prev.pageId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHead</span><span class="hljs-params">(Node node)</span>&#123;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        node.prev = head;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(Node node)</span>&#123;<br>        removeNode(node);<br>        addHead(node);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        PageId pageId;<br>        Node prev;<br>        Node next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(PageId pageId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.pageId = pageId;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>flushPage(pid)</code>：  如果pid脏的，就写回磁盘</li><li><code>discardPage(pid)</code>：直接扔掉某一个page</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> some_data_file1,<br>     some_data_file2<br><span class="hljs-keyword">WHERE</span> some_data_file1.field1 <span class="hljs-operator">=</span> some_data_file2.field1<br>  <span class="hljs-keyword">AND</span> some_data_file1.id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// construct a 3-column table schema</span><br>        Type types[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>[]&#123;Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE&#125;;<br>        String names[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;field0&quot;</span>, <span class="hljs-string">&quot;field1&quot;</span>, <span class="hljs-string">&quot;field2&quot;</span>&#125;;<br><br>        <span class="hljs-type">TupleDesc</span> <span class="hljs-variable">td</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TupleDesc</span>(types, names);<br><br>        <span class="hljs-comment">// create the tables, associate them with the data files</span><br>        <span class="hljs-comment">// and tell the catalog about the schema  the tables.</span><br>        <span class="hljs-type">HeapFile</span> <span class="hljs-variable">table1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;lab2_file1.dat&quot;</span>), td);<br>        Database.getCatalog().addTable(table1, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">HeapFile</span> <span class="hljs-variable">table2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;lab2_file2.dat&quot;</span>), td);<br>        Database.getCatalog().addTable(table2, <span class="hljs-string">&quot;t2&quot;</span>);<br>    <br>    <span class="hljs-comment">// 上面的是加载数据库表信息到Catalog，运行在数据库系统启动时</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------------------</span><br>    <span class="hljs-comment">// 下面是用户执行查询请求</span><br><br>        <span class="hljs-comment">// construct the query: we use two SeqScans, which spoonfeed</span><br>        <span class="hljs-comment">// tuples via iterators into join</span><br>        <span class="hljs-type">TransactionId</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionId</span>();<br><br>        <span class="hljs-type">SeqScan</span> <span class="hljs-variable">ss1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table1.getId(), <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">SeqScan</span> <span class="hljs-variable">ss2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table2.getId(), <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        <span class="hljs-comment">// create a filter for the where condition</span><br>        <span class="hljs-type">Filter</span> <span class="hljs-variable">sf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>(<span class="hljs-number">0</span>,<br>                        Predicate.Op.GREATER_THAN, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntField</span>(<span class="hljs-number">1</span>)), ss1);<br><br>        <span class="hljs-type">JoinPredicate</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinPredicate</span>(<span class="hljs-number">1</span>, Predicate.Op.EQUALS, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Join</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Join</span>(p, sf1, ss2);<br><br>        <span class="hljs-comment">// and run it</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            j.open();<br>            <span class="hljs-keyword">while</span> (j.hasNext()) &#123;<br>                <span class="hljs-type">Tuple</span> <span class="hljs-variable">tup</span> <span class="hljs-operator">=</span> j.next();<br>                System.out.println(tup);<br>            &#125;<br>            j.close();<br>            Database.getBufferPool().transactionComplete(tid);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">table1Id</span> <span class="hljs-operator">=</span> Database.getCatalog().getTableId(<span class="hljs-string">&quot;t1&quot;</span>)<br><br><span class="hljs-comment">// inset到t1表中</span><br>Database.getBufferPool().insertTuple(tid, table1Id, tuple);<br><br><span class="hljs-comment">// delete tuple中PageId 下 第TupleNumber slot的数据</span><br>Database.getBufferPool().deleteTuple(tid, tuple);<br><br><span class="hljs-comment">// 先读取全部数据</span><br><span class="hljs-type">SeqScan</span> <span class="hljs-variable">ss1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqScan</span>(tid, table1Id, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-comment">// 过滤field0小于1的行</span><br><span class="hljs-type">Filter</span> <span class="hljs-variable">sf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>(<span class="hljs-number">0</span>,<br>                        Predicate.Op.GREATER_THAN, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntField</span>(<span class="hljs-number">1</span>)), ss1);<br><br><span class="hljs-comment">// aggregate afiele=1; gfield=2</span><br><span class="hljs-type">Aggregate</span> <span class="hljs-variable">ag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aggregate</span>(sf1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, Aggregator.Op.SUM);<br><br><span class="hljs-comment">// join  field1和field1</span><br><span class="hljs-type">JoinPredicate</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinPredicate</span>(<span class="hljs-number">1</span>, Predicate.Op.EQUALS, <span class="hljs-number">1</span>);<br><span class="hljs-type">Join</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Join</span>(p, sf1, ss2);<br></code></pre></td></tr></table></figure><h4 id="Query-Parser"><a href="#Query-Parser" class="headerlink" title="Query Parser"></a>Query Parser</h4><p>读取表数据 并运行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">java -jar dist/simpledb.jar parser catalog.<span class="hljs-function">txt</span><br><span class="hljs-function"><span class="hljs-title">lab2_file1</span> (<span class="hljs-params">f1 <span class="hljs-built_in">int</span>, f2 <span class="hljs-built_in">int</span>, f3 <span class="hljs-built_in">int</span></span>)</span><br><span class="hljs-function"><span class="hljs-title">lab2_file2</span> (<span class="hljs-params">f1 <span class="hljs-built_in">int</span>, f2 <span class="hljs-built_in">int</span>, f3 <span class="hljs-built_in">int</span></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">select</span> d.f1, d.f2 <span class="hljs-keyword">from</span> lab2_file1 d</span>;<br><br><span class="hljs-keyword">where</span>语句报错？<br></code></pre></td></tr></table></figure><h3 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h3><ul><li>通过分析表的统计信息，可以估算不同查询计划的成本。计划的成本与中间连接和选择的元组数量、过滤器和连接谓词的选择性相关。</li><li>使用这些统计数据  order joins and selections  to get an <strong>optimal</strong> way</li></ul><p>selectivity: 筛选比例</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653185.png" alt="image-20230606152332166"></p><p>在这个实验中，我们只关注连接和基本表访问序列的成本。我们不必担心访问方法的选择（因为我们只有一种访问方法，即表扫描），也不必考虑其他操作符（如聚合）的成本。</p><h4 id="Filter-Selectivity"><a href="#Filter-Selectivity" class="headerlink" title="Filter Selectivity"></a>Filter Selectivity</h4><p>base on histogram，to get <code>ntups</code> with one or more predicates </p><ul><li><em>f&#x3D;const</em>：<em>h&#x2F;w</em></li><li><em>f&gt;const</em>：<em>h_b x   (b_right - const) &#x2F; w_b   + buckets( b+1…NumB-1)</em></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653186.png" alt="image-20230606161236443"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] buckets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">IntHistogram</span><span class="hljs-params">(<span class="hljs-type">int</span> buckets, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对于某一个tableid，创建从下标到Histogram的映射</span><br><span class="hljs-comment">// 扫描两次 第一次求出最大最小，第二次添加</span><br><span class="hljs-keyword">private</span> Map&lt;Integer, IntHistogram&gt; intHistogramMap;<br><span class="hljs-keyword">private</span> Map&lt;Integer, StringHistogram&gt; stringHistogramMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TableStats</span><span class="hljs-params">(<span class="hljs-type">int</span> tableid, <span class="hljs-type">int</span> ioCostPerPage)</span><br>    <br><span class="hljs-comment">// 返回某一个fieldid相对于某个值的比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">estimateSelectivity</span><span class="hljs-params">(<span class="hljs-type">int</span> field, Predicate.Op op, Field constant)</span><br>    intHistogramMap.get(field).estimateSelectivity(op, ((IntField) constant).getValue())<br>    <br><span class="hljs-comment">// 全表扫描代价 没有寻道时间 且 都不在pool中 IO_COST = 71</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">estimateScanCost</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> numPage * ioCostPerPage;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最后每一个table都生成一个TableStats</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, TableStats&gt; statsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="Join-cardinality"><a href="#Join-cardinality" class="headerlink" title="Join cardinality"></a>Join cardinality</h4><p> estimate the size (<code>ntups</code>) of <code>t1 join t2</code></p><ul><li>for equality joins, primary key &gt; non-primary key</li><li>For range scans  &gt;  non-primary key equality     估值product*0.3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">estimateJoinCardinality</span><span class="hljs-params">(LogicalJoinNode j, <span class="hljs-type">int</span> card1, <span class="hljs-type">int</span> card2,</span><br><span class="hljs-params">                                   <span class="hljs-type">boolean</span> t1pkey, <span class="hljs-type">boolean</span> t2pkey, Map&lt;String, TableStats&gt; stats)</span> &#123;<br><span class="hljs-keyword">switch</span> (joinOp) &#123;<br>    <span class="hljs-keyword">case</span> EQUALS:<br>        <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; !t2pkey) &#123;<br>            card = card2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!t1pkey &amp;&amp; t2pkey) &#123;<br>            card = card1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; t2pkey) &#123;<br>            card = Math.min(card1, card2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            card = Math.max(card1, card2);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> NOT_EQUALS:<br>        <span class="hljs-comment">// 记录总数-等值记录数</span><br>        <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; !t2pkey) &#123;<br>            card = card1 * card2 - card2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!t1pkey &amp;&amp; t2pkey) &#123;<br>            card = card1 * card2 - card1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t1pkey &amp;&amp; t2pkey) &#123;<br>            card = card1 * card2 - Math.min(card1, card2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            card = card1 * card2 - Math.max(card1, card2);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 其他记录按范围查询计算</span><br>        card = (<span class="hljs-type">int</span>) (<span class="hljs-number">0.3</span> * card1 * card2);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Join-cost"><a href="#Join-cost" class="headerlink" title="Join cost"></a>Join cost</h4><p><code>p=t1 join t2 join ... tn</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scancost(t1) </span>+ <span class="hljs-keyword">scancost(t2) </span>+ <span class="hljs-keyword">joincost(t1 </span><span class="hljs-keyword">join </span><span class="hljs-built_in">t2</span>) +<br><span class="hljs-keyword">scancost(t3) </span>+ <span class="hljs-keyword">joincost((t1 </span><span class="hljs-keyword">join </span><span class="hljs-built_in">t2</span>) <span class="hljs-keyword">join </span><span class="hljs-built_in">t3</span>) +<br>... <br></code></pre></td></tr></table></figure><p><code>scancost(t1)</code> ：  the number of pages in t1 x <code>SCALING_FACTOR</code></p><p><code>joincost(t1 join t2)</code>： &#x3D; scancost(t1) + ntups(t1) x scancost(t2) &#x2F;&#x2F;IO cost </p><p>​+ ntups(t1) x ntups(t2)  &#x2F;&#x2F;CPU cost</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">estimateJoinCost</span><span class="hljs-params">(LogicalJoinNode j, <span class="hljs-type">int</span> card1, <span class="hljs-type">int</span> card2,</span><br><span class="hljs-params">            <span class="hljs-type">double</span> cost1, <span class="hljs-type">double</span> cost2)</span><br>cost1 + card1 * cost2 + card1 * card2;<br></code></pre></td></tr></table></figure><h4 id="Join-order"><a href="#Join-order" class="headerlink" title="Join order"></a>Join order</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CostCard</span> &#123;<br>    <span class="hljs-comment">/** The cost of the optimal subplan */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> cost;<br>    <span class="hljs-comment">/** The cardinality of the optimal subplan */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> card;<br>    <span class="hljs-comment">/** The optimal subplan */</span><br>    <span class="hljs-keyword">public</span> List&lt;LogicalJoinNode&gt; plan;<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;LogicalJoinNode&gt; <span class="hljs-title function_">orderJoins</span><span class="hljs-params">(</span><br><span class="hljs-params">    Map&lt;String, TableStats&gt; stats,</span><br><span class="hljs-params">    Map&lt;String, Double&gt; filterSelectivities, <span class="hljs-type">boolean</span> explain)</span><br>    <span class="hljs-keyword">throws</span> ParsingException &#123;<br><br>    <span class="hljs-comment">// some code goes here</span><br>    <span class="hljs-comment">//Replace the following</span><br>    <span class="hljs-comment">// some code goes here</span><br>    <span class="hljs-comment">//Replace the following</span><br>    <span class="hljs-type">PlanCache</span> <span class="hljs-variable">planCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlanCache</span>();<br>    <span class="hljs-type">CostCard</span> <span class="hljs-variable">bestCostCard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CostCard</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> joins.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;<br>        <span class="hljs-comment">// 找出给定size的所有子集</span><br>        Set&lt;Set&lt;LogicalJoinNode&gt;&gt; subsets = enumerateSubsets(joins, i);<br>        <span class="hljs-keyword">for</span> (Set&lt;LogicalJoinNode&gt; subset : subsets) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">bestCostSoFar</span> <span class="hljs-operator">=</span> Double.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (LogicalJoinNode joinNode : subset) &#123;<br>                <span class="hljs-type">CostCard</span> <span class="hljs-variable">costCard</span> <span class="hljs-operator">=</span><br>                    computeCostAndCardOfSubplan(stats, filterSelectivities, joinNode, subset, bestCostSoFar, planCache);<br>                <span class="hljs-keyword">if</span> (costCard == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                bestCostSoFar = costCard.cost;<br>                bestCostCard = costCard;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bestCostSoFar != Double.MAX_VALUE) &#123;<br>                planCache.addPlan(subset, bestCostCard.cost, bestCostCard.card, bestCostCard.plan);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (explain) &#123;<br>        printJoins(bestCostCard.plan, planCache, stats, filterSelectivities);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bestCostCard.plan;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&quot;SELECT * FROM emp,dept,hobbies,hobby WHERE emp.c1 = dept.c0 AND hobbies.c0 = emp.c2 AND hobbies.c1 = hobby.c0 AND emp.c3 &lt; 1000;&quot;</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202312181653187.png" alt="image-20230607161413205"></p><p>emp过滤后1500： 随机数最大值65530，1500≈（1000&#x2F;65535*10w）</p><h3 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h3><p>A <strong>transaction</strong> is a group of database actions (e.g., inserts, deletes, and reads) that are executed <em>atomically</em>;</p><ul><li><strong>Atomicity</strong>: Strict two-phase locking and careful buffer management ensure atomicity.</li><li><strong>Consistency</strong>: The database is transaction consistent by virtue of atomicity. Other consistency issues (e.g., key constraints) are not addressed in SimpleDB.</li><li><strong>Isolation</strong>: Strict two-phase locking provides isolation.</li><li><strong>Durability</strong>: A FORCE buffer management policy ensures durability (see Section 2.3 below).</li></ul><p>核心思想：<strong>NO STEAL&#x2F;FORCE</strong></p><p>To simplify your job, we recommend that you implement a <strong>NO STEAL&#x2F;FORCE</strong> buffer management policy.</p><ul><li>You shouldn’t evict dirty (updated) pages from the buffer pool if they are locked by an uncommitted transaction (this is NO STEAL).  <ul><li>由于只在最后刷盘，不需要undo了，失败只要重新从磁盘加载page即可</li></ul></li><li>On transaction commit, you should force dirty pages to disk (e.g., write the pages out) (this is FORCE). <ul><li>假设<code>transactionComplete</code>不会失败，这样就不需要redo log</li></ul></li></ul><h4 id="lock-acquire"><a href="#lock-acquire" class="headerlink" title="lock acquire"></a>lock acquire</h4><p>acquire and release locks in BufferPool</p><ul><li>Modify <code>getPage()</code> to block and acquire the desired lock before returning a page. 核心方法，阻塞获取锁</li><li>Implement <code>unsafeReleasePage(tid, pid)</code>. This method is primarily used for testing, and at the end of transactions. 释放tid在pid上的锁</li><li>Implement <code>holdsLock(tid, pid)</code> so that logic in Exercise 2 can determine whether a page is already locked by a transaction. tid是否锁住pid</li></ul><p>create data structures that keep track of which locks each transaction holds and check to see if a lock should be granted to a transaction when it is requested：<code>hashmap: pageid-&gt;locks</code></p><ul><li>插入 删除 查找都是调用pool的getPage，需要传入正确的permission</li><li>被操作的页置为dirty</li><li>插入时创建了新的page，能否正常锁定</li></ul><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p><code>strict two-phase locking</code>：This means that transactions should acquire the appropriate type of lock on any object before accessing that object and shouldn’t release any locks until after the transaction commits.</p><p>release a shared lock on a page after scanning it to find empty slots</p><h4 id="NO-STEAL"><a href="#NO-STEAL" class="headerlink" title="NO STEAL"></a>NO STEAL</h4><p>只evict非脏页，都是脏页就抛出异常。<code>AbortEvictionTest </code>  <code>testAllDirtyFails()</code>测试</p><h4 id="transactionComplete"><a href="#transactionComplete" class="headerlink" title="transactionComplete"></a>transactionComplete</h4><p><em>commits</em> or <em>aborts</em></p><p>途中可能抛出<code>TransactionAbortedException</code> 请求超时，死锁  如readpage</p><ul><li>commit：写回磁盘 释放锁</li><li>abort：重新从磁盘加载page  释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transactionComplete</span><span class="hljs-params">(TransactionId tid, <span class="hljs-type">boolean</span> commit)</span> &#123;<br>    <span class="hljs-keyword">if</span> (commit) &#123;<br>        flushPages(tid);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        recoverPages(tid);<br>    &#125;<br>    lockManager.completeTransaction(tid);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbortEvictionTest</code>测试 ：如果abort 插入的行是否还能找到</p><h4 id="Deadlocks-and-Aborts"><a href="#Deadlocks-and-Aborts" class="headerlink" title="Deadlocks and Aborts"></a>Deadlocks and Aborts</h4><p> detect <code>deadlock</code> and throw a <code>TransactionAbortedException</code>，被捕获后调用<code>transactionComplete</code></p><ol><li>a simple timeout policy（或者retry次数过多）</li><li>check for cycles in a dependency graph</li><li>全局排序：每个事务分配一个全局序号  <strong>WAIT-DIE</strong>(当前高就wait、否则rollback；保证环路中优先级最低的一定die) <strong>WOUND-WAIT</strong><ul><li>或者资源分配一个序号 哲学家，在这里代表着pageid 不好实现 因为pageid的读取顺序和业务相关</li><li>可能会中止本该成功的事务</li></ul></li></ol><p><code>DeadlockTest.java</code></p><p>t1读p1 t2读p2，然后t1写p2(等t2)  t2写p1(等t1)，就死锁了</p><p><code>TransactionTest.java</code></p><p>n个进程，首先都获取读锁，然后再进行一次删除和插入</p><p>锁升级时就会出现死锁等待</p><h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">2000</span>) + <span class="hljs-number">1000</span>;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (lockManager.acquire(pid, tid, perm)) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">if</span> (now - start &gt; timeout) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionAbortedException</span>();<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 睡眠可以减少竞争 否则肯定过不了测试  但加了也很慢</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cycle-check"><a href="#cycle-check" class="headerlink" title="cycle check"></a>cycle check</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(!lockManager.acquire(pid, tid, perm))&#123;<br>    Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));  <span class="hljs-comment">// 不加很慢 加了很快</span><br>&#125;<br><br><br><span class="hljs-comment">// acquire：</span><br><span class="hljs-comment">// 在获取锁失败时，检测有没有环</span><br><span class="hljs-keyword">if</span> (next.getValue().getLockType() == LockType.EXCLUSIVE || perm == Permissions.READ_WRITE)&#123;<br>    <span class="hljs-type">TidNode</span> <span class="hljs-variable">tidNow</span> <span class="hljs-operator">=</span> tidMap.getOrDefault(tid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TidNode</span>(tid));<br>    tidNow.next = tidMap.get(next.getValue().getTid());<br>    checkCycle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;TidNode&gt;(), tidNow);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkCycle</span><span class="hljs-params">(HashSet&lt;TidNode&gt; visited, TidNode tidNode)</span> <span class="hljs-keyword">throws</span> TransactionAbortedException &#123;<br>    <span class="hljs-keyword">if</span>(visited.contains(tidNode))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionAbortedException</span>();<br>    &#125;<br>    visited.add(tidNode);<br>    <span class="hljs-keyword">if</span>(tidNode.next != <span class="hljs-literal">null</span>)&#123;<br>        checkCycle(visited, tidNode.next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="wait-die"><a href="#wait-die" class="headerlink" title="wait-die"></a>wait-die</h5><p>可以保证环路中，优先级最低的一定die</p><p>需要遍历全部资源冲突的(否则会失效)，如果存在优先级高的则die</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">unlock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>    Map.Entry&lt;TransactionId, LockInfo&gt; next = iterator.next();<br>    <span class="hljs-keyword">if</span> (next.getKey().equals(tid))&#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next.getValue().getLockType() == LockType.EXCLUSIVE || perm == Permissions.READ_WRITE)&#123;<br><br>        <span class="hljs-keyword">if</span>(tid.getId() &gt; next.getValue().getTid().getId())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionAbortedException</span>();<br>        &#125;<br><br>        unlock = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!unlock)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进阶：能否在获取失败后wait而不是自旋？    wait的锁住的对象不好处理    用map&lt;PageId, PageId&gt;尝试失败</p><h3 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h3><h3 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h3><ul><li>之前的pool中的脏页不能写回磁盘（NO STEAL），现在提供undo解决这一问题</li><li>commit后如果宕机怎么办？先写入日志，日志实现恢复</li></ul><p>You will implement rollback and recovery using the contents of the log file.</p><ul><li>undo：记录下修改 用于 abort</li><li>redo：恢复成功的事务</li></ul><p>STEAL and NO-FORCE：提供更灵活的缓冲区管理，允许commit前写回磁盘</p><p>​abort时，先根据日志把磁盘中的数据还原，再删除pool中的该页面，最后把pool中的脏页recover</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>因为可能没有commit就写回了（缓存空间不足 ，测试中通过<code>flushAllPages</code>模拟），需要写回前记录下写回前后的内容信息。当commit后，需要更新旧的信息</p><ol><li><p>Insert the following lines into <code>BufferPool.flushPage()</code> before your call to <code>writePage(p)</code>, where <code>p</code> is a reference to the page being written: 在page写回磁盘前，先将log写回，包含最开始的内容(<code>BeforeImage</code>)以及当前内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// append an update record to the log, with </span><br><span class="hljs-comment">// a before-image and after-image.</span><br><span class="hljs-type">TransactionId</span> <span class="hljs-variable">dirtier</span> <span class="hljs-operator">=</span> p.isDirty();<br><span class="hljs-keyword">if</span> (dirtier != <span class="hljs-literal">null</span>)&#123;<br>  Database.getLogFile().logWrite(dirtier, p.getBeforeImage(), p);<br>  Database.getLogFile().force();<br>&#125;<br><span class="hljs-keyword">if</span> (page.isDirty() != <span class="hljs-literal">null</span>)&#123;<br>    table.writePage(page);<br>    page.markDirty(<span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在commit并刷盘后，更新<code>BeforeImage</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">flushPages(tid)<br>    flushPage(pageId);<br>    <span class="hljs-comment">// use current page contents as the before-image</span><br>    <span class="hljs-comment">// for the next transaction that modifies this page.</span><br>    page.setBeforeImage();<br></code></pre></td></tr></table></figure></li></ol><p>先debug，查看在什么情况下会写log</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ABORT_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMMIT_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UPDATE_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BEGIN_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHECKPOINT_RECORD</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">NO_CHECKPOINT_ID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  日志文件开始<br>    <br>preAppend() 每次都调用 记录加一 或者重置日志<br><br>logXactionBegin(tid) 事务开始<br><br>logWrite(TransactionId tid, Page before, Page after) <br>page写回磁盘前，记录下写回前后的page<br><br><span class="hljs-title function_">logCommit</span><span class="hljs-params">(tid)</span> 提交事务<br><br>logAbort(tid) 回滚 <br>    需要rollback()<br><br>shutdown() 优雅关闭系统 记录下状态<br>logCheckpoint 关闭前记录下 tidToFirstLogRecord， 并在开头写入startCpOffset  <br>    写回所有脏页，log中只保存正在运行的tid的内容 minLogRecord 节约空间<br>logTruncate 截断以及commit的log内容，只保留正在运行的， 修改raf的指向<br><br></code></pre></td></tr></table></figure><p>log格式：type 和 tid，  内容  ,   最后写offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">raf.writeInt(ABORT_RECORD);<br>raf.writeLong(tid.getId());<br><br>...<br>raf.writeLong(currentOffset);<br>currentOffset = raf.getFilePointer();<br></code></pre></td></tr></table></figure><h4 id="RollBack"><a href="#RollBack" class="headerlink" title="RollBack"></a>RollBack</h4><p><code>logFile/rollback()</code>：事务回滚后，把改事务修改的page还原到之前的状态</p><ol><li><p>修改了但已经写回磁盘：pool中存在但已经不是dirty(flushPage会写回磁盘并删除脏页标记)</p><ul><li>根据log找到该事务修改的pageId，读出before-image， 并写回（ tidToFirstLogRecord map到第一个log）</li><li>删除pool中的页面(这里丢弃了页面，注意evict中没丢会空指针，所以evict多加一个判断)</li><li>同一个pageId可能有多条log，最老的beforeimage才是正确的（page出去过后before就错了）</li></ul></li><li><p>修改了还在pool中的（No steal时只有这一个），直接recoverPages(tid) 对dirty把磁盘中读出来并覆盖</p></li></ol><p><code>TestAbort</code> and <code>TestAbortCommitInterleaved</code> sub-tests of the LogTest system test.</p><h4 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h4><ol><li>针对未commit的事务，回滚这些事务</li><li>针对已commit但可能还没同步写入磁盘，再次写回以确定一致性</li></ol><p>问题：flushAllPages中flushPage时会清除Dirty标记，清除后事务commit时<code>flushPages(tid)</code>就不会再次移出该page，导致pool中的beforeimage并不会更新  <code>TestCommitAbortCommitCrash</code>测出来的（第二次看，最简单的方法就是把setbeforeimage放到flushPage的结尾）</p><ul><li>开源代码在commit时<code>flushPages(tid)</code>更新所有的old，该方案应该是错的，会影响还在进行中的其他事务</li><li>pool什么时候会被移出？ 页面不足时  也就是正常情况下是会在evict调用flushpage，之后一定会removepage，之后再次读入时oldpage就是最新的(对于进行中的当前事务oldpage是错的，但log中存了正确的)；也就是正常逻辑下不会出错，但flushAllPages会。所以需要在flushAllPages调用flushpage后也强制removepage一次就可以了</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>基于java语言，实现一个简易事务支持的关系型数据库</p><ul><li>实现基本的遍历、连接、聚合和删除等基本<strong>操作算子</strong>，以及基于直方图的查询优化</li><li>实现BufferPool缓存Page，且实现基于<strong>LRU</strong>的页面淘汰机制</li><li>实现<strong>页面级</strong>的共享锁、排他锁和锁升级，实现<strong>可串行化</strong>的并发策略</li><li>实现多种死锁检测算法：<strong>Timeout</strong>、<strong>Wait-for Graph</strong> 、 <strong>Global Orderings</strong>(wait-die)</li><li>基于UNDO日志实现<strong>STEAL&#x2F;NO FORCE</strong>策略，提供更灵活的缓冲区管理</li><li>实现基本的WAL(Write-Ahead Logging)策略实现<strong>事务回滚与恢复</strong></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/Cscprx/article/details/123418692">https://blog.csdn.net/Cscprx/article/details/123418692</a></p><p><a href="https://github.com/MIT-DB-Class/simple-db-hw-2021/blob/master">github</a></p><p><a href="https://gitee.com/wygandwind/simple-db/">Code</a></p><p><a href="https://gitee.com/wygandwind/simple-db/tree/master/src/java/simpledb/storage">wind&#x2F;SimpleDB - 码云 - 开源中国 (gitee.com)</a> <a href="https://www.wygandwdn.cn/article/62">风在哪个人博客 (wygandwdn.cn)</a></p><p><a href="https://blog.csdn.net/weixin_45834777/article/details/120595851">SimpleDb 实验报告_simpledb实验_跳着迪斯科学Java的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/402325847">MIT6.830 SimpleDB Lab1</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文主要介绍了面向对象设计中的五大原则（SOLID）以及几种常见的设计模式，包括策略模式、观察者模式、装饰者模式、单例模式、状态模式、模板方法模式和责任链模式。  <strong>五大设计原则</strong>： 1. 单一职责原则：每个类只负责单一功能，提升可维护性。 2. 开放封闭原则：通过扩展而非修改来增强功能，提高扩展性。 3. 里氏替换原则：子类应能完全替代父类而不影响程序。 4. 接口隔离原则：细化接口，避免依赖不必要的方法。 5. 依赖倒置原则：依赖于抽象而非具体实现，实现松耦合。  <strong>核心设计模式</strong>： - <strong>策略模式</strong>：封装可变算法到独立策略对象，使算法可互换（如排序算法的灵活切换）。 - <strong>观察者模式</strong>：建立一对多依赖，主题变化时自动通知所有观察者（如订单状态更新通知多模块）。 - <strong>装饰者模式</strong>：通过包装对象动态扩展功能，避免继承膨胀（如Java I&#x2F;O流的多层包装）。 - <strong>单例模式</strong>：确保全局唯一实例，提供可控访问（数据库连接池等资源共享场景）。 - <strong>状态模式</strong>：对象行为随内部状态改变（如订单状态流转对应不同操作）。 - <strong>模板方法模式</strong>：定义算法骨架，子类实现具体步骤（如统一服务流程模板）。 - <strong>责任链模式</strong>：请求沿处理链传递直至被处理（如多级审批或折扣策略链）。  <strong>关键实现方法</strong>均包含抽象接口定义、具体实现类及上下文管理，通过组合优于继承的方式提升系统灵活性和可维护性。每种模式通过示例代码（如咖啡订单装饰、订单状态机等）直观展示了应用场景和实现要点。</p></blockquote><h3 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h3><ol><li>单一职责原则（Single Responsibility Principle，SRP）：一个类只负责单一的功能，避免一个类承担过多的职责，从而提高代码的可维护性。</li><li>开放封闭原则（Open Closed Principle，OCP）：软件实体应该对扩展开放，对修改关闭，也就是说，应该通过<strong>增加代码而不是修改代码来扩展软件功能</strong>，从而提高代码的可维护性和扩展性。</li><li>里氏替换原则（Liskov Substitution Principle，LSP）：子类应该能够替换父类并且不影响程序的正确性，也就是说，子类必须能够完全实现父类的功能，从而提高代码的可扩展性。</li><li>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖于它不需要的接口，也就是说，应该尽量将接口细化，将不同的功能分离开来，从而提高代码的灵活性和可复用性。</li><li>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们应该依赖于抽象，而不是具体实现，也就是说，应该通过接口或者抽象类来实现模块之间的松耦合，从而提高代码的可维护性和可扩展性。</li></ol><p>找出会变的地方，把他们从不变的地方抽离出来（策略模式运用了）</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>将<strong>不同的算法</strong>或行为封装成独立的<strong>策略对象</strong>，使它们可以<strong>相互替换</strong>，从而使系统更加灵活和可扩展。</p><p>提高代码的可复用性和可维护性:</p><ul><li>如果每一个上下文都有该方法，我只需要设置成员变量即可，代码都写在策略中。不同的策略实现不同的方法<ul><li>如果使用继承去获得该策略，那么有的上下文他不需要(有的鸭子不会叫)就需要覆盖</li><li>如果使用接口，接口可以扩展上下文，但每一个上下文都需要实现同样的方法，代码没有复用</li><li>拉取出变化的部分，重新建立一个类，并针对接口编程。最后把拉出来的作为成员变量插入</li></ul></li></ul><p>实现过程：</p><ol><li><strong>策略接口：</strong>定义一个抽象策略接口，该接口定义了算法的公共方法。(Fly)</li><li><strong>具体策略：</strong>然后针对每种算法，创建一个具体的策略类，实现该接口。(FlyWings、NoWay)</li><li><strong>环境类</strong>：最后，我们还需要创建一个上下文类，该类包含一个策略成员变量，可以在运行时设置具体的策略。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象策略接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SortingStrategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体策略类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SortingStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-comment">// Bubble sort implementation</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体策略类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SortingStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-comment">// Quick sort implementation</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 上下文类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortingContext</span> &#123;<br>    <span class="hljs-keyword">private</span> SortingStrategy strategy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(SortingStrategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        strategy.sort(array);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">SortingContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SortingContext</span>();<br><br>        <span class="hljs-comment">// 使用冒泡排序</span><br>        context.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BubbleSort</span>());<br>        context.sort(array);<br><br>        <span class="hljs-comment">// 使用快速排序</span><br>        context.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>());<br>        context.sort(array);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>一(主题)对多(观察者)；主题变化时需要通知所有人</p><p><strong>普通写法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>person1.update();<br>person2.update();<br>    ...<br>    <span class="hljs-comment">// 如果加入新对象，该函数代码需要进行修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>观察者模式：</strong>定义一个数组保存全部Observe，观察者在创建时加入主题数组，主题在变化时通知数组全部人</p><p>​我想要数组中每一个不同的观察者统一调用同一个函数，自然而然想到使用接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主题接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span>;  <span class="hljs-comment">// 注册观察者</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;    <span class="hljs-comment">// 移除观察者</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;                    <span class="hljs-comment">// 通知观察者</span><br>    <span class="hljs-comment">// 具体实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123; <span class="hljs-comment">// 通知所有人</span><br>            observer.update(temperature, humidity, pressure);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 观察者接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span>;  <span class="hljs-comment">// 更新状态</span><br>&#125;<br><span class="hljs-comment">// 具体的观察者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditionsDisplay</span><span class="hljs-params">(Subject weatherData)</span> &#123;<br>        <span class="hljs-built_in">this</span>.weatherData = weatherData;<br>        weatherData.registerObserver(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 注册加入</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>”趣学架构“中的<strong>非主链路</strong>的统计、打点，使用<strong>观察者模式</strong>实现</p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰器类将对象包装，通过构造函数传递给装饰器；装饰器和被装饰对象需要实现相同的接口，并在实现中进行叠加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Beverage beverage)</span> &#123;<br><span class="hljs-built_in">this</span>.beverage = beverage; <span class="hljs-comment">// 构造函数传递被装饰对象</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> beverage.getCost() + <span class="hljs-number">0.10</span>;  <span class="hljs-comment">// 叠加使用</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>允许你在运行时<strong>动态地扩展</strong>一个对象的功能。</li><li>组合而非继承</li><li>包装原始对象而不影响其原始结构和行为(通过成员变量引用访问到原始对象<code>has-a的关系</code>)</li></ul><ol><li>抽象组件（Component）：定义了被装饰者和装饰者的共同接口。</li><li>具体组件（ConcreteComponent）：实现了抽象组件接口，并定义了被装饰者的基本行为。</li><li>抽象装饰者（Decorator）：定义了装饰者的接口，并持有一个被装饰者的引用。<code>has-a</code></li><li>具体装饰者（ConcreteDecorator）：实现了抽象装饰者的接口，并向被装饰者添加新的行为和责任。</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230422155809934.png" alt="image-20230422155809934"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象组件</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Espresso</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Espresso&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰者</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CondimentDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-keyword">protected</span> Beverage beverage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CondimentDecorator</span><span class="hljs-params">(Beverage beverage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.beverage = beverage;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体装饰者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Milk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CondimentDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Milk</span><span class="hljs-params">(Beverage beverage)</span> &#123;<br>        <span class="hljs-built_in">super</span>(beverage);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Milk&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beverage.getCost() + <span class="hljs-number">0.10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CondimentDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mocha</span><span class="hljs-params">(Beverage beverage)</span> &#123;<br>        <span class="hljs-built_in">super</span>(beverage);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Mocha&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getCost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beverage.getCost() + <span class="hljs-number">0.20</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">beverage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Espresso</span>();<br>        System.out.println(beverage.getDescription() + <span class="hljs-string">&quot; $&quot;</span> + beverage.getCost());<br><br>        <span class="hljs-type">Beverage</span> <span class="hljs-variable">beverage2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Espresso</span>();<br>        beverage2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Milk</span>(beverage2);<br>        beverage2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mocha</span>(beverage2);<br>        System.out.println(beverage2.getDescription() + <span class="hljs-string">&quot; $&quot;</span> + beverage2.getCost());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在此基础上，我还想添加满减、九折等，同样是定义一个ConcreteDecorator即可  beverage.getCost()*0.9</span><br></code></pre></td></tr></table></figure><p>Java I&#x2F;O库</p><p>SQL查询通常由多个组件构成，如SELECT、FROM、WHERE、JOIN等。我们可以使用装饰者模式来构建这些组件，并动态地添加额外的功能，例如缓存、日志记录等。  Filter 和 SeqScan的关系</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>全局变量可以提供全局访问，但不能确保唯一。</p><p>public的类，但private的构造方法，通过static方法访问private构造方法，构造一个static变量</p><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>全局直接初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重检查</p><p>volatile：强制立即写入内存，并强制内存读取，而不是缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>共享对象来减少内存使用和提高性能</p><p>字符串池、Integer常量池、数据库连接池</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>当一个对象的行为取决于其状态，并且它必须在运行时根据状态改变其行为时。</p><p>订单处理系统：订单有多种状态，如新建订单、已支付、已发货、已收货、已完成等。每种状态下，订单可以执行的操作都可能不同。</p><p>以下是一个基于Java的状态模式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">(Order order)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">prev</span><span class="hljs-params">(Order order)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStatus</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">New</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">(Order order)</span> &#123;<br>        order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Paid</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prev</span><span class="hljs-params">(Order order)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The order is in its root state.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStatus</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;New order.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Paid</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">(Order order)</span> &#123;<br>        order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Shipped</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prev</span><span class="hljs-params">(Order order)</span> &#123;<br>        order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">New</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStatus</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Order paid.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shipped</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">(Order order)</span> &#123;<br>        order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Delivered</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prev</span><span class="hljs-params">(Order order)</span> &#123;<br>        order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Paid</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStatus</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Order shipped.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delivered</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">(Order order)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This order is already delivered.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prev</span><span class="hljs-params">(Order order)</span> &#123;<br>        order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Shipped</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStatus</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Order delivered.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 上下文类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> OrderState state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-keyword">new</span> <span class="hljs-title class_">New</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(OrderState state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        state.next(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prev</span><span class="hljs-params">()</span> &#123;<br>        state.prev(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStatus</span><span class="hljs-params">()</span> &#123;<br>        state.printStatus();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br><br>        order.printStatus();  <span class="hljs-comment">// 输出: New order.</span><br><br>        order.next();<br>        order.printStatus();  <span class="hljs-comment">// 输出: Order paid.</span><br><br>        order.next();<br>        order.printStatus();  <span class="hljs-comment">// 输出: Order shipped.</span><br><br>        order.prev();<br>        order.printStatus();  <span class="hljs-comment">// 输出: Order paid.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>OrderState</code>接口定义了<code>next</code>、<code>prev</code>和<code>printStatus</code>三个方法，表示订单的下一个状态、上一个状态和打印当前状态。<code>New</code>、<code>Paid</code>、<code>Shipped</code>和<code>Delivered</code>类分别实现了<code>OrderState</code>接口，代表了订单的四种状态。<code>Order</code>类就是所谓的上下文，它持有一个<code>OrderState</code>对象，代表当前的状态。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>定义一个操作中的骨架，标准化流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Stopwatch;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTemplate</span>&lt;T, R&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggerImpl</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模板统一暴露执行入口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">process</span><span class="hljs-params">(T request)</span> &#123;<br>        <span class="hljs-comment">// 1.打印入口日志</span><br>        logger.info(<span class="hljs-string">&quot;start invoke, request=&quot;</span> + request);<br>        <span class="hljs-comment">// 开始计时，用于日志记录耗时</span><br>        <span class="hljs-type">Stopwatch</span> <span class="hljs-variable">stopwatch</span> <span class="hljs-operator">=</span> Stopwatch.createStarted();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 2. 校验参数</span><br>            validParam(request);<br>            <span class="hljs-comment">// 3. 子类实现逻辑</span><br>            <span class="hljs-type">R</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> doProcess(request);<br>            <span class="hljs-comment">// 4.打印出口日志</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">timeCost</span> <span class="hljs-operator">=</span> stopwatch.elapsed(TimeUnit.MILLISECONDS);<br>            logger.info(<span class="hljs-string">&quot;end invoke, response=&quot;</span> + response + <span class="hljs-string">&quot;, costTime=&quot;</span> + timeCost);<br>            <span class="hljs-keyword">return</span> response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 打印异常日志</span><br>            logger.error(<span class="hljs-string">&quot;error invoke, exception:&quot;</span> + Arrays.toString(e.getStackTrace()));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数校验(交给子类实现)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validParam</span><span class="hljs-params">(T request)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行业务逻辑(交给子类实现)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> R <span class="hljs-title function_">doProcess</span><span class="hljs-params">(T request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240118172157467-1711604046257.png" alt="image-20240118172157467"></p><p>责任链：沿着这条链传递请求，直到有一个对象处理它为止，具体由哪个对象处理则在运行时动态决定的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">protected</span> Handler successor;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;No discount applied.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Low discount applied. Amount: &quot;</span> + amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighDiscountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt;= <span class="hljs-number">1000</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;High discount applied. Amount: &quot;</span> + amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>            successor.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChain</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler head;<br>    <span class="hljs-keyword">private</span> Handler tail;<br><br>    <span class="hljs-keyword">public</span> HandlerChain <span class="hljs-title function_">add</span><span class="hljs-params">(Handler handler)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = handler;<br>            tail = handler;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.setSuccessor(handler);<br>            tail = handler;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            head.handleRequest(amount);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HandlerChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChain</span>();<br>        chain.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LowDiscountHandler</span>())<br>             .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HighDiscountHandler</span>())<br>             .add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoDiscountHandler</span>());<br><br>        <span class="hljs-comment">// Making requests</span><br>        chain.handleRequest(<span class="hljs-number">500</span>);<br>        chain.handleRequest(<span class="hljs-number">1500</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h3><p>见 ”趣学架构“</p>]]></content>
    
    
    <categories>
      
      <category>系统架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发</title>
    <link href="/2023/06/12/java%E5%B9%B6%E5%8F%91/"/>
    <url>/2023/06/12/java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章是Java多线程编程的学习大纲，涵盖了多线程编程的核心概念和高级特性。主要内容包括线程基础知识（创建、状态、中断、守护线程等）、线程同步机制（synchronized关键字、Monitor对象、锁优化、wait&#x2F;notify机制）、并发问题（死锁、活锁、饥饿）、可重入锁（ReentrantLock及其特性）、Java内存模型（可见性、有序性、volatile关键字）、原子操作（CAS、AtomicInteger等原子类）、线程池（创建、任务提交、拒绝策略、各种预定义线程池）、并发工具类（AQS、读写锁、StampedLock、Semaphore、CountDownLatch、CyclicBarrier）等。文本还提到了一些同步模式设计模式（保护性暂停、生产者&#x2F;消费者模式、顺序控制模式）以及不可变设计和享元模式在并发编程中的应用。整体来看，这是一份较为全面的Java并发编程知识体系，涵盖了从基础概念到高级特性的多个层面，适合系统学习Java多线程编程。</p></blockquote><p>效率提升：</p><ul><li>异步，防止阻塞IO</li><li>充分发挥多核CPU</li></ul><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol><li>重写thread的run方法</li><li>创建runnable 抽象出来任务</li><li>FutureTask 带返回值  线程间通信</li></ol><p>核心Thread是创建一个线程，其中run方法或者Runnable只是代表具体的任务。如果main线程中调用Runnable.run该任务就是main执行的</p><p>extends Thread 并重写run方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>Runnable :当成参数传给thread，run方法默认会检查Runnable如果有就执行Runnable.run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// lambda:单个抽象方法的接口</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 继承Runnable</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 阻塞等待返回结果</span><br>            System.out.println(s);<br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasklist    jps</code>   <code>taskkill</code></p><p><code>top -H -p pid           jstack</code>  查看进程中线程信息</p><p>每一个线程都有一个独立的栈，栈内每个函数都会有栈帧。main线程中的三个函数：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808190.png" alt="image-20230607100221439"></p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>切换当前执行的线程</p><ul><li>CPU时间片</li><li>垃圾回收</li><li>更高优先权</li><li>线程主动调用sleep、yield、wait、 join、 park、 synchronized、 lock</li></ul><p>如何保存上下文信息？</p><ul><li>线程内程序计数器 记录运行到哪里</li><li>栈帧记录变量信息</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <strong>start</strong>()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void <strong>run</strong>()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void <strong>sleep</strong>(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public static native void <strong>yield</strong>()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void <strong>setPriority</strong>(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void <strong>join</strong>()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ul><li><strong>操作系统层面</strong>：新建 就绪 运行 阻塞(io) 终止</li><li><strong>java层面</strong>：其中Runnable包含 就绪 运行 阻塞(io)</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808191.png" alt="image-20230607112856036"></p><table><thead><tr><th>程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态 <code>synchronized</code>      <strong>EntryList</strong></td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态. <code>wait</code>(WaitSet) <code>join</code>(原理wait) <code>park</code></td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。常用方法有 <code>Thread.sleep(time) 、wait(time)  </code> <code>join(time)</code> <code>parkUntil(time)</code></td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul><li><code>public void interrupt()</code>：打断这个线程，异常处理机制</li><li><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong></li><li><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</li></ul><ol><li><p>线程处于<strong>阻塞</strong>状态：如果线程当前处于阻塞状态，如调用了 <code>Thread.sleep()</code>、<code>Object.wait()</code>、<code>join</code> <code>BlockingQueue.take()</code> 等阻塞方法，调用 <code>interrupt()</code> 方法会中断线程的阻塞状态，抛出 <code>InterruptedException</code> 异常，打断标记。因为线程都不在运行，所以需要抛异常来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    t1.interrupt();<br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程处于<strong>非阻塞</strong>状态：如果线程当前处于非阻塞状态，调用 <code>interrupt()</code> 方法会将线程的中断状态设置为 <code>true</code>，但不会中断线程的执行。可以通过检查中断状态来决定是否终止线程的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主线程休眠 2 秒后中断子线程</span><br>Thread.sleep(<span class="hljs-number">2000</span>);<br>myThread.interrupt();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            <span class="hljs-comment">// 线程执行的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;Thread is running.&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Thread interrupted. Exiting...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="两阶段终止"><a href="#两阶段终止" class="headerlink" title="两阶段终止"></a>两阶段终止</h5><p>功能：记录系统的利用率，但需要能停止下来。<br>如果在sleep时被打断，则手动标记一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInterrupt</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    current.interrupt();<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作 </span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="打断park"><a href="#打断park" class="headerlink" title="打断park"></a>打断park</h5><p>park阻塞线程类似于一直sleep，但被打断不会清空标记。需要标记为假时才生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true</span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><ul><li><code>public final void join()</code>等待该线程执行完成，原理上可以使用信号量PV</li><li><code>join(long millis)</code> 最大等待时间</li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>当其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p><code>t1.setDaemon(true);</code></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><h2 id="共享模型之并发"><a href="#共享模型之并发" class="headerlink" title="共享模型之并发"></a>共享模型之并发</h2><p>访问共享变量时，代码的原子性（互斥）以及并发协调（同步）</p><ul><li>共享问题</li><li>synchronized</li><li>线程安全分析 </li><li>Monitor </li><li>wait&#x2F;notify </li><li>线程状态转换 </li><li>活跃性 </li><li>Lock 加以改进</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 共享资源</span><br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter++;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter--;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br></code></pre></td></tr></table></figure><ul><li>阻塞：synchronized、lock</li><li>非阻塞：原子变量</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>对象锁，同一时刻只有一个线程获取到针对该对象的锁，获取失败进入等待队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>临界区<br>&#125;<br><br>大括号相当于 获取锁 + 释放锁。  对象相当于locked<br>    没有获取到时会阻塞释放资源 相当于Futex <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (xchg(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; xchg(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure><p>加在成员方法上，锁<strong>对象</strong>  <code>synchronized(this)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块</span><br>&#125;<br><br>同一类中的多个函数，如果<span class="hljs-keyword">synchronized</span>了 也不能并行，因为对象被锁了而不是函数被锁了<br></code></pre></td></tr></table></figure><p>加在静态方法上，锁<strong>类对象</strong>  <code>synchronized(MyClass.class)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步的静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量理论是线程安全的（每个栈都有栈帧），成员变量和静态变量不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但如果方法是public并且在子类中被修改了，就可能出错，所以private 或者 final的修饰符是有必要的，满足开<strong>闭</strong>原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadSafe</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h4><p>线程安全的类： 单一方法是安全的，组合不一定（想要安全还要额外上锁）</p><ul><li>java.lang.String、 java.lang.Integer  不可变对象</li><li>java.lang.StringBuffer</li><li>java.lang.Float</li><li>java.lang.Boolean</li><li>java.util.Vector</li><li>java.util.Hashtable</li><li>java.util.concurrent.ConcurrentHashMap</li></ul><p>非线程安全的类：</p><ul><li>java.lang.StringBuilder</li><li>java.util.ArrayList</li><li>java.util.LinkedList</li><li>java.util.HashMap</li><li>java.util.HashSet</li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>MyServlet只有一个，共享的。所以userService也是一个共享的。count不是安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>     userService.update(...);<br>     &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>     <span class="hljs-comment">// 记录调用次数</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// ...</span><br>     count++;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例中的成员变量都是共享的。  改成环绕通知中的局部变量就解决了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br><br>     <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>         start = System.nanoTime();<br>     &#125;<br><br>     <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>         System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dao中的数据库连接，不能共享否则被别人close了，所以每个查询都要在局部变量中获取一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br> <span class="hljs-comment">// 是否安全</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>         conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>         <span class="hljs-comment">// ...</span><br>         conn.close();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转账 锁住类对象，简单的解决办法但效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Account.class)&#123;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.money &gt; amount) &#123;<br>                <span class="hljs-built_in">this</span>.setMoney(<span class="hljs-built_in">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>        &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808192.png" alt="image-20230609132432143" style="zoom: 80%;" /><p>Mark Word</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808194.png" alt="image-20230609132408757"></p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor是JVM中提供的一个对象，负责管理某个对象的锁。我们的对象通过MarkWord中的指针指向monitor对象（一对一）  c++实现的</p><ul><li>获取成功为Owner</li><li>失败加入EntryList（还可以先进行<strong>自旋</strong>几次，如果还失败才加入，减少上下文切换   自适应）；</li><li>在thread-2释放时唤醒一个（线程的阻塞和唤醒操作是在<strong>Java虚拟机内部</strong>进行的，而不涉及到底层操作系统的系统调用）</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808195.png" alt="image-20230609133445269"></p><h4 id="字节码角度"><a href="#字节码角度" class="headerlink" title="字节码角度"></a>字节码角度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) <br>&#123;<br>count++;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了正常处理外，19~23为异常处理，也会释放锁</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808196.png" alt="image-20230609134409660"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>优化：轻量级、偏向锁</p><ul><li><strong>轻量级锁</strong>：在竞争比较少的情况下，每次上锁太麻烦了；房门上挂书包  <strong>对使用者透明</strong></li><li><strong>偏向锁</strong>：直接在房门上课上名字，专属于谁</li></ul><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p><strong>锁记录</strong>：线程中负责记录 该线程锁住了哪些对象</p><ul><li><p>加锁：如果对象没被锁(01)，通过<strong>CAS</strong>让对象头保留锁记录地址，锁记录保存原对象头信息</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808197.png" alt="image-20230610113617600" style="zoom:67%;" /></li><li><p>加锁失败：如果对象已经被锁了(00)，<strong>锁膨胀</strong>：申请一个monitor，对象头指向monitor，加入entrylist</p></li><li><p>解锁：CAS再交换回来，如果发现对象被重量级锁锁住了，就进入重量级锁解锁流程</p></li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808198.png" alt="image-20230610114230079" style="zoom:67%;" /><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁问题：自己调用时，还需要指向<strong>CAS</strong>操作（这次一定会失败），偏向锁优化掉这个操作</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808199.png" alt="image-20230610123937238"></p><ul><li><p>把线程的ID放入MarkWord，以后轻量级锁前先查看线程ID是否是自己，自己就不用CAS了</p></li><li><p>如果threadID不是自己，升级为轻量级锁，解锁后变成normal</p><ul><li>（如果超过20次，会发生批量重新偏向，全部直接偏向t2）</li><li>（如果超过40次，直接所有新建对象不可偏向）</li></ul></li><li><p>偏向锁释放时，并不会清空threadID</p></li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808200.png" alt="image-20230610124244401" style="zoom: 80%;" /><ul><li>初始时默认状态就是该状态，但程序加载会有延时</li><li>可以手动禁用，或者hashCode()时会禁用（因为放不下，而在轻量级锁记录 重量级monitor会记录hash）</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁压根不会发生冲突，则直接被优化掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     <span class="hljs-keyword">synchronized</span> (o) &#123;<br>     x++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait &#x2F; notify"></a>wait &#x2F; notify</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>等价于万能条件变量法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>        lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>        System.out.println(<span class="hljs-string">&quot;Thread A is resumed&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread B is performing some task&quot;</span>);<br>        lock.notify();  <span class="hljs-comment">// 唤醒等待的线程A</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808201.png" alt="image-20230610133052012"></p><ul><li><p>在获取锁后，发现不满足情况，<code>lock.wait()</code>释放锁并进入<code>WaitSet</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;lk);<br><span class="hljs-keyword">if</span> (!cond) cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 睡眠前释放锁；在唤醒后，会重新尝试获取锁</span><br></code></pre></td></tr></table></figure></li><li><p>在被Owner <code>lock.notify</code>后，重新进入<code>EntryList</code>。<code>notifyAll()</code>唤醒全部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cond_signal(&amp;cv);<br>broadcast(&amp;cv);<br></code></pre></td></tr></table></figure></li><li><p>和<strong>操作系统不同点</strong>就是这里锁lk和唤醒信号cv都是lock对象</p></li></ul><p>同样可能会存在错误叫醒的情况，while + 广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>     <span class="hljs-keyword">while</span>(!cond) &#123;<br>     lock.wait();<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait sleep区别"></a>wait sleep区别</h4><ul><li>wait 是Object方法；sleep是Thread方法</li><li>wait必须要先获取锁并且再释放锁，sleep不用且不会释放锁</li></ul><h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><ul><li>一个线程等待另外一个线程结果</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>但如果是一直产生：消息队列（见生产者&#x2F;消费者）</li></ul><p>如果用join实现，必须要下载线程结束，并且变量要设置为全局的</p><h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>     <span class="hljs-keyword">private</span> Object response;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件不满足则等待</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件满足，通知等待线程</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            lock.notifyAll();<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 子线程执行下载 耗时</span><br>        List&lt;String&gt; response = download();<br>        log.debug(<span class="hljs-string">&quot;download complete...&quot;</span>);<br>        guardedObject.complete(response);<br>        <br>    &#125;).start();<br><br>    <span class="hljs-comment">// 主线程阻塞等待</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> guardedObject.get();<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="带超时"><a href="#带超时" class="headerlink" title="带超时"></a><strong>带超时</strong></h5><p>直接wait(time) break不行，因为存在虚假唤醒。记录等待时间防止多等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 1) 记录最初时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 2) 已经经历的时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;<br>            log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);<br>            <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;break...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait(waitTime);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span><br>            timePassed = System.currentTimeMillis() - begin;<br>            log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, timePassed, response == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="扩展多个"><a href="#扩展多个" class="headerlink" title="扩展多个"></a>扩展多个</h5><p>多加一个中间者，实现多对多，但其中每一对还是一一对应的。解耦产生和消费；  PRC框架</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808202.png" alt="image-20230610155101901"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Join原理"><a href="#Join原理" class="headerlink" title="Join原理"></a>Join原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">线程对象也是对象<br>A线程调用B.join()时，会先获取锁<span class="hljs-keyword">synchronized</span> 然后执行B.wait(delay);<br>B线程运行结束后，调用notifyAll唤醒所有等待<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span>&#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h4><ul><li>生产者消费者不需要一一对应</li><li>JDK中的阻塞队列原理</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808203.png" alt="image-20230610155149434"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            <span class="hljs-keyword">return</span> queue.getFirst();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Message m)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            queue.add(m);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h3><p>wait状态，有点像<strong>值最大为1的信号量</strong>  但是是以<strong>线程</strong>为单位   不需要获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    LockSupport.park(); <span class="hljs-comment">// 暂停自己</span><br>    log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1); <span class="hljs-comment">// 恢复某个线程运行，可以在线程暂停前使用</span><br></code></pre></td></tr></table></figure><ul><li>不需要monitor，唤醒比较精确</li><li>可以先恢复再暂停</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每个线程一个parker对象</p><p>其中有一个_counter(干粮数量)&#x3D;0或者1</p><ul><li>unpark：<code>_counter++  if(线程在等待) &#123;唤醒， _counter=0&#125;</code></li><li>park：<code>_counter--   if ( _counter&lt;0)  &#123;wait , _counter=0&#125;</code></li></ul><h3 id="细粒度锁"><a href="#细粒度锁" class="headerlink" title="细粒度锁"></a>细粒度锁</h3><p>睡觉和学习应该能并发，所以需要将锁细粒度化，而不是直接锁住this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在一个线程需要获取多把锁时就可能导致</p><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">jps <span class="hljs-comment">// 输出java进程 pid</span><br><br>jconsole <span class="hljs-comment">// 切换到线程，然后检测死锁</span><br>jstack pid  <span class="hljs-comment">// 显示进程运行信息  可以检测死锁  但只能检测java自己的  imple-db项目中锁是用map定义的就无法检测</span><br><br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361d378</span> (object <span class="hljs-number">0x000000076b5bf1c0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361e768</span> (object <span class="hljs-number">0x000000076b5bf1d0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-1&quot;</span><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">1</span>(TestDeadLock.java:<span class="hljs-number">28</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">883049899.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">0</span>(TestDeadLock.java:<span class="hljs-number">15</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">495053715.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。开发中可以增加随机时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望减到 0 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count--;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望超过 20 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count++;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>某个线程始终不能运行，如设置了线程优先级，优先级低的可能难以运行</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul><li>可中断</li><li>可以设置超时时间     </li><li>可以设置为公平锁     先到先得而不是随机</li><li>支持多个条件变量     相当于不同条件变量进入不同<code>WaitSet</code>    现在就完全相当于万能条件变量法 等价于synchronized+wait notifyall 升级</li></ul><p>都可以重入</p><p>java实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h4><p>等待锁的过程中可以被叫醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    lock.lockInterruptibly();  <span class="hljs-comment">// 如果别人获取了锁，我在等待过程可以被打断</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>    log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br>lock.lock();<br>t1.start();<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br></code></pre></td></tr></table></figure><h4 id="可超时"><a href="#可超时" class="headerlink" title="可超时"></a>可超时</h4><p>避免无限制的等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!lock.tryLock()) &#123; <span class="hljs-comment">// 查看当前状态下是否能够获取锁 立即返回true false</span><br>    log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br><br>lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 尝试1s</span><br></code></pre></td></tr></table></figure><h5 id="解决哲学家"><a href="#解决哲学家" class="headerlink" title="解决哲学家"></a>解决哲学家</h5><p>获取锁时，如果右手获取不到，需要立马不等并且左手要解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 尝试获得左手筷子</span><br><span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试获得右手筷子</span><br>        <span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                eat();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                right.unlock();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        left.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>会降低并发度 默认为false   <code>lock = new ReentrantLock(true);</code></p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>之前等待队列只有一个，直接是lock对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>    lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在lock基础上，创建一个condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 创建一个condition</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionMet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (!conditionMet) &#123;<br>            condition.await(); <span class="hljs-comment">// 在该condition上等待 进入该队列</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Condition is met. Resuming execution.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        conditionMet = <span class="hljs-literal">true</span>;<br>        condition.signal(); <span class="hljs-comment">// signalAll()</span><br>        System.out.println(<span class="hljs-string">&quot;Condition is signaled.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><h4 id="线程执行顺序"><a href="#线程执行顺序" class="headerlink" title="线程执行顺序"></a>线程执行顺序</h4><ul><li>wait notify：  还需要一个额外变量标记代表cond</li><li>park unpark  非常简洁</li></ul><h4 id="打印指定形状"><a href="#打印指定形状" class="headerlink" title="打印指定形状"></a>打印指定形状</h4><p>例如打印abcabc   和打印🐟一个原理</p><ol><li><p>直接万能条件变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag, String str)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.flag != waitFlag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.print(str);<br>        flag = nextFlag;<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ReentrantLock + condition  每个线程都有等待的cond以及唤醒的cond 感觉没有必要 不如直接上面whlie+notifyAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        current.await();<br>        log.debug(str);<br>        next.signal();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>park unpark：每次unpark下一个想打印的线程，需要一个数组以获得下一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();<br>System.out.print(str);<br>LockSupport.unpark(nextThread());<br></code></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>分析多线程访问共享资源时，哪些代码片段属于临界区 </p><p>使用 synchronized 互斥解决临界区的线程安全问题 </p><ul><li>掌握 synchronized 锁对象语法 </li><li>掌握 synchronzied 加载成员方法this 和静态方法语法 this.getClass()</li><li>掌握 wait&#x2F;notify 同步方法</li></ul><p>使用 lock 互斥解决临界区的线程安全问题 </p><ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量   </li><li>相当于synchronzied 的<strong>升级</strong></li></ul><p>学会分析变量的线程安全性、掌握常见<strong>线程安全类</strong>的使用</p><p> 了解线程活跃性问题：死锁、活锁、饥饿 </p><p><strong>应用方面</strong> </p><ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li><li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果</li></ul><p><strong>原理方面</strong> </p><ul><li>monitor、synchronized 、wait&#x2F;notify 原理 </li><li>synchronized 进阶原理   轻量级  偏向锁  锁消除</li><li>park &amp; unpark 原理</li></ul><p><strong>模式方面</strong> </p><ul><li>同步模式之保护性暂停 </li><li>异步模式之生产者消费者 </li><li>同步模式之顺序控制</li></ul><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>通过volatile解决由于缓存引发的可见性问题，以及重排序引发的有序性问题</p><p>JMM java memory model</p><ul><li>原子性</li><li>可见性  不受缓存影响</li><li>有序性  不受cpu指令并行优化影响</li></ul><p>JMM的主要内容包括：</p><ol><li>主内存（Main Memory）：主内存是所有线程共享的内存区域，用于存储共享变量。主内存中的数据对所有线程可见。</li><li>工作内存（Working Memory）：每个线程都有自己的工作内存，用于存储线程执行时需要使用的数据。工作内存中包含了主内存中的部分数据副本。</li><li>内存间交互操作：JMM定义了一组规则，用于线程在主内存和工作内存之间进行数据交互。这些操作包括读取、写入和同步操作。</li><li>顺序一致性（Sequential Consistency）：JMM保证线程的执行结果与顺序一致的执行结果相同。即，对于一个线程来说，它的操作将按照程序中的顺序执行，并且对其他线程可见。</li><li>可见性（Visibility）：JMM保证一个线程对共享变量的修改对其他线程是可见的。这意味着一个线程对变量的修改，将会在之后的操作中对其他线程可见。</li><li>原子性（Atomicity）：JMM提供了一些原子性的保证。例如，对<code>volatile</code>变量的读写具有原子性，单个读写操作不会被线程中断。</li><li>重排序（Reordering）：JMM允许编译器和处理器对指令进行优化和重排序，但要求保持程序的顺序一致性和线程的可见性。</li></ol><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>实际上停不下来，为什么？</li><li>while中如果有sout，就可以停下来了 为什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1</span>);<br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t会在下一次循环中停下来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>线程中存储了<code>run = true;</code> 的副本</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808204.png" alt="image-20230612163339523"></p><ul><li><strong>volatile</strong>：强制到主存中读取，修饰成员变量和静态成员变量。不能保证原子性，一个i++ 一个i– 还是会错，适合一个写其他读的情况 (轻量级的同步机制)</li><li><strong>synchronized</strong>：也可以实现必须去主存读取，但复杂度高。可以实现原子性(代码块内也可能重排序）<ul><li>进入时从主存读取最新</li><li>退出时将修改刷新到主存</li></ul></li></ul><h4 id="改进两阶段"><a href="#改进两阶段" class="headerlink" title="改进两阶段"></a>改进两阶段</h4><p>使用volatile标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作</span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt(); <span class="hljs-comment">// 立即打断 不用等待sleep</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="balking"><a href="#balking" class="headerlink" title="balking"></a>balking</h4><p>监控线程只有一个，但如果有人多次start()其实会调用多个。balking<strong>避免重复执行某个操作</strong>  任务调度</p><ul><li>加一个volatile变量if判断 ？   不行 不能保证原子</li><li>加synchronized  可以实现，但每次都要synchronized同步比较慢（如用这个实现单例）</li><li>缩小synchronized 范围。  为什么不直接用单例 单例是保证只有一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting; <span class="hljs-comment">// 如果只在synchronized内读写可以不加volatile</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808205.png" alt="image-20230612172143500" style="zoom:67%;" /><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和组合来实现指令级并行，单线程下正确，但多线程下有问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// 指令2</span><br>System.out.println( a + b );<br><span class="hljs-comment">// 不能重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">5</span>; <span class="hljs-comment">// 指令2</span><br></code></pre></td></tr></table></figure><h4 id="指令重排序问题"><a href="#指令重排序问题" class="headerlink" title="指令重排序问题"></a>指令重排序问题</h4><p>1 4为正常输出 但可能出现0(概率比较低)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123; <br>    num = <span class="hljs-number">2</span>; <span class="hljs-comment">// 这两条可能被交换位置  或者num = 2并没有被写入主存中</span><br>    ready = <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>对变量ready添加volatile会禁用重排序</p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可见性：<ul><li>遇到写屏障（sfence），对所有共享变量的改动，都同步到主存当中</li><li>遇到读屏障（lfence），去主存加载最新数据</li></ul></li><li>有序性：<ul><li>指令不能跨越屏障</li></ul></li></ul><h3 id="double-check-locking"><a href="#double-check-locking" class="headerlink" title="double-check-locking"></a>double-check-locking</h3><p>普通写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>double</p><ul><li><p>需要把同步的范围缩小，只在第一次加锁</p></li><li><p>并且通过volatile保证读取最新值保证<strong>可见性</strong>，并且<strong>有序性</strong>防止指令重排导致 还没初始化完毕的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 的过程<br>    <span class="hljs-number">17</span> 表示创建对象，将对象引用入栈 <span class="hljs-comment">// new Singleton</span><br>    <span class="hljs-number">20</span> 表示复制一份对象引用 <span class="hljs-comment">// 引用地址</span><br>    <span class="hljs-number">21</span> 表示利用一个对象引用，调用构造方法<br>    <span class="hljs-number">24</span> 表示利用一个对象引用，赋值给 <span class="hljs-keyword">static</span> INSTANCE  <span class="hljs-comment">// 可能先执行  需要加volatile写屏障</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?</span><br>    <span class="hljs-comment">// volatile会在synchronized读取，synchronized外面需要volatile保证从内存读取</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗  EntryList都会进到这里</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2 </span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可见性进阶"><a href="#可见性进阶" class="headerlink" title="可见性进阶"></a>可见性进阶</h3><ol><li>synchronized中的变量</li><li>volatile修饰的变量</li><li>在线程开始前修改变量（可以理解为创建副本）</li><li>t1.join() 后，可以看到t1中的修改</li><li>t1打断t2， t2.interrupt();  t2可以看到t1的写</li><li>对变量默认值的写，其他线程可见</li><li>具有传递性 ，在写屏障前的全部修改都可见 y &#x3D; 10 x &#x3D; 1  (x是volatile)</li></ol><h3 id="单例习题"><a href="#单例习题" class="headerlink" title="单例习题"></a>单例习题</h3><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final 防止被修改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?  不能</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?  jvm实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 避免反序列化</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的      </span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题    jvm避免</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例        不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例    不会</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式      饿汉式  static 静态成员变量</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做  构造方法</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123; <br> INSTANCE; <br>&#125;<br></code></pre></td></tr></table></figure><p>类加载实现懒汉式单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyHolder</span> &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-comment">// 问题2：在创建时是否有并发问题  不会 JVM保证只有一个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无锁并发"><a href="#无锁并发" class="headerlink" title="无锁并发"></a>无锁并发</h2><ul><li>本章内容</li><li>CAS 与 volatile </li><li>原子整数 </li><li>原子引用 </li><li>原子累加器 </li><li>Unsafe</li></ul><ol><li>CAS可以实现锁，0代表空闲1代表占用，下一章连接池中使用atomic数组实现多个连接池的锁</li><li>reentrantlock底层其实还是CAS，外带一个等待队列（park实现等待） 见原理部分</li></ol><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取当前值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.get();<br><br><span class="hljs-comment">// 设置新的值</span><br>atomicInteger.set(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 获取当前值，并设置新的值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> atomicInteger.getAndSet(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 比较当前值是否等于期望值，如果等于则设置新的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> atomicInteger.compareAndSet(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br><span class="hljs-comment">// public final native boolean compareAndSwapInt(Object this, long offset, int old, int new);</span><br><br><span class="hljs-comment">// 获取当前值，并将其加1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> atomicInteger.getAndIncrement();<br><br><span class="hljs-comment">// 获取当前值，并将其减1</span><br>newValue = atomicInteger.getAndDecrement();<br><br><span class="hljs-comment">// 获取当前值，并将其加上delta</span><br>newValue = atomicInteger.getAndAdd(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 将当前值加1，并返回新的值</span><br>newValue = atomicInteger.incrementAndGet();<br><br><span class="hljs-comment">// 将当前值减1，并返回新的值</span><br>newValue = atomicInteger.decrementAndGet();<br><br><span class="hljs-comment">// 将当前值加上delta，并返回新的值</span><br>newValue = atomicInteger.addAndGet(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CAS修改过程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>    <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>    <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;  <span class="hljs-comment">//compareAndSwapInt(this, offset, prev, next)</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 包括getAndIncrement也是这个原理 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object <span class="hljs-built_in">this</span>, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> var4=<span class="hljs-number">1</span>)</span> &#123;<br>    <span class="hljs-type">int</span> old;<br>    <span class="hljs-keyword">do</span> &#123;<br>        old = <span class="hljs-built_in">this</span>.getIntVolatile(<span class="hljs-built_in">this</span>, offset);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(<span class="hljs-built_in">this</span>, offset, old, old + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>Compare And Swap</code>：先比较是否是旧值，旧值没被修改才swap（乐观锁） </p><p>核心一个函数：this和offset用于确定地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object <span class="hljs-built_in">this</span>, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> old, <span class="hljs-type">int</span> new)</span>;<br></code></pre></td></tr></table></figure><p>底层：<code>lock cmpxchg</code> 指令（X86 架构）</p><p>变量存储在一个<strong>volatile</strong>值中，因为每次都要保证可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><p><strong>效率高</strong>：不需要 锁的获取 以及 线程的上下文下切换，但需要更高的cpu资源，受限cpu内核数</p><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><ul><li>AtomicBoolean </li><li>AtomicInteger </li><li>AtomicLong</li></ul><p>操作 原理都是while中尝试<code>compareAndSwapInt</code></p><ul><li>getAndIncrement();  incrementAndGet</li><li>getAndAdd(10);</li><li>getAndUpdate(p -&gt; p * 2);</li></ul><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul><li>AtomicReference </li><li>AtomicMarkableReference </li><li>AtomicStampedReference</li></ul><p>对象不是基本类型，提供CAS对对象进行操作，compare比较的是地址</p><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>保证多线程环境下取钱操作正常，并且不需要加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AtomicReference&lt;Double&gt; balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-number">0.0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>    Double oldValue;<br>    Double newValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = balance.get();<br>        newValue = oldValue - amount;<br>    &#125; <span class="hljs-keyword">while</span> (!balance.compareAndSet(oldValue, newValue));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h4><p>有人修改了值，但又改回来了，如何察觉到被修改了呢？</p><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>添加版本号，每次操作版本号+1，除了值要匹配，版本号也要匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取值 A</span><br><span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br><span class="hljs-comment">// 获取版本号</span><br><span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br><br><br>ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><p>不关心换了几次，只关心有没有换。用一个bool 来判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicMarkableReference&lt;T&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark=<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">T</span> <span class="hljs-variable">currentRef</span> <span class="hljs-operator">=</span> ref.getReference();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">currentMark</span> <span class="hljs-operator">=</span> ref.isMarked();<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(expectedRef, newRef, expectedMark, newMark);<br><br><span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> counter.get(mark);<br>counter.compareAndSet(value, value + <span class="hljs-number">1</span>, mark[<span class="hljs-number">0</span>], !mark[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul><li>AtomicIntegerArray </li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><p>前面的是保证引用的对象不变，现在需要保护引用对象的内部不被改变，例如数组对象的内容没有修改（多个引用对象），底层就是偏移量不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment"> 参数2，获取数组长度的方法</span><br><span class="hljs-comment"> 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment"> 参数4，打印数组的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">    Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">    Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">    BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">    Consumer&lt;T&gt; printConsumer )</span> &#123;<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                putConsumer.accept(array, j%length);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>    printConsumer.accept(array);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br> ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br> (array)-&gt;array.length,<br> (array, index) -&gt; array[index]++,<br> array-&gt; System.out.println(Arrays.toString(array))<br>);<br><br>demo(<br> ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br> (array) -&gt; array.length(),<br> (array, index) -&gt; array.getAndIncrement(index),<br> array -&gt; System.out.println(array)<br>);<br></code></pre></td></tr></table></figure><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul><li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdater</li></ul><p>某个对象内部的字段，保证原子操作。必须volatile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span>AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="hljs-string">&quot;field&quot;</span>);<br>    <span class="hljs-type">Test5</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test5</span>();<br>    fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>更高级的自增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(), adder -&gt; adder.increment());<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> adderSupplier.get();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                action.accept(adder);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start());<br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁   CAS实现</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><h5 id="sun-misc-Contended"><a href="#sun-misc-Contended" class="headerlink" title="@sun.misc.Contended"></a>@sun.misc.Contended</h5><p>防止cell伪共享</p><p>缓存行64 byte，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value）  一个缓存行可能有多个Cell，注解添加128B的pad防止在同一个缓存行</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808206.png" alt="image-20230630145548007"></p><table><thead><tr><th>从 cpu 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>会操作内存，比较危险</p><p>获取unsafe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Unsafe.getUnsafe();  被CallerSensitive修饰，能在引导类加载器加载的类中访问 抛出 SecurityException <br><br><span class="hljs-comment">// 反射获取</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) unsafeField.get(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>操作field</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br><br><span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br><span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>unsafe.compareAndSwapInt(teacher, idOffset, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br>System.out.println(teacher);<br></code></pre></td></tr></table></figure><h4 id="模拟原子整数"><a href="#模拟原子整数" class="headerlink" title="模拟原子整数"></a>模拟原子整数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicData</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> DATA_OFFSET;<br>    <span class="hljs-keyword">static</span> &#123;<br>        unsafe = UnsafeAccessor.getUnsafe();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>            DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrease</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> oldValue;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>            oldValue = data;<br>            <span class="hljs-comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span><br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><h3 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>); <span class="hljs-comment">// 不是线程安全的 多个线程调用会出错</span><br><br><span class="hljs-keyword">synchronized</span> (sdf)&#123;  <span class="hljs-comment">// 可以解决 但太慢了</span><br>    sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>内部属性不可变实现安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 保护性拷贝，防止内容被修改</span><br><span class="hljs-built_in">this</span>.value = Arrays.copyOf(value, value.length); <br><span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br></code></pre></td></tr></table></figure><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>minimizes memory usage by sharing</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的<br>valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对<br>象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="String-串池"><a href="#String-串池" class="headerlink" title="String 串池"></a>String 串池</h4><h4 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h4><h3 id="模拟连接池！"><a href="#模拟连接池！" class="headerlink" title="模拟连接池！"></a>模拟连接池！</h3><p>有多个连接，所以需要array标记使用状态：AtomicArray</p><p>AtomicIntegerArray来标记连接状态，并且是线程安全的，注意需要使用cas修改标记<br>在所有的连接都占用时，wait等待以节约cpu</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-comment">// 实现略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理</li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache<br>commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><p>tomcat jdbc连接池比较简单易读</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>线程池 ThreadPollExecutor Fork&#x2F;Join</li><li>JUC   Lock Semaphore CountdownLatch CyclicBarrier…</li><li>第三方</li></ul><h3 id="自己线程池"><a href="#自己线程池" class="headerlink" title="自己线程池"></a>自己线程池</h3><p>无救急线程</p><p>高并发下，并不是越大越好，而是需要充分发挥已有线程的潜力</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808207.png" alt="image-20230702093206100"></p><ul><li>需要一个线程set</li><li>当一个线程结束后，查看有没有BlockingQueue有没有任务，有就run（实现复用）</li></ul><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>实现保存暂时没有执行的任务列表，任务队列相当于<a href="###%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85/%E6%B6%88%E8%B4%B9%E8%80%85">生产者消费者模型</a>,但使用lock实现</p><ul><li><p>获取一个任务take</p><ul><li>为了实现如果等一段时间内还没有任务结束线程（不是一直死等），需要添加超时的等待<code>take -&gt; poll(timeout, unit)</code></li></ul></li><li><p>添加一个任务put</p><ul><li><p>等待任务队列也不是无穷大，有一个capcity</p></li><li><p>当满了以后，有<strong>不同的策略</strong></p><ol><li><p><code>put</code> 死等，阻塞主线程 fullWaitSet.await()</p></li><li><p><code>offer(task, timeout, unit)</code> 带超时等待</p></li><li><p>添加一个拒绝策略，策略模式</p><ul><li><p>具体实现的策略可以是死等、超时…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">(queue, task)-&gt;&#123;<br>    <span class="hljs-comment">// 1. 死等</span><br>    queue.put(task);<br>    <span class="hljs-comment">// 2) 带超时等待</span><br>    queue.offer(task, <span class="hljs-number">1500</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>    log.debug(<span class="hljs-string">&quot;放弃&#123;&#125;&quot;</span>, task);<br>    <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;任务执行失败 &quot;</span> + task);<br>    <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>    task.run();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 1. 任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-comment">// 2. 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 3. 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 4. 消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 5. 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br>    <span class="hljs-comment">// 带超时阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 timeout 统一转换为 纳秒</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 返回值是剩余时间</span><br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<span class="hljs-comment">//自动返回剩余时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 带超时时间阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断队列是否满</span><br>            <span class="hljs-keyword">if</span>(queue.size() == capcity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有空闲</span><br>                log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务队列</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><span class="hljs-comment">// 线程集合</span><br><span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">// 核心线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br><span class="hljs-comment">// 等待队列满了时，拒绝策略</span><br><span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br></code></pre></td></tr></table></figure><h5 id="创建任务："><a href="#创建任务：" class="headerlink" title="创建任务："></a>创建任务：</h5><ul><li><p>任务数量小于coreSize时，创建一个Worker并加入线程集合中</p></li><li><p>否则加入taskQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>    <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>    <span class="hljs-keyword">synchronized</span> (workers) &#123; <span class="hljs-comment">// 保证线程安全</span><br>        <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>            <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>            log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>            workers.add(worker);<br>            worker.start();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// taskQueue.put(task);</span><br>            <span class="hljs-comment">// 1) 死等</span><br>            <span class="hljs-comment">// 2) 带超时等待</span><br>            <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>            <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>            <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>            taskQueue.tryPut(rejectPolicy, task);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="执行与任务完成："><a href="#执行与任务完成：" class="headerlink" title="执行与任务完成："></a>执行与任务完成：</h5><ul><li><p>当任务完成后，Worker需要从taskQueue取出下一个任务，实现Worker的复用</p><ul><li>一直等待 或者 等一段时间后结束线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable task;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>        <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>        <span class="hljs-comment">// while(task != null || (task = taskQueue.take()) != null) &#123;  // 会一直等awiati</span><br>        <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                task.run();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>            workers.remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> threadpoolself;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">// 获取任务时的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>        <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// taskQueue.put(task);</span><br>                <span class="hljs-comment">// 1) 死等</span><br>                <span class="hljs-comment">// 2) 带超时等待</span><br>                <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>                <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>                <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, <span class="hljs-type">int</span> queueCapcity,</span><br><span class="hljs-params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>            <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>            <span class="hljs-comment">// while(task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808208.png" alt="image-20230702105624890"></p><p> int 的高 3 位来表示线程池状态，低 29 位表示线程数量，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</p><table><thead><tr><th>状态名</th><th>高3位</th><th>新任务</th><th>处理阻塞队列任务</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不会接收新任务，但会处理阻塞队列剩余任务shutdown</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>会中断正在执行的任务，并抛弃阻塞队列任务shutdownNow</td></tr><tr><td>TIDYING</td><td>010</td><td></td><td></td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td></td><td></td><td>终结状态</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目   减去核心线程就是救急线程数量，多出来的会被销毁</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p><strong>当阻塞队列满时，会先创建救济线程，再考虑拒绝策略</strong></p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808209.png" alt="image-20230702111206853"></p><ul><li><p>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p></li><li><p>CallerRunsPolicy 让调用者运行任务</p></li><li><p>DiscardPolicy 放弃本次任务</p></li><li><p>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</p></li><li><p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方<br>便定位问题</p></li><li><p>Netty 的实现，是创建一个新线程来执行任务</p></li><li><p>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</p></li><li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li><li>任务量已知，任务耗时</li></ul><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>全部都是救急线程（60s 后可以回收）</li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li><li>适合任务数比较密集，但每个任务执行时间较短的情况</li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p><p><code>FinalizableDelegatedExecutorService</code>限制了一些方法的暴露</p><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;   futer.get()获取结果（原理保护性暂停模式） 有异常返回异常<br><br><span class="hljs-comment">// 提交 tasks 中所有任务, 会等最后一个完成</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非阻塞</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br>- 会将队列中的任务返回<br>- 并用 interrupt 的方式中断正在执行的任务<br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> <br><br><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事</span><br>情，可以利用此方法等待<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><h4 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h4><p>分工模式，不同的任务采用不同的线程池。如点餐线程池和做饭线程池</p><p>如果同一个线程池中，可能会没有做饭的导致点餐的一直在等待，导致饥饿。但jconsole死锁检测不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">waiterPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cookPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>waiterPool.execute(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>    Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>        <span class="hljs-keyword">return</span> cooking();<br>    &#125;);<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="线程池数量"><a href="#线程池数量" class="headerlink" title="线程池数量"></a>线程池数量</h5><ul><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p></li><li><p><strong>CPU 密集</strong>型运算</p><p>​通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因<br>导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p></li><li><p><strong>I&#x2F;O 密集型</strong>运算</p><p>​CPU 容易闲下来（IO RPC），你可以利用多线程提高它的利用率。    时间占比可以用工具估算</p><p>​线程数 &#x3D; 核数 * 期望 CPU 利用率(1.0) * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p></li></ul><h4 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h4><p>如何实现一些延时的任务，或者反复执行</p><h5 id="Timmer"><a href="#Timmer" class="headerlink" title="Timmer"></a>Timmer</h5><p>同一时间只能有一个任务在执行，出现异常后续不可以执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span><br>    <span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><p>延时任务或者重复执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 添加两个任务，希望它们都在 1s 后执行</span><br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br><br><span class="hljs-comment">// 延时2s后 每隔1s反复执行，延时包括执行时间，任务开始间隔时间 = max（执行时间，等待时间）</span><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 延时从上一个任务结束开始算  任务开始间隔时间 = 执行时间+等待时间</span><br>executor.scheduleWithFixedDelay(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul><li><p>方法1：主动捉异常</p></li><li><p>方法2：使用submit中的 Future，f.get()会返回异常信息</p></li></ul><h3 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808210.png" alt="image-20230703111719298"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor implement Runnable），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><h4 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h4><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同<br>    如果总线程数达到 maximumPoolSize<br>        这时不会立刻抛 RejectedExecutionException 异常<br>        而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    submittedCount.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> (TaskQueue)<span class="hljs-built_in">super</span>.getQueue();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;<br>                    submittedCount.decrementAndGet();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>                submittedCount.decrementAndGet();<br>                Thread.interrupted();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(x);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            submittedCount.decrementAndGet();<br>            <span class="hljs-keyword">throw</span> rx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Connector 配置</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808211.png" alt="image-20230703112719086"></p><p>Executor 线程配置，优先级高于上面的配置</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808212.png" alt="image-20230703112911572"></p><p>此外，对救急线程的激活逻辑做了修改，先创建救急线程而不是加入队列</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808213.png" alt="image-20230703113021772"></p><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>大任务拆分为算法上相同的小任务，小任务分配到不同线程从而并行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(<span class="hljs-number">5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">AddTask1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork(); <span class="hljs-comment">// 启动另一个线程执行该任务</span><br>        <br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拆分优化：拆分成 begin-mid，mid+1-end 能提高并行度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask3</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-built_in">this</span>.begin = begin;<br>    <span class="hljs-built_in">this</span>.end = end;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p>特点：</p><ul><li>用 <strong>state</strong>  volatile属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取<br>锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br>    <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span><br>&#125;<br><br><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要实现以下方法： 不同的实现代表不同锁类型    AQS其他方法会调用下面的方法,详情见ReentrantLock</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808214.png" alt="image-20230704100702089" style="zoom:50%;" /><p>入队需要把当前Node变成tail，CAS操作防止并发影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 原来的 tail</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail;<br><span class="hljs-comment">// 用 cas 在原来 tail 的基础上改为 node</span><br>&#125; <span class="hljs-keyword">while</span>(tail.compareAndSet(prev, node))<br></code></pre></td></tr></table></figure><p>某个线程释放锁后，会唤醒Head的下一个，并尝试tryAcquire；成功后设置当前节点为head，并且出队列，失败继续等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 释放锁</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <span class="hljs-comment">// 修改state 自己定义的方法</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>        unparkSuccessor(h);  <span class="hljs-comment">// unpark下一个thread，优先叫醒head下一个；只是unpark，后面还要获取锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 老二被叫醒 尝试获取锁，成功了才被删除</span><br>    setHead(node);<br>    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    failed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> interrupted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义非重入锁"><a href="#自定义非重入锁" class="headerlink" title="自定义非重入锁"></a>自定义非重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span> (acquires == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span>(acquires == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列，可打断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试一次，不成功返回，不进入队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列，有时限</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 生成条件变量</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808215.png" alt="image-20230703151551509"></p><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>当前线程在获取失败后会park</p><p>有一个Node链表连接所有线程（有一个虚假head），前一个负责unpark后一个</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808216.png" alt="image-20230703154753396"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="hljs-comment">// add加入到链表中</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 老二被叫醒 尝试获取锁</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="hljs-comment">// pre的state设置为-1</span><br>                parkAndCheckInterrupt()) <span class="hljs-comment">// park 并返回等待过程中有没有被打断</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ul><li>设置state</li><li>unpark队列中离head最近的Thread</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808217.png" alt="image-20230703155757360"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <span class="hljs-comment">// 修改state 自己定义的方法</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);  <span class="hljs-comment">// unpark下一个thread，优先叫醒head下一个；只是unpark，后面还要获取锁</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>state：代表计数，获取时++，释放时–</p><h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><p>获取锁时会进入park，如果被打断就立马抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>(); <span class="hljs-comment">// 被打断后 立马抛出异常</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 如果被打断 返回true</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平性原理"><a href="#公平性原理" class="headerlink" title="公平性原理"></a>公平性原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">tryAcquire<br>    <span class="hljs-title function_">if</span> <span class="hljs-params">(!hasQueuedPredecessors()</span> &amp;&amp;  <span class="hljs-comment">// 添加这一句  队列中等待有时，新来的不可以tryAcquire</span><br>        compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h4><p>每一个ConditionObject有一个Node等待队列，nextWaiter串起来，firstWaiter为第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br>    <span class="hljs-comment">/** First node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">/** Last node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br><br>await<br>    <span class="hljs-comment">// 添加一个节点，CONDITION 并加入到Waiter队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br><br>    <span class="hljs-comment">// 释放掉当前lock上的锁，并唤醒等待队列</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br><br>    <span class="hljs-comment">// park自己</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br><br>signal<br>    从ConditionObject.firstWaiter转移到等待列表<br></code></pre></td></tr></table></figure><p>await</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808218.png" alt="image-20230703173859988"></p><p>signal</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808219.png" alt="image-20230703173947214"></p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>让<code>读-读</code>并发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataContainer</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>dataContainer.read();<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>dataContainer.write();<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>写锁才有条件变量</li><li>不支持升级但支持降级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedData</span> &#123;<br>    Object data;<br>    <span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// 获取写锁前必须释放读锁</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>                        cacheValid = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span><br>                rwl.readLock().lock();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                rwl.writeLock().unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 自己用完数据, 释放读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            use(data);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwl.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读写锁实现缓存一致性"><a href="#读写锁实现缓存一致性" class="headerlink" title="读写锁实现缓存一致性"></a><strong>读写锁实现缓存一致性</strong></h4><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑<br>    适合读多写少，如果写操作比较频繁，以上实现性能低<br>    没有考虑缓存容量<br>    没有考虑缓存过期<br>    只适合单机<br>    并发性还是低，目前只会用一把锁<br>    更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）<br>乐观锁实现：用 CAS 去更新</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位，Node链表还是只有一个</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808220.png" alt="image-20230704112731294"></p><p>没有仔细读源码</p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(stamp);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();  <span class="hljs-comment">// 无锁</span><br>sleep(readTime); <br><span class="hljs-comment">// 验戳 如果有人修改了，那么会失败</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br>    <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>semaphore.acquire();<br>semaphore.release();<br></code></pre></td></tr></table></figure><h4 id="优化连接池"><a href="#优化连接池" class="headerlink" title="优化连接池"></a>优化连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(poolSize);<br><br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// t1, t2, t3</span><br>    <span class="hljs-comment">// 获取许可</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire(); <span class="hljs-comment">// 没有许可的线程，在此等待</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>        <span class="hljs-comment">// 获取空闲连接</span><br>        <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                <span class="hljs-keyword">return</span> connections[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不会执行到这里</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 6. 归还连接</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>            states.set(i, <span class="hljs-number">0</span>);<br>            log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>            semaphore.release();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>原理：state记录数量，cas操作。减完小于零时进入队列 <code>doAcquireSharedInterruptibly</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放，检查唤醒后面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>    doReleaseShared();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">         * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">         * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">         * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">         * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">         * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">         * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">         * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">         * fails, if so rechecking.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>用来进行线程同步协作，等待所有线程完成倒计时。<br>其中构造参数用来初始化等待计数值<code>new CountDownLatch(3)</code>，<code>await()</code> 用来等待计数归零，<code>countDown()</code> 用来让计数减一</p><p>原理可以看源码，非常短countDown：state–   await：state不等于零就加入队列</p><p>可以用来实现等待线程完成，为什么不用join？线程池！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            latch.await();<br>            log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p> 应用：</p><ul><li>等待线程完成，如用户加载</li><li>等待远程调用完成</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>人满发车，可重复使用，state变成0后，会修改为init</p><p>await： state–  不为零就加入队列；为零就唤醒所有人，并重置state</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>); <br><br>t1: cb.await(); <span class="hljs-comment">// 当个数不足时，等</span><br>t2: cb.await(); <span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span><br><br><span class="hljs-comment">// 发车后执行的操作</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, ()-&gt;&#123;<br>    <span class="hljs-string">&quot;发车了&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>注意线程池数量要和CyclicBarrier一样，否则可能出现同时两次都是task1的await触发</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章是算法与数据结构学习的大纲，涵盖了从基础算法到高级算法的多个领域。主要内容包括基础算法（排序、二分、高精度计算、前缀和、双指针等）、数据结构（链表、栈、队列、树、Trie树、并查集、堆等）、图论算法（深度优先搜索、广度优先搜索、最短路、最小生成树等）、数学算法（质数筛选、约数、快速幂、逆元、组合数学等）、动态规划（背包问题、线性动态规划、状态动态规划、记忆化搜索）以及贪心算法。文章还列出了LeetCode的Hot 100题单和按类别分类的刷题建议，包括找规律题、基础算法题、数据结构应用题、搜索算法题和动态规划题等。此外，还提到了一些高级算法和数据结构的实现，如马拉车算法、非递归快速排序、非递归中序遍历等。整体来看，这是一份较为全面的算法与数据结构学习路线图，适合系统性学习和刷题准备。</p></blockquote><h2 id="0-特殊"><a href="#0-特殊" class="headerlink" title="0.特殊"></a>0.特殊</h2><p>leetcode  10^7^</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">n&lt;=</span><span class="hljs-number">12</span><span class="language-xml">      n!</span><br><span class="language-xml"></span><br><span class="language-xml">n&lt;=</span><span class="hljs-number">30</span><span class="language-xml">      </span><span class="hljs-number">2</span><span class="hljs-keyword">^n</span><span class="language-xml">           dfs+剪枝</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">100</span><span class="language-xml">~</span><span class="hljs-number">300</span><span class="language-xml">  n</span><span class="hljs-keyword">^3</span><span class="language-xml">            floyd</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^3</span><span class="language-xml">        n</span><span class="hljs-keyword">^2</span><span class="language-xml">            dp dij 二分  </span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^4</span><span class="language-xml">        n*根号n      块状链表</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span><span class="language-xml">~</span><span class="hljs-number">6</span><span class="language-xml">    nlogn         排序 线段树 树状数组 set/map heap dij+heap spfa 二分 求凸包 求半平面交</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^6</span><span class="language-xml">         n               hash 双指针  kmp ac自动机  </span><br><span class="language-xml">小常nlogn   sort 树状数组 heap+dij spfa</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^7</span><span class="language-xml">         n                hash 双指针  kmp ac自动机  线性筛质素</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^9</span><span class="language-xml">         根号n         判断质素</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^18</span><span class="language-xml">        logn          欧几里得  快速幂</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span> map</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> memset(h,-1,sizeof h); memset(dis,0x3f,sizeof dis);</span><br><span class="hljs-comment">// 小于x的第一个元素</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>(), x)-alls.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">// 优先队列</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; q;  <span class="hljs-comment">//大根堆 priority_queue&lt;int&gt; q; </span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt;q;  <span class="hljs-comment">//小根堆</span><br><span class="hljs-comment">// 自定义比较函数：STL构造时放入 https://www.cnblogs.com/lengbingshy/p/3491192.html</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">mycmp</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span>  <span class="hljs-keyword">return</span> l1-&gt;val&gt;l2-&gt;val</span>;<br>    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,function&lt;<span class="hljs-type">bool</span>(ListNode*, ListNode*)&gt;&gt; <span class="hljs-built_in">pq</span>(mycmp);<br><span class="hljs-comment">// 或者</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">comp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a, ListNode* b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; q;<br><br><span class="hljs-comment">// 保留小数</span><br><span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)<br><span class="hljs-comment">//排序 去重  algorithm</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// vector</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(b)</span> vector&lt;<span class="hljs-type">int</span>&gt; a </span>= &#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>&#125;初始化<br>    <br>a.<span class="hljs-built_in">swap</span>(b)交换<br>add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;)  <span class="hljs-comment">//vector中 pair插入:</span><br>        <br><span class="hljs-comment">// 优先队列 栈  top()   pop() push()</span><br><span class="hljs-comment">// 队列        front() pop() push()</span><br>        <br><span class="hljs-comment">//set map multiset multimap 平衡二叉树（红黑树） 动态维护有序序列 增删改查:O(logN)</span><br><span class="hljs-built_in">size</span>() <span class="hljs-built_in">empty</span>() <span class="hljs-built_in">clear</span>() <span class="hljs-built_in">begin</span>() <span class="hljs-built_in">end</span>()<br>set 无重复有序 multiset 有重复<br>    <span class="hljs-built_in">insert</span>()<br>    <span class="hljs-built_in">find</span>()<br>    <span class="hljs-built_in">count</span>() <span class="hljs-comment">// 0 1</span><br>    <span class="hljs-built_in">erase</span>(x)删除所有x  k+<span class="hljs-function">logn</span><br><span class="hljs-function">    <span class="hljs-title">erase</span><span class="hljs-params">(迭代器)</span>删除当前</span><br><span class="hljs-function">    <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span> 删除大于等于x最小的  </span><br><span class="hljs-function">    <span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span> 删除大于x中最小的</span><br><span class="hljs-function"></span><br><span class="hljs-function">map multimap</span><br><span class="hljs-function">    <span class="hljs-title">insert</span><span class="hljs-params">(&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;)</span> <span class="hljs-title">erase</span><span class="hljs-params">()</span> 参数pair</span><br><span class="hljs-function">    添加M[&quot;str&quot;]</span>=<span class="hljs-number">1</span> ,如果没有该key，默认值为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">auto</span>遍历时first,second取数，和pair遍历一样<br>    multimap可以用map&lt;x,vector&lt;y&gt; &gt;代替<br><br>unordered_set unordered_map unoerder_multiset unoerder_multimap 哈希表<br>    增删改查<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 不支持 lower_bound upper_bound<br><br><span class="hljs-comment">//二分返回第一个大于等于x的数</span><br><span class="hljs-built_in">lower_bound</span>(a,a+n,x)-a;<br><span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),x)-v.<span class="hljs-built_in">begin</span>();  <br><br><span class="hljs-comment">// 随机数</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>cout &lt;&lt; <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b;&#125;<br><span class="hljs-built_in">sort</span>(a,a+n,cmp);<br><span class="hljs-comment">// greater比较</span><br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><h3 id="1-0排序"><a href="#1-0排序" class="headerlink" title="1.0排序"></a>1.0排序</h3><blockquote><p>快速排序</p></blockquote><p>​选取中点为划分，左边&lt;&#x3D;，右边&gt;&#x3D;。再分别排序两边  空间O(logn)   不稳定 <a href="https://www.acwing.com/activity/content/code/content/487415/">边界选择</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span> ,j=r<span class="hljs-number">+1</span> mid=a[l + r &gt;&gt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>    i++;<span class="hljs-keyword">while</span>(a[i]&lt;mid) i ++;<br>    j--;<span class="hljs-keyword">while</span>(a[j]&gt;mid) j --;<br>    <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(a[i], a[j]);<br>&#125;<br><span class="hljs-built_in">quickSort</span>(l, j);        <span class="hljs-comment">// j会停留在&lt;=mid的位置，且j右边一定满足&gt;=mid</span><br><span class="hljs-built_in">quickSort</span>(j<span class="hljs-number">+1</span>, r);<br><br><span class="hljs-comment">// 如果以i-1  i分解 mid要加一  否则死循环  [1, 2]</span><br><span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure><p>​<strong>partition</strong>:  l的左边小于key，r的右边大于key。[l:i)的数等于key</p><p>l为下一个放小于key的地方，r为下一个放大于key的地方</p><p>最后0<del>l-1小于key ， l</del>r等于key ， r+1到n-1大于key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>,i=l<br><span class="hljs-keyword">while</span>(i&lt;=r)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]&lt;key)&#123;<br>    <span class="hljs-built_in">swap</span>(nums[i],nums[l]);<br>    i++,l++;<span class="hljs-comment">//换过来的数一定等于key，i直接增加</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&gt;key)&#123;<br>    <span class="hljs-built_in">swap</span>(nums[i],nums[r]);<br>    r--;   <span class="hljs-comment">// 换过来的数不知道大小，i不增加</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    i++;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>归并排序</p></blockquote><p>​先排好中点左边，再排中点右边，然后merge两边,  空间O(n)  稳定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l+r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(l,mid);<br><span class="hljs-built_in">merge_sort</span>(mid<span class="hljs-number">+1</span>,r);<br><span class="hljs-comment">// merge  merge时tmp数组只申请需要的大小，或者全局申请</span><br></code></pre></td></tr></table></figure><blockquote><p>其他</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">冒泡 每次交换出一个最大<br>插入 <br>选择  不稳定<br><br>堆排序 不稳定<br><br>计数排序<br>桶排序  ：桶内排序，桶外计数排序<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">排序算法平均时间复杂度最坏时间复杂度空间复杂度稳定性<br><span class="hljs-variable">QuickSort</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>不稳定<br><span class="hljs-built_in">Merge</span> <span class="hljs-built_in">Sort</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>稳定<br><span class="hljs-variable">Heap</span> <span class="hljs-built_in">Sort</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>不稳定<br><span class="hljs-variable">Timsort</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>稳定  归并<span class="hljs-operator">+</span>插入<br><span class="hljs-variable">Dual</span><span class="hljs-operator">-</span><span class="hljs-variable">Pivot</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>不稳定  <span class="hljs-variable">java</span> <span class="hljs-variable">int</span> <span class="hljs-variable">char</span> <span class="hljs-variable">long</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">Insertion</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>稳定   每次向有序中插入一个元素 常数小！<br><span class="hljs-variable">Bubble</span> <span class="hljs-built_in">Sort</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>稳定   冒泡 每次交换出一个最大<br><span class="hljs-built_in">Selection</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>不稳定  每次在无序中，选出一个最小的<br><span class="hljs-variable">Counting</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>稳定  <span class="hljs-number">0</span><span class="hljs-operator">~</span><span class="hljs-variable">k</span>个桶 统计数量，适用于小范围整数。<br><span class="hljs-variable">Radix</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">d</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">d</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>稳定 按位排序，适用于整数和固定长度字符串。<br><span class="hljs-variable">Bucket</span> <span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>稳定数据分桶<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">0.1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-operator">,</span> <span class="hljs-number">0.2</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span>后排序，再合并所有桶。<br></code></pre></td></tr></table></figure><h4 id="TimSort-的过程："><a href="#TimSort-的过程：" class="headerlink" title="TimSort 的过程："></a><strong>TimSort 的过程：</strong></h4><ol><li><strong>分块</strong>: TimSort 首先将数组分成若干个小的子数组，这些子数组称为 <strong>Run</strong>。每个 Run 的大小通常在 32 到 64 之间，具体取决于数组的大小和实现。</li><li><strong>对每个 Run 进行排序</strong>: 对每个 Run 使用插入排序进行排序，因为插入排序在小规模数据上效率高。</li><li><strong>合并 Run</strong>: 将这些有序的 Run 通过归并排序的方式合并在一起，形成一个更大的有序数组。TimSort 会根据实际情况决定何时合并哪些 Run，以保持整体效率。</li></ol><h3 id="1-1二分"><a href="#1-1二分" class="headerlink" title="1.1二分"></a>1.1二分</h3><p>分界点右边都满足一种性质，左边都不满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">l=<span class="hljs-number">0</span> ,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//寻找满足条件的最左边的数        大于等于aim      不会用到a[r]的值     </span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(a[mid]&gt;=aim)&#123;<br>        r=mid;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//寻找满足条件的最右边的数        小于等于aim      不会用到a[l]的值</span><br> <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    mid=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-comment">//不加一 会死循环</span><br>    <span class="hljs-keyword">if</span>(a[mid]&lt;=aim)&#123;<br>        l=mid;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//浮点数二分，结束条件要多两位</span><br><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">0.00000001</span>)&#123;        <span class="hljs-comment">//多两位</span><br>    <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(mid*mid*mid&lt;=n) l=mid;<br>    <span class="hljs-keyword">else</span> r=mid;<br>&#125;<br></code></pre></td></tr></table></figure><p>0.旋转数组找旋转点</p><p>1.机器人跳跃 1e5 n a[i]，从起点跳到终点 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">每次跳跃res= res*<span class="hljs-number">2</span>-a[i];   res始终要大于零，求最小的起始res。<br>检测一个数要<span class="hljs-number">1e5</span>，遍历[<span class="hljs-number">1</span>,<span class="hljs-number">1e5</span>]个数超时，二分遍历即可解决<br></code></pre></td></tr></table></figure><p>2.分巧克力</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">对于每一种大小的切法，1e5时间能求出是否满足数量<br>二分求出这个大小即可。<br></code></pre></td></tr></table></figure><p>3.炸弹问题：矩阵和</p><p><strong>4.四平方和 四个数的平方和为x，求出序列最小的  x&lt; 5*1e6</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">求出三个数，就能得出最后一个，但是时间上最多求出两个<br>枚举前面两个数c d，并存下来 按照sum排序 如果相同就按照c排序<br>（或者把和扔到hash中，只放入第一次遇到的）<br>枚举<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span>，查看<span class="hljs-attribute">x</span>-<span class="hljs-selector-tag">a</span>^<span class="hljs-number">2</span>-<span class="hljs-selector-tag">b</span>^<span class="hljs-number">2</span>是否在存下的数中（二分，hash）<br></code></pre></td></tr></table></figure><p>5.k倍区间  一个数组中子串为给定数k的倍数，求共有多少个这样的区间  1e5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">两个循环加前缀和 但依旧会超时<br><br>s[r]-s[l]  % k == <span class="hljs-number">0</span> 相当于  s[r]与s[l]余数相同，所以每次是在找余数为固定值的个数<br>cnt[i] 代表当前余数为i的个数（包括s[r]）<br>先计算出s[r]全取的情况下，余数为零的个数，再取算s[l]与s[r]同余的个数<br>遍历右端点<br>    <span class="hljs-keyword">if</span>(s[r]==<span class="hljs-number">0</span>)res ++;<br>cnt[s[r]]++;<br>    res += (cnt[s[r]]<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h3 id="1-2高精度"><a href="#1-2高精度" class="headerlink" title="1.2高精度"></a>1.2高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//两个大整数，求和          10^6位</span><br><span class="hljs-comment">//相减                    10^6位</span><br><span class="hljs-comment">//一个大整数乘一个小整数    &lt;10^6位 * 1000000</span><br><span class="hljs-comment">//          除</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//大整数的每一位存到vector中，个位放下标0,输入用字符串,记得-&#x27;0&#x27;</span><br><span class="hljs-comment">//t = a[i] + b[i] + t</span><br></code></pre></td></tr></table></figure><ul><li>除了加法都要去除前面的零    while(C.size()&gt;1&amp;&amp;C.back()&#x3D;&#x3D;0)C.pop_back();</li><li>乘法每一位直接拿小的数乘</li><li>除法从高位开始除，最后反转 reverse(C.begin(),C.end());</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 乘法直接一位一位乘, 最后再一次性进位</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a1.size();i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a2.size();j++)&#123;<br>    res[i+j] += a1.get(i) * a2.get(j);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length-<span class="hljs-number">1</span>;i++)&#123;<br>    res[i+<span class="hljs-number">1</span>] += res[i]/<span class="hljs-number">10</span>;<br>    res[i] %= <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>java中，<code>string</code>到<code>List&lt;Integer&gt;</code>需要-‘0’，而sb.append 可以直接append数字</p><h3 id="1-3前缀和-差分"><a href="#1-3前缀和-差分" class="headerlink" title="1.3前缀和  差分"></a>1.3前缀和  差分</h3><p>&#x3D;&#x3D;前缀和&#x3D;&#x3D;：前缀和一个值代表着一个区间的性质</p><ol><li>普通前缀和  <strong>询问区间</strong></li><li>矩阵和        求出每个到0，0点的矩阵的和   <strong>询问矩阵</strong></li><li>前缀积 <a href="https://leetcode.cn/problems/range-product-queries-of-powers/solutions/2453873/yi-ti-duo-jie-bu-chong-ling-shen-bzhan-s-20vb/">2438. 二的幂数组中查询范围内的乘积 - 力扣（LeetCode）</a>  需要结合逆元</li></ol><p>&#x3D;&#x3D;差分&#x3D;&#x3D;：差分数组一个值的改变影响一个区间</p><ol><li>差分数组   <strong>多次区间操作后，询问结果</strong></li><li>差分矩阵b求和等于a，不用考虑b如何出来的，只需要考虑b如何改变a的<ul><li>当b增加时，改变的时全部右下角的数</li></ul></li></ol><h3 id="1-4双指针"><a href="#1-4双指针" class="headerlink" title="1.4双指针"></a>1.4双指针</h3><p>双指针<br>快排 归并排序</p><p>将i j 两种枚举n^2的情况，优化为O(n);<br>找到i j 之间存在的单调性</p><p>将一个英文句子的每个单词输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>连续最长不重复子串</p></li><li><p>两个升序数组，求和为x的两个数组的下标</p></li><li><p>判断是否是字串</p></li></ul><h3 id="1-5位运算"><a href="#1-5位运算" class="headerlink" title="1.5位运算"></a>1.5位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) x&amp;-x</span><br><span class="hljs-comment">//lowbit:返回最后一位1以及后面的零 110100 -&gt; 100</span><br><br>n&gt;&gt;k&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//二进制中第k位是几</span><br></code></pre></td></tr></table></figure><ul><li>求一个数中二进制1的个数，两种方法都可以</li></ul><h3 id="1-6离散化"><a href="#1-6离散化" class="headerlink" title="1.6离散化"></a>1.6离散化</h3><p>原来的下标太大了，将大数，转为排序数组的下标</p><ul><li>操作无限长坐标上的元素后，询问区间和</li></ul><p>将大的数保存到vector中后，排序，去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>将大值和下标映射用<strong>二分查找</strong>或<strong>unordered_map</strong>映射</p><p>询问上的点也要先加入到alls中</p><p>如果只想将大数映射到小数，也可也不去重，同一个数每次查找时会获取出同一个idx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sorted 所有的大数 并且已经排序 可能重复</span><br>Arrays.sort(sorted);<br><br>idx = Arrays.binarySearch(sorted, nums[i]);   <span class="hljs-comment">//或者用map</span><br></code></pre></td></tr></table></figure><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>int h&#x3D;-1, e[], ne[], idx</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>s[],  t&#x3D;-1</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调增：栈内元素单调递增，遍历到i时，导致某元素出栈，则i是右边第一个比该元素小的，新栈顶为左边第一个比该元素小的。</p><ol start="84"><li>最大矩阵面积</li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>q[], t&#x3D;-1, h&#x3D;0;     t进h出   q[++t]&#x3D;x;  h++;</p><ul><li>单调队列：把最小的始终保存在队头，实现滑动窗口求最小</li></ul><h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">297</span> 树的序列化与反序列化<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">middle_order</span><span class="hljs-params">(Node Node)</span>:</span><br><span class="hljs-function">if(Node =</span>= <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);前</span><br>    <span class="hljs-built_in">middle_order</span>(Node-&gt;left);<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);中</span><br>    <span class="hljs-built_in">middle_order</span>(Node-&gt;right);<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);后</span><br><br>非递归实现：颜色标记法<br><span class="hljs-function">def <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[<span class="hljs-type">int</span>]:</span><br><span class="hljs-function">    WHITE, GRAY =</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    res = []<br>    stack = [(WHITE, root)]<br>    <span class="hljs-keyword">while</span> stack:<br>        color, node = stack.<span class="hljs-built_in">pop</span>()<br>        <span class="hljs-keyword">if</span> node is None: <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> color == WHITE:<br>            stack.<span class="hljs-built_in">append</span>((WHITE, node.right)) # 先输出的后入栈<br>            stack.<span class="hljs-built_in">append</span>((GRAY, node))<br>            stack.<span class="hljs-built_in">append</span>((WHITE, node.left))<br>        <span class="hljs-keyword">else</span>:<br>            res.<span class="hljs-built_in">append</span>(node.val)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>树：边的个数加+ 1 &#x3D; ∑节点*度 + 1 &#x3D; 节点个数</p><p><a href="https://www.bilibili.com/video/BV1Tb4y197Fe">https://www.bilibili.com/video/BV1Tb4y197Fe</a></p><p>Binary Search Tree: <strong>BST</strong>   -&gt;退化-&gt;   <strong>AVL</strong> （左右高度差不超过1）&gt;频繁增删&gt;  <strong>RBT</strong></p><p>如果失去平衡, 找到第一个失去平衡的点左右旋转使得平衡 LL，RR（直接旋转）  LR（先左旋）</p><p> RBT：根是黑色（空结点也是黑色）、红节点不连续、黑节点到达空指针进过的黑点个数相同</p><p><strong>B树</strong>（数据库）：一个节最多m-1个值（连续，访问磁盘次数就会更少），m个孩子节点。m为树的阶</p><p>​非叶子节点最少有(m+1)&#x2F;2子树，最多m</p><p>​叶子节点为空节点，都在同一层</p><p>​<strong>查找</strong>：和BST类似       范围查询：中序遍历</p><p>​<strong>插入</strong>：当节点个数多于(m+1)&#x2F;2时，进行分裂</p><p>​<strong>删除</strong>：终端节点：大于(m+1)&#x2F;2-1个节点：直接删</p><p>​等于(m+1)&#x2F;2-1，去兄弟节点借，借不到就合并：上一层挪下来一个</p><p>​非终端：和相邻关键字（前驱、后驱）互换，就变成了终端节点</p><p><strong>B+树：</strong></p><p>​n个节点n个子树</p><p>​非叶子节点只能索引，叶子节点才指向记录。</p><p>​叶子节点被串成了一个单链表，可以线性访问，头指针被保存。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>p 在 s中所有的起始位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">ne:p当前匹配失败后，j跳转的位置（j<span class="hljs-number">-1</span>的最大匹配长度） ababc ne[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>  ne[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">get</span>()&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">-1</span>;<br>    ne[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||p[i]==p[j])&#123;<br>            i++,j++;<br>            ne[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;m)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==p[j])&#123;<br>            i++,j++;<br>            <span class="hljs-keyword">if</span>(j==n)&#123;<br>                cout&lt;&lt;i-n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                j=ne[j];  <span class="hljs-comment">// 这里不可以从头开始，不然会少很多  如 aba  ababa</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cin&gt;&gt;n&gt;&gt;s&gt;&gt;m&gt;&gt;p;<br><span class="hljs-built_in">get</span>();<br><span class="hljs-built_in">kmp</span>();<br></code></pre></td></tr></table></figure><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>字符串出现次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idx;   <span class="hljs-comment">//son 保存下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        <span class="hljs-type">int</span> u=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u])son[p][u]=++idx;<br>        p=son[p][u];<br>    &#125;<br>    cnt[p]++;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回根节点编号 路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x!=p[x])&#123;<br>        p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(fx!=fy)&#123;     <span class="hljs-comment">//在不同的情况下才相加</span><br>        p[fx]=fy;<br>        cnt[fy]+=cnt[fx];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用数列保存，从1开始存 儿子（2<em>u，2</em>u+1）</p><p>down: 左右儿子已经是堆，加上直接再构成堆    n&#x2F;2开始down</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=u;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span>&lt;=si&amp;&amp;h[u*<span class="hljs-number">2</span>]&lt;h[t])t=u*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;=si&amp;&amp;h[u*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&lt;h[t])t=u*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">if</span>(u!=t)&#123;<br>        <span class="hljs-built_in">swap</span>(h[u],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span> &amp;&amp; heap[i]&lt;heap[i/<span class="hljs-number">2</span>])&#123;<br>        <span class="hljs-built_in">swap</span>(heap[i],heap[i/<span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">up</span>(i/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 插入到最后一个元素，然后up</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>    now++;<br>    heap[now] = p;<br>    <span class="hljs-built_in">up</span>(now);<br>&#125;<br><span class="hljs-comment">// 最后一个元素放到第一个位置，然后down</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    heap[<span class="hljs-number">1</span>]=heap[now];<br>    now--;<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>无扩容java堆，0开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriorityQueue</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> Object[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyPriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span>&#123;<br>        <span class="hljs-built_in">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity+<span class="hljs-number">1</span>];<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.comparator = comparator;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>&#123;<br>        queue[size] = e;<br>        size ++;<br>        up(size-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span>: (E)queue[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (E)queue[<span class="hljs-number">0</span>];<br>        queue[<span class="hljs-number">0</span>] = queue[size-<span class="hljs-number">1</span>];<br>        size--;<br>        down(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;size &amp;&amp; comparator.compare((E)queue[u], (E)queue[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)&#123;<br>            u = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>&lt;size &amp;&amp; comparator.compare((E)queue[u], (E)queue[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">0</span>)&#123;<br>            u = i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u != i)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue[i];<br>            queue[i] = queue[u];<br>            queue[u] = t;<br>            down(u);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (i-<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>(comparator.compare((E)queue[i], (E)queue[p]) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue[i];<br>            queue[i] = queue[p];<br>            queue[p] = t;<br>            up(p);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>方法1：线性探测表，开两倍地址空间 null&#x3D;0x3f3f3f3f</p><p>&#x2F;&#x2F;返回x对应下标,没有x就返回应该放的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(a[k]!=null&amp;&amp;a[k]!=x)&#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k==N)k=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：链地址法，也是存图的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> mod=<span class="hljs-number">100003</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N; <span class="hljs-comment">//保证都映射到正数上</span><br>    e[idx]=x;<br>    ne[idx]=h[k];<br>    h[k]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[k];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        <span class="hljs-keyword">if</span>(e[i]==x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><p>将一段<strong>字符串</strong>用一个<strong>数字</strong>表示，字符串低位为数字高位  左高右低</p><p>hash值用ULL保存typedef unsigned long long ULL;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> P=<span class="hljs-number">131</span>;<span class="hljs-comment">//131进制，字符串中下标小的为高位</span><br>ULL p[N];  <span class="hljs-comment">// 进制的i次方</span><br>ULL h[N];  <span class="hljs-comment">// hash值   下标1~i</span><br></code></pre></td></tr></table></figure><p>存入时,计算字符串hash</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    h[i]=h[i<span class="hljs-number">-1</span>]*P+s[i];<br>    p[i]=p[i<span class="hljs-number">-1</span>]*P;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算式，L到R之间的字符串的hash值为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ULL t=h[R]-h[L<span class="hljs-number">-1</span>]*p[R-L<span class="hljs-number">+1</span>];<br></code></pre></td></tr></table></figure><p>java：<a href="https://leetcode.cn/problems/shortest-palindrome/">214. 最短回文串</a> 前添加字符使得字符串回文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">131</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mul</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, suffix = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-comment">// abcde</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br>    prefix = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) prefix * base + c)%mod); <span class="hljs-comment">//a ab abc  正常字符串写法</span><br>    suffix = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) mul * c + suffix)%); <span class="hljs-comment">//a ba cba</span><br>    mul = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) mul * base) % mod);<br><br>    <span class="hljs-keyword">if</span>(prefix == suffix)&#123;<br>        idx = i;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span>(idx==n-<span class="hljs-number">1</span> || n==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.substring(idx+<span class="hljs-number">1</span>)).reverse().toString() + s;<br></code></pre></td></tr></table></figure><h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;$#&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            t.append(s.charAt(i));<br>            t.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        n = t.length();<br>        t.append(<span class="hljs-string">&#x27;!&#x27;</span>);<br><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">iMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rMax = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-comment">// 初始化 f[i]</span><br>            f[i] = i &lt;= rMax ? Math.min(rMax - i + <span class="hljs-number">1</span>, f[<span class="hljs-number">2</span> * iMax - i]) : <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 中心拓展</span><br>            <span class="hljs-keyword">while</span> (t.charAt(i + f[i]) == t.charAt(i - f[i])) &#123;<br>                ++f[i];<br>            &#125;<br>            <span class="hljs-comment">// 动态维护 iMax 和 rMax</span><br>            <span class="hljs-keyword">if</span> (i + f[i] - <span class="hljs-number">1</span> &gt; rMax) &#123;<br>                iMax = i;<br>                rMax = i + f[i] - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 回文串数量</span><br>            ans += f[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 回文串长度</span><br>            ans  = Math.max(ans, f[i] -<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol start="315"><li><p>逆序对数量</p></li><li><p><strong>单点更新</strong> <code>update(x, delta)</code>： 把序列 x 位置的数加上一个值 delta；  logn</p></li><li><p><strong>前缀和查询</strong> <code>query(x)</code>：查询序列 <code>[1,...x]</code> 区间的区间和，即位置 x 的前缀和。logn</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>建树规则：<strong>c[i] 管理着 从i开始的前lowbit(i)个数的和</strong></p><ul><li><p>求前 10010010的和 只需要拿出c[10010010] (最后两个数) + [sum(10010000) &#x3D; c[10010000] + c[10000000] ]</p></li><li><p>当一个数修改后 1010，会影响管理者他的c：c[1010]  c[1100] c[10000] c[100000] …</p></li><li><p>单点修改+区间查询      （单纯前缀和不能在这两种操作混合时发挥作用）</p></li><li><p>区间修改+单点查询      维护差分数组   （单纯差分数组在这两种操作混合时发挥作用）</p></li></ul><h2 id="3-图"><a href="#3-图" class="headerlink" title="3.图"></a>3.图</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],ne[N],e[N],w[N];<br><span class="hljs-type">int</span> idx;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    w[idx]=c;<br>    e[idx]=b;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[a];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>    <span class="hljs-type">int</span> j=e[i];<br></code></pre></td></tr></table></figure><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs:"></a>dfs:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 需要标记数组st[N],  遍历节点的每个相邻的边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记一下，记录为已经被搜索过了，下面进行搜索过程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            <span class="hljs-built_in">dfs</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br>实践：求树的重心 acwing846<br></code></pre></td></tr></table></figure><h3 id="bfs："><a href="#bfs：" class="headerlink" title="bfs："></a>bfs：</h3><p>st[] 和 queue</p><p>求距离，先进距离短 先出</p><p> d[]保存距离，同时判断是否访问过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>    <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>)&#123;<br>            d[j]=d[x]<span class="hljs-number">+1</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs inform7">无负边 （从顶点角度出发每次取出最近顶点）<br>                                                  都需要dis<span class="hljs-comment">[N]</span><br>   dij稠密          n*n      二维数组           st<span class="hljs-comment">[N]</span> //判断是否已经求出来了<br>   dij稀疏  堆优化      m*logn     邻接表              优先队列存&lt;PII&gt;  st<span class="hljs-comment">[N]</span><br><br><br>有负边  (从边的角度出发)<br><br>   有负环 bellmanford      n*m               struct存边       backup<span class="hljs-comment">[N]</span>//防止串联更新<br>   无负环 spfa             m -&gt; n*m          邻接表            q  st<span class="hljs-comment">[N]</span>//是否在队列中<br>      判负环：不用设置dis，所有点都加入队列                        +cnt<span class="hljs-comment">[N]</span>  连了多少条边<br><br>floyd 动态规划             n^3                 二维数组<br><br><br>二维数组处理重边g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>=min(g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>,c); dij初始化可以全为0x3f3f3f3f但floyd不行。<br>邻接表、struct存边不需要额外处理，松弛时自动选择小的边<br><br>存在负边会导致正无穷变小（bellmanford 和 floyd）所以判断改成：dis<span class="hljs-comment">[n]</span>&gt;0x3f3f3f3f /2<br></code></pre></td></tr></table></figure><h4 id="dij"><a href="#dij" class="headerlink" title="dij"></a>dij</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">priority_queue</span>&lt;PII,<span class="hljs-built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt; &gt; p;<br>p.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-keyword">while</span>(p.size())&#123;<br>    PII tmp = p.top();<br>    p.pop();<br>    <span class="hljs-keyword">if</span>(st[tmp.second])<span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-type">int</span> x = tmp.second;<br>    st[x] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(dis[j]&gt;dis[x]+w[i])&#123;  <span class="hljs-comment">// 这里及时更新距离，并通过距离剪枝</span><br>            dis[j] = dis[x]+w[i];<br>            p.push(&#123;dis[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bellmanford"><a href="#bellmanford" class="headerlink" title="bellmanford"></a>bellmanford</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最多k条边,对所有点的出边进行更新</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    <span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis); <span class="hljs-comment">//防止串联更新</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-type">int</span> a=edges[j].a,b=edges[j].b,c=edges[j].c;<br>        dis[b]=<span class="hljs-built_in">min</span>(dis[b],backup[a]+c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果k&#x3D;n时还更新了，就是存在包含点1的负环</p><h4 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h4><p>当一个点距离变小后，所有以该点的出边才可能更新。st数组防止重复添加(不用也能过)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>st[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>    <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;<br>            dis[j]=dis[t]+w[i];<br>            <span class="hljs-keyword">if</span>(st[j]==<span class="hljs-number">0</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                st[j]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h4><p>最短路包含边数大于n-1</p><p>设置一个虚拟源节点，到所有阶段距离都为0，原图有负环等价于现在的图有负环，</p><p>第一次spfa等价于所以开始时所有点都加入</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">普里姆： 加最近点，有点像dij    n</span><span class="hljs-keyword">^2</span><span class="language-xml"></span><br><span class="language-xml">克鲁斯卡尔： 加最小的边     E</span><span class="hljs-keyword">^2</span><span class="language-xml">     并查集</span><br></code></pre></td></tr></table></figure><h2 id="4-数学"><a href="#4-数学" class="headerlink" title="4.数学"></a>4.数学</h2><h3 id="筛质素"><a href="#筛质素" class="headerlink" title="筛质素"></a>筛质素</h3><p>诶氏筛法 O(nloglogn):小于等于 n 的质数的倒数和大约是 loglogn</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            primes[cnt++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//可以用质数就把所有的合数都筛掉；</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线性筛法 O(n)：每个数只被最小的质素筛 <a href="https://www.acwing.com/solution/content/2559/">https://www.acwing.com/solution/content/2559/</a></p><p>i&#x3D;15  会筛掉 15* 2 15* 3 ，但15*5不会被15筛，而是被25 * 3筛, 所以primes[j]只到 i 的最小因子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<br>        <span class="hljs-comment">//假设primes[0]为n最小的质因子,i为最大的因数，</span><br>        <span class="hljs-comment">//易知若primes[i]中i&gt;0,则会进入循环后产生多余的标记。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)<br>        &#123;<br>            <span class="hljs-comment">//标记;primes[j]一定是primes[j]*i的最小质因子</span><br>            st[primes[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//表明primes[j]一定是i的最小质因子,没有必要再遍历,primes要小于等于i的最小质因子</span><br>            <span class="hljs-comment">//这样能保证每个数遍历一遍,而没有重复</span><br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p>n 个正整数 ai，请你输出这些数的乘积的约数个数</p><p>求出所有质因子p以及个数x：N &#x3D; (p1^x1^)(p2^x2^)(p3^x3^)…(pk^xk^)   </p><p>约数个数： (x1+1)(x2+1)(x3+1)…(xk+1)</p><p>约数和&#x3D;(1+p1^1^+p1^2^+…+p1^x1^)×(1+p2^1^+p2^2^+…+p2^x2^)…×(1+pk^1^+pk^2^+…+pk^xk^)   每一个括号里取出一个数相乘就得到一个约数，最后求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><span class="hljs-keyword">while</span> (n -- )<br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            x /= i;<br>            primes[i] ++ ;<br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>&#125;<br><br>LL res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes)<br>&#123;<br>    LL a = p.first, b = p.second;<br>    LL t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b -- ) t = (t * a + <span class="hljs-number">1</span>) % mod;<br>    res = res * t % mod;<br>&#125;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>秦九韶算法: 计算多项式朴素方法需要2n乘法（xn-1 * x * a）n次加法，秦九韶只需要n次乘n次加<br>$$<br>f(x) &#x3D; a_nx^n + a_{n-1}x^{n-1} + \cdots + a_1x + a_0&#x3D; (((a_nx + a_{n-1})x + \cdots )x + a_1)x + a_0<br>$$</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">求 m^k mod p，时间复杂度 <span class="hljs-built_in">O</span>(logk)。<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>将递推式写成矩阵形式：斐波那契数列 O（n）-&gt; O（m^3*logn）</p><p><a href="https://vjudge.net/contest/350535">矩阵快速幂 - Virtual Judge (vjudge.net)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">6</span>;                  <span class="hljs-comment">//题目中可能出现的最大大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">6</span>;                  <span class="hljs-comment">//实际常数矩阵的大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">123456789</span>;        <span class="hljs-comment">// const int 和int 作为模数还运算速度不一样</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> t[N][N];          <span class="hljs-comment">//常数矩阵</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> tmp[N][N];         <span class="hljs-comment">//相乘时的temp  辅助</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> b[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>                tmp[i][j]=(tmp[i][j]+a[i][k]*b[k][j])%mod;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>    a[i][j]=tmp[i][j];<br><br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> result[N][N];                     <span class="hljs-comment">//保存求幂后的值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(result,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> result);             <span class="hljs-comment">//N是矩阵大小</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) result[i][i]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">multi</span>(result,a,n);              <span class="hljs-comment">//result=result*a;复制直接在multi里面实现了；</span><br>        <span class="hljs-built_in">multi</span>(a,a,N);                       <span class="hljs-comment">//a=a*a</span><br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x&amp;&amp;x!=<span class="hljs-number">-1</span>)&#123;<br>        t[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=t[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=t[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        t[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pow</span>(t,x);<br>        cout&lt;&lt;result[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><ul><li>(ab)modp&#x3D;(amodp)∗(bmodp)modp</li><li>(a+b)modp&#x3D;((amodp)+(bmodp))modp</li><li>(a−b)modp&#x3D;((amodp)−(bmodp)+p)modp</li><li><strong>注意(a&#x2F;b)modp≠((amodp)&#x2F;(bmodp))modp 这也是为什么需要求乘法逆元</strong></li></ul><p>若整数 b，m互质，并且对于任意的整数 a，如果满足 b|a，则存在一个整数 x，使得 a&#x2F;b≡a×x(modm)，则称 x为 b的模 m 乘法逆元，记为 b−1(modm)。</p><p>b存在乘法逆元的充要条件是 b与模数 m互质：</p><ul><li><p>当模数 m为质数时，b^m−2^即为 b 的乘法逆元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = (LL)a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p)<br></code></pre></td></tr></table></figure></li><li><p>否者用扩展欧几里得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a, p, x, y);<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) cout &lt;&lt; ((LL)x + p) % p &lt;&lt; endl;<span class="hljs-comment">//保证x是正数</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">a / b ≡ a * x (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>两边同乘b可得 a ≡ a * b * x (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>即 <span class="hljs-number">1</span> ≡ b * x (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>同 b * x ≡ <span class="hljs-number">1</span> (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>由费马小定理可知，当<span class="hljs-built_in">n</span>为质数时 且b <span class="hljs-built_in">n</span> 互质<br>b ^ (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) ≡ <span class="hljs-number">1</span> (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>拆一个b出来可得 b * b ^ (<span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>) ≡ <span class="hljs-number">1</span> (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>故当<span class="hljs-built_in">n</span>为质数时，b的乘法逆元 x = b ^ (<span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>逆元可拆分：（a!)-1 &#x3D;（a-1! * a)-1 &#x3D; ( a-1! )-1 * ( a )-1</p><h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/35805_f4228ae4c7-%E7%BB%84%E5%90%88%E6%95%B0.png" alt="组合数.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>, p = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] fact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], infact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( k &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>( (k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> ) res = res * a % p;<br>            a =(<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) a * a % p);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Integer.valueOf(read.readLine());<br>        fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>            fact[i] =(<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>)fact[i - <span class="hljs-number">1</span>] * i % p);<br>            infact[i] = (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) infact[i - <span class="hljs-number">1</span>] * qmi(i, p - <span class="hljs-number">2</span>, p ) % p);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(t -- &gt; <span class="hljs-number">0</span>)&#123;<br>            String[] ss = read.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(ss[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(ss[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) fact[a] * infact[a - b] % p * infact[b] % p);<br>            System.out.println(res);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p><a href="https://www.acwing.com/solution/content/29702/">https://www.acwing.com/solution/content/29702/</a></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">n = <span class="hljs-number">10</span>, <span class="hljs-built_in">p1</span><span class="hljs-number">=2</span>,<span class="hljs-built_in">p2</span><span class="hljs-number">=3</span><br>求<span class="hljs-number">1</span>-<span class="hljs-number">10</span>中能满足能整除<span class="hljs-built_in">p1</span>或<span class="hljs-built_in">p2</span>的个数, 即<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">8</span>，<span class="hljs-number">9</span>，<span class="hljs-number">10</span>,共<span class="hljs-number">7</span>个<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240330222536954.png" alt="image-20240330222536954"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> p[N], n, m;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <span class="hljs-built_in">cin</span> &gt;&gt; p[i];<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;             <span class="hljs-comment">//选中集合对应质数的乘积</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;             <span class="hljs-comment">//选中的集合数量</span><br><br>        <span class="hljs-comment">//枚举当前状态的每一位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>            <span class="hljs-comment">//选中一个集合</span><br>            <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//乘积大于n, 则n/t = 0, 跳出这轮循环</span><br>                <span class="hljs-keyword">if</span>((LL)t * p[j] &gt; n)&#123;    <br>                    t = <span class="hljs-number">-1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                s++;                  <span class="hljs-comment">//有一个1，集合数量+1</span><br>                t *= p[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;  <br><br>        <span class="hljs-keyword">if</span>(s &amp; <span class="hljs-number">1</span>) res += n / t;              <span class="hljs-comment">//选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量</span><br>        <span class="hljs-keyword">else</span> res -= n / t;                      <span class="hljs-comment">//反之则为 -1</span><br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs subunit">n元1次方程组<br><br>初等行列变换：1.某一行乘非零的数   2.交换某2行   3.把某一行的k倍加到另外一行取<br><br>高斯消元：每一次消去每行第一个，把方程边成上三角，再逆推求xn xn<span class="hljs-string">-1</span>...<br><br>完美阶梯型(第一行n个数 第二行n<span class="hljs-string">-1</span>...最后一行1个) 唯一解             r(A)=r(A,b)=n<br>左边没有未知数，右边不为零                    无解                r(A)&lt;r(A,b)<br>方程没有n个                                无穷多组           r(A)=r(A,b)&lt;n<br><br>（矩阵的秩r：矩阵中所有行向量中极大线性代无关组的元素个数。有效方程数量, 阶梯矩阵非零行数）<br>https://www.zhihu.com/question/21605094<br><br>化阶梯型：<br>int r=0,c=0;<br>枚举每一列c 0~n<span class="hljs-string">-1</span><br>1.选出r~n<span class="hljs-string">-1</span>行中，第c列的数最大的那一行(为零就continue),移到第r行上去（最上面）<br>2.将该数a[r][c]化成1<br>3.将r<span class="hljs-string">+1</span>~n<span class="hljs-string">-1</span>行，如果第c列不是零，将第c列化为零<br>成功消除一列r++<br>r==n 有解  有解逆推 i=n<span class="hljs-string">-1</span> ~0，<br>j= i<span class="hljs-string">+1</span>~n<span class="hljs-string">-1</span> <br>a[i][n]-=a[i][j]*a[j][n];<br>r&lt;n <br>for i in r~n<span class="hljs-string">-1</span><br>如果存在b不为零，无解 否则无穷解<br></code></pre></td></tr></table></figure><h2 id="5-dp"><a href="#5-dp" class="headerlink" title="5.dp"></a>5.dp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>每一个状态为一个集合，分集合思想后，求转移方程是通过大的划分出小的(不重不漏)<br><span class="hljs-number">2.</span>代码实现时，是从小的推导出大的，一定要保证转移方程中小的项已经求出来了。自底向上逐步填充数组<br>因此有的循环顺序可以交换：背包、整数划分      有的一定不行：哈密顿<br><span class="hljs-number">3.</span>初始化，按题意给出有效的初始值<br>计数时有效：<span class="hljs-number">1</span>，无效为<span class="hljs-number">0</span><br>最值时有效：<span class="hljs-number">0</span>  负无穷或正无穷<br></code></pre></td></tr></table></figure><h3 id="5-1背包问题"><a href="#5-1背包问题" class="headerlink" title="5.1背包问题"></a>5.1背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">https:<span class="hljs-comment">//blog.csdn.net/yandaoqiusheng/article/details/84782655</span><br><span class="hljs-number">01</span>背包    每种只有一个             <br>完全背包 可以无限重复        <br>    <span class="hljs-number">1000</span> *<span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> 暴力tle，f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-v[i]] +w[i]) 用本层求出来的值优化<br>多重背包 限制单种数量              <br>    <span class="hljs-number">1000</span>* <span class="hljs-number">2000</span>* <span class="hljs-number">2000</span> 暴力tle，二进制优化（像快速幂），打包后<span class="hljs-number">1000</span>* <span class="hljs-number">2000</span>* <span class="hljs-number">12</span>转化为<span class="hljs-number">01</span>背包  <br>分组背包 每一组最多选一个       <br>    <span class="hljs-number">100</span>* <span class="hljs-number">100</span>* <span class="hljs-number">100</span>直接暴力<br>限制总数量                                <br>    额外一个sum[][]记录当前数量<br><br><span class="hljs-number">1.</span>一维数组存储，用上一层的值j就从大到小，用本层的j从小到大<br><br><span class="hljs-number">2.</span>完全背包 和 <span class="hljs-number">01</span>背包 的区别仅在于状态更新时的遍历顺序。（即<span class="hljs-number">01</span>是逆序，完全是顺序）<br><br><span class="hljs-number">3.</span>不超过容量 和 恰好装满 的区别仅在于二者的初始化~<br>- 前者全<span class="hljs-number">0</span>；也就是全有效<br>- 后者，f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>（第一列），其余全为负无穷，一维：除f[<span class="hljs-number">0</span>]为<span class="hljs-number">0</span>外，其余f[j]都是负无穷）<br></code></pre></td></tr></table></figure><h3 id="5-2线性dp"><a href="#5-2线性dp" class="headerlink" title="5.2线性dp:"></a>5.2线性dp:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>三角形<br><span class="hljs-number">2.</span>a最长上升子序列 f[i] 以i结尾的长度     优化：f[i]长度为i的序列结尾的数字<br><span class="hljs-number">3.</span>a、b最长公共子序列 f[i][j] a[i],b[j]结尾的最大长度   以a[i],b[j]是否出现四次划分<span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span><br><span class="hljs-number">4.</span>编辑距离       f[i][j]a前i个变成b前j个的最小操作次数 只操作i的最后一个字母（<span class="hljs-number">3</span>种）<br><span class="hljs-number">5.</span>最短编辑距离 同上<br><span class="hljs-number">6.</span>石头合并最小代价（最优矩阵相乘）  f[i][j] i到j的代价  最后一次的分界线为分类（因为该区间最后一定是某两个区间合并出来的）<br>(!!!!!!区间问题：先枚举区间长度，再枚举起点，最后再根据决策计算。)<br>    长度 -&gt; 起点 -&gt; 拆分点<br><br><span class="hljs-number">7.</span>整数划分<span class="hljs-number">1.</span> 转化为体积为<span class="hljs-number">1</span>~n的！恰好 ！为n的完全背包物体 计数问题<br>            f[i][j]只取i个数，体积恰好为j的种类<br><br> <span class="hljs-number">2.</span> f[i][j] 总和为i，总数为j   分成有无<span class="hljs-number">1</span>两类 f[i][j]=(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i-j][j])%mod;<br><br><span class="hljs-number">8.</span>计数问题<br></code></pre></td></tr></table></figure><h3 id="5-3状态dp"><a href="#5-3状态dp" class="headerlink" title="5.3状态dp"></a>5.3状态dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">AcWing <span class="hljs-number">291</span><br>只考虑放水平的方格，列方格自动补全（前提不能有连续奇数个零，不然补全不了）<br>用二进制表示状态，<span class="hljs-number">0</span>表示无<span class="hljs-number">1</span>表示有<br><br>横向放置第i列结尾方格时  <span class="hljs-number">1.</span>满足与第i<span class="hljs-number">-1</span>列不冲突     (j&amp;k)==<span class="hljs-number">0</span><br>         <span class="hljs-number">2.</span>i<span class="hljs-number">-1</span>列剩下的格子，没有连续奇数个格子   st[ j|k ]==<span class="hljs-number">1</span><br>当n不同时，st数组也不同<br><br><span class="hljs-comment">//棋盘为0~m-1列，需要计算到m列</span><br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)     <span class="hljs-comment">//放以i列结尾的方块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; <span class="hljs-number">1</span>&lt;&lt;n ;j++)      <span class="hljs-comment">//i-1列结尾的方块状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt; <span class="hljs-number">1</span>&lt;&lt;n ;k++)     <span class="hljs-comment">//尝试i列结尾的方块状态</span><br>            <span class="hljs-keyword">if</span>((j&amp;k)==<span class="hljs-number">0</span> &amp;&amp; st[j|k])<br>                f[i][k]+=f[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-number">11</span>* <span class="hljs-number">2</span>^<span class="hljs-number">11</span> *<span class="hljs-number">2</span>^<span class="hljs-number">11</span> =<span class="hljs-number">4</span> * <span class="hljs-number">10</span>^<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">acwing <span class="hljs-number">91</span> 最短hamilton哈密顿距离<br><span class="hljs-number">1</span>≤n≤<span class="hljs-number">20</span> <br>用二进制保存进过点的状态 <br><span class="hljs-type">int</span> f[<span class="hljs-number">1</span>&lt;&lt;N][N];<span class="hljs-comment">//i状态 j结尾的最小长度</span><br><span class="hljs-keyword">for</span> 状态<br><span class="hljs-keyword">for</span> 终点<br><span class="hljs-keyword">for</span> 倒数第二个点<br></code></pre></td></tr></table></figure><h3 id="5-4记忆化搜索"><a href="#5-4记忆化搜索" class="headerlink" title="5.4记忆化搜索"></a>5.4记忆化搜索</h3><p>dfs的同时，返回前记录下当前状态值。</p><p>没有上司的舞会、最长滑雪长度 <a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>(需要注意什么情况下是无解 什么条件是还没求 什么时候是中止)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x])<span class="hljs-keyword">return</span> f[x];<br>    <span class="hljs-comment">// 中止条件 </span><br>    ... 求解f[x]的最优解res<br>    f[x] = res;<br>    <span class="hljs-keyword">return</span> f[x];<br></code></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">322</span>Coin Change：给定无数个定值硬币，最少数量凑出amount。<br>dp：恰好、完全背包<br>记忆化搜索：凑<span class="hljs-attribute">x</span>需要的个数 me<span class="hljs-selector-attr">[x]</span>, 画出求解树,存在重叠，需要记忆优化<br><br>矩阵左上角到右下角传纸条，穿两次路径和最大<br><br>栈的出栈入栈序列<br></code></pre></td></tr></table></figure><h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><p>0.合并区间</p><p>1.区间选点使得每个区间至少一个点。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">右端点排序，每次更新最右边的点<br></code></pre></td></tr></table></figure><p>2.安排课表，使得上的课最多[区间不重叠]</p><p>3.区间分组，组内互不相交      优先队列+左端点排序</p><p>4.选择区间覆盖指定区间。     左端点+贪心</p><p>5.排序</p><p>6.牛的最大忍耐度最小     对两头牛交换，会导致结果变大还是变小</p><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="Hot-100"><a href="#Hot-100" class="headerlink" title="Hot 100"></a>Hot 100</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1 两数之和 hash  双指针<br>4  二分<br>5 最长回文 dp || 马拉车<br>10 正则表达式匹配 ！ dp  处理边界以及情况列举<br>11 盛水容器  每次移动是丢弃了一些状态 <br>15 三数和为零 hash+set去重  |  排序+双指针 注意去重 <br>19 一次遍历删除链表第n个元素  快慢指针<br>23 合并k个有序列表  分治！类似归并、维护优先队列<br>31 下一个排序 找规律<br>33 旋转过的有序数组 二分寻找一个数<br>34 二分模板<br>39 组合总和 dfs   引用更快，但需要回溯回状态<br>42 接雨水<br><span class="hljs-code">求出每个i能够接到的雨水数</span><br><span class="hljs-code">单调栈</span><br><span class="hljs-code">46 全排列</span><br><span class="hljs-code">48 旋转矩阵</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">49.</span> 字母异位词分组 输入vector<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span></span> 将所含字母相同放入一个vector中输出<br><span class="hljs-code">1.map&lt;string,[s1,s2]&gt; string为排序后 s1,s2为原来</span><br><span class="hljs-code">2.将字母映射一个质素double a[26]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125;;</span><br><span class="hljs-code">将string转为质素相乘，其他与1一样，少一个排序时间</span><br><span class="hljs-code">小心溢出，用long long后取余(余数要大)或者用double</span><br><span class="hljs-code">3.如果是string需要完全相同，可以字符串哈希映射为一个数字</span><br><span class="hljs-code">4.统计个数后，map&lt;string,[s1,s2]&gt; string是每一个元素的个数 &#x27;a:x b:y&#x27;</span><br><span class="hljs-code"></span><br>53* 最大子数组和 字串的最大连续和  【dp】  二分分治维护区间关系，可以求解任意[l，r]区间最大值  -&gt; 线段树<br><span class="hljs-code">后续题目：2321. 拼接数组的最大分数  或者转为状态dp </span><br><span class="hljs-code"></span><br>55 从数组第一个位置能否跳到最后一位置，数组上值为最大跳跃距离  dp优化成【贪心】<br><br>56 区间合并 【贪心】<br><br><span class="hljs-bullet">62.</span> 【dp】或者 记忆化搜索 或者 排列组合<br><br>63 【dp】可以优化空间到<br><br>64 【dp】可以直接原数组上dp<br><br>70 【dp】或找规律<br><br>72 最短编辑距离 【dp】    边界条件(如何初始化方便)<br><br>75 将数组分为0 1 2 【partition】 L:下一个放0的位置   R：下一个放2   有等号<br><br>76 【滑动窗口】求最小覆盖串<br><span class="hljs-code">滑动窗口的套路</span><br><span class="hljs-code">先找到一个可行解，再优化这个可行解。</span><br><span class="hljs-code">优化到不能优化，产生出一个可能的最优解。</span><br><span class="hljs-code">继续找新的可行解，再优化这个可行解。</span><br><span class="hljs-code"></span><br><span class="hljs-code">直接用数组代替map映射需要的字母的数量，用额外count记下还需要匹配多少个，免去遍历过程</span><br><span class="hljs-code"></span><br>78  求无重复数组的子集   直接每层选出一个，下一层接着这个数选，有重复的话剪枝，排序后只拿第一个<br><br>79  普通回溯，记得找到后【提前结束】寻找，不然超时<br><br>84  柱状图中最大的矩形 暴力：以i为高度两边扩散；     【单调栈】<br><br>85  最大矩形 0和1的矩阵，求最大矩形面积 多个84题<br><br>96  n个节点二叉搜索数的个数    暴力超时，dp分解求解   卡特兰数<br><br>98 验证二叉搜索树  中序遍历为上升序列，巧用pre保存前一个点   or  dfs<br><br>101 对称二叉树  dfs or bfs<br><br>102二叉树层次遍历  需要知道层次，一次性处理一行<br><br>104 二叉树的最大深度 dfs<br><br>105前序中序得到树dfs<br><br>114 将树转为链表：右节点转为下一个节点  dfs    解法很巧妙，自己用的最朴素的返回链后头尾节点<br><br><span class="hljs-bullet">121.</span> 买卖股票的最佳时机 直接求<br><br><span class="hljs-bullet">124.</span> 二叉树中的最大路径和  注意dfs的返回值的含义！<br><br>128 最长连续序列  数组中的数值，连续的最长序列长度<br><span class="hljs-code">1.暴力：计算以每一个数为开头的长度n  2.优化：只计算区间起点的长度 3.并查集  4.dp</span><br><span class="hljs-code"></span><br>136 只出现一次的数字  异或<br><br><span class="hljs-bullet">139.</span> 单词拆分  给wordDict 拼出s，可重复使用<br><span class="hljs-code">1.暴力 超时  2.hash优化字符串比较+记忆化（存在重复 所以想到）  3.dp</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">142.</span> 环形链表 II  并返回入环点<br><br><span class="hljs-bullet">148.</span> 排序链表 1.归并排序 logn空间  2.O1不会<br><br><span class="hljs-bullet">152.</span> 乘积最大子数组 dp<br><br><span class="hljs-bullet">155.</span> 最小栈 栈，但能获取到最小值<br><br><span class="hljs-bullet">160.</span> 相交链表 求相交点 1.hash 2.求多出来的长度 3.相互连接起来<br><br><span class="hljs-bullet">169.</span> 多数元素 删除不同的两个数 还是多数元素<br><br><span class="hljs-bullet">198.</span> 打家劫舍<br><br><span class="hljs-bullet">200.</span> 岛屿数量 DFS||BFS<br><br><span class="hljs-bullet">206.</span> 反转链表<br><br><span class="hljs-bullet">207.</span> 课程表 图是否有环  拓扑图 ||  DFS搜索看是否回来<br><br><span class="hljs-bullet">208.</span> 实现 Trie (前缀树) <br><br><span class="hljs-bullet">215.</span> 数组中的第K个最大元素<br><br><span class="hljs-bullet">221.</span> 最大正方形  dp || 85. 直接用长方形来解答的，没用答案的正方形性质<br><br><span class="hljs-bullet">235.</span> 二叉搜索树的最近公共祖先  非搜索树236也可也解，递归，函数返回结果为是否包含p或q<br><br><span class="hljs-bullet">238.</span> 除自身以外数组的乘积  不用除法、On时间 On空间  前缀和<br><br><span class="hljs-bullet">240.</span> 搜索二维矩阵 II  在搜索矩阵中高效找一个数<br><br><span class="hljs-bullet">279.</span> 完全平方数  dp | 记忆化<br><br><span class="hljs-bullet">283.</span> 移动零<br><br><span class="hljs-bullet">287.</span> 寻找重复数 有一个数出现两次及以上  二分 | 位运算 | 快慢指针<br><br><span class="hljs-bullet">297.</span> 二叉树的序列化与反序列化 解析时删除元素<br><br><span class="hljs-bullet">300.</span> 最长递增子序列<br><br><span class="hljs-bullet">301.</span> 删除无效的括号  可能的方案？<br><br><span class="hljs-bullet">309.</span> 买卖股票的最佳时机含冷冻期  dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">3</span>]<br><br>312<span class="hljs-emphasis">*. 戳气球 区间dp 以区间最后一个气球为准</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">322. 零钱兑换  dp  见分类刷题-dp</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">337. 打家劫舍 III  树上 记忆化搜索  可以不要考虑两种情直接求</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">338. 比特位计数 dp</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">347. 前 K 个高频元素 堆</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">394. 字符串解码 递归</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">399. 除法求值 构建为图  List<span class="language-xml">&lt;List&lt;Pair&lt;Integer, Double&gt;</span>&gt;&gt; edges  最外层是点，存List<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Pair</span>&gt;</span></span>代表点的每条出边</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">406. 根据身高重建队列 贪心排序 + 暴力找位置 or  树状数组+二分 （想知道1~x区间和，同时也会增加1，二分找区间和&gt;=k+1的地方  logn *</span> logn）<br><br><span class="hljs-bullet">416.</span> 分割等和子集 选择一些数和等于sum/2 dp 注意顺序，数组在内部循环会导致错误（元素重复使用）  零钱兑换是需要重复使用<br><br><span class="hljs-bullet">437.</span> 路径总和 III 暴力  || 前缀和+hash<br><br><span class="hljs-bullet">438.</span> 找到字符串中所有字母异位词 双指针<br><br><span class="hljs-bullet">448.</span> 找到所有数组中消失的数字  交换到应该的位置 |  +n标记<br><br><span class="hljs-bullet">494.</span> 目标和 添加正负号和为target  dfs -&gt; 记忆化 -&gt; dp  || 转为数组中选取元素，之和等于 target 416.<br><br><span class="hljs-bullet">538.</span> 把二叉搜索树转换为累加树 反中序遍历<br><br><span class="hljs-bullet">543.</span> 二叉树的直径  二叉树任意两个点的最大距离 dfs  定义好dfs的返回值的意义！ 同 二叉树中的最大路径和<br><br><span class="hljs-bullet">560.</span> 和为 K 的子数组 数量  暴力 | 前缀和 + hash（不关心具体下标，只关心等于 k 的前缀和之差出现的次数c）  遍历右维护左<br><br><span class="hljs-bullet">581.</span> 最短无序连续子数组 将数组部分排序后有序 nlogn排序-二分  找规律技巧<br><br><span class="hljs-bullet">617.</span> 合并二叉树 dfs<br><br><span class="hljs-bullet">621.</span> 任务调度器 模拟题<br><br><span class="hljs-bullet">647.</span> 回文子串 中心点暴力<br><br>739 每日温度 下一个更大的温度 单调栈<br></code></pre></td></tr></table></figure><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-number">24</span> 两两交换链表节点  递归<br><span class="hljs-number">26</span> 删除有序<span class="hljs-built_in">vector</span>重复项     双指针<br><br><span class="hljs-number">172</span> 阶层中零的个数<br><span class="hljs-number">202</span> 将一个数每一位求平方和，判断最后是否收敛到<span class="hljs-number">1</span>  <span class="hljs-number">19</span>-&gt;<span class="hljs-number">82</span>-&gt;<span class="hljs-number">68</span>-&gt;<span class="hljs-number">100</span>-&gt;<span class="hljs-number">1</span>  <br>判断是否存在循环：快慢指针、hash<br>o<br></code></pre></td></tr></table></figure><p>卡特兰数：n对括号正确匹配数目 (22)，n个节点二叉搜索树(96)，出栈次序，矩阵相乘<br>C0 &#x3D; 0   Cn+1 &#x3D; 2(2n+1) &#x2F; (n+2) * Cn</p><p>$$<br>C0 &#x3D; 0      ~~~~~~~~~<br>Cn+1&#x3D;<br>\frac{2(2n+1)}{n+2}Cn<br>$$</p><h2 id="分类刷题"><a href="#分类刷题" class="headerlink" title="分类刷题"></a>分类刷题</h2><p><a href="https://github.com/doocs/leetcode">doocs&#x2F;leetcode: 😏 LeetCode solutions</a></p><h3 id="0-找规律"><a href="#0-找规律" class="headerlink" title="0.找规律"></a>0.找规律</h3><ul><li><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>   每一个i可以的最大高度</li><li>438 异位词比较 <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>    滑动窗口；字符比较：排序hash、计数后拼接hash、26个桶比较</li><li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组的个数</a>  hash+前缀和</li><li><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a>  数组向后移动k位  最大公约数 | 反转数组</li><li></li></ul><h3 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1. 基础算法"></a>1. 基础算法</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">在排序数组中查找元素的第一个和最后一个位置 - 二分查找<br>准时到达的列车最小时速 - 二分查找  对速度进行二分<br>找到需要补充粉笔的学生编号 - 二分查找<br>可移除字符的最大数目 - 二分查找<br><br>排序数组 - 快速排序、归并排序<br><br>字符串相加 - 高精度加法<br>字符串相乘 - 高精度乘法<br><br>区域和检索 - 数组不可变 - 前缀和<br>二维区域和检索 - 矩阵不可变 - 二维前缀和<br>区间加法 - 前缀和、差分<br>用邮票贴满网格图 - 二维前缀和、二维差分<br><br><br>位<span class="hljs-number"> 1 </span>的个数 - 位运算、lowbit<br>合并区间 - 区间合并<br></code></pre></td></tr></table></figure><h4 id="枚举右，维护左"><a href="#枚举右，维护左" class="headerlink" title="枚举右，维护左"></a>枚举右，维护左</h4><p>哈希表维护左边全部<strong>（找等值关系）</strong>, 或者单变量维护最值(买卖股票1)  （<strong>找最值关系</strong>）</p><ul><li><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></li><li><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">2874. 有序三元组中的最大值 II - 力扣（LeetCode）</a>  max ((nums[i] - nums[j]) * nums[k])，  枚举j或者k</li><li><a href="https://leetcode.cn/problems/count-nice-pairs-in-an-array/">1814. 统计一个数组中好对子的数目</a></li></ul><p>前缀和+维护左</p><ul><li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/path-sum-iii/submissions/">437. 路径总和 III - 力扣（LeetCode）</a>   + 回溯</li><li><a href="https://leetcode.cn/problems/maximum-good-subarray-sum/">3026. 最大好子数组和 - 力扣（LeetCode）</a> 子数组满足|nums[l] - nums[r]| &#x3D;&#x3D; k，给出sum子数组最大值</li></ul><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p><a href="https://leetcode.cn/circle/discuss/SqopEo/">分享丨【题单】二分算法（二分答案&#x2F;最小化最大值&#x2F;最大化最小值&#x2F;第K小） - 力扣（LeetCode）</a></p><ul><li><a href="https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/">3296. 移山所需的最少秒数 - 力扣（LeetCode）</a> 双二分、堆</li><li><a href="https://leetcode.cn/problems/maximum-number-of-removable-characters/">1898. 可移除字符的最大数目</a></li></ul><h3 id="2-数据结构-1"><a href="#2-数据结构-1" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">设计链表 <span class="hljs-operator">-</span> 单链表、指针引用、数组实现<br>下一个更大元素 <span class="hljs-built_in">I</span> <span class="hljs-operator">-</span> 单调栈<br>每日温度 <span class="hljs-operator">-</span> 单调栈<br>子数组的最小值之和 <span class="hljs-operator">-</span> 单调栈<br>最大宽度坡 <span class="hljs-operator">-</span> 单调栈<br>最多能完成排序的块 <span class="hljs-variable">II</span> <span class="hljs-operator">-</span> 单调栈   ×<br>子数组范围和 <span class="hljs-operator">-</span> 单调栈<br>子数组最小乘积的最大值 <span class="hljs-operator">-</span> 单调栈<br>滑动窗口最大值 <span class="hljs-operator">-</span> 单调队列<br>满足不等式的最大值 <span class="hljs-operator">-</span> 单调队列 ×<br>和至少为 <span class="hljs-built_in">K</span> 的最短子数组 <span class="hljs-operator">-</span> 单调队列   尝试单调栈<span class="hljs-operator">-&gt;</span>无单调性？  前缀和<span class="hljs-operator">+</span>单调队列<br>带限制的子序列和 <span class="hljs-operator">-</span> 动态规划、单调队列优化<br>单词规律 <span class="hljs-variable">II</span> <span class="hljs-operator">-</span> 哈希表、回溯 ×<br>最短回文串 <span class="hljs-operator">-</span> 字符串哈希<br>回文对 <span class="hljs-operator">-</span> 字符串哈希<br>最长重复子串 <span class="hljs-operator">-</span> 字符串哈希、二分查找<br>不同的循环子字符串 <span class="hljs-operator">-</span> 字符串哈希<br></code></pre></td></tr></table></figure><h4 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h4><p>查找满足某要求的字串、子序列；<strong>解题时看到字串子序列：先考虑所有以i结尾的串，在考虑j的单调</strong></p><p>（此外还有一种二分的解法 nlogn：每一个right结尾时，二分寻找left的最优）</p><p><strong>基本思想</strong>：随着 i的增大，满足 某表达式 的j 值是单调的。</p><p>​        1.我遍历了全部以i结尾的串。确保不遗漏<br>​        2.暴力：j需要for一次 -&gt; 如果以i结尾的<code>j~i</code>窗口是一个可行解，i往后移，<strong>j不能回头</strong>。该单调性可以优化掉O(n^2^)</p><p><strong>步骤</strong></p><ol><li>左右指针ji控制窗口，遍历右指针i向右边移动，以获取所有的答案（理解为以i结尾的所有串）</li><li>目前ji是可行解</li><li>当前窗口<code>i++</code>，不是可行解或最优解（窗口大小,字符数量）</li><li><code>j++</code>，直到可行</li><li>更新res</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 朴素 N^2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (check(i, j)) &#123;<br>            <span class="hljs-comment">// 具体问题的逻辑 res = max(res, j-i+1)</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双指针 N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑 res = max(res, j-i+1)</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="基础："><a href="#基础：" class="headerlink" title="基础："></a><strong>基础：</strong></h5><ol><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小且sum大于k的子数组</a>：<code>j~i</code>以i结尾长度最小且大于k，<code>j ~ i+1</code> 一定大于但可能不是最短； 除了双指针还可以二分j</li><li><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">乘积小于 K 的子数组</a>：有多少个子串乘积后严格小于k。<code>j~i &lt; k</code>，<code>j ~ i+1</code>不一定&lt;k, 但j一定要往后走<ol><li>拓展：字串加减乘除(不能有负数:<a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">反例</a>) 满足 大于小于某个值:<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小且sum大于k的子数组</a></li></ol></li><li><a href="https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/">3097. 或值至少为 K 的最短子数组 II</a> 将求和改成了或，需要记录每一位上的数量</li><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>：<code>j~i</code>以i结尾无重复且最长，<code>j ~ i+1</code>  不一定无重复，但j一定是往后移动缩小窗口，使得无重复<ol><li><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/description/">长度为 K 的无重复字符子串</a> 的个数 多一个长度缩小</li></ol></li><li><a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>：s2是否存在的某个子串刚好包含s1全部字符  ；新加进来的不能多+直接长度判断是否满足</li><li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a> 同上，需要找出所有的  </li><li>**<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>**：s中字串能包含t全部字符，且最小（可以多，所以不能用长度判断 要多一个need记录）。<code>j~i</code>覆盖且最小，<code>j ~ i+1</code>  覆盖但不一定最小，但j一定是往后移动缩小窗口，使得更小；用一个变量记录下一共要多少个字符、一个hash记录每个字符需要多少（也可也直接用长为26字母遍历check）</li><li><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">统计定界子数组的数目</a> 满足最大为min 最小为max的子数组的数量<ol><li>维护两个指针，i是以i结尾的子数组。</li><li>当i不越界时，数量关系取决于最后一个min 和 max的下标</li><li>当i越界时，两指针都跳到i+1</li></ol></li><li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">最大连续1的个数 III</a>：最多存在k个0，求数组连续1的个数</li></ol><h5 id="相向："><a href="#相向：" class="headerlink" title="相向："></a><strong>相向：</strong></h5><ol><li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></li><li><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>  三数和为0，并且去重 ； 排序去重 然后双指针（有序）找值，当然也可也hash维护找（空间消耗）</li><li><a href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a>两个升序数组，求和为x的两个数组的下标<ul><li>一个i指针一直往大了走，说明窗口是变大的，那么j的移动方向就是使得窗口值变小</li><li>因此推断<code>i=0  -&gt; n</code> ;  <code>j=m-1 -&gt; 0</code>  <ul><li>if  <code>v(i,j)&gt;x</code>，j一直移动变小，直到满足&lt;&#x3D;x       （<code>v(i,j)&gt;x</code>，那么<code>v(i+1,j)&gt;x</code>，不会遗漏）</li><li>如果ij小于x，x变大，并且j</li></ul></li></ul></li><li><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器 - 力扣（LeetCode）</a></li></ol><h5 id="恰好型"><a href="#恰好型" class="headerlink" title="恰好型"></a>恰好型</h5><p>恰好为k，拆分成&gt;&#x3D;k 以及 &gt;&#x3D;k+1</p><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><ul><li><p>想知道每个元素前后第一个比它大(或小)的元素；  当新来元素很大时，前面比他小的都找到下一个更大了 于是出栈，所以栈中是一个递减的序列</p></li><li><p><code>pre ~ i ~ next</code>时(两边只包含一个) i 都是最大，就可以知道所有子数组中，i 当了<code>(k-i)(i-j)</code>次老大</p></li><li><p>经常要求所有子数组的个数或者子数组求和，需要注意越界问题</p></li></ul><p>求下一个更大：暴力：每个元素都可能要遍历后面的所有；优化：维护一个栈，当目前元素比栈顶更大时，栈顶就找到了下一个更大。一直pop，最后栈顶是i的前一个更大</p><p>模板1：当前元素必须进栈，进栈后影响栈内元素  可以见<a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">https://leetcode.cn/problems/sum-of-subarray-ranges/</a><br>这里pre next 一个是严格一个不是，可以保证子数组不重不漏！ <strong>如果都想要严格或者非严格就再求一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt;= nums[i]) &#123;<br>        nextBig[stack.top()] = i; <span class="hljs-comment">// 栈顶的下一个非严格大是i，出栈时记录   下面是严格大，去掉等号要反过来</span><br>        stack.pop();<br>    &#125;<br>    preBig[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();  <span class="hljs-comment">// 当前i的前一个严格大是栈顶</span><br>    stack.push(i);<br>&#125;<br><span class="hljs-comment">// 不能忘了最后栈内的</span><br><span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>    nextBig[stack.pop()] = n;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板2：当前元素可能不进栈，进栈后会影响后面未进栈的。左边小的可以让后面大的都不进栈，相当于从右到左模板1的弹出过程,用的比较少，看题目具体情况（最大宽度坡）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (stack.isEmpty() || nums[stack.peek() &gt; nums[i]]) &#123;<br>    stack.push(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模板1从左到右和从右到左得到结果不一样</li><li>从左到右模板2的结果和从右到左模板1并反序，栈内元素会一样</li></ul><p>例题：</p><ol><li><p><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></p></li><li><p>求所有子数组中最小值，并求和  907</p><p>​<strong>方法一</strong>:  dp[i] 以i结尾的所有子数组，最小和：<code>a[i]</code>能影响到上一个比a[i]小数a[j] <strong>单调栈</strong>，dp[i] &#x3D; dp[j] + (i-j)*a[i]  如果这一步不dp记录下来，就会导致超时</p><p>​<strong>方法二</strong>：每个元素 <code>nums[i]</code> 作为最小值出现在了多少个子数组中：pre j、next k <code>(k-i)(i-j)</code>。<strong>单调栈！</strong></p><p>​<strong>方法三</strong>：排序后，从最小数的下标开始  <code>Arrays.sort(B, (i, j) -&gt; ((Integer) A[i]).compareTo(A[j]));</code></p></li><li><p>最大宽度坡  满足 <code>A[i] &lt;= A[j]</code> 的最大 <code>j - i</code> 值</p><p>​需要从左往右建立一个特殊的栈，小的元素会导致后面大的元素直接不进栈，建立后从右往左找规律求结果</p></li><li><p><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">最多能完成排序的块 II</a> 排序子数组使得整体有序</p><p>​1、找规律 max nums[0:i-1] &lt; min nums[i:n-1]   和单调栈无关</p><p>​2、和排序的对比字符数</p><p>​3、单调栈</p></li><li><p><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">子数组范围和</a>  </p><p>​求全部子数组(max-min)，并求和，同2，但多一个最pre nextMax。</p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray-min-product/">子数组最小乘积的最大值</a></p><p>​求全部子数组中，<code>min(a) * sum(a)</code>最大的。mina 还是用单调栈，注意这里是越宽越好，所以pre next都用非严格的两次去求(单次同时求出非严格需要跳跃 <a href="https://leetcode.cn/submissions/detail/427726444/">代码</a>)。（其实一个非严格一个严格也可以，因为第一个元素的nextBig会包裹相同元素，1111相当于以第一个1为代表）。</p></li><li><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a>  模板</p></li></ol><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>​为什么要引入队列？有的题目前后都要弹出！！元素满足单调性</p><p>理解：通过单调性来移出不优的元素，例如在“和至少为 K 的最短子数组”，对于每个点作为左节点<code>j</code>，如果来了一个新值<code>j‘</code>，并且更小，那么左边的旧值<code>j</code>就永远不需要看了；作为左节点<code>j</code>如果<code>j~i</code>满足条件，那么右边的<code>j~i&#39;</code>就不用再看了</p><p><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/[">可以获取最值的队列</a>  可以在队尾插入，队头取出；并且O1最大值</p><ol><li>维护全局一个最大值，但该元素出队列后找不到下一个最大值  ×</li><li>维护有效最大值列表，使得最大出列后还能找到第二大：<ol><li>有效的特点：当队尾来了一个很大的数，最大值列表中的小值都可以被忽略了，所以是一个递减的</li><li>队头也可也删除元素，当普通队列的元素和最大值队列队头相同时，最大值队列需要出队</li></ol></li><li>类似题目：<a href="https://leetcode.cn/problems/min-stack/">可以获取最小值的栈</a>  同样是维护一个最小值列表</li></ol><p>[滑动窗口最大值](<a href="https://github.com/doocs/leetcode/blob/main/solution/0200-0299/0239.Sliding">https://github.com/doocs/leetcode/blob/main/solution/0200-0299/0239.Sliding</a> Window Maximum&#x2F;README.md)</p><p>​求滑动窗口的最大值，当新来元素很大时，前面比他小的都可以忽略了，所以窗口中是一个递减的序列，最大值就在peekLast  （此外还可以维护一个优先队列（堆） <code>O(logn)</code>取出最值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队尾超出窗口大小 pop</span><br><span class="hljs-keyword">while</span>(deque.peekLast().index&lt;i-k+<span class="hljs-number">1</span>)&#123;<br>    deque.pollLast();<br>&#125;<br><br><span class="hljs-comment">// 队头出pop， 并且新元素入队</span><br><span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst().value&lt;nums[i])&#123;<br>    deque.pollFirst();<br>&#125;<br>deque.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(nums[i], i));<br><span class="hljs-comment">// 根据队列最大值计算相关值</span><br>res[i] = deque.peekLast().value;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a> ：如果全是正数，那么用双指针可以把空间复杂度也降低到O1</p><ol><li><p>使用<code>前缀和的差</code>来计算子数组的和；</p></li><li><p>使用一种数据结构，将<code>当前前缀和i</code>与<code>最前面的前缀和j</code>作差，如果满足&gt;&#x3D;k的条件，那么<code>j</code>在之后就可以不用看了。【因为即使后面也有满足条件的，长度也会更长，所以需要将j从前面弹出】；</p></li><li><p>第2步完成了之后，当前的i也要放入数据结构，那么如果数据结构中有<code>前缀和j</code>比<code>前缀和i</code>大，j也可以不用看了。【因为即使后面有满足条件的，与i作差肯定也满足条件，并且长度更短，所以需要将大于等于i的从后面弹出】。</p><p>​前面后面都要弹出，压入的元素满足单调性，所以使用单调队列。</p><p>数组存在负数，所以不能用二分查找i结尾的起点在哪。</p><p>第二次做：其实是找满足条件的<code>j~i</code>，不能暴力遍历就找规律：对于左起点j以及右终点i，如果<code>j~i</code>当前满足了，那j不需要再去找后面的i了；i以后作为左起点 对于左起点，如果当前比左边的数小，那么左边的数都不可能再作为左起点了</p></li></ol><p><a href="https://leetcode.cn/problems/constrained-subsequence-sum/">带限制的子序列和</a>  求<code>max ( sum[子序列] )</code> ， 且子序列中的最大下标间隔不能超过k</p><ol><li><code>dp[i]</code> 代表以i结尾的子序列的最大和，保证不遗漏</li><li><code>dp[i] = max(dp [i-k] ~ dp[i-1])</code>  如果遍历k的话，超时；分析目前是想得到前k个元素的最大值</li><li>维护一个窗口大小为k的单调队列！</li></ol><h4 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h4><ul><li><p>单点更新，区间查询</p></li><li><p>值不断变化，<strong>动态数组查找小于（大于）x的和 或 个数</strong></p><ul><li>或者是给出要查找第x大的数，给出这个数字；多一个二分查找过程 2653</li></ul></li><li><p><a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/">3072. 将元素分配到两个数组中 II - 力扣（LeetCode）</a></p></li><li><p>严格单调递减的子序列右多少个； 树状数组+离散化； 求所有小于当前数x的i  dp[i]的和</p></li><li><p><a href="https://leetcode.cn/problems/sliding-subarray-beauty/description/">2653. 滑动子数组的美丽值 - 力扣（LeetCode）</a>     动态数组查找第x大的数字，二分  ；数据范围小这题可以直接计数</p></li></ul><h3 id="3-搜索"><a href="#3-搜索" class="headerlink" title="3.搜索"></a>3.搜索</h3><p>BFS：有很多结果，需要最优的，所以需要BFS同时尝试所有的，并且最先遇到的就是最优解<br>DFS：存在问题，只需要一个；把一种可能的情况尝试到底</p><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>BFS</strong>：状态转换 + <strong>最短路&#x2F;最小步数&#x2F;最小操作</strong>；空间范围有限</p><ul><li>有一个全局的visit代表是否访问过，<strong>用来保证不走回头路</strong>，可以用距离(使用距离的话，入队的点就不用额外保存距离)</li><li><strong>入队时</strong>标记而不是出队时标记，防止同一个节点入队两次</li><li>尽量只将有意义的节点入队，同时入队时判断结束条件最好：<a href="https://leetcode.cn/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">grid[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 入队时标记</span><br>deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;n-<span class="hljs-number">1</span>, m-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>    <span class="hljs-type">int</span>[] tmp = deque.pollFirst();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> tmp[<span class="hljs-number">0</span>], y = tmp[<span class="hljs-number">1</span>], dis = tmp[<span class="hljs-number">2</span>];<br>    <br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> dis; <span class="hljs-comment">// 出队时判断全集最优 结束搜索</span><br><br>    <span class="hljs-type">int</span> []dx = &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> []dy = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">xx</span> <span class="hljs-operator">=</span> x + dx[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yy</span> <span class="hljs-operator">=</span> y + dy[i];<br>        <span class="hljs-keyword">if</span>(xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&lt;m&amp;&amp;grid[xx][yy]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 入队的条件</span><br>            grid[xx][yy] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 入队标记</span><br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;xx, yy, dis+<span class="hljs-number">1</span>&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br>https:<span class="hljs-comment">//leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/submissions/505710677/</span><br></code></pre></td></tr></table></figure><p>优化：<strong>双向DFS</strong>，可以节约百倍空间复杂度[模板](<a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/submissions/505775766/">1091. 二进制矩阵中的最短路径 - 力扣（LeetCode）</a>) <a href="https://leetcode.cn/problems/open-the-lock/submissions/505756847/">模板code</a>  </p><p>1+2+4+8+16+32+64+128+256+512  -&gt;    1+2+4+8+16  + (相遇)  16+8+4+2+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">queue1、queue2 为两个方向的队列<br>dis1、dis2 为两个方向的距离数组，记录每个节点距离起点的<br><br>更新时优先更新小的，并且一次更新一层<br>二者相遇时即为结果<br><br>    <span class="hljs-keyword">while</span>(!deque1.isEmpty() &amp;&amp; !deque2.isEmpty())&#123;<br>        <span class="hljs-type">int</span> res=-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 优先扩展size小的 缩小搜索空间</span><br>        <span class="hljs-keyword">if</span>(deque1.size()&lt;deque2.size())&#123;<br>            res = update(deque1, dis1, dis2);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res = update(deque2, dis2, dis1);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(res!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span>-<span class="hljs-number">1</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Deque&lt;Integer&gt; deque, <span class="hljs-type">int</span> []dis, <span class="hljs-type">int</span> []other)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> deque.size();<br>        <span class="hljs-keyword">while</span>(num-- != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> deque.pollFirst();<br><br>            <span class="hljs-comment">// 相遇为终结</span><br>            <span class="hljs-keyword">if</span>(other[x] != -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> dis[x] + other[x];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-comment">// 具体业务</span><br>                <span class="hljs-keyword">if</span>(...&amp;&amp;dis[now]==-<span class="hljs-number">1</span>)&#123;<br>                deque.addLast(now);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">图像渲染- <span class="hljs-keyword">BFS、DFS、Flood </span>Fill 算法、连通性模型<br>岛屿数量 - <span class="hljs-keyword">BFS、DFS、Flood </span>Fill 算法<br><span class="hljs-number">01</span> 矩阵 - 多源 <span class="hljs-keyword">BFS </span>    注意只能多源<span class="hljs-keyword">BFS！！DFS实现失败 </span>  还可以dp，但没看<br>地图中的最高点 - 多源 <span class="hljs-keyword">BFS </span>和上面一模一样<br>进击的骑士 - <span class="hljs-keyword">BFS、最短路模型 </span>  暴力或者双向<span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span>二进制矩阵中的最短路径 - <span class="hljs-keyword">BFS、最短路模型 </span>    模板  如果入队没有标记而是出队标记 会超时<br>迷宫中离入口最近的出口 - <span class="hljs-keyword">BFS、最短路模型 </span>    模板<br><br>网格中的最短路径 - <span class="hljs-keyword">BFS、最短路模型 </span>          从左上到右下最短路，可以删除k个障碍；这里即便访问过，后来的也可也访问：入队额外记录剩余删除个数，如果比全局的更多（后来的距离一定更大，想要继续走就必须要剩余更多删除），就可以入队<br><br>打开转盘锁 - 最小步数模型、双向 <span class="hljs-keyword">BFS、A* </span>IDA*  四位旋转到目标数  看上去题目复杂，但搜索空间只有<span class="hljs-number">1</span>e5 直接暴力 dfs第一次遇到的是最优的，set去重。  双向<span class="hljs-keyword">BFS优化模板</span><br><span class="hljs-keyword"></span><br>单词接龙 - 最小步数模型、双向 <span class="hljs-keyword">BFS </span>  同上 仔细分析搜索空间其实不是特别大  最多也就<span class="hljs-number">5</span>k个词<br>转化数字的最小运算数 - 最小步数模型、双向 <span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span>滑动谜题 - <span class="hljs-keyword">BFS、最小步数模型、A* </span>算法<br>访问所有节点的最短路径 - <span class="hljs-keyword">BFS、最小步数模型、A* </span>算法<br>为高尔夫比赛砍树 - <span class="hljs-keyword">BFS、A* </span>算法<br>使网格图至少有一条有效路径的最小代价 - 双端队列 <span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span>到达角落需要移除障碍物的最小数目 - 双端队列 <span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span><br></code></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a><strong>DFS</strong></h4><ul><li><p>存在问题，剪枝：搜索到了就直接<code>return true</code>   <a href="https://leetcode.cn/problems/word-search/">单词搜索</a> <a href="https://leetcode.cn/problems/matchsticks-to-square/">火柴拼正方形</a> <a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">划分为k个相等的子集</a></p></li><li><p>最优问题，剪枝：</p><ul><li><p>最大值：遍历全部 <a href="https://leetcode.cn/problems/path-with-maximum-gold/"> 黄金矿工</a></p></li><li><p>最小值：维护一个全局最小，当前值大于就剪枝 <a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">公平分发饼干</a>  <a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">完成所有工作的最短时间</a></p><p>  全排列问题需要记录数字是否使用  used<br>  组合问题需要按照搜索顺序  使用begin  如果可重复begin下次还是i 不可重复i+1；<br>  <a href="https://www.bilibili.com/video/BV1mG4y1A7Gu">https://www.bilibili.com/video/BV1mG4y1A7Gu</a><br>  枚举选哪个<br>  当前选或不选<br>      组合问题两种写法 <a href="https://leetcode.cn/problems/combinations/submissions/566429278/">https://leetcode.cn/problems/combinations/submissions/566429278/</a><br>  划分为 k 个相等的子集 从组成边角度，每一条边是组合问题begin标记，边与边之间需要用used标记</p></li><li><p>分配时，如果效果一样的化可以剪枝</p></li></ul></li></ul><p>​进入时修改状态，回溯后改回状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当前状态保存在传参中 now 和 idx</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []matchsticks, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> now, <span class="hljs-type">int</span> start)</span>&#123;<br><span class="hljs-comment">// 结束条件</span><br>    <span class="hljs-keyword">if</span>(idx == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(now == target) <span class="hljs-keyword">return</span> dfs(matchsticks, target, idx+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;matchsticks.length;i++)&#123;<br>        <span class="hljs-comment">// 遍历选择列表 过滤不满足的</span><br>        <span class="hljs-keyword">if</span>(i&gt;start &amp;&amp; matchsticks[i] == matchsticks[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(matchsticks[i]==-<span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(matchsticks[i] + now &gt; target) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 修改选择状态 并加入下一次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> matchsticks[i];<br>        matchsticks[i] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 存在类问题提前返回，如果是最优问题需要用最优值剪枝</span><br>        <span class="hljs-keyword">if</span> (dfs(matchsticks, target, idx, now + t, i+<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        matchsticks[i] = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>记忆化搜索</strong>： 自顶向下，并记录。可以改写dp</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">迷宫 - DFS、连通性模型、Flood Fill 算法<br>单词搜索 - DFS、搜索顺序、回溯<br>黄金矿工 - DFS、搜索顺序、回溯<br>火柴拼正方形 - DFS、回溯、剪枝 n=<span class="hljs-number">15</span>          数组组合成一个正方形，暴力遍历 <br><span class="hljs-number">1.</span>从组成边的角度出发：(<span class="hljs-number">2</span>^n)^k used标记 在组成某一条边时，是组合问题而不是排列！所以需要起始idx<br><span class="hljs-number">2.</span>从使用每一个数字出发： 每个数字可以放<span class="hljs-number">4</span>个位置 <span class="hljs-number">4</span>^n 剪枝：优先遍历大的数字，这样遍历空间更小 edge一样剪纸<br><span class="hljs-number">3.</span>状态压缩 + 动态规划<br><br>划分为 k 个相等的子集 - DFS、回溯、剪枝  k&lt;=<span class="hljs-number">16</span>    同上, 数组从划分<span class="hljs-number">4</span>个子数组改为k个<br><span class="hljs-number">1.</span>从组成子集角度 n!   对于每一个子集，是组合问题，需要使用<span class="hljs-keyword">begin</span>控制搜索<br><span class="hljs-number">2.</span>从使用每一个数字：k^n   超时！  加上edge[i+<span class="hljs-number">1</span>] == edge[i]优化可以过<br><br>公平分发饼干 - DFS、回溯、剪枝  n=k=<span class="hljs-number">8</span>   数组划分为k个，求划分使得最小化：max(sum(子数组)) 同下<br><span class="hljs-number">1.</span>无法从组成子集角度 <br><span class="hljs-number">2.</span>分配每一个数字即可, n=<span class="hljs-number">8</span>不需要剪枝<br><br>完成所有工作的最短时间 - DFS、回溯、剪枝  n=k=<span class="hljs-number">12</span>   数组划分为k个，求划分使得最小化：max(sum(子数组))<br><span class="hljs-number">1.</span>从分配每一个任务角度：k^n   超时！   剪枝：维护一个全局最优  降序排列<br>剪枝：默认dfs第一次会把任务全给<span class="hljs-number">0</span>号工人，其实是最差情况，我们希望分配平均一点<br> 优化<span class="hljs-number">1</span>：先用优先队列贪心求取出一个res，缩小dfs范围<br> 优化<span class="hljs-number">2</span>：edge[i+<span class="hljs-number">1</span>] == edge[i]时 二者等价  直接跳过<br> 优化<span class="hljs-number">3.</span> 优先分配给未分配的工人（和<span class="hljs-number">2</span>一样）; 因为未分配都一样，所以就分配给未分配的第一个人<br>     可以快速获得一个全局最优，并且去重。原来第一个任务分配给所有人，现在只给<span class="hljs-number">1</span><br> 优化<span class="hljs-number">4.</span> 对分配排序，每次取出最小的：问题<span class="hljs-number">1</span> 直接排序下一层影响这一层，使用idx<br>           问题<span class="hljs-number">2</span> 每次都排序复杂度太高了，排序行不通<br>     <br><span class="hljs-number">2.</span> 状态压缩 dp<br><span class="hljs-number">3.</span> 二分+转为存在问题<br><br>组合总和 组合出target  可重复使用，不考虑顺序   记录下list&lt;&gt;now 进入时<span class="hljs-keyword">add</span> 回溯时remove<br>全排列问题需要记录数字是否使用  used<br>组合问题需要按照搜索顺序  使用<span class="hljs-keyword">begin</span>  如果可重复<span class="hljs-keyword">begin</span>下次还是i 不可重复i+<span class="hljs-number">1</span><br><br>[<span class="hljs-number">40.</span> 组合总和 II] 需要去重  <span class="hljs-keyword">set</span>直接去重超时  改成排序后一次处理同一种数<br><br><br><br>划分为k个相等的子集 问题的组成每个子集角度，整体需要used标记，单个子集是组合问题需要<span class="hljs-keyword">begin</span>标记<br><br>矩阵中的最长递增路径 - DFS、记忆化搜索      模板<br>网格图中递增路径的数目 - DFS、记忆化搜索    模板  上面是最大长度，这里是求和<br>翻转游戏 II - DFS、状态压缩、记忆化搜索 你和朋友轮流将 连续 的两个 &quot;++&quot; 反转成 &quot;--&quot; 是否存在必胜<br>代码特别优雅，使用位运算实现字符串的改变<br>String nextState = state.substring(<span class="hljs-number">0</span>, i) + &quot;--&quot; + state.substring(i + <span class="hljs-number">2</span>);<br><br>    // 优化<br>    <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) == <span class="hljs-number">0</span> || (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>))) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dfs(mask ^ (<span class="hljs-number">1</span> &lt;&lt; i) ^ (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>)))) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <br>    <br>统计所有可行路径 - DFS、记忆化搜索    <br>模板，记录从 dp[i][fuel]  从 i并且有fuel燃料 到finish 有多少解法 sum dfs(j, fuel-<span class="hljs-keyword">cost</span>(i-&gt;j))<br>需要注意边界条件，如果i==finish，那么ans += <span class="hljs-number">1</span> 当前立即结束代表一种解法<br><br>改写成dp！！！  fuel 有大小关系所以在外层，注意dp的初始化<br><br>切披萨的方案数 - DFS、记忆化搜索+二维前缀和<br></code></pre></td></tr></table></figure><h3 id="4-DP"><a href="#4-DP" class="headerlink" title="4.DP"></a>4.DP</h3><p>dp有两种</p><ul><li>一种是当前状态由哪些状态转移来的(一般idx从n开始,方便改写dp，以及前缀和优化转移过程 <a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/submissions/568578185/">3251. 单调数组对的数目 </a>)</li><li>一种是当前状态可以转移出哪些状态 （买卖股票、<a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/submissions/568472363/">3251. 单调数组对的数目 II - 力扣（LeetCode）</a>，一般idx从0开始）</li></ul><p><a href="https://leetcode.cn/circle/discuss/tXLS3i/">分享丨【题单】动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划分&#x2F;区间&#x2F;状压&#x2F;数位&#x2F;树形&#x2F;数据结构优化） - 力扣（LeetCode）</a></p><ol><li><p>01背包</p><ul><li><p>dp：</p><ul><li>从使用每一个物品出发 0或1个  <a href="https://leetcode.cn/problems/target-sum/">目标和</a>  <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a>  <a href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a>  <a href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">将一个数字表示成幂的和的方案数</a> </li><li>保证从小的转移过来时， 二维循环可以交换</li></ul></li><li><p>记忆化：当前物品有选和不选两种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dfs(now+nums[idx], idx+<span class="hljs-number">1</span>);<br>dfs(now, idx+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>完全背包</p><ul><li><p>dp：</p><ul><li>从使用每一个物品出发，x个<code>dp[i][j] = 最优 dp[i-1][j-x * [w]]</code>  -&gt; 优化为当前层取值   -&gt;  优化为1维</li><li>从组成的数出发，可重复使用的物品循环在内。 <a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a>  ； <a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>  <a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a> dp只有一维（不考虑顺序可从完全背包出发， 但组合总数考虑了所有不可以）</li></ul></li><li><p>记忆化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">从使用每一个物品出发  选了但idx不变<br>dfs(idx-<span class="hljs-number">1</span>, target);<br>dfs(idx, target-coins[idx]);<br><br><br>从组成的数出发<br><span class="hljs-keyword">for</span> i in n:<br>dfs(target-nums[i]);<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>找到所有可能的解决方案一般要dfs <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs inform7">杨辉三角 - 线性 DP、数字三角形模型<br>最小路径和 - 线性 DP、数字三角形模型<br><br>摘樱桃 - 线性 DP、数字三角形模型  ×<br><br>摘樱桃 II - 线性 DP、数字三角形模型<br><br>最长递增子序列 - 线性 DP、最长上升子序列模型<br>暴力：查找前面所有的<br>优化：如果当前长度为5，并且结尾字符比以前的长度为5的结尾字符小，那么以前的就被忽略了，有点像单调栈<br>所以每一个长度只需要保存一个结尾字符最小的就行了。<br>长度越长结尾字符肯定越大，用二分查找哪一个长度的字符刚好比现在小<br><br>无重叠区间 - 线性 DP、最长上升子序列模型、贪心优化<br>dp：以当前区间结尾的 无重复区间数，和上面一样可以用二分优化<br><br>删列造序 III - 线性 DP、最长上升子序列模型<br><br>俄罗斯套娃信封问题 - 线性 DP、最长上升子序列模型、贪心优化<br><br>堆叠长方体的最大高度 - 排序、线性 DP、最长上升子序列模型<br>无矛盾的最佳球队 - 排序、线性 DP、最长上升子序列模型<br><br><br>最长公共子序列 - 线性 DP、最长公共子序列模型<br>两个字符串的最小 ASCII 删除和 - 线性 DP、最长公共子序列模型<br>两个字符串的删除操作 - 线性 DP、最长公共子序列模型<br><br>目标和 - 0-1 背包问题<br>数组前面添加+ 或 -， 最后凑出目标的方案数<br>方法1：dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>  前i个数凑出j-1000的方案个数<br>init: dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1000]</span> = 1; return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[target+1000]</span>;<br>方法2：负号和为x。sum - 2x = target。 数组中凑出(sum-target)/2的方案数<br>   dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 前i个数和为j的方案数(可以不选) <br>    init: dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;  return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[target]</span><br>方案3：dfs暴力 2^n^   <br><br>   <br>分割等和子集 - 0-1 背包问题  是否存在使得划分两个集合sum相等  计算方案会溢出<br><br>最后一块石头的重量 II - 0-1 背包问题  分成两堆 sum差值最小<br><br>零钱兑换 - 完全背包问题 给出零钱面值数组(可重复)，凑出target的最小数量<br>1.完全背包 f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 前i种零钱凑出j<br>2.普通背包问题 f<span class="hljs-comment">[i]</span> 凑出i的硬币数量。从n种状态种选出最优<br>3.记忆化搜索 从上到下 定义什么时候终止 什么状态为求出来了 求出来中什么状态无解  同样有两种<br><br>组合总和 Ⅳ - 完全背包问题  数组中凑出target方案数  <br>不考虑顺序是完全背包问题  <br>考虑顺序为f<span class="hljs-comment">[i]</span>凑出i的方案数，从n种状态种选出最优<br><br><br>从栈中取出 K 个硬币的最大面值和 - 分组背包问题<br><br>数字 1 的个数 - 数位 DP、记忆化搜索<br><br>统计各位数字都不同的数字个数 - 数位 DP、记忆化搜索、状态压缩<br><br>不含连续 1 的非负整数 - 数位 DP、记忆化搜索<br><br>旋转数字 - 数位 DP、记忆化搜索<br>最大为 N 的数字组合 - 数位 DP、记忆化搜索<br>统计特殊整数 - 数位 DP、记忆化搜索<br><br>买卖股票的最佳时机 <br>II  无限制次数 ，记忆化idx flag<br>III IIII 限制次数，记忆化idx left flag，map记忆化比数组慢快10倍<br>冷冻期 idx state(无 持有 冷冻)<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-number">139</span>. 单词拆分 使用给定<span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> 拼接出<span class="hljs-selector-tag">s</span>，能不能拼接出来<br><span class="hljs-number">2707</span>. 字符串中的额外字符 同上，但目标是剩余字符最少  <span class="hljs-selector-tag">dp</span><span class="hljs-selector-attr">[i]</span>: <span class="hljs-number">0</span>~<span class="hljs-selector-tag">i</span>  暴力<span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">trie</span> || 字符串<span class="hljs-selector-tag">hash</span>优化查找字符串<br></code></pre></td></tr></table></figure><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><ul><li><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a>  凑出target<ul><li>考虑顺序，不可以用完全背包</li><li>dfs(x)  从最后一个数转移</li></ul></li><li><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组 - 力扣（LeetCode）</a>   保持两种最优状态</li><li><a href="https://leetcode.cn/problems/count-number-of-texts/">2266. 统计打字方案数 - 力扣（LeetCode）</a>  分解子问题</li><li><a href="https://leetcode.cn/problems/find-the-k-th-character-in-string-game-ii/description/">3307. 找出第 K 个字符 II - 力扣（LeetCode）</a>  分解子问题</li></ul><h4 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h4><ul><li><a href="https://leetcode.cn/problems/pascals-triangle/description/">118. 杨辉三角 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/minimum-path-sum/description/">64. 最小路径和 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/">329. 矩阵中的最长递增路径 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/description/">2328. 网格图中递增路径的数目 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/minimum-falling-path-sum-ii/">1289. 下降路径最小和 II - 力扣（LeetCode）</a>  n^3   -&gt; 维护最优和次优状态 </li><li><a href="https://leetcode.cn/problems/cherry-pickup/description/">741. 摘樱桃 - 力扣（LeetCode）</a></li></ul><h4 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h4><h5 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h5><p>一些物品 选或者不选；<code>dp[i][j] = Math.max(dp[i][j], dp[i-1][j-nums[i-1]]);</code> -&gt; 优化为逆序1维</p><ul><li><a href="https://leetcode.cn/problems/target-sum/">目标和</a>  选或者不选，凑出目标的方案数 <code>dfs(target, nums.length-1);</code>  前idx个数 凑出的方案</li><li><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a>   能否凑出  <code>dfs(target, nums.length-1);</code>  前idx个数 能否凑出target</li><li><a href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a>  凑出的最大长度 <code>dfs(target, nums.length-1);</code>  前idx个数 凑出target最大长度</li><li><a href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">将一个数字表示成幂的和的方案数</a>  <code>dfs(target, nums.length-1)</code> 前idx个数 凑出target的方案</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">取或者不取<br>前idx个数，拼接出target <span class="hljs-comment">// 也可也从0开始，dfs含义为idx~n-1个数的结果</span><br>dfs(nums, idx-<span class="hljs-number">1</span>, target);<br>dfs(nums, idx-<span class="hljs-number">1</span>, target-nums.get(idx));<br><br>递归终点 -<span class="hljs-number">1</span>  <br>    方案数  有效 <span class="hljs-number">1</span>  无效<span class="hljs-number">0</span><br>    最值 有效<span class="hljs-number">0</span> 无效inf<br>    能否 有效<span class="hljs-number">1</span> 无效<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><ul><li>从使用每一个物品出发，x个<code>dp[i][j] = 最优 dp[i-1][j-x * [w]]</code>  -&gt; 优化为当前层取值   -&gt;  优化为1维</li><li>从组成的数出发，可重复使用的物品循环在内。</li></ul><p>不考虑顺序，完全背包</p><ul><li><p><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>  </p><ul><li><p>前i种零钱凑出j；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">记忆化，前idx个元素，凑出amount的最少数量<br><br>dfs(coins, idx-<span class="hljs-number">1</span>, amount);<br><span class="hljs-number">1</span> + dfs(coins, idx, amount-coins[idx]); <span class="hljs-comment">// 选了但idx不变</span><br></code></pre></td></tr></table></figure></li><li><p>也可也从普通dp问题：f[i] 凑出i的硬币数量。从n种状态种选出最优</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    t = Math.min(t, dfs(coins, amount - coins[i]));<br>&#125;<br>t++;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></p></li></ul><p>考虑顺序，从使用的最后一个数出发, 因为考虑顺序，不可以用完全背包解决</p><ul><li><a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a></li></ul><h4 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h4><ul><li>记忆化从idx&#x3D;0或者n-1开始记忆化都可以，本质都一样（只是看数组的方向变了）</li><li><strong>当前结束状态</strong>和<strong>当前进入状态</strong> 有较大区别，1比较通用，2有时比较好理解<ol><li>当前结束状态（通常n-1开始） 更方便改写dp（前缀和优化 <a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/description/">3251</a> 、空间优化、二分优化） ，需要逆向思考<strong>状态转移方程</strong></li><li>进入状态（0开始 ） 更方便理解 （最长子序列、<a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/description/">3098</a> 、<a href="https://leetcode.cn/problems/count-number-of-special-subsequences/submissions/570562800/">1955. 012数组个数</a>） ，从最初始的状态 <strong>按照题目逻辑</strong> 转移到后续状态</li></ol><ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/submissions/570468057/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a>  </li><li><a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/submissions/570522662/">3251. 单调数组对的数目 II - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/submissions/570561616/">1911. 最大子序列交替和 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/count-number-of-special-subsequences/submissions/570562800/">1955. 012数组个数</a> </li><li><a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/description/">1911. 最大子序列交替和 - 力扣（LeetCode）</a></li></ul></li></ul><p>相邻相关 最长上升子序列  需要多保存一个相邻关系（可以理解为状态）</p><ul><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/submissions/562282284/">300. 最长递增子序列 - 力扣（LeetCode）</a><ul><li>暴力记忆化时 <code>dfs(idx, pre)</code>，用hashmap会超时  在使用idx~n-1，且pre情况下的最长长度</li><li>或者<code>dfs(idx, next)</code> 在使用0~idx, 且next情况下的最长长度</li></ul></li><li><a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/description/">3098. 求出所有子序列的能量和 - 力扣（LeetCode）</a>  <a href="https://www.bilibili.com/video/BV19t421g7Pd">https://www.bilibili.com/video/BV19t421g7Pd</a><ul><li><code>dfs(idx, pre, minnow, lennow)  n * n * n^2 * k</code>  在使用0~idx，且pre情况下的值</li><li>选或不选、枚举选哪个 都可以</li></ul></li><li><a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/description/">3251. 单调数组对的数目 II - 力扣（LeetCode）</a> 拆分成一个递增一个递减数组  <a href="https://www.bilibili.com/video/BV1Cf421v7Ky">bili</a><ul><li>需要保存上一个数是什么，有点像状态dp  <code>dfs(idx, pre1)</code> 在下一个数取了pre1的情况下, 0~idx的方案数</li><li>不好改写dp，换第二种记忆化（当前值）<code>dfs(idx, j)</code> 在idx取了j的情况下 0~idx的方案数</li><li>改写成dp后，前缀和优化</li></ul></li><li><a href="https://leetcode.cn/problems/count-number-of-special-subsequences/submissions/570562800/">1955. 012数组个数</a> <ul><li><code>dfs(nums, 0, 0)</code>  从idx&#x3D;0开始，初始state&#x3D;0表示不包含0, 从初始状态转移到其他状态</li><li><code>dfs(nums, n-1, 2)</code>   前n-1个数，且由（state&#x3D;0 0；state&#x3D;1 01； state&#x3D;2 012）组成的子序列   更难获得状态转移方程</li></ul></li><li>一个字符串，每次可以将char+1，求<strong>最小</strong>操作使得任意两个相邻的字符不同 <ul><li><code>dfs(idx, pre)</code>0~idx且下一个是pre需要的操作次数</li><li>同样不好改dp，  修改为  <code>dfs(idx, now)</code>0~idx且当前为now字符的情况下，的最值</li><li><a href="https://mp.weixin.qq.com/s/DIfwTtXarjktN5BYMWMgUQ">9月22日字节跳动校招机试题目+题解+在线测试 (qq.com)</a></li></ul></li></ul><p><code>dp[i][j] 为s[:i] 和t[:j] 的结果</code>， 转移考虑最后一个i j</p><ul><li><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a>  <code>dfs(i, j)</code>  前i和前j</li><li><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/">712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a>  <code>dfs(i, j)</code>  前i和前j</li><li>两个数组取出k个相乘，值最大  </li><li><code>dfs(i, j, k)</code> arr1前i个和arr2前j个，还剩下k个；这题中j和k相等</li><li>dp，注意溢出，key选择string可以，List作为key会超时</li></ul><h4 id="状态dp"><a href="#状态dp" class="headerlink" title="状态dp"></a>状态dp</h4><ul><li>买卖股票  从右往左思考且是结束的状态，更方便改写dp ；之前自己写是从左往右+进入状态<ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a>  无限制次数 ，记忆化<code>dfs(idx, flag)</code>  0~idx -1, 第idx天结束状态为flag</li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a>   <code>dfs(idx, state(无 持有 冷冻))</code></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/submissions/570470696/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a>  限制次数  <code>dfs(idx, state(无 持有), left)</code></li></ul></li><li><a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/description/">1911. 最大子序列交替和 - 力扣（LeetCode）</a>  <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 的最大值 <ul><li>进入状态 <code>dfs(idx, state)</code>  idx ~ n       且 state&#x3D;0 下一个数为+、  1 下一个为-</li><li>最终状态  <code>dfs(idx, state)</code>  前idx个数 且 state&#x3D;0 偶数个数、  1 奇数个数</li><li>对比：<a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/submissions/570561616/">1911. 最大子序列交替和 - 力扣（LeetCode）</a></li></ul></li></ul><h2 id="题单刷"><a href="#题单刷" class="headerlink" title="题单刷"></a>题单刷</h2><p><a href="https://leetcode.cn/circle/discuss/RvFUtj/">分享｜如何科学刷题？ - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/circle/discuss/mOr1u6/">分享丨【题单】常用数据结构（前缀和&#x2F;差分&#x2F;栈&#x2F;队列&#x2F;堆&#x2F;字典树&#x2F;并查集&#x2F;树状数组&#x2F;线段树） - 力扣（LeetCode）</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="周赛补题"><a href="#周赛补题" class="headerlink" title="周赛补题"></a>周赛补题</h3><p><a href="https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/">3097. 或值至少为 K 的最短子数组 II</a>：长度最小且或后大于k的子数组；和求sum很相似</p><ul><li><strong>暴力</strong>：以每一个i结尾，往前找left超时；<strong>双指针优化</strong>，但和求和不同，求和left移动直接减就行，这里需要记录下每一位1的个数</li><li>还是暴力每一个结尾i，但以i结尾能筹出来的或最多32个，也就是i -&gt; i+1的转换为O32的，而不是On的，这和求和不同</li></ul><p><a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/">3098. 求出所有子序列的能量和</a>：</p><ul><li>子序列<ul><li>相邻无关 01背包</li><li>相邻相关 最长上升子序列  多一个相邻关系</li></ul></li><li>排序后，dfs  -&gt; 记忆化优化  50^5  但有一些系数的减小（变量有大小关系，相当于在求组合数，组合数下面有阶乘系数）</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">给你一个长度为 <span class="hljs-built_in">n</span> &lt; <span class="hljs-number">50</span> 的整数数组 nums 和一个 正 整数 k 。<br><br>一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。<br><br>请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。<br><br>由于答案可能会很大，将答案对 <span class="hljs-number">109</span> + <span class="hljs-number">7</span> 取余 后返回。<br><br><br>dfs(idx, pre, minnow, lennow)  <span class="hljs-built_in">n</span> * <span class="hljs-built_in">n</span> * <span class="hljs-built_in">n</span>^<span class="hljs-number">2</span> * k<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-cost-walk-in-weighted-graph/">100244. 带权图里旅途的最小代价</a>: 图中两点距离为 &amp; 值，求x y之间的最小距离，可以重复访问</p><ul><li><strong>and是越多越小</strong>，所以尽量访问x和y之间全部的边，因此一个连通块为一个结果</li><li>并查集 or  dfs</li><li>初始化数组太大会超时，n或者只大max一点</li></ul><p><a href="https://leetcode.cn/problems/maximum-multiplication-score/description/">3290. 最高乘法得分 - 力扣（LeetCode）</a></p><ul><li>dp，注意溢出，key选择string可以，List作为key会超时</li></ul><p><a href="https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-i/description/">3291. 形成目标字符串需要的最少字符串数 I - 力扣（LeetCode）</a></p><ul><li>记忆化搜索 dfs(i)代表从i~n-1需要多少个字符，但由于每次需要尝试n次，n^2复杂度</li><li>改成跳跃游戏；如何求每一个idx可以到达的最长长度？ 二分长度 + 字符串hash（字符串普通hash是On的，字符串hash是O1比较）</li></ul><p><a href="https://leetcode.cn/contest/weekly-contest-410/problems/find-the-count-of-monotonic-pairs-ii/">Q4. 单调数组对的数目 II</a>：将数组nums[] 拆分成一个递增的 一个递减的</p><ul><li>经典子序列题，记忆化解决  可以从当前状态可以推出哪些，也可也从转移，转移才可以改写dp优化</li><li>改写成dp后，前缀和优化</li></ul><p><a href="https://leetcode.cn/problems/find-the-k-th-character-in-string-game-ii/description/">3307. 找出第 K 个字符 II - 力扣（LeetCode）</a></p><ul><li>拆分成子问题</li></ul><h3 id="非递归快排"><a href="#非递归快排" class="headerlink" title="非递归快排"></a>非递归快排</h3><p>用栈模拟递归保存排序区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort_no_Recursion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] q)</span>&#123;<br>        ArrayDeque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        st.push(<span class="hljs-number">0</span>);<br>        st.push(q.length-<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-type">int</span> l, r, x, i, j;<br>        <span class="hljs-keyword">while</span>(st.size() != <span class="hljs-number">0</span>)&#123;<br>            <br>            r = st.pop();<br>            l = st.pop();<br>            <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">continue</span>;<br>            <br>            x = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>        <br>            i = l-<span class="hljs-number">1</span>; j = r+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>                i++; <span class="hljs-keyword">while</span>(q[i] &lt; x) i++;<br>                j--; <span class="hljs-keyword">while</span>(q[j] &gt; x) j--;<br>                <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[i];<br>                    q[i] = q[j];<br>                    q[j] = t;<br>                &#125;<br>            &#125;<br>            <br>            st.push(l);<br>            st.push(j);<br>            <br>            st.push(j+<span class="hljs-number">1</span>);<br>            st.push(r);<br>            <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="非递归中序"><a href="#非递归中序" class="headerlink" title="非递归中序"></a>非递归中序</h3><p>染色来标记是否是第一次遇到，先序可以不用染色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;Node&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Node&gt;();<br><br>    deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(root, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">while</span>(deque.size() &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> deque.pollLast();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tmp.root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> tmp.flag;<br>        <span class="hljs-keyword">if</span>(r == <span class="hljs-literal">null</span>)<span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;<br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(r.right, <span class="hljs-number">0</span>));<br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(r, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 放最上面就是后续  最下面就是先序</span><br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(r.left, <span class="hljs-number">0</span>));<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res.add(r.val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a>: 矩阵快速幂</p><h3 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 预处理字符串，插入特殊字符以便处理偶数长度回文</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 转换后的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// p[i]表示以i为中心的回文半径</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前最右的回文的中心和右边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大的回文长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCenter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大回文中心</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 如果i在当前最右回文的范围内，使用之前的对称性加速</span><br>            <span class="hljs-keyword">if</span> (i &lt; right) &#123;<br>                p[i] = Math.min(right - i, p[<span class="hljs-number">2</span> * center - i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 尝试扩展以i为中心的回文串</span><br>            <span class="hljs-keyword">while</span> (i - p[i] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; i + p[i] + <span class="hljs-number">1</span> &lt; n &amp;&amp; str.charAt(i - p[i] - <span class="hljs-number">1</span>) == str.charAt(i + p[i] + <span class="hljs-number">1</span>)) &#123;<br>                p[i]++;<br>            &#125;<br><br>            <span class="hljs-comment">// 更新右边界和中心</span><br>            <span class="hljs-keyword">if</span> (i + p[i] &gt; right) &#123;<br>                center = i;<br>                right = i + p[i];<br>            &#125;<br><br>            <span class="hljs-comment">// 更新最大回文长度和中心</span><br>            <span class="hljs-keyword">if</span> (p[i] &gt; maxLen) &#123;<br>                maxLen = p[i];<br>                maxCenter = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 从原始字符串中提取最长回文子串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> (maxCenter - maxLen) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 起始位置 (注意去掉#号)</span><br>        <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h4 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>String[] line = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br><br>n = Integer.parseInt(line[<span class="hljs-number">0</span>]);<br>m = Integer.parseInt(line[<span class="hljs-number">1</span>]);<br><br><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out));<br>out.println();<br>out.flush();<br></code></pre></td></tr></table></figure><p><code>stringbuilder</code>删除的时候，从后往前删防止影响，传入整数自动转为字符串</p><p><code>new Integer(&#39;0&#39;)</code>  得到的是ASCII， char可以自动转integer，反过来不行 <code>new Character((char) 48)</code></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">set去重<br>Set&lt;List&lt;Integer&gt;&gt;  使用里面元素的equal  默认ArrayList 是一个一个对比 但<span class="hljs-type">int</span>[]是比较地址<br><br><span class="hljs-type">char</span>加上一个<span class="hljs-type">int</span>需要强转 <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + j);<br><br><br>数组初始化，此外对应<span class="hljs-type">int</span>，里面默认值为<span class="hljs-number">0</span>，如果是object，还需要额外<span class="hljs-keyword">new</span>  <span class="hljs-title class_">left</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][<span class="hljs-number">2</span>];  <span class="hljs-comment">// 26 行 2 列的二维数组</span><br>System.out.println(left[<span class="hljs-number">0</span>].length);  <span class="hljs-comment">// 输出 2</span><br><br>    <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][]; <span class="hljs-comment">// 锯齿数组</span><br>    System.out.println(left[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 输出 null，因为还没有为第 0 行分配列</span><br>    left[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 手动为第 0 行分配 2 列</span><br>    left[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];  <span class="hljs-comment">// 手动为第 1 行分配 3 列</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">数组    .length  <br>String  .length()<br>List    .size()<br><br><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][]; <span class="hljs-comment">// 3行的二维数组，但每行的列数不定  内存不连续</span><br><br><br>Arrays:<br>    sort(a);     <span class="hljs-comment">// 对于非基本类 第二个参数可以传入比较方法，见 后面</span><br>binarySearch(a, key);  binarySearch(a, start, end, key);   不包括end<br>Collections.binarySearch(list, key);<br>fill(a, value);<br>a2 = copyOf(a1, a1.length);<br>toString() <span class="hljs-comment">// 打印</span><br>        <br>Arrays.stream(a).sum();<br>Arrays.stream(a).max().getAsInt();<br><br>object[]转List： <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(ints))<br>        反过来 ints = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][]) <span class="hljs-comment">//这里是二维的 list中存放 &lt;int[]&gt; 带参方法 56.</span><br><span class="hljs-type">int</span>[] 转List ：  <br>         Arrays.stream(a).boxed().collect(Collectors.toList());    <span class="hljs-comment">//需要装箱</span><br>integerList.stream().mapToInt(Integer::intValue).toArray();<br><br>隐式强转可以小转大，大转小需要显式并且不能溢出<br><br>    <br>java 包含声明和创建<br>    变量的声明通常在栈内存中完成<br>    创建通常为<span class="hljs-keyword">new</span>在堆中完成，返回堆内存地址<br>    <br>Object[] arr:申明数组类型变量时，为其分配了（<span class="hljs-number">32</span>位）引用空间 栈中，由于未赋值，因此并不指向任何对象<br>    <br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>]  堆中创建一个长度为<span class="hljs-number">10</span>的Object 类型数组对象(也是对象)，分配了<span class="hljs-number">10</span>个连续的内存空间，各自占用（<span class="hljs-number">32</span>位的）Object用空间，但现在默认指向<span class="hljs-literal">null</span><br>    <br>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() 在堆中为 Object 类型的对象分配一段内存空间，将引用存储在arr[i]<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>重写排序，<code>Array.sorts(a)</code> 排序数组同理。注意int不能重写，需要逆序就先排序再反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList：<br>    方法一：直接传一个函数，原理还是下面 FunctionalInterface<br>        nums.sort( (x, y) -&gt; x - y ); <span class="hljs-comment">// integer</span><br>            nums.sort(persons, (p1, p2) -&gt; p2.getAge() - p1.getAge());  <span class="hljs-comment">// 方便 </span><br>   nums.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 数组</span><br>方法二：传一个Comparator类对象，比较时调用Comparator.compare<br>            nums.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                    <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>                &#125;<br>            &#125;)<br>    方法三：类重写接口方法<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyClass&gt;&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyClass other)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.priority, other.priority);<br>            &#125;<br>&#125;<br><br><br><br>或者对于List<br>Collections.sort(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">栈 底层数组，适合两端插入删除；LinkedList是链表<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();  或 Stack<br>.isEmpty() .peek() .pop() .push(num)<br><br>队列  在栈中pop push都是从First操作，因此我代码也在first加入，但严格来说队列是队尾插入<br>.addFirst  .addLast<br>.peekFirst .peekLast<br>.pollFirst .pollLast<br>    <br>map 遍历 <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) map.forEach((key, value) -&gt; sout)<br>    <br>优先队列 PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <span class="hljs-comment">// 自己的类同sort方法 默认小根堆</span><br><span class="hljs-comment">// (a, b) -&gt; a.getValue() - b.getValue() 小根堆</span><br>pq.offer(<span class="hljs-number">3</span>); add()<br> pq.peek();<br>pq.poll();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">console</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(T... input)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (T i: input) &#123;<br>            sb.append(i.toString());<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        System.out.println(sb.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重写hashmap"><a href="#重写hashmap" class="headerlink" title="重写hashmap"></a>重写hashmap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    TreeNode t;<br>    <span class="hljs-type">int</span> state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(TreeNode t, <span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (Node) o;<br>        <span class="hljs-keyword">return</span> t == x.t &amp;&amp; state == x.state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(t, state);  <span class="hljs-comment">// 使用 Objects.hash() 生成基于 t 和 state 的哈希值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="randomfile"><a href="#randomfile" class="headerlink" title="randomfile"></a>randomfile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">randomAccess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(filepath, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = ...<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.write(buffer);<br><br>randomAccess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(filepath, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[pageSize]<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.read(buffer);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapPage</span>((HeapPageId) pid, buffer);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图网络入门</title>
    <link href="/2023/05/26/dl/GNN-base/"/>
    <url>/2023/05/26/dl/GNN-base/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章介绍了图神经网络（GNN）的基础概念和实现方法。主要内容包括：  1. <strong>图的表示方式</strong>：介绍了邻接矩阵和邻接表两种表示方法，并分析了它们在空间效率和稀疏性上的差异。顶点、边和全局信息可以用向量表示，而连接信息通过邻接结构体现。  2. <strong>图数据的应用场景</strong>：讨论了图片、文本、分子结构和社交网络等不同类型的数据如何用图表示，并展示了图级别（如判断环路）、节点级别（如社交网络中的影响力分析）和边级别（如物体关系判断）的任务示例。  3. <strong>GNN的核心机制</strong>：通过消息传递神经网络（MPNN）实现层间信息传递，置换不变性是关键特性。文章强调聚合操作（如池化）和邻域聚合（如GCN）的作用，包括点边信息的交互更新和引入全局节点（master node）以解决长距离依赖问题。  4. <strong>实现细节与优化</strong>：提供了PyTorch的GCN实现代码示例，涵盖邻接矩阵归一化、自环添加和多层传播过程。还讨论了超参数选择（如嵌入维度、层数）和注意力机制（如加权聚合与内积评分）。  5. <strong>扩展与改进</strong>：提到了超图、随机游走采样等技术，以及如何通过增加复杂特征（如边与全局信息的融合）提升模型表现力。</p></blockquote><p><a href="https://distill.pub/2021/gnn-intro/">https://distill.pub/2021/gnn-intro/</a></p><ul><li>图的矩阵表示<ul><li>邻接矩阵</li><li>邻接表：稀疏性</li></ul></li><li>聚合操作：实现层间的信息传递<ul><li>层内：池化</li><li>层间：GCN邻域聚合、考虑邻接节点的权重（attention）  先采样再聚合</li></ul></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056327.png" alt="image-20230524214233460"></p><p>什么数据会用图表示  图数据有什么特点区别，构建一个GNN，提供一个GNN playground</p><h3 id="图表示"><a href="#图表示" class="headerlink" title="图表示"></a>图表示</h3><p>顶点、边、全局  用向量来表示。内部有信息，通过向量存储</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056329.png" alt="image-20230524214810624"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056330.png" alt="image-20230524215123040"></p><h3 id="什么能被表示为图"><a href="#什么能被表示为图" class="headerlink" title="什么能被表示为图"></a>什么能被表示为图</h3><p><strong>图片表示为图</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056331.png" alt="image-20230524215156969"></p><p><strong>文本</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056332.png" alt="image-20230524215642756"></p><p><strong>分子 Molecules</strong> </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056333.png" alt="image-20230525095851988"></p><p><strong>社交关系图</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056334.png" alt="image-20230524215744881"></p><h3 id="引出什么问题"><a href="#引出什么问题" class="headerlink" title="引出什么问题"></a>引出什么问题</h3><p>graph-level, node-level, and edge-level</p><ul><li>对整个图判断：是否有环</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056335.png" alt="image-20230525100550222" style="zoom:50%;" /><ul><li>对顶点判断：社交网络有两个老师分开了，学生跟随谁</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056336.png" alt="image-20230525100534543" style="zoom:50%;" /><ul><li>对边判断：顶点是图中的物体，判断物体和物体间关系</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056337.png" alt="image-20230525100522460" style="zoom:50%;" /><h3 id="represent-graphs"><a href="#represent-graphs" class="headerlink" title="represent graphs"></a>represent graphs</h3><ul><li><strong>顶点 边 全局信息</strong>：直接用向量，比较简单</li><li><strong>连接信息</strong>：邻接矩阵，比较大浪费空间、同一图交换两行会影响矩阵形状；邻接表</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056338.png" alt="image-20230524220829767" style="zoom:67%;" /><p>这里用标量表示的，可替换向量</p><h3 id="GNN："><a href="#GNN：" class="headerlink" title="GNN："></a>GNN：</h3><p><strong>Define</strong>：对顶点、边、全局进行变换，变换满足置换不变性。输入输出都是图，对顶点、边进行变化但不改变连接性</p><p>message passing neural network</p><p>通过MLP更新顶点向量，最后对单个顶点的向量就可以通过softmax分类</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056339.png" alt="image-20230524221712195"></p><h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p>可能点没有信息，但边有，在最后一层pool。pool: 边-&gt;点   。同理可以点到边</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056340.png"></p><h4 id="Passing-messages"><a href="#Passing-messages" class="headerlink" title="Passing messages"></a>Passing messages</h4><p>问题：我们没有使用图的信息(除了最后一次)，顶点和哪些边相连的。我想在GNN层中使用池化来做出更复杂的预测</p><h5 id="点-点-或-边-边"><a href="#点-点-或-边-边" class="headerlink" title="点-点 或 边-边"></a>点-点 或 边-边</h5><p>消息传递：进入mlp前，当前顶点会加上所有相邻的点，如果很多层就可以看到全局的点，如第一张图所示（像感受野）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056341.png" alt="image-20230524222021997"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056342.png" alt="image-20230525094552106"></p><h5 id="点-边"><a href="#点-边" class="headerlink" title="点-边"></a>点-边</h5><p>顶点信息给边，再给边信息给点（相加、concat）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056343.png" alt="image-20230524222504445"></p><h5 id="全局信息"><a href="#全局信息" class="headerlink" title="全局信息"></a>全局信息</h5><p>解决很远的节点间的消息传递问题</p><p>master node：<strong>和所有点和边相连</strong> 包含全局信息，更新时需要点边信息，点边更新时会额外加入全局</p><p>先更E(包含V，U)，再更新点（包含E，U），最后更新U（包含V，E）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056344.png" alt="image-20230524224543319"></p><h3 id="PlayGround"><a href="#PlayGround" class="headerlink" title="PlayGround"></a>PlayGround</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056345.png" alt="image-20230525104435625"></p><p><strong>hyperparameters</strong>：</p><ul><li><p>Style of message passing   明显全部消息传递效果最优</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056347.png" alt="image-20230525104737176"></p></li><li><p>the dimensionality of embeddings</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056348.png" alt="image-20230525104343737"></p></li><li><p>number of layers</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056349.png" alt="image-20230525104804863"></p></li><li><p>aggregation operation type</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056350.png" alt="image-20230525104615998"></p></li></ul><h3 id="Into-the-Weeds"><a href="#Into-the-Weeds" class="headerlink" title="Into the Weeds"></a>Into the Weeds</h3><h4 id="Other-types-of-graphs"><a href="#Other-types-of-graphs" class="headerlink" title="**Other types of graphs **"></a>**Other types of graphs **</h4><p><strong>(multigraphs, hypergraphs, hypernodes, hierarchical graphs)</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056351.png" alt="image-20230525110752250"></p><h4 id="Sampling-Graphs-and-Batching"><a href="#Sampling-Graphs-and-Batching" class="headerlink" title="Sampling Graphs and Batching"></a><strong>Sampling Graphs and Batching</strong></h4><p>随机子图，随机游走多少步，随机游走再加邻居，单点BFS多少步</p><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a><strong>GCN</strong></h4><p><code>GCNConv</code> 是 PyTorch Geometric 中实现 GCN 的模块，它的内部实现如下：<code>GCNConv(x, edge_index)</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056352.png" alt="image-20230525213032091"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GCN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, hidden_dim, output_dim</span>):<br>        <span class="hljs-built_in">super</span>(GCN, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.fc1 = nn.Linear(input_dim, hidden_dim)<br>        <span class="hljs-variable language_">self</span>.fc2 = nn.Linear(hidden_dim, output_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, adj</span>):<br>        <span class="hljs-comment"># 计算规范化的邻接矩阵</span><br>        adj = adj + torch.eye(adj.size(<span class="hljs-number">0</span>))  <span class="hljs-comment"># 加上自环</span><br>        degree = torch.<span class="hljs-built_in">sum</span>(adj, dim=<span class="hljs-number">1</span>)<br>        degree_sqrt = torch.sqrt(degree)<br>        adj_normalized = adj / degree_sqrt.unsqueeze(<span class="hljs-number">1</span>) / degree_sqrt.unsqueeze(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 计算GCN层的输出</span><br>        x = <span class="hljs-variable language_">self</span>.fc1(adj_normalized @ x)<br>        x = torch.relu(x)<br>        x = <span class="hljs-variable language_">self</span>.fc2(adj_normalized @ x)<br><br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 定义输入数据和邻接矩阵</span><br>x = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 10个节点，每个节点5维特征</span><br>adj = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 10个节点的邻接矩阵</span><br><br><span class="hljs-comment"># 创建GCN网络实例</span><br>gcn = GCN(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 输入特征维度为5，隐藏层维度为10，输出维度为2</span><br><br><span class="hljs-comment"># 计算GCN的输出</span><br>output = gcn(x, adj)<br><br><span class="hljs-comment"># 定义损失函数和优化器</span><br>criterion = nn.CrossEntropyLoss()<br>optimizer = torch.optim.Adam(gcn.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># 训练GCN网络</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    optimizer.zero_grad()<br>    output = gcn(x, adj)<br>    loss = criterion(output, torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]))  <span class="hljs-comment"># 10个节点分为两类</span><br>    loss.backward()<br>    optimizer.step()<br><br></code></pre></td></tr></table></figure><h4 id="Graph-Attention-Networks"><a href="#Graph-Attention-Networks" class="headerlink" title="Graph Attention Networks"></a><strong>Graph Attention Networks</strong></h4><p>当我们考虑一个节点及其1度相邻节点的和聚合时，我们也可以考虑使用加权和</p><p>常用的评分函数是<strong>内积</strong>，评分前常通过<strong>线性映射</strong>将节点转换为查询和关键向量，以提高评分机制的表现力。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056353.png" alt="image-20230525111909292"></p><p>a(l)代表着注意力分数向量；W(l)是对当前层特征做一个映射，相当于一个MLP</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261056354.png" alt="image-20230525122735492"></p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>GNN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习NLP</title>
    <link href="/2023/05/23/dl/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0NLP/"/>
    <url>/2023/05/23/dl/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0NLP/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要介绍了GoogLeNet（Inception）网络的结构和特点。GoogLeNet是由Google团队提出的一种深度卷积神经网络，以其高效的计算性能和优异的分类能力而闻名。关键点包括：  1. <strong>Inception模块</strong> - 核心创新，通过并行使用不同尺寸的卷积核和池化操作，能够更高效地提取多尺度特征。     2. <strong>网络深度</strong> - GoogLeNet比之前的网络更深（22层），但同时通过1×1卷积减少计算量。  3. <strong>辅助分类器</strong> - 在网络中间层添加辅助分类器，以缓解梯度消失问题并增强训练过程。  4. <strong>全局平均池化</strong> - 替代全连接层以减少参数量，防止过拟合。  5. <strong>高效性</strong> - 通过精心设计，在保持高性能的同时大幅降低了计算成本。  文章详细分析了Inception模块的不同版本（v1-v4）的演进，包括引入批量归一化、因子分解卷积等改进。整体而言，GoogLeNet通过创新的架构设计，实现了在ImageNet等基准数据集上的出色表现。</p></blockquote><p><a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p><a href="https://course.d2l.ai/zh-v2/">课程安排 - 动手学深度学习课程 (d2l.ai)</a></p><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><h3 id="时序模型"><a href="#时序模型" class="headerlink" title="时序模型"></a>时序模型</h3><p>当前数据与之前数据相关</p><p>音乐、语言、文本</p><p>与前面所有有关：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100600.png" alt="image-20230515113440168"></p><p>对过去的数据建模，然后预测自己：<strong>自回归模型</strong></p><p>A：<strong>马可夫模型</strong>：当前数据只与最近数据相关；用函数前4个值作为特征，预测下一个值，2层MLP</p><p><code>nn.Sequential(nn.Linear(4, 10),nn.ReLU(),nn.Linear(10, 1))</code></p><p>紫线为单步预测，绿线为长步预测</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100601.png" alt="image-20230515115303920"></p><p>B：<strong>潜变量</strong>：引入潜变量，来概括历史信息  RNN  两个模型，（在实际训练中，还是切成了一段段step，实际可以理解为暗含隐马可夫step）</p><p>​ot利用ht输出（ht由 xt-1 和 ht-1 求出，保存<strong>历史信息</strong>），来推测xt</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100602.png" alt="image-20210818124506982" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100603.png" alt="image-20210818124810932" style="zoom:67%;" /><p>QA：</p><ol><li>RNN甚至可以用来排序？因为可用记住</li><li>数据到底和多长的前面的数据相关呢？transformer自动探索多少个</li><li>传感器、电池故障预测。单步多步不是重点，关键在于负样本数量</li><li>序列也是一维数据，可用用CNN做分类吗？ 可以用1维卷积，效果不错的</li></ol><p>Vocab</p><p>tokenize：将文章按<strong>词</strong>或<strong>字母</strong>划分，如果是词中文需要分词</p><p>Vocab：文本词汇表，可以按单词分也可以按字母分，将单词映射为index。  按频率排序，方便观察、常用数据内存在一起</p><h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>估计联合概率p(x1 x2 xT)，序列出现的概率</p><ul><li>做预序列模型 BERT GPT-3</li><li>文本生成</li><li>判断序列更常见      语音识别哪个更正常  打字</li></ul><p>使用计数建模：判断文本出现的概率</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100604.png" alt="image-20210817212714212"></p><p>n元语法：一个单词出现的概率与它前面的n-1个单词有关。n-1阶段马可夫模型</p><p>二元词汇：两个词合起来算一个token</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 扫一边，长度还是为n，但重复的会减少，种类会增加</span><br>bigram_tokens = [pair <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(corpus[:-<span class="hljs-number">1</span>], corpus[<span class="hljs-number">1</span>:])]<br>trigram_tokens = [triple <span class="hljs-keyword">for</span> triple <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>    corpus[:-<span class="hljs-number">2</span>], corpus[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>], corpus[<span class="hljs-number">2</span>:])]<br>[((<span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;traveller&#x27;</span>), <span class="hljs-number">59</span>),<br> ((<span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;machine&#x27;</span>), <span class="hljs-number">30</span>),]<br></code></pre></td></tr></table></figure><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100605.png" alt="image-20210817221810317" style="zoom: 67%;" /><h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><p>将corpus 转为 batchsize，单个长度为num_step</p><p>1.batch间随机；随机起始点，每个单词每次只用一次</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100606.png" alt="image-20230515160816014"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">2</span>， step = <span class="hljs-number">5</span><br>X:  tensor([[<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],<br>        [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]) <br>Y: tensor([[<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>],<br>        [ <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br>X:  tensor([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],<br>        [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>]]) <br>Y: tensor([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],<br></code></pre></td></tr></table></figure><p>2.batch间连续</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">X:  tensor([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>],<br>        [<span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>]]) <br>Y: tensor([[ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>]])<br>X:  tensor([[ <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>],<br>        [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>]]) <br>Y: tensor([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],<br></code></pre></td></tr></table></figure><p>load_data_time_machine: 封装数据并返回vocab</p><p>x &#x3D; [b,t] y&#x3D;[b,t]                                 <strong>特征抽取</strong></p><p><strong>x</strong> -&gt;onehot-&gt;   <strong>[t, b, infeature]</strong>  -&gt;layer-&gt;   <strong>[t, b,  hidden]</strong>  -&gt;linear-&gt;   <strong>[t*b, outfeature]</strong></p><p>​                                                      定义：**[in, hidden]**  state:( layers * direction, batch, hidden，)</p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p>任务定义：给定一串字母，生成下一个或者n个</p><p>模型的好坏（<strong>困惑度</strong>）：每一个词都可以看成分类，将每一个词的交叉熵求和求平均。最后做个指数</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100607.png" alt="image-20210818125137879" style="zoom:67%;" /><p>T个时间上的梯度连乘，需要梯度剪裁。但无法处理梯度消失</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100608.png" alt="image-20230515165612896" style="zoom:50%;" /><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100609.png" alt="image-20210818125528564" style="zoom: 50%;" /><p>视频Tracking：不需要用rnn，直接判断bbox帧间周围的情况</p><h4 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h4><p>h是一个hiddens长的特征记录信息，每一个序列x都会更新下一个h，同时该h能够给出一个o输出，代表着预测的输出</p><p>关注h，h是对历史的建模，从h到o只是一个线性回归</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100602.png" alt="image-20210818124506982" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100603.png" alt="image-20210818124810932" style="zoom:67%;" /><p><strong>参数定义：</strong>五个参数，需要梯度。并且需要定义初始化h的函数 ( (b, hiddens),  )</p><p><strong>forward函数：</strong></p><p>序列输入，所以t一定是在最外面。b的作用仅仅是泛化，b之间互不影响。h也是存储了b个</p><ol><li>输入<code>[b,t]</code>和<code>state</code> 转置onehot转为<code>[t, b, onehot]</code> </li><li>按t遍历输入到网络中，每次输出<code>[b onehot]</code>， 并更新t次state</li><li>(和y计算损失函数，预测的下一个字母)</li><li>最后堆叠输出 <code>[t*b, onehot]</code>，<code>new_state</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 传入[t, b, vocab_size]  以及参数、初始状态  返回   [t*b, vocab_size]</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rnn</span>(<span class="hljs-params">inputs, state, params</span>):<br>    <span class="hljs-comment"># `inputs`的形状：(`时间步数量`，`批量大小`，`词表大小`)</span><br>    W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    outputs = []<br>    <span class="hljs-comment"># `X`的形状：(`批量大小`，`词表大小`)</span><br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        <span class="hljs-comment"># 一次序列更新一次H，生成一个Y</span><br>        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)<br>        Y = torch.mm(H, W_hq) + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> torch.cat(outputs, dim=<span class="hljs-number">0</span>), (H,)<br><br>对于一个 [t, b, vocab_size]， 根据state，每次传入[b, vocab_size]给出[b]个结果预测<br><br><br><span class="hljs-comment"># 网络执行的方式，X传进来后需要onehot</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, X, state</span>):<br>    X = F.one_hot(X.T, <span class="hljs-variable language_">self</span>.vocab_size).<span class="hljs-built_in">type</span>(torch.float32)<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.forward_fn(X, state, <span class="hljs-variable language_">self</span>.params)<br></code></pre></td></tr></table></figure><p><strong>剪裁 ：</strong>梯度二范数 torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params)) &lt;  θ  </p><p><strong>预测</strong>： 用预先给的词初始化h，并不断forward给输出并更新state</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据h和上一个x来预测下一个值x，并更新h</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_ch8</span>(<span class="hljs-params">prefix, num_preds, net, vocab, device</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;在`prefix`后面生成新字符。&quot;&quot;&quot;</span><br>    state = net.begin_state(batch_size=<span class="hljs-number">1</span>, device=device)<br>    outputs = [vocab[prefix[<span class="hljs-number">0</span>]]]<br>    get_input = <span class="hljs-keyword">lambda</span>: torch.tensor([outputs[-<span class="hljs-number">1</span>]], device=device).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># 根据input，更新state</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> prefix[<span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 预热期</span><br>        _, state = net(get_input(), state)<br>        outputs.append(vocab[y])<br>        <br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_preds):  <span class="hljs-comment"># 预测`num_preds`步</span><br>        y, state = net(get_input(), state)<br>        outputs.append(<span class="hljs-built_in">int</span>(y.argmax(dim=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> outputs])<br></code></pre></td></tr></table></figure><p><strong>训练：</strong>一个epoch中，注意batch间如果打乱了的化，state要重新初始化。否者沿用之前的，并且需要<strong>detach_()</strong></p><p><strong>损失函数：</strong>直接CrossEntropy 注意更新前先剪裁梯度。y是[b, t] 传入前先转置一下</p><h4 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h4><p>核心：通过保存state信息，对t个features编码，转为t个num_hiddens</p><p>RNN的定义是没有b的，只需要features num_hiddens，但state有b且多了个1维度</p><p>RNN实际上就是对输入的t个时间序列，进行建模处理，并返回hidden维度信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入维度，隐藏层维度</span><br>rnn_layer = nn.RNN(features, num_hiddens)<br><span class="hljs-comment">#传入数据也是onehot后的， 输出没有输出层，加一层linear, state需要自己传入，</span><br><br><span class="hljs-comment"># X：[t, b, features]    </span><br><span class="hljs-comment"># state： [1, b, num_hiddens]</span><br>Y,   state            = rnn_layer (X ,             state )<br><span class="hljs-comment"># Y [t, b, num_hiddens]   t次最后一个layer的H的cat</span><br><span class="hljs-comment"># state_new [1, b, num_hiddens]  用于传入下一次  1为num_layer</span><br><br><span class="hljs-comment"># 所以网络的输出是t个时间段全部的（num_layer[-1].state值cat，最后一个state）   Y[-1] == state_new </span><br></code></pre></td></tr></table></figure><p>输入数据中的t代表着输入数据的时序长度，很像t次MLP分类，但是前面的数据会影响state从而影响后面的分类</p><p>为什么没有out层？输出不一定要和输入的维度一样，比如我可以只去做一个情感分类，或者只想提取特征。如果想分类，直接输入到全连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Y, state = <span class="hljs-variable language_">self</span>.rnn(X, state)<br><span class="hljs-comment"># 全连接层首先将`Y`的形状改为(num_steps * b, `隐藏单元数`)。</span><br>output = <span class="hljs-variable language_">self</span>.linear(Y.reshape((-<span class="hljs-number">1</span>, Y.shape[-<span class="hljs-number">1</span>])))<br></code></pre></td></tr></table></figure><h4 id="QA："><a href="#QA：" class="headerlink" title="QA："></a>QA：</h4><ol><li><p>处理视频时序序列，t就是想要关联的帧长度，而onehot则改成了由神经网络抽取出来单帧图片的特征。所以[t,features]输入到rnn后，rnn返回给你[t,features’ ] ，根据这个提取出信息</p></li><li><p>如果用<strong>单词作为预测目标</strong>，<code>onehot</code>将会非常长。不利于预测</p></li><li><p>RNN不能处理长序列：<code>num_hiddens</code>决定着你记录<strong>之前的状态</strong>。但太大会过拟合，太小会无法记录下之前的消息</p></li><li><p>高频词可以对概率开根号，或者随机去除</p></li></ol><h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>添加两个门，<strong>更好的保留以前的信息</strong>：如一群老鼠突然出现一直猫，注意点要转移到猫上。（0~1取值，按位乘）</p><p><strong>遗忘门R：</strong>计算h<del>t</del>时，h<del>t-1</del>h忘记多少    <strong>更新门Z</strong>：h<del>t</del>和现在h<del>t-1</del>所占的比例</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100610.png" alt="image-20210819132116519" style="zoom: 67%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>获取参数</strong> ：11个  <code>W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q</code></p><p><strong>forward函数</strong>：按照公式写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gru</span>(<span class="hljs-params">inputs, state, params</span>):<br>    W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params<br>    H, = state<br>    outputs = []<br>    <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> inputs:<br>        Z = torch.sigmoid((X @ W_xz) + (H @ W_hz) + b_z)<br>        R = torch.sigmoid((X @ W_xr) + (H @ W_hr) + b_r)<br>        H_tilda = torch.tanh((X @ W_xh) + ((R * H) @ W_hh) + b_h)<br>        H = Z * H + (<span class="hljs-number">1</span> - Z) * H_tilda<br>        Y = H @ W_hq + b_q<br>        outputs.append(Y)<br>    <span class="hljs-keyword">return</span> torch.cat(outputs, dim=<span class="hljs-number">0</span>), (H,)<br></code></pre></td></tr></table></figure><p>和前面一样封装到类中，需要传入infeature hidden  <code>get_param</code>  <code>init_state</code>  <code>forward</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = d2l.RNNModelScratch(<span class="hljs-built_in">len</span>(vocab), num_hiddens, device, get_params,<br>                            init_gru_state, gru)<br>d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)<br></code></pre></td></tr></table></figure><h4 id="简洁："><a href="#简洁：" class="headerlink" title="简洁："></a>简洁：</h4><p>封装到RNNModel中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gru_layer = nn.GRU(num_inputs, num_hiddens)<br>model = d2l.RNNModel(gru_layer, <span class="hljs-built_in">len</span>(vocab))<br><span class="hljs-comment"># state依然是(1, b, num_hiddens)</span><br><span class="hljs-comment"># nn.GRU输入为[t,b,in] 输出为[t,b,hi],[1,b,hi]</span><br></code></pre></td></tr></table></figure><p>对比GRU，虽然计算复杂了，但运算速度反而更快了 242822.8  -&gt;  26820.1   tokens&#x2F;sec</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA:"></a>QA:</h4><ol><li>GRU LSTM参数更多，但稳定性比RNN更好</li><li>尽量不要使用RNN</li></ol><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>两个state ：C、H</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100611.png" alt="image-20210819142947789" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100612.png" alt="image-20210819143001209" style="zoom:50%;" /></p><p>F （忘记门） 和 I （输入门）决定以前C和现在C~所占比例，O（输出门）决定C求出来后如何向H转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens)<br><span class="hljs-comment"># state: ([1, b, num_hiddens],[1, b, num_hiddens])   H C</span><br><br>Y, state_new = lstm_layer(X, state)<br><span class="hljs-comment"># Y [t, b, num_hiddens])   最后一个H的集合</span><br><span class="hljs-comment"># state_new ([1, b, num_hiddens],[1, b, num_hiddens])  用于传入下一次  1为num_layer</span><br></code></pre></td></tr></table></figure><p>实际内存难以计算，cudnn会用内存换速度，直接跑来看占用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RNNModel</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;The RNN model.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`sec_rnn-concise`&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rnn_layer, vocab_size, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(RNNModel, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.rnn = rnn_layer<br>        <span class="hljs-variable language_">self</span>.vocab_size = vocab_size<br>        <span class="hljs-variable language_">self</span>.num_hiddens = <span class="hljs-variable language_">self</span>.rnn.hidden_size<br>        <span class="hljs-comment"># If the RNN is bidirectional (to be introduced later),</span><br>        <span class="hljs-comment"># `num_directions` should be 2, else it should be 1.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.rnn.bidirectional:<br>            <span class="hljs-variable language_">self</span>.num_directions = <span class="hljs-number">1</span><br>            <span class="hljs-variable language_">self</span>.linear = nn.Linear(<span class="hljs-variable language_">self</span>.num_hiddens, <span class="hljs-variable language_">self</span>.vocab_size)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.num_directions = <span class="hljs-number">2</span><br>            <span class="hljs-variable language_">self</span>.linear = nn.Linear(<span class="hljs-variable language_">self</span>.num_hiddens * <span class="hljs-number">2</span>, <span class="hljs-variable language_">self</span>.vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs, state</span>):<br>        X = F.one_hot(inputs.T.long(), <span class="hljs-variable language_">self</span>.vocab_size)<br>        X = X.to(torch.float32)<br>        Y, state = <span class="hljs-variable language_">self</span>.rnn(X, state)<br>        <span class="hljs-comment"># The fully connected layer will first change the shape of `Y` to</span><br>        <span class="hljs-comment"># (`num_steps` * `batch_size`, `num_hiddens`). Its output shape is</span><br>        <span class="hljs-comment"># (`num_steps` * `batch_size`, `vocab_size`).</span><br>        output = <span class="hljs-variable language_">self</span>.linear(Y.reshape((-<span class="hljs-number">1</span>, Y.shape[-<span class="hljs-number">1</span>])))<br>        <span class="hljs-keyword">return</span> output, state<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">begin_state</span>(<span class="hljs-params">self, device, batch_size=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-variable language_">self</span>.rnn, nn.LSTM):<br>            <span class="hljs-comment"># `nn.GRU` takes a tensor as hidden state</span><br>            <span class="hljs-keyword">return</span>  torch.zeros((<span class="hljs-variable language_">self</span>.num_directions * <span class="hljs-variable language_">self</span>.rnn.num_layers,<br>                                 batch_size, <span class="hljs-variable language_">self</span>.num_hiddens),<br>                                device=device)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># `nn.LSTM` takes a tuple of hidden states</span><br>            <span class="hljs-keyword">return</span> (torch.zeros((<br>                <span class="hljs-variable language_">self</span>.num_directions * <span class="hljs-variable language_">self</span>.rnn.num_layers,<br>                batch_size, <span class="hljs-variable language_">self</span>.num_hiddens), device=device),<br>                    torch.zeros((<br>                        <span class="hljs-variable language_">self</span>.num_directions * <span class="hljs-variable language_">self</span>.rnn.num_layers,<br>                        batch_size, <span class="hljs-variable language_">self</span>.num_hiddens), device=device))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch8</span>(<span class="hljs-params">net, train_iter, loss, updater, device, use_random_iter</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Train a net within one epoch (defined in Chapter 8).</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`sec_rnn_scratch`&quot;&quot;&quot;</span><br>    state, timer = <span class="hljs-literal">None</span>, d2l.Timer()<br>    metric = d2l.Accumulator(<span class="hljs-number">2</span>)  <span class="hljs-comment"># Sum of training loss, no. of tokens</span><br>    <span class="hljs-keyword">for</span> X, Y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> use_random_iter:<br>            <span class="hljs-comment"># Initialize `state` when either it is the first iteration or</span><br>            <span class="hljs-comment"># using random sampling</span><br>            state = net.begin_state(batch_size=X.shape[<span class="hljs-number">0</span>], device=device)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, nn.Module) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(state, <span class="hljs-built_in">tuple</span>):<br>                <span class="hljs-comment"># `state` is a tensor for `nn.GRU`</span><br>                state.detach_()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># `state` is a tuple of tensors for `nn.LSTM` and</span><br>                <span class="hljs-comment"># for our custom scratch implementation</span><br>                <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> state:<br>                    s.detach_()<br>        y = Y.T.reshape(-<span class="hljs-number">1</span>)<br>        X, y = X.to(device), y.to(device)<br>        y_hat, state = net(X, state)<br>        l = loss(y_hat, y.long()).mean()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            updater.zero_grad()<br>            l.backward()<br>            grad_clipping(net, <span class="hljs-number">1</span>)<br>            updater.step()<br>        <span class="hljs-keyword">else</span>:<br>            l.backward()<br>            grad_clipping(net, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># Since the `mean` function has been invoked</span><br>            updater(batch_size=<span class="hljs-number">1</span>)<br>        metric.add(l * d2l.size(y), d2l.size(y))<br>    <span class="hljs-keyword">return</span> math.exp(metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">1</span>]), metric[<span class="hljs-number">1</span>] / timer.stop()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)<br>model = d2l.RNNModel(lstm_layer, <span class="hljs-built_in">len</span>(vocab))<br><br>d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)<br></code></pre></td></tr></table></figure><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><p>多个隐藏层获得非线性性</p><p>​                             <img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100613.png" alt="image-20210819150224101" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100614.png" alt="image-20230516144012521" style="zoom:50%;" /></p><p>在同一个时刻，保存多个<code>Ht</code>  ,由左下角推理而来</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100615.png" alt="image-20210819150931603"></p><p>state: ([1, b, num_hiddens],[1, b, num_hiddens])  -&gt;([2, b, num_hiddens],[2, b, num_hiddens])   两层够了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens，num_layer)  num_layer决定H个数<br></code></pre></td></tr></table></figure><h3 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100616.png" alt="image-20230516145522237"></p><p>两个H，一个依赖以前的，一个依赖以后的。相互独立，cat在一起决定输出</p><p>抽取特征，分类，填空、翻译。但不能预测未来，因为反方向不存在</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100617.png" alt="image-20210819160940494" style="zoom:50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100618.png" alt="image-20210819161400150" style="zoom:50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100619.png" alt="image-20210819161423155" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm_layer = nn.LSTM(num_inputs, num_hiddens，num_layer, bidirectional=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>对句子做特征提取：做翻译、改写，不能做预测，因为完全没有反方向的信息</p><h3 id="机器翻译数据集"><a href="#机器翻译数据集" class="headerlink" title="机器翻译数据集"></a>机器翻译数据集</h3><ul><li><p>读入数据，预处理去除大写、特殊字符。</p></li><li><p>单词化后，英语，法语分别绘制vocab，加入一些特殊字符</p></li><li><p>结尾补上vocab[‘<eos>‘], 批量计算，每一个句子长度要想同，所以限制最大长度，不足补vocab[‘<pad>‘] 转idx</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_array_nmt</span>(<span class="hljs-params">lines, vocab, num_steps</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;将机器翻译的文本序列转换成小批量&quot;&quot;&quot;</span><br>    lines = [vocab[l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines]<br>    lines = [l + [vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines]<br>    array = torch.tensor([truncate_pad(<br>        l, num_steps, vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines])<br>    valid_len = (array != vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]).<span class="hljs-built_in">type</span>(torch.int32).<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> array, valid_len<br></code></pre></td></tr></table></figure></li><li><p>封装成batch，每次返回 <code>X, X_valid_len, Y, Y_valid_len</code>.   len为实际句子长度</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_nmt</span>(<span class="hljs-params">batch_size, num_steps, num_examples=<span class="hljs-number">600</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回翻译数据集的迭代器和词表&quot;&quot;&quot;</span><br>    text = preprocess_nmt(read_data_nmt())<br>    source, target = tokenize_nmt(text, num_examples)<br>    src_vocab = d2l.Vocab(source, min_freq=<span class="hljs-number">2</span>,<br>                          reserved_tokens=[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>])<br>    tgt_vocab = d2l.Vocab(target, min_freq=<span class="hljs-number">2</span>,<br>                          reserved_tokens=[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>])<br>    src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps)<br>    tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps)<br>    data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len)<br>    data_iter = d2l.load_array(data_arrays, batch_size)<br>    <span class="hljs-keyword">return</span> data_iter, src_vocab, tgt_vocab<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> X, X_valid_len, Y, Y_valid_len <span class="hljs-keyword">in</span> train_iter:<br>X: tensor([[<span class="hljs-number">93</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">13</span>, <span class="hljs-number">34</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>]])<br>valid lengths <span class="hljs-keyword">for</span> X: tensor([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br><br>Y: tensor([[  <span class="hljs-number">0</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">121</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>]], dtype=torch.int32)<br>valid lengths <span class="hljs-keyword">for</span> Y: tensor([<span class="hljs-number">6</span>, <span class="hljs-number">3</span>])<br>    <br>b=<span class="hljs-number">2</span>，每个句子最大长度num_steps=<span class="hljs-number">8</span>    输入为一个句子，输出也为一个句子<br>不同于文本生成：序列中每一个输入都有一个输出<br>机器翻译为一整个序列输入：对应一整个序列输出<br></code></pre></td></tr></table></figure><h3 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100620.png" alt="image-20210819171331079" style="zoom:80%;" /><p>encoder最后的隐藏状态作为decoder的输入，decoder还可以有额外输入。decoder时，由于不知道后面的信息，所以需要一个一个输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderDecoder</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;编码器-解码器架构的基类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, encoder, decoder, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(EncoderDecoder, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.encoder = encoder<br>        <span class="hljs-variable language_">self</span>.decoder = decoder<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, enc_X, dec_X, *args</span>):<br>        enc_outputs = <span class="hljs-variable language_">self</span>.encoder(enc_X, *args)<br>        dec_state = <span class="hljs-variable language_">self</span>.decoder.init_state(enc_outputs, *args)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.decoder(dec_X, dec_state)<br></code></pre></td></tr></table></figure><h3 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h3><p>句子生成句子，使用编码器解码器架构</p><p>编码器用于提取句子(生成context)，解码器输入为</p><ul><li>预测阶段：前一个单词<code>(1,b,h)</code> 和 context的concate</li><li>训练阶段：整个单词序列<code>(t,b,h)</code> 和 context的concate，由于context不变，GRU内部其实也是相对于进行了t次</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100621.png" alt="image-20230516154007581"></p><p>encoder可用<strong>双向</strong>，对输入编码后返回编码器最后的状态，作为decoder输入</p><p>训练时decoder需要右移位一下，每次用的正确的输入（强制教学），推理用的上一次输出</p><h4 id="衡量结果"><a href="#衡量结果" class="headerlink" title="衡量结果"></a>衡量结果</h4><p>如何衡量生成序列的好坏</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100623.png" alt="image-20230516154646648" style="zoom:50%;" /><ol><li>编码器获得state后，把最后一次的state <code>[num_layer, b, num_hiddens]</code> 作为解码器的输入state</li><li>解码器负责将state[-1]重复t次，作为历史状态，并和输入Y<code>[b,t]</code> concat <code>[t, b, emb+hid]</code>传入GRU网络</li><li>GRU将t个state作为dense的输入，输出<code>t * b * vocab</code> permute<code>b * t * vocab</code></li></ol><h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><h5 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">输入 b, t<br>输出 [t, b, hiddens] [numlayer, b, hiddens]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seq2SeqEncoder</span>(d2l.Encoder):<br>    <span class="hljs-string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, embed_size, num_hiddens, num_layers,</span><br><span class="hljs-params">                 dropout=<span class="hljs-number">0</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(Seq2SeqEncoder, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-comment"># 嵌入层</span><br>        <span class="hljs-variable language_">self</span>.embedding = nn.Embedding(vocab_size, embed_size)<br>        <span class="hljs-variable language_">self</span>.rnn = nn.GRU(embed_size, num_hiddens, num_layers,<br>                          dropout=dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, *args</span>):<br>        <span class="hljs-comment"># 输出&#x27;X&#x27;的形状：(batch_size,num_steps,embed_size)</span><br>        X = <span class="hljs-variable language_">self</span>.embedding(X)<br>        <span class="hljs-comment"># 在循环神经网络模型中，第一个轴对应于时间步</span><br>        X = X.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 如果未提及状态，则默认为0</span><br>        output, state = <span class="hljs-variable language_">self</span>.rnn(X)<br>        <span class="hljs-comment"># output的形状:(num_steps,batch_size,num_hiddens)</span><br>        <span class="hljs-comment"># state的形状:(num_layers,batch_size,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><h5 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">输入 X[b, t]   embedding -&gt;  X[t, b, embed_size]  + cat state[t, b, hiddens] = [t, b, em+hiddens]<br>输出[t, b, hiddens] 经过dense [b, t, vocab_size]  <br>一次性得到t次预测做loss(模型内部还是一个一个词输入并且一个个输出，但由于强制学习强制使用已知的正确的词作为前一个词，就可以一次性全部输入到模型中)<br>    predict时每次输出一个，并作为下一个的输入<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seq2SeqDecoder</span>(d2l.Decoder):<br>    <span class="hljs-string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络解码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, embed_size, num_hiddens, num_layers,</span><br><span class="hljs-params">                 dropout=<span class="hljs-number">0</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(Seq2SeqDecoder, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.embedding = nn.Embedding(vocab_size, embed_size)<br>        <span class="hljs-variable language_">self</span>.rnn = nn.GRU(embed_size + num_hiddens, num_hiddens, num_layers,<br>                          dropout=dropout)<br>        <span class="hljs-variable language_">self</span>.dense = nn.Linear(num_hiddens, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self, enc_outputs, *args</span>):<br>        <span class="hljs-keyword">return</span> enc_outputs[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        <span class="hljs-comment"># 输出&#x27;X&#x27;的形状：(num_steps,batch_size,embed_size)</span><br>        X = <span class="hljs-variable language_">self</span>.embedding(X).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 广播context，使其具有与X相同的num_steps</span><br>        context = state[-<span class="hljs-number">1</span>].repeat(X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        X_and_context = torch.cat((X, context), <span class="hljs-number">2</span>)<br>        output, state = <span class="hljs-variable language_">self</span>.rnn(X_and_context, state)<br>        output = <span class="hljs-variable language_">self</span>.dense(output).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># output的形状:(batch_size,num_steps,vocab_size)</span><br>        <span class="hljs-comment"># state的形状:(num_layers,batch_size,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> output, state<br></code></pre></td></tr></table></figure><h4 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要根据实际的长度，超出valid_len部分weights为0从而损失为0, 忽略pad</span><br>X = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]) b, t<br>sequence_mask(X, torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<br>输出 [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskedSoftmaxCELoss</span>(nn.CrossEntropyLoss):<br>    <span class="hljs-string">&quot;&quot;&quot;带遮蔽的softmax交叉熵损失函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># pred的形状：(batch_size,num_steps,vocab_size)</span><br>    <span class="hljs-comment"># label的形状：(batch_size,num_steps)</span><br>    <span class="hljs-comment"># valid_len的形状：(batch_size,)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, pred, label, valid_len</span>):<br>        weights = torch.ones_like(label)<br>        weights = sequence_mask(weights, valid_len)<br>        <span class="hljs-variable language_">self</span>.reduction=<span class="hljs-string">&#x27;none&#x27;</span><br>        unweighted_loss = <span class="hljs-built_in">super</span>(MaskedSoftmaxCELoss, <span class="hljs-variable language_">self</span>).forward(<br>            pred.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), label)<br>        weighted_loss = (unweighted_loss * weights).mean(dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> weighted_loss<br></code></pre></td></tr></table></figure><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> data_iter:<br>    optimizer.zero_grad()<br>    X, X_valid_len, Y, Y_valid_len = [x.to(device) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> batch]<br>    bos = torch.tensor([tgt_vocab[<span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>]] * Y.shape[<span class="hljs-number">0</span>],<br>                       device=device).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    dec_input = torch.cat([bos, Y[:, :-<span class="hljs-number">1</span>]], <span class="hljs-number">1</span>)  <span class="hljs-comment"># 强制教学 你好啊 -&gt;    &lt;bos&gt;你好</span><br>    Y_hat, _ = net(X, dec_input, X_valid_len) <span class="hljs-comment"># 这里X_valid_len没有用上</span><br>    l = loss(Y_hat, Y, Y_valid_len)<br>    l.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-comment"># 反向传播</span><br>    d2l.grad_clipping(net, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="predict"><a href="#predict" class="headerlink" title="predict"></a>predict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_seq2seq</span>(<span class="hljs-params">net, src_sentence, src_vocab, tgt_vocab, num_steps,</span><br><span class="hljs-params">                    device, save_attention_weights=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;序列到序列模型的预测&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 在预测时将net设置为评估模式</span><br>    net.<span class="hljs-built_in">eval</span>()<br>    src_tokens = src_vocab[src_sentence.lower().split(<span class="hljs-string">&#x27; &#x27;</span>)] + [<br>        src_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]]<br>    enc_valid_len = torch.tensor([<span class="hljs-built_in">len</span>(src_tokens)], device=device)<br>    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>])<br>    <span class="hljs-comment"># 添加批量轴</span><br>    enc_X = torch.unsqueeze(<br>        torch.tensor(src_tokens, dtype=torch.long, device=device), dim=<span class="hljs-number">0</span>)<br>    enc_outputs = net.encoder(enc_X, enc_valid_len)<br>    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)<br>    <span class="hljs-comment"># 添加批量轴</span><br>    dec_X = torch.unsqueeze(torch.tensor(<br>        [tgt_vocab[<span class="hljs-string">&#x27;&lt;bos&gt;&#x27;</span>]], dtype=torch.long, device=device), dim=<span class="hljs-number">0</span>)<br>    output_seq, attention_weight_seq = [], []<br>    <span class="hljs-comment"># 输入dec_X为(1, 1) tb都等于</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_steps):<br>        Y, dec_state = net.decoder(dec_X, dec_state)<br>        <span class="hljs-comment"># 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入</span><br>        dec_X = Y.argmax(dim=<span class="hljs-number">2</span>)<br>        pred = dec_X.squeeze(dim=<span class="hljs-number">0</span>).<span class="hljs-built_in">type</span>(torch.int32).item()<br>        <span class="hljs-comment"># 保存注意力权重（稍后讨论）</span><br>        <span class="hljs-keyword">if</span> save_attention_weights:<br>            attention_weight_seq.append(net.decoder.attention_weights)<br>        <span class="hljs-comment"># 一旦序列结束词元被预测，输出序列的生成就完成了</span><br>        <span class="hljs-keyword">if</span> pred == tgt_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]:<br>            <span class="hljs-keyword">break</span><br>        output_seq.append(pred)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq<br></code></pre></td></tr></table></figure><h4 id="QA：-1"><a href="#QA：-1" class="headerlink" title="QA："></a>QA：</h4><ol><li>word2vec没讲，跳过了</li><li>transformer可以代替seq2seq</li></ol><h3 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h3><p>预测时，每一步都是取最优的（贪心），但贪心不一定是全局最优，例如下面第二步取C</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100624.png" alt="image-20230516202920183"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100625.png" alt="image-20230516202927638"></p><p>穷举：指数级 太大了</p><p>束搜索：每次在所有kn个选项中，保留k个最大的。只保留一个就是贪心</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100626.png" alt="image-20230516203605851" style="zoom:50%;" /><h2 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h2><h3 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h3><p><code>query</code>：输入   <code>key，value</code>  ：已有的一些数据</p><p>核心：根据<code>query</code>和<code>keyi</code>的关系，决定出<code>valuei</code>的权重，加权得到一个最终value</p><h4 id="核回归"><a href="#核回归" class="headerlink" title="核回归"></a>核回归</h4><h5 id="非参数"><a href="#非参数" class="headerlink" title="非参数"></a>非参数</h5><p>query为输入x，根据数据（(xi,yi)）给出预测y。<code>xi-yi</code>是<code>keys-values</code></p><ol><li>最简单的是对y的数据求平均，这样每个数据给出的f(x)都一样</li><li>根据一个权重，加权求和。权重为根据K(距离)函数求出来的。如果k是高斯核，就等价于用高斯距离<code>softmax</code>加权</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100627.png" alt="image-20230517120533488"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100628.png" alt="image-20230517121458578"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># X_repeat的形状:(n_test,n_train),</span><br><span class="hljs-comment"># 每一行都包含着相同的测试输入（例如：同样的查询）</span><br>X_repeat = x_test.repeat_interleave(n_train).reshape((-<span class="hljs-number">1</span>, n_train))<br><span class="hljs-comment"># x_train包含着键。attention_weights的形状：(n_test,n_train),</span><br><span class="hljs-comment"># 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重</span><br>attention_weights = nn.functional.softmax(-(X_repeat - x_train)**<span class="hljs-number">2</span> / <span class="hljs-number">2</span>, dim=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重</span><br>y_hat = torch.matmul(attention_weights, y_train)<br>plot_kernel_reg(y_hat)<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100629.png" alt="image-20230517114942706"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100630.png" alt="image-20230517115633471"></p><p>一行代表，对哪个inpute的权重更大。权重给的比较平滑，所以pred也比较平滑</p><h5 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h5><p>引入可学习的<code>w=nn.Parameter(torch.rand((1,), requires_grad=True))</code>  控制高斯核的窗口大小，w越大窗口越小<br>$$<br>\begin{aligned}f(x) &amp;&#x3D; \sum_{i&#x3D;1}^n \alpha(x, x_i) y_i \&amp;&#x3D; \sum_{i&#x3D;1}^n \frac{\exp\left(-\frac{1}{2}((x - x_i)w)^2\right)}{\sum_{j&#x3D;1}^n \exp\left(-\frac{1}{2}((x - x_j)w)^2\right)} y_i \&amp;&#x3D; \sum_{i&#x3D;1}^n \mathrm{softmax}\left(-\frac{1}{2}((x - x_i)w)^2\right) y_i.\end{aligned}<br>$$<br><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100631.png" alt="image-20230517120017210"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100632.png" alt="image-20230517120026332"></p><p>窗口更窄了，只给离得近的分配权重，所以pred更加弯曲</p><h4 id="注意力分数"><a href="#注意力分数" class="headerlink" title="注意力分数"></a>注意力分数</h4><p>拓展到<strong>高维</strong>情况，q k v都是向量</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100633.png" alt="image-20230517121659643"></p><h5 id="Scaled-Dot"><a href="#Scaled-Dot" class="headerlink" title="Scaled Dot"></a>Scaled Dot</h5><ul><li>k和q长度一样：kq做内积后除去根号dk。transformer。两次矩阵乘法，无学习的参数，去除根号d防止梯度问题</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100634.png" alt="image-20230517122729061"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DotProductAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Scaled dot product attention.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Defined in :numref:`subsec_additive-attention`&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(DotProductAttention, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-comment"># Shape of `queries`: (`batch_size`, no. of queries, `d`)</span><br>    <span class="hljs-comment"># Shape of `keys`: (`batch_size`, no. of key-value pairs, `d`)</span><br>    <span class="hljs-comment"># Shape of `values`: (`batch_size`, no. of key-value pairs, value</span><br>    <span class="hljs-comment"># dimension)</span><br>    <span class="hljs-comment"># Shape of `valid_lens`: (`batch_size`,) or (`batch_size`, no. of queries)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens=<span class="hljs-literal">None</span></span>):<br>        d = queries.shape[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># Set `transpose_b=True` to swap the last two dimensions of `keys`</span><br>        scores = torch.bmm(queries, keys.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) / math.sqrt(d)<br>        <span class="hljs-variable language_">self</span>.attention_weights = masked_softmax(scores, valid_lens)<br>        <span class="hljs-keyword">return</span> torch.bmm(<span class="hljs-variable language_">self</span>.dropout(<span class="hljs-variable language_">self</span>.attention_weights), values)<br></code></pre></td></tr></table></figure><h5 id="additive"><a href="#additive" class="headerlink" title="additive"></a>additive</h5><ul><li>k和q长度一样：k和q  concat输入到隐藏层为h输出为1的MLP，再乘上vT输出为分数值。有参</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100635.png" alt="image-20230517122801534" style="zoom:67%;" /><p>对于每一个query，我都需要得到一个<code>len(“键-值”对)</code>的向量，多个query就是一个weight矩阵 <code>[len(query), len(“键-值”对)]</code>，weight*values得到加权输出<code>[querys, d(v)]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br>[querys, d(q)]  -》  [querys, d(v)]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdditiveAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(AdditiveAttention, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.w_v = nn.Linear(num_hiddens, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout(dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):<br>        <span class="hljs-comment"># valid_lens对于每个query 考虑多少个kv</span><br>        queries, keys = <span class="hljs-variable language_">self</span>.W_q(queries), <span class="hljs-variable language_">self</span>.W_k(keys)<br>        <span class="hljs-comment"># 在维度扩展后，</span><br>        <span class="hljs-comment"># queries的形状：(batch_size，查询的个数，1，num_hidden)</span><br>        <span class="hljs-comment"># key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># 使用广播方式进行求和</span><br>        features = queries.unsqueeze(<span class="hljs-number">2</span>) + keys.unsqueeze(<span class="hljs-number">1</span>)<br>        features = torch.tanh(features)<br>        <span class="hljs-comment"># self.w_v仅有一个输出，因此从形状中移除最后那个维度。</span><br>        <span class="hljs-comment"># scores的形状：(batch_size，查询的个数，“键-值”对的个数)</span><br>        scores = <span class="hljs-variable language_">self</span>.w_v(features).squeeze(-<span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.attention_weights = masked_softmax(scores, valid_lens) <span class="hljs-comment"># valid_lens强行把scores得分1e-6</span><br>        <span class="hljs-comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span><br>        <span class="hljs-keyword">return</span> torch.bmm(<span class="hljs-variable language_">self</span>.dropout(<span class="hljs-variable language_">self</span>.attention_weights), values)<br></code></pre></td></tr></table></figure><p>dropout增加模型的泛化能力</p><p>应用：key value query到底是什么</p><h3 id="Bahdanau-seq2seq"><a href="#Bahdanau-seq2seq" class="headerlink" title="Bahdanau seq2seq"></a>Bahdanau seq2seq</h3><p>翻译时额外添加原句子的对应信息，而不是只用最后一个state。具体用以前的哪个state由attention决定</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100636.png" alt="image-20230517144406568"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100637.png" alt="image-20230524211826420" style="zoom:50%;" /><ul><li>key-value：编码器每一次的RNN 的输出states</li><li>query：解码器上一次输出</li></ul><p>对比之前的改进：之前context直接用最后一个state，现在对所有state拿出来做一个weight</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100638.png" alt="image-20230517150923131"></p><ul><li><code>query</code>：当前state[-1]  <code>[batch_size,1,num_hiddens]</code> </li><li><code>key-value</code>: encoder的output<code>[batch_size,num_steps,num_hiddens]</code></li></ul><p><strong>以前的context</strong>：t次都一样，都是最后的state</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoder的state重复t次，代表着我t次上下文关注点都一样，每一次都是state(b, 1, num_hiddens)</span><br>context = state[-<span class="hljs-number">1</span>].repeat(X.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>X_and_context = torch.cat((X, context), <span class="hljs-number">2</span>)<br>output, state = <span class="hljs-variable language_">self</span>.rnn(X_and_context, state)  直接一次性输入到网络<br></code></pre></td></tr></table></figure><p><strong>现在的context：</strong>每次都不一样，为output的加权。<code>C=attention(pre-state, (h1,h2...ht))</code> <strong>不一样所以需要遍历</strong></p><ul><li><code>query</code>为上次state[-1]，代表着当前状态 <code>[batch_size, query=1, num_hiddens]</code>  当前状态的维度为<code>num_hiddens</code></li><li><code>key-value = enc_outputs</code>是encoder的output转置下  <code>[batch_size, num_steps, num_hiddens]</code> 代表着有t次状态，每个状态的维度为<code>num_hiddens</code>，attention对t次状态加权后得到<code>[batch_size, query=1, num_hiddens]</code>, 权重矩阵为<code>[b, query=1, num_steps]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X:  <span class="hljs-comment"># 每一次query(当前状态都不同，代表着翻译到了哪个单词，不同状态不同注意点)</span><br>    <span class="hljs-comment"># query的形状为(batch_size, 1, num_hiddens)          1代表着一次询问</span><br>    query = torch.unsqueeze(hidden_state[-<span class="hljs-number">1</span>], dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># context的形状为(batch_size,1,num_hiddens)   enc_valid_lens忽略输入的pad</span><br>    context = <span class="hljs-variable language_">self</span>.attention(query, enc_outputs, enc_outputs, enc_valid_lens)<br>    <br>    <span class="hljs-comment"># 在特征维度上连结</span><br>    x = torch.cat((context, torch.unsqueeze(x, dim=<span class="hljs-number">1</span>)), dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 将x变形为(t=1, batch_size, embed_size+num_hiddens)</span><br>    out, hidden_state = <span class="hljs-variable language_">self</span>.rnn(x.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>), hidden_state)<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100639.png" alt="image-20230525165633633"></p><p>纵坐标为生成的token<code>[&#39;&lt;bos&gt;&#39;, &#39;je&#39;, &#39;suis&#39;, &#39;chez&#39;, &#39;moi&#39;, &#39;.&#39;, &#39;&lt;eos&gt;&#39;]</code><br>横坐标为输入的4个词 <code>[&quot;i&#39;m&quot;, &#39;home&#39;, &#39;.&#39;, &#39;&lt;eos&gt;&#39;]</code></p><h3 id="self-attention！"><a href="#self-attention！" class="headerlink" title="self-attention！"></a>self-attention！</h3><p>同时拉取汇聚全部时间的信息</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100640.png" alt="image-20230517161838017"></p><p>key value query都是x</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100641.png" alt="image-20230517164245269"></p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原来： [querys, d(q)]  -&gt;  [querys, d(v)]</span><br>o = attention(queries, keys, values)   <span class="hljs-variable language_">self</span>.attention(query, enc_outputs, enc_outputs)<br><br><span class="hljs-comment"># 现在: [querys=t, d(x)]  -&gt;  [t, d(x)]</span><br>X = <span class="hljs-variable language_">self</span>.attention(X, X, X)<br><br><span class="hljs-comment"># 如果是在decoer，则不能看到当前t时刻以后的信息,(b, t) 每一行都是[1, 2, ...n]代表长度</span><br>X = <span class="hljs-variable language_">self</span>.attention(X, X, X, <br>                   torch.arange(<span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 如果所在预测阶段，Key_value需要不断生成，X为单个字符(1, 1, h) key_value(1, now_t, h) 前t个字符</span><br>    enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span><br>    <span class="hljs-comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span><br>    key_values = torch.cat((state[<span class="hljs-number">2</span>][<span class="hljs-variable language_">self</span>.i], X), axis=<span class="hljs-number">1</span>)<br>    state[<span class="hljs-number">2</span>][<span class="hljs-variable language_">self</span>.i] = key_values<br><br>    <span class="hljs-comment"># 自注意力</span><br>    X2 = <span class="hljs-variable language_">self</span>.attention1(X, key_values, key_values, dec_valid_lens=<span class="hljs-literal">None</span>)<br>    Y = <span class="hljs-variable language_">self</span>.addnorm1(X, X2)<br></code></pre></td></tr></table></figure><h4 id="pos-encoding"><a href="#pos-encoding" class="headerlink" title="pos-encoding"></a>pos-encoding</h4><p>失去了位置信息，添加上位置P矩阵。n个词i，每个d维j。也可以是可学习（BERT）<br>$$<br>\begin{aligned} p_{i, 2j} &amp;&#x3D; \sin\left(\frac{i}{10000^{2j&#x2F;d}}\right),\p_{i, 2j+1} &amp;&#x3D; \cos\left(\frac{i}{10000^{2j&#x2F;d}}\right).\end{aligned}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save </span><br>[b, t, d]  -&gt;  [b, t, d]    p:[<span class="hljs-number">1</span>, max_len, num_hiddens]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionalEncoding</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;位置编码&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_hiddens, dropout, max_len=<span class="hljs-number">1000</span></span>):<br>        <span class="hljs-built_in">super</span>(PositionalEncoding, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout(dropout)<br>        <span class="hljs-comment"># 创建一个足够长的P</span><br>        <span class="hljs-variable language_">self</span>.P = torch.zeros((<span class="hljs-number">1</span>, max_len, num_hiddens))<br>        X = torch.arange(max_len, dtype=torch.float32).reshape(<br>            -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) / torch.<span class="hljs-built_in">pow</span>(<span class="hljs-number">10000</span>, torch.arange(<br>            <span class="hljs-number">0</span>, num_hiddens, <span class="hljs-number">2</span>, dtype=torch.float32) / num_hiddens)<br>        <span class="hljs-variable language_">self</span>.P[:, :, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(X)<br>        <span class="hljs-variable language_">self</span>.P[:, :, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(X)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        X = X + <span class="hljs-variable language_">self</span>.P[:, :X.shape[<span class="hljs-number">1</span>], :].to(X.device)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dropout(X)<br></code></pre></td></tr></table></figure><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100642.png" alt="image-20230517164528517" style="zoom:67%;" /><p>QA：</p><ol><li>self-attention理解为一个layer，有输入输出</li><li>BERT 其实是纯self-attention + context-attention</li></ol><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><ul><li>encoder-decoder架构</li><li>纯注意力，n个transformer块</li><li>block input-output形状一样</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100643.png" alt="image-20230523122148500"></p><p>编码器的状态信息会同时传给每一个解码器block</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100644.png" alt="image-20230524212752754" style="zoom:50%;" /><h4 id="muti-head-attention"><a href="#muti-head-attention" class="headerlink" title="muti-head-attention"></a>muti-head-attention</h4><p>多个dot attention，也就是多个h。dot attention通过一个多头相当于添加了可学习参数</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100645.png" alt="image-20230523112624348"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num_hiddens, num_heads = <span class="hljs-number">100</span>, <span class="hljs-number">5</span><br><br>X = torch.ones((b, num_queries, num_hiddens))<br>Y = torch.ones((b, num_kvpairs, num_hiddens))<br>attention = MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,<br>                               num_hiddens, num_heads, <span class="hljs-number">0.5</span>)<br>attention(X, Y, Y, valid_lens).shape = [b, num_queries, num_hiddens]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save </span><br>t:查询或者“键－值”对的个数<br>transpose_qkv：(b，t，num_hiddens) -&gt; (b*num_heads, t, num_hiddens/num_heads)<br>相对于num_hiddens保存了多个头的信息，输入时拆分出来，为了直接大矩阵乘法去除<span class="hljs-keyword">for</span>循环<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;多头注意力&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 num_heads, dropout, bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(MultiHeadAttention, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.num_heads = num_heads<br>        <span class="hljs-variable language_">self</span>.attention = d2l.DotProductAttention(dropout)<br>        <span class="hljs-variable language_">self</span>.W_q = nn.Linear(query_size, num_hiddens, bias=bias)<br>        <span class="hljs-variable language_">self</span>.W_k = nn.Linear(key_size, num_hiddens, bias=bias)<br>        <span class="hljs-variable language_">self</span>.W_v = nn.Linear(value_size, num_hiddens, bias=bias)<br>        <span class="hljs-variable language_">self</span>.W_o = nn.Linear(num_hiddens, num_hiddens, bias=bias)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, queries, keys, values, valid_lens</span>):<br>        <span class="hljs-comment"># queries，keys，values的形状:</span><br>        <span class="hljs-comment"># (batch_size，查询或者“键－值”对的个数，num_hiddens)</span><br>        <span class="hljs-comment"># valid_lens　的形状:</span><br>        <span class="hljs-comment"># (batch_size，)或(batch_size，查询的个数)</span><br>        <span class="hljs-comment"># 经过变换后，输出的queries，keys，values　的形状:</span><br>        <span class="hljs-comment"># (batch_size*num_heads，查询或者“键－值”对的个数，</span><br>        <span class="hljs-comment"># num_hiddens/num_heads)</span><br>        queries = transpose_qkv(<span class="hljs-variable language_">self</span>.W_q(queries), <span class="hljs-variable language_">self</span>.num_heads)<br>        keys = transpose_qkv(<span class="hljs-variable language_">self</span>.W_k(keys), <span class="hljs-variable language_">self</span>.num_heads)<br>        values = transpose_qkv(<span class="hljs-variable language_">self</span>.W_v(values), <span class="hljs-variable language_">self</span>.num_heads)<br><br>        <span class="hljs-keyword">if</span> valid_lens <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 在轴0，将第一项（标量或者矢量）复制num_heads次，</span><br>            <span class="hljs-comment"># 然后如此复制第二项，然后诸如此类。</span><br>            valid_lens = torch.repeat_interleave(<br>                valid_lens, repeats=<span class="hljs-variable language_">self</span>.num_heads, dim=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># output的形状:(batch_size*num_heads，查询的个数，</span><br>        <span class="hljs-comment"># num_hiddens/num_heads)</span><br>        output = <span class="hljs-variable language_">self</span>.attention(queries, keys, values, valid_lens)<br><br>        <span class="hljs-comment"># output_concat的形状:(batch_size，查询的个数，num_hiddens)</span><br>        output_concat = transpose_output(output, <span class="hljs-variable language_">self</span>.num_heads)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.W_o(output_concat)<br></code></pre></td></tr></table></figure><h4 id="FFN"><a href="#FFN" class="headerlink" title="FFN"></a>FFN</h4><p>基于位置的前馈网络两层 MLP，[b, t, in] -&gt; [b, t, out]</p><p>self-attention是在不同的t之间汇聚信息，而mlp对单个t中的in信息做处理</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100646.png" alt="image-20230524205443098" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PositionWiseFFN</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;基于位置的前馈网络&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ffn_num_input=<span class="hljs-number">512</span>, ffn_num_hiddens=<span class="hljs-number">2048</span>, ffn_num_outputs=<span class="hljs-number">512</span>,</span><br><span class="hljs-params">                 **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(PositionWiseFFN, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens)<br>        <span class="hljs-variable language_">self</span>.relu = nn.ReLU()<br>        <span class="hljs-variable language_">self</span>.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dense2(<span class="hljs-variable language_">self</span>.relu(<span class="hljs-variable language_">self</span>.dense1(X)))<br></code></pre></td></tr></table></figure><h4 id="mask-Mutiattention"><a href="#mask-Mutiattention" class="headerlink" title="mask-Mutiattention"></a>mask-Mutiattention</h4><p>predict时，不能使用未来的信息，通过设置有效的attention长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.training:<br>    batch_size, num_steps, _ = X.shape<br>    <span class="hljs-comment"># dec_valid_lens的开头:(batch_size,num_steps),</span><br>    <span class="hljs-comment"># 其中每一行是[1,2,...,num_steps] 因为X相对于有num_steps个query，后面的query长度更长</span><br>    dec_valid_lens = torch.arange(<br>        <span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        dec_valid_lens = <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># mask-自注意力</span><br>X2 = <span class="hljs-variable language_">self</span>.attention1(X, X, X, dec_valid_lens)  <span class="hljs-comment"># 预测阶段key value需要不断拼接得到</span><br>Y = <span class="hljs-variable language_">self</span>.addnorm1(X, X2)<br></code></pre></td></tr></table></figure><h4 id="Context-Attention"><a href="#Context-Attention" class="headerlink" title="Context Attention"></a>Context Attention</h4><p>decoder第二层为context attention，query当前状态，keyvalue为encoder的输出</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100647.png" alt="image-20230524204852405" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>Y2 = <span class="hljs-variable language_">self</span>.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)<br>Z = <span class="hljs-variable language_">self</span>.addnorm2(Y, Y2)<br></code></pre></td></tr></table></figure><h4 id="AddNorm"><a href="#AddNorm" class="headerlink" title="AddNorm"></a>AddNorm</h4><p>残差标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddNorm</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, normalized_shape, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(AddNorm, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout(dropout)<br>        <span class="hljs-variable language_">self</span>.ln = nn.LayerNorm(normalized_shape)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, Y</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ln(<span class="hljs-variable language_">self</span>.dropout(Y) + X)<br></code></pre></td></tr></table></figure><h4 id="Encoderblock"><a href="#Encoderblock" class="headerlink" title="Encoderblock"></a>Encoderblock</h4><p>MultiHeadAttention + addnorm1 + ffn + addnorm2  输入输出维度不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>))<br>valid_lens = torch.tensor([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br>encoder_blk = EncoderBlock(<span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>)<br>encoder_blk.<span class="hljs-built_in">eval</span>()<br>encoder_blk(X, valid_lens).shape = [<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span><br><span class="hljs-params">                 dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(EncoderBlock, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.attention = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout,<br>            use_bias)<br>        <span class="hljs-variable language_">self</span>.addnorm1 = AddNorm(norm_shape, dropout)<br>        <span class="hljs-variable language_">self</span>.ffn = PositionWiseFFN(<br>            ffn_num_input, ffn_num_hiddens, num_hiddens)<br>        <span class="hljs-variable language_">self</span>.addnorm2 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, valid_lens</span>):<br>        Y = <span class="hljs-variable language_">self</span>.addnorm1(X, <span class="hljs-variable language_">self</span>.attention(X, X, X, valid_lens))<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.addnorm2(Y, <span class="hljs-variable language_">self</span>.ffn(Y))<br></code></pre></td></tr></table></figure><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>多个block堆叠。embedding + pos_encoding + 多个EncoderBlock</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">encoder = TransformerEncoder(<br>    <span class="hljs-number">200</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.5</span>)<br>encoder.<span class="hljs-built_in">eval</span>()<br>encoder(torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>), dtype=torch.long), valid_lens).shape<br>torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerEncoder</span>(d2l.Encoder):<br>    <span class="hljs-string">&quot;&quot;&quot;Transformer编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, key_size, query_size, value_size,</span><br><span class="hljs-params">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="hljs-params">                 num_heads, num_layers, dropout, use_bias=<span class="hljs-literal">False</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(TransformerEncoder, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.num_hiddens = num_hiddens<br>        <span class="hljs-variable language_">self</span>.embedding = nn.Embedding(vocab_size, num_hiddens)<br>        <span class="hljs-variable language_">self</span>.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)<br>        <span class="hljs-variable language_">self</span>.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            <span class="hljs-variable language_">self</span>.blks.add_module(<span class="hljs-string">&quot;block&quot;</span>+<span class="hljs-built_in">str</span>(i),<br>                EncoderBlock(key_size, query_size, value_size, num_hiddens,<br>                             norm_shape, ffn_num_input, ffn_num_hiddens,<br>                             num_heads, dropout, use_bias))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, valid_lens, *args</span>):<br>        <span class="hljs-comment"># 因为位置编码值在-1和1之间，</span><br>        <span class="hljs-comment"># 因此嵌入值乘以嵌入维度的平方根进行缩放，</span><br>        <span class="hljs-comment"># 然后再与位置编码相加。</span><br>        X = <span class="hljs-variable language_">self</span>.pos_encoding(<span class="hljs-variable language_">self</span>.embedding(X) * math.sqrt(<span class="hljs-variable language_">self</span>.num_hiddens))<br>        <span class="hljs-variable language_">self</span>.attention_weights = [<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.blks)<br>        <span class="hljs-keyword">for</span> i, blk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-variable language_">self</span>.blks):<br>            X = blk(X, valid_lens)<br>            <span class="hljs-variable language_">self</span>.attention_weights[<br>                i] = blk.attention.attention.attention_weights<br>        <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><h4 id="Decoderblock"><a href="#Decoderblock" class="headerlink" title="Decoderblock"></a>Decoderblock</h4><p>需要自己的输入和encoder的输出。输入输出维度不变！</p><p><code>self-MultiHeadAttention + addnorm1 + MultiHeadAttention（编码器解码器注意力） + addnorm2  + fnn + addnorm3</code></p><ul><li>第一次mask-self-attention就是<code>attention1(X, X, X, dec_valid_lens)</code>，dec_valid_lens保证不看后面</li><li>第二次需要用到encoder输出<code>attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderBlock</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key_size, query_size, value_size, num_hiddens,</span><br><span class="hljs-params">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span><br><span class="hljs-params">                 dropout, i, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(DecoderBlock, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.i = i<br>        <span class="hljs-variable language_">self</span>.attention1 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        <span class="hljs-variable language_">self</span>.addnorm1 = AddNorm(norm_shape, dropout)<br>        <span class="hljs-variable language_">self</span>.attention2 = d2l.MultiHeadAttention(<br>            key_size, query_size, value_size, num_hiddens, num_heads, dropout)<br>        <span class="hljs-variable language_">self</span>.addnorm2 = AddNorm(norm_shape, dropout)<br>        <span class="hljs-variable language_">self</span>.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens,<br>                                   num_hiddens)<br>        <span class="hljs-variable language_">self</span>.addnorm3 = AddNorm(norm_shape, dropout)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        enc_outputs, enc_valid_lens = state[<span class="hljs-number">0</span>], state[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 训练阶段，输出序列的所有词元都在同一时间处理，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]初始化为None。</span><br>        <span class="hljs-comment"># 预测阶段，输出序列是通过词元一个接着一个解码的，</span><br>        <span class="hljs-comment"># 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示</span><br>        <span class="hljs-keyword">if</span> state[<span class="hljs-number">2</span>][<span class="hljs-variable language_">self</span>.i] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            key_values = X<br>        <span class="hljs-keyword">else</span>:<br>            key_values = torch.cat((state[<span class="hljs-number">2</span>][<span class="hljs-variable language_">self</span>.i], X), axis=<span class="hljs-number">1</span>)<br>        state[<span class="hljs-number">2</span>][<span class="hljs-variable language_">self</span>.i] = key_values<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.training:<br>            batch_size, num_steps, _ = X.shape<br>            <span class="hljs-comment"># dec_valid_lens的开头:(batch_size,num_steps),</span><br>            <span class="hljs-comment"># 其中每一行是[1,2,...,num_steps] 因为X相对于有num_steps个query，后面的query长度更长</span><br>            dec_valid_lens = torch.arange(<br>                <span class="hljs-number">1</span>, num_steps + <span class="hljs-number">1</span>, device=X.device).repeat(batch_size, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            dec_valid_lens = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 自注意力</span><br>        X2 = <span class="hljs-variable language_">self</span>.attention1(X, key_values, key_values, dec_valid_lens)<br>        Y = <span class="hljs-variable language_">self</span>.addnorm1(X, X2)<br>        <span class="hljs-comment"># 编码器－解码器注意力。</span><br>        <span class="hljs-comment"># enc_outputs的开头:(batch_size,num_steps,num_hiddens)</span><br>        Y2 = <span class="hljs-variable language_">self</span>.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)<br>        Z = <span class="hljs-variable language_">self</span>.addnorm2(Y, Y2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.addnorm3(Z, <span class="hljs-variable language_">self</span>.ffn(Z)), state<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">decoder_blk = DecoderBlock(<span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">24</span>], <span class="hljs-number">24</span>, <span class="hljs-number">48</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>)<br>decoder_blk.<span class="hljs-built_in">eval</span>()<br>X = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">24</span>))<br>state = [encoder_blk(X, valid_lens), valid_lens, [<span class="hljs-literal">None</span>]]<br>decoder_blk(X, state)[<span class="hljs-number">0</span>].shape <span class="hljs-comment"># [2, 100, 24]</span><br></code></pre></td></tr></table></figure><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>embedding + pos_encoding + 多个decoderBlock + dense；decoderBlock需要的state训练时不变，都是encoder给的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerDecoder</span>(d2l.AttentionDecoder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, key_size, query_size, value_size,</span><br><span class="hljs-params">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="hljs-params">                 num_heads, num_layers, dropout, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(TransformerDecoder, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.num_hiddens = num_hiddens<br>        <span class="hljs-variable language_">self</span>.num_layers = num_layers<br>        <span class="hljs-variable language_">self</span>.embedding = nn.Embedding(vocab_size, num_hiddens)<br>        <span class="hljs-variable language_">self</span>.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)<br>        <span class="hljs-variable language_">self</span>.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            <span class="hljs-variable language_">self</span>.blks.add_module(<span class="hljs-string">&quot;block&quot;</span>+<span class="hljs-built_in">str</span>(i),<br>                DecoderBlock(key_size, query_size, value_size, num_hiddens,<br>                             norm_shape, ffn_num_input, ffn_num_hiddens,<br>                             num_heads, dropout, i))<br>        <span class="hljs-variable language_">self</span>.dense = nn.Linear(num_hiddens, vocab_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init_state</span>(<span class="hljs-params">self, enc_outputs, enc_valid_lens, *args</span>):<br>        <span class="hljs-keyword">return</span> [enc_outputs, enc_valid_lens, [<span class="hljs-literal">None</span>] * <span class="hljs-variable language_">self</span>.num_layers]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, state</span>):<br>        X = <span class="hljs-variable language_">self</span>.pos_encoding(<span class="hljs-variable language_">self</span>.embedding(X) * math.sqrt(<span class="hljs-variable language_">self</span>.num_hiddens))<br>        <span class="hljs-variable language_">self</span>._attention_weights = [[<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.blks) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">2</span>)]<br>        <span class="hljs-keyword">for</span> i, blk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-variable language_">self</span>.blks):<br>            X, state = blk(X, state)<br>            <span class="hljs-comment"># 解码器自注意力权重</span><br>            <span class="hljs-variable language_">self</span>._attention_weights[<span class="hljs-number">0</span>][<br>                i] = blk.attention1.attention.attention_weights<br>            <span class="hljs-comment"># “编码器－解码器”自注意力权重</span><br>            <span class="hljs-variable language_">self</span>._attention_weights[<span class="hljs-number">1</span>][<br>                i] = blk.attention2.attention.attention_weights<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dense(X), state<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">attention_weights</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._attention_weights<br></code></pre></td></tr></table></figure><h4 id="train-1"><a href="#train-1" class="headerlink" title="train"></a>train</h4><p><code>num_hiddens 512 1024， num_heads 8 16</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">num_hiddens, num_layers, dropout, batch_size, num_steps = <span class="hljs-number">32</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">10</span><br>lr, num_epochs, device = <span class="hljs-number">0.005</span>, <span class="hljs-number">200</span>, d2l.try_gpu()<br>ffn_num_input, ffn_num_hiddens, num_heads = <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">4</span><br>key_size, query_size, value_size = <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span><br>norm_shape = [<span class="hljs-number">32</span>]<br><br>train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps)<br><br>encoder = TransformerEncoder(<br>    <span class="hljs-built_in">len</span>(src_vocab), key_size, query_size, value_size, num_hiddens,<br>    norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,<br>    num_layers, dropout)<br>decoder = TransformerDecoder(<br>    <span class="hljs-built_in">len</span>(tgt_vocab), key_size, query_size, value_size, num_hiddens,<br>    norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,<br>    num_layers, dropout)<br>net = d2l.EncoderDecoder(encoder, decoder)<br>d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device)<br></code></pre></td></tr></table></figure><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>预测t+1：前t个转为key value，第t个为query</p><h4 id="QA：-2"><a href="#QA：-2" class="headerlink" title="QA："></a>QA：</h4><ol><li>concat特征比加权平均好</li><li>transfomer硬件要求还好，BERT很大</li><li>很多模型只有encoder，如bert</li><li>可以处理图片，抠出一个个patch</li></ol><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p>使用预训练模型提取句子特征，如word2vec(忽略时序)。预训练模型可以不更新，只修改output layer</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100648.png" alt="image-20230523145131209" style="zoom: 33%;" /><p>只有transformer的encoder：<code>block=12 24 hiddensize=768 1024 head=12 16   parameters=110 340M</code>  10亿个词</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li>Segment：没有解码器，所以输入输出都输入到encoder，用<sep>分开并且添加额外编码</li><li>Position：可学习</li><li>Token：普通编码</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100649.png" alt="image-20230523150435634"></p><h4 id="训练任务"><a href="#训练任务" class="headerlink" title="训练任务"></a>训练任务</h4><h5 id="带掩码"><a href="#带掩码" class="headerlink" title="带掩码"></a>带掩码</h5><p>transformer是双向的，如何做单向预测？</p><p>带掩码的语言模型：15%将一些词作为<mask>，完形填空</p><p>微调任务时，压根没有没有mask，让模型能在有答案情况下填空：对于mask 80%不变、10%保持、10%替换别的</p><h5 id="下一句子预测"><a href="#下一句子预测" class="headerlink" title="下一句子预测"></a>下一句子预测</h5><p>句子是不是相邻</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100650.png" alt="image-20230523151222497"></p><h4 id="BERT代码"><a href="#BERT代码" class="headerlink" title="BERT代码"></a>BERT代码</h4><p>1.对token添加<cls> <sep></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tokens_and_segments</span>(<span class="hljs-params">tokens_a, tokens_b=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;获取输入序列的词元及其片段索引&quot;&quot;&quot;</span><br>    tokens = [<span class="hljs-string">&#x27;&lt;cls&gt;&#x27;</span>] + tokens_a + [<span class="hljs-string">&#x27;&lt;sep&gt;&#x27;</span>]<br>    <span class="hljs-comment"># 0和1分别标记片段A和B</span><br>    segments = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(tokens_a) + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> tokens_b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        tokens += tokens_b + [<span class="hljs-string">&#x27;&lt;sep&gt;&#x27;</span>]<br>        segments += [<span class="hljs-number">1</span>] * (<span class="hljs-built_in">len</span>(tokens_b) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> tokens, segments<br></code></pre></td></tr></table></figure><h5 id="BERTEncoder"><a href="#BERTEncoder" class="headerlink" title="BERTEncoder"></a>BERTEncoder</h5><p>输入tokens，segments [b, t]，返回[b, t, hidden]。Encoder中包含pos_embedding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTEncoder</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT编码器&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="hljs-params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span><br><span class="hljs-params">                 max_len=<span class="hljs-number">1000</span>, key_size=<span class="hljs-number">768</span>, query_size=<span class="hljs-number">768</span>, value_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(BERTEncoder, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.token_embedding = nn.Embedding(vocab_size, num_hiddens)<br>        <span class="hljs-variable language_">self</span>.segment_embedding = nn.Embedding(<span class="hljs-number">2</span>, num_hiddens)<br>        <span class="hljs-variable language_">self</span>.blks = nn.Sequential()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers):<br>            <span class="hljs-variable language_">self</span>.blks.add_module(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, d2l.EncoderBlock(<br>                key_size, query_size, value_size, num_hiddens, norm_shape,<br>                ffn_num_input, ffn_num_hiddens, num_heads, dropout, <span class="hljs-literal">True</span>))<br>        <span class="hljs-comment"># 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数</span><br>        <span class="hljs-variable language_">self</span>.pos_embedding = nn.Parameter(torch.randn(<span class="hljs-number">1</span>, max_len,<br>                                                      num_hiddens))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, tokens, segments, valid_lens</span>):<br>        <span class="hljs-comment"># 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens）</span><br>        X = <span class="hljs-variable language_">self</span>.token_embedding(tokens) + <span class="hljs-variable language_">self</span>.segment_embedding(segments)<br>        X = X + <span class="hljs-variable language_">self</span>.pos_embedding.data[:, :X.shape[<span class="hljs-number">1</span>], :]<br>        <span class="hljs-keyword">for</span> blk <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.blks:<br>            X = blk(X, valid_lens)<br>        <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><h5 id="MaskLM"><a href="#MaskLM" class="headerlink" title="MaskLM"></a>MaskLM</h5><p>对编码器的输出特征encoded_X，在指定位置上pred_positions，提取出该位置特征masked_X去分类</p><p><code>encoded_X：[b, t, hidden]    pred_positions：[b, num_pred]    masked_X：[b, num_pred, hidden]   </code></p><p><code>out: [b, num_pred, vocab_size]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskLM</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT的掩蔽语言模型任务&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, num_inputs=<span class="hljs-number">768</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(MaskLM, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens),<br>                                 nn.ReLU(),<br>                                 nn.LayerNorm(num_hiddens),<br>                                 nn.Linear(num_hiddens, vocab_size))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, pred_positions</span>):<br>        num_pred_positions = pred_positions.shape[<span class="hljs-number">1</span>]<br>        pred_positions = pred_positions.reshape(-<span class="hljs-number">1</span>)<br>        batch_size = X.shape[<span class="hljs-number">0</span>]<br>        batch_idx = torch.arange(<span class="hljs-number">0</span>, batch_size)<br>        <span class="hljs-comment"># 假设batch_size=2，num_pred_positions=3</span><br>        <span class="hljs-comment"># 那么batch_idx是np.array（[0,0,0,1,1,1]）</span><br>        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)<br>        masked_X = X[batch_idx, pred_positions]<br>        masked_X = masked_X.reshape((batch_size, num_pred_positions, -<span class="hljs-number">1</span>))<br>        mlm_Y_hat = <span class="hljs-variable language_">self</span>.mlp(masked_X)<br>        <span class="hljs-keyword">return</span> mlm_Y_hat<br></code></pre></td></tr></table></figure><h5 id="NextSentencePred"><a href="#NextSentencePred" class="headerlink" title="NextSentencePred"></a>NextSentencePred</h5><p>对<code>encoded_X[:, 0, :]</code><cls>的特征进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NextSentencePred</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT的下一句预测任务&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_inputs, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>(NextSentencePred, <span class="hljs-variable language_">self</span>).__init__(**kwargs)<br>        <span class="hljs-variable language_">self</span>.output = nn.Linear(num_inputs, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-comment"># X的形状：(batchsize,num_hiddens)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.output(X)<br></code></pre></td></tr></table></figure><h5 id="BERTModel"><a href="#BERTModel" class="headerlink" title="BERTModel"></a>BERTModel</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTModel</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;BERT模型&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="hljs-params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span><br><span class="hljs-params">                 max_len=<span class="hljs-number">1000</span>, key_size=<span class="hljs-number">768</span>, query_size=<span class="hljs-number">768</span>, value_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 hid_in_features=<span class="hljs-number">768</span>, mlm_in_features=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">                 nsp_in_features=<span class="hljs-number">768</span></span>):<br>        <span class="hljs-built_in">super</span>(BERTModel, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape,<br>                    ffn_num_input, ffn_num_hiddens, num_heads, num_layers,<br>                    dropout, max_len=max_len, key_size=key_size,<br>                    query_size=query_size, value_size=value_size)<br>        <span class="hljs-variable language_">self</span>.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens),<br>                                    nn.Tanh())<br>        <span class="hljs-variable language_">self</span>.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features)<br>        <span class="hljs-variable language_">self</span>.nsp = NextSentencePred(nsp_in_features)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, tokens, segments, valid_lens=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                pred_positions=<span class="hljs-literal">None</span></span>):<br>        encoded_X = <span class="hljs-variable language_">self</span>.encoder(tokens, segments, valid_lens)<br>        <span class="hljs-keyword">if</span> pred_positions <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            mlm_Y_hat = <span class="hljs-variable language_">self</span>.mlm(encoded_X, pred_positions)<br>        <span class="hljs-keyword">else</span>:<br>            mlm_Y_hat = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 用于下一句预测的多层感知机分类器的隐藏层，0是“&lt;cls&gt;”标记的索引</span><br>        nsp_Y_hat = <span class="hljs-variable language_">self</span>.nsp(<span class="hljs-variable language_">self</span>.hidden(encoded_X[:, <span class="hljs-number">0</span>, :]))<br>        <span class="hljs-keyword">return</span> encoded_X, mlm_Y_hat, nsp_Y_hat<br></code></pre></td></tr></table></figure><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul><li>需要先获得 tokens, segments, is_next ； segments为0、1用于区别句子</li><li>对tokens进行mask替换，返回tokens，positions，positions上原词汇mlm_Y</li><li>pad  和对应 valid_lens。all_mlm_weights0或1用于过滤掉mask中，属于pad的词</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) <span class="hljs-keyword">in</span> train_iter<br><br>torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 64]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 64]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512, 10]</span>) torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[512]</span>)<br><br>mlm_weights_X <span class="hljs-number">0</span>或<span class="hljs-number">1</span>用于过滤掉<span class="hljs-attribute">mask</span>中，属于pad的词<br></code></pre></td></tr></table></figure><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练是不需要encoder_X,为了提升模型抽取encoder的能力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">net = d2l.BERTModel(<span class="hljs-built_in">len</span>(vocab), num_hiddens=<span class="hljs-number">128</span>, norm_shape=[<span class="hljs-number">128</span>],<br>                    ffn_num_input=<span class="hljs-number">128</span>, ffn_num_hiddens=<span class="hljs-number">256</span>, num_heads=<span class="hljs-number">2</span>,<br>                    num_layers=<span class="hljs-number">2</span>, dropout=<span class="hljs-number">0.2</span>, key_size=<span class="hljs-number">128</span>, query_size=<span class="hljs-number">128</span>,<br>                    value_size=<span class="hljs-number">128</span>, hid_in_features=<span class="hljs-number">128</span>, mlm_in_features=<span class="hljs-number">128</span>,<br>                    nsp_in_features=<span class="hljs-number">128</span>)<br>devices = d2l.try_all_gpus()<br>loss = nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_batch_loss_bert</span>(<span class="hljs-params">net, loss, vocab_size, tokens_X,</span><br><span class="hljs-params">                         segments_X, valid_lens_x,</span><br><span class="hljs-params">                         pred_positions_X, mlm_weights_X,</span><br><span class="hljs-params">                         mlm_Y, nsp_y</span>):<br>    <span class="hljs-comment"># 前向传播</span><br>    _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X,<br>                                  valid_lens_x.reshape(-<span class="hljs-number">1</span>),<br>                                  pred_positions_X)<br>    <span class="hljs-comment"># 计算遮蔽语言模型损失 不计算pad的</span><br>    mlm_l = loss(mlm_Y_hat.reshape(-<span class="hljs-number">1</span>, vocab_size), mlm_Y.reshape(-<span class="hljs-number">1</span>)) *\<br>    mlm_weights_X.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    mlm_l = mlm_l.<span class="hljs-built_in">sum</span>() / (mlm_weights_X.<span class="hljs-built_in">sum</span>() + <span class="hljs-number">1e-8</span>)<br>    <span class="hljs-comment"># 计算下一句子预测任务的损失</span><br>    nsp_l = loss(nsp_Y_hat, nsp_y)<br>    l = mlm_l + nsp_l<br>    <span class="hljs-keyword">return</span> mlm_l, nsp_l, l<br></code></pre></td></tr></table></figure><h4 id="BERT表示文本"><a href="#BERT表示文本" class="headerlink" title="BERT表示文本"></a>BERT表示文本</h4><p>利用BERT获得句子的encoded_X，去进行分类、预测等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_bert_encoding</span>(<span class="hljs-params">net, tokens_a, tokens_b=<span class="hljs-literal">None</span></span>):<br>    tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)<br>    token_ids = torch.tensor(vocab[tokens], device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    segments = torch.tensor(segments, device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    valid_len = torch.tensor(<span class="hljs-built_in">len</span>(tokens), device=devices[<span class="hljs-number">0</span>]).unsqueeze(<span class="hljs-number">0</span>)<br>    encoded_X, _, _ = net(token_ids, segments, valid_len)<br>    <span class="hljs-keyword">return</span> encoded_X<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">tokens_a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;crane&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;flying&#x27;</span>]<br>encoded_text = get_bert_encoding(net, tokens_a) [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">128</span>]<br><span class="hljs-comment"># 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;is&#x27;,&#x27;flying&#x27;,&#x27;&lt;sep&gt;&#x27;</span><br>encoded_text_cls = encoded_text[:, <span class="hljs-number">0</span>, :]  [<span class="hljs-number">1</span>, <span class="hljs-number">128</span>]<br><br>tokens_a, tokens_b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;crane&#x27;</span>, <span class="hljs-string">&#x27;driver&#x27;</span>, <span class="hljs-string">&#x27;came&#x27;</span>], [<span class="hljs-string">&#x27;he&#x27;</span>, <span class="hljs-string">&#x27;just&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>]<br>encoded_pair = get_bert_encoding(net, tokens_a, tokens_b)<br><span class="hljs-comment"># 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;driver&#x27;,&#x27;came&#x27;,&#x27;&lt;sep&gt;&#x27;,&#x27;he&#x27;,&#x27;just&#x27;, &#x27;left&#x27;,&#x27;&lt;sep&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="QA：-3"><a href="#QA：-3" class="headerlink" title="QA："></a>QA：</h4><ol><li>模型太大？ model分在不同GPU上</li></ol><h3 id="微调BERT"><a href="#微调BERT" class="headerlink" title="微调BERT"></a>微调BERT</h3><p>利用bert对每个词都抽取了特征，我们不需要考虑如何抽取句子特征、词特征了。只需要添加输出层。需要相同Vocab</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100651.png" alt="image-20230523164053828" style="zoom:50%;" /><ul><li><p>句子分类：直接用<cls>的特征，别的也可以但最好cls</p></li><li><p>识别词元是不是特殊词：人名、地名、机构。  对每一个词的特征做二分类</p></li><li><p>问题回答：给出一段话和一个问题。对于一段话中每一个词，预测是不是问题的开始和结束。三分类</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305261100652.png" alt="image-20230523164551697" style="zoom:50%;" /></li></ul><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><p>只需要用上encoder，hidden是bert中输出到NSP前的处理，这里也用上；相对于替换了NSP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERTClassifier</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bert</span>):<br>        <span class="hljs-built_in">super</span>(BERTClassifier, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.encoder = bert.encoder<br>        <span class="hljs-variable language_">self</span>.hidden = bert.hidden<br>        <span class="hljs-variable language_">self</span>.output = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        tokens_X, segments_X, valid_lens_x = inputs<br>        encoded_X = <span class="hljs-variable language_">self</span>.encoder(tokens_X, segments_X, valid_lens_x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.output(<span class="hljs-variable language_">self</span>.hidden(encoded_X[:, <span class="hljs-number">0</span>, :]))<br></code></pre></td></tr></table></figure><h4 id="QA-1"><a href="#QA-1" class="headerlink" title="QA:"></a>QA:</h4><ol><li>YOLO基础效果不好，但加了大量trick细节</li><li>通过蒸馏十分之一大小，但精度不会下降很多</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 - jyy</title>
    <link href="/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20jyy/"/>
    <url>/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20jyy/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章涵盖了计算机编程和操作系统的多个重要概念，包括并发编程、线程、互斥锁、死锁、生产者和消费者问题、操作系统内核、进程管理、内存映射、系统调用等。通过一系列示例代码和模型演示，文章深入探讨了如何实现和管理并发程序、系统调用的作用、进程创建和切换机制、地址空间管理等内容。它强调了使用工具（如锁、条件变量、信号量）解决并发问题的方法，并通过代码实例展示了如何避免数据竞争和死锁。最后，文章探讨了如何通过入侵地址空间进行调试和性能分析，以及如何利用系统提供的机制（如mmap）管理内存。整体上，这篇文章提供了对计算机系统核心概念的全面理解，对于理解现代操作系统和并发程序的实现机制非常有价值。</p></blockquote><p>有什么不懂的直接问gpt</p><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404494.png" alt="image-20230512154440672" style="zoom: 67%;" /><p>00 01 10 00 01 10</p><h4 id="源代码角度"><a href="#源代码角度" class="headerlink" title="源代码角度"></a>源代码角度</h4><p>同时我们也可以用C语言实现</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404496.png" alt="image-20230512155633763"></p><p>状态：内存中的所有东西，全部栈帧</p><p>使用栈模拟递归</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404497.png" alt="image-20230512161116475" style="zoom: 67%;" /><h4 id="二进制角度"><a href="#二进制角度" class="headerlink" title="二进制角度"></a>二进制角度</h4><ul><li>状态：内存 + 寄存器</li><li>初始状态：</li><li>迁移：一条01指令</li></ul><p>任何的程序都需要退出，也就是结束。因此需要特别的指令 <code>syscall</code> 把现在的状态交给操作系统</p><p>程序 &#x3D;  普通计算 + <code>syscall</code></p><p>实现与操作系统中别的对象交互</p><ul><li>读写文件  如果有权限，操作系统把状态写入程序的M, R</li><li>改变进程 杀死程序</li></ul><p>如何构造一个<code>printf(&quot;hello world&quot;)</code></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404498.png" alt="image-20230512171448873" style="zoom:67%;" /><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>收编了所有对象（包含程序状态机和文件），实现霸主地位</li><li>管理多个状态机，根据权限访问。打开文件，屏幕显示</li></ul><p>在程序眼里，操作系统就是<code>syscall</code>，程序 &#x3D; (普通计算 + <code>syscall</code>)  如何只展示<code>syscall</code></p><ul><li><code>strace a.out</code>  去掉计算，只展示用到的所有的系统调用</li></ul><p>c语言的第一条程序是什么，谁定义的，能不能修改</p><p>计算机没有玄学，一切都建立在确定的机制上。bug只要能复现，就能解决</p><h4 id="Python操作系统"><a href="#Python操作系统" class="headerlink" title="Python操作系统"></a>Python操作系统</h4><p><strong>思路</strong></p><ul><li>应用程序 &#x3D; 纯粹计算（Python 代码） + <code>syscall</code>；  状态机</li><li>操作系统 &#x3D; Python <code>syscall</code>实现，有 “假想” 的 I&#x2F;O 设备；   管理状态机</li></ul><p>​    操作系统为方框，程序为圆圈，操作系统管理全部程序，并且会提供红色的<code>syscall</code>指令。蓝色为当前运行程序<br>当<code>spawn</code>创建程序后，操作系统有了选择，到底执行哪一个程序呢？</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404499.png" alt="image-20230527124547932"></p><p><strong>四个 “系统调用” API</strong></p><ul><li><code>choose(xs)</code>: 返回 <code>xs</code> 中的一个随机选项，纯粹的计算不能实现随机</li><li><code>write(s)</code>: 输出字符串 <code>s</code></li><li><code>spawn(fn)</code>: 创建一个可运行的状态机 <code>fn</code></li><li><code>sched()</code>: 随机切换到任意状态机执行（这里是主动切换，实际也存在被OS强制切换）</li></ul><h5 id="demo-code"><a href="#demo-code" class="headerlink" title="demo-code"></a>demo-code</h5><p>我进行状态机切换，肯定需要保存状态（变量值是多少、pc在哪） ： <code>yield</code>  （实际OS由一段汇编代码将当前状态机 (执行流) 的寄存器保存到内存中）<br>每一个进程在操作系统里被视为一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatingSystem</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;A minimal executable operating system model.&quot;&quot;&quot;</span><br><br>    SYSCALLS = [<span class="hljs-string">&#x27;choose&#x27;</span>, <span class="hljs-string">&#x27;write&#x27;</span>, <span class="hljs-string">&#x27;spawn&#x27;</span>, <span class="hljs-string">&#x27;sched&#x27;</span>]<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;A &quot;freezed&quot; thread state.&quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func, *args</span>):<br>            <span class="hljs-variable language_">self</span>._func = func(*args)<br>            <span class="hljs-variable language_">self</span>.retval = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;Proceed with the thread until its next trap.&quot;&quot;&quot;</span><br>            syscall, args, *_ = <span class="hljs-variable language_">self</span>._func.send(<span class="hljs-variable language_">self</span>.retval)<br>            <span class="hljs-variable language_">self</span>.retval = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">return</span> syscall, args<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, src</span>):<br>        variables = &#123;&#125;<br>        <span class="hljs-built_in">exec</span>(src, variables)<br>        <span class="hljs-variable language_">self</span>._main = variables[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        threads = [OperatingSystem.Thread(<span class="hljs-variable language_">self</span>._main)]<br>        <span class="hljs-keyword">while</span> threads:  <span class="hljs-comment"># Any thread lives</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">match</span> (t := threads[<span class="hljs-number">0</span>]).step():<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;choose&#x27;</span>, xs:  <span class="hljs-comment"># Return a random choice</span><br>                        t.retval = random.choice(xs)<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;write&#x27;</span>, xs:  <span class="hljs-comment"># Write to debug console</span><br>                        <span class="hljs-built_in">print</span>(xs, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;spawn&#x27;</span>, (fn, args):  <span class="hljs-comment"># Spawn a new thread</span><br>                        threads += [OperatingSystem.Thread(fn, *args)]<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sched&#x27;</span>, _:  <span class="hljs-comment"># Non-deterministic schedule</span><br>                        random.shuffle(threads)<br>            <span class="hljs-keyword">except</span> StopIteration:  <span class="hljs-comment"># A thread terminates</span><br>                threads.remove(t)<br>                random.shuffle(threads)  <span class="hljs-comment"># sys_sched()</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Usage: <span class="hljs-subst">&#123;sys.argv[<span class="hljs-number">0</span>]&#125;</span> file&#x27;</span>)<br>        exit(<span class="hljs-number">1</span>)<br><br>    src = Path(sys.argv[<span class="hljs-number">1</span>]).read_text()<br>    <span class="hljs-keyword">for</span> syscall <span class="hljs-keyword">in</span> OperatingSystem.SYSCALLS:<br>        src = src.replace(<span class="hljs-string">f&#x27;sys_<span class="hljs-subst">&#123;syscall&#125;</span>&#x27;</span>,        <span class="hljs-comment"># sys_write(...)</span><br>                          <span class="hljs-string">f&#x27;yield &quot;<span class="hljs-subst">&#123;syscall&#125;</span>&quot;, &#x27;</span>)  <span class="hljs-comment">#  -&gt; yield &#x27;write&#x27;, (...)</span><br><br>    OperatingSystem(src).run()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Tprint</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">global</span> count<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        count += <span class="hljs-number">1</span><br>        sys_write(<span class="hljs-string">f&#x27;#<span class="hljs-subst">&#123;count:02&#125;</span> Hello from <span class="hljs-subst">&#123;name&#125;</span><span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>\n&#x27;</span>)<br>        sys_sched()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n = sys_choose([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>    sys_write(<span class="hljs-string">f&#x27;#Thread = <span class="hljs-subst">&#123;n&#125;</span>\n&#x27;</span>)<br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABCDE&#x27;</span>[:n]:<br>        sys_spawn(Tprint, name)<br>    sys_sched()<br></code></pre></td></tr></table></figure><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><p>进程 + 线程 + 终端 + 存储 (崩溃一致性)</p><table><thead><tr><th align="left">系统调用&#x2F;Linux 对应</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">sys_spawn(fn)&#x2F;pthread_create</td><td align="left">创建从 fn 开始执行的线程</td></tr><tr><td align="left">sys_fork()&#x2F;fork</td><td align="left">创建当前状态机的完整复制</td></tr><tr><td align="left">sys_sched()&#x2F;定时被动调用</td><td align="left">切换到随机的线程&#x2F;进程执行</td></tr><tr><td align="left">sys_choose(xs)&#x2F;rand</td><td align="left">返回一个 xs 中的随机的选择</td></tr><tr><td align="left">sys_write(s)&#x2F;printf</td><td align="left">向调试终端输出字符串 s</td></tr><tr><td align="left">sys_bread(k)&#x2F;read</td><td align="left">读取虚拟设磁盘块 �<em>k</em> 的数据</td></tr><tr><td align="left">sys_bwrite(k, v)&#x2F;write</td><td align="left">向虚拟磁盘块 �<em>k</em> 写入数据 �<em>v</em></td></tr><tr><td align="left">sys_sync()&#x2F;sync</td><td align="left">将所有向虚拟磁盘的数据写入落盘</td></tr><tr><td align="left">sys_crash()&#x2F;长按电源按键</td><td align="left">模拟系统崩溃</td></tr></tbody></table><p><code>mosaic.py</code>：500行操作系统。还实现了打印每一步的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">T = <span class="hljs-number">3</span><br>n = <span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Tsum</span>( ):<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        tmp = heap.x<br>        tmp += <span class="hljs-number">1</span><br>        sys_sched()<br>        heap.x = tmp<br>        sys_sched()  <span class="hljs-comment"># 没有这一步, 最小为 n=3  添加后为2</span><br>    heap.done += <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    heap.x = <span class="hljs-number">0</span><br>    heap.done = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br>    sys_spawn(Tsum)<br>    <span class="hljs-keyword">while</span> heap.done != T:<br>    sys_sched()<br>    sys_write(<span class="hljs-string">f&#x27;SUM = <span class="hljs-subst">&#123;heap.x&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>不确定性发生在<code>sys_sched()</code>， <code>--check</code> 遍历所有答案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tsum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> tmp = sum;<br>    tmp++;<br>    <span class="hljs-comment">// 假设此时可能发生进程/线程切换</span><br>    sum = tmp;<br>    <span class="hljs-comment">// 假设此时可能发生进程/线程切换  没有这个最小值为n</span><br>  &#125;<br>&#125;<br>T个程序执行n次，[<span class="hljs-number">2</span>~n*T]<br></code></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="多处理器编程"><a href="#多处理器编程" class="headerlink" title="多处理器编程"></a><a href="http://jyywiki.cn/OS/2022/slides/3.slides">多处理器编程</a></h3><p><strong>1.放弃原子性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> balance = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Alipay_withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amt)</span> &#123;<br>  <span class="hljs-keyword">if</span> (balance &gt;= amt) &#123;<br>    balance -= amt;<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> FAIL;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) sum++;<br></code></pre></td></tr></table></figure><p><code>printf(&quot;a&quot;) </code>为什么不会报错？带了锁</p><p>互斥和原子性是本学期的重要主题</p><p> <strong>2.顺序丧失</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">-O1: R[eax] = sum; R[eax] += N; sum = R[eax]<br>    O1保证最终一致，如果要写入多次，直接一次性写入<br>    最终读出<span class="hljs-number">100000000</span><br>    <br>-O2: sum += N;  <span class="hljs-number">200000000</span><br>    <br>另一个例子： 系统默认done不会改变了<br>    <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-comment">// would be optimized to</span><br>    <span class="hljs-keyword">if</span> (!done) <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>3.丧失可见性</strong></p><p>理论上输出 01 10 11, 但其实00也有输出</p><p>处理器也是一个编译器，一条指令拆分多个uops</p><p>如果想写入x时未命中，print就可以先执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span> &#123;<br>  x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y = %d\n&quot;</span>, y);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span> &#123;<br>  y = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d\n&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="理解并发程序执行"><a href="#理解并发程序执行" class="headerlink" title="理解并发程序执行"></a><a href="http://jyywiki.cn/OS/2022/slides/4.slides">理解并发程序执行</a></h3><p>在<strong>共享内存</strong>实现并发时，一个反例   <code>get set</code>不是原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> locked = UNLOCK;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">critical_section</span><span class="hljs-params">()</span> &#123;<br>retry:<br>  <span class="hljs-keyword">if</span> (locked != UNLOCK) &#123;<br>    <span class="hljs-keyword">goto</span> retry;<br>  &#125;<br>  locked = LOCK;<br><br>  <span class="hljs-comment">// critical section</span><br><br>  locked = UNLOCK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Peterson"><a href="#Peterson" class="headerlink" title="Peterson"></a>Peterson</h4><p>棋子代表：我想上厕所；门上贴的人代表着：谁能上厕所</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404500.png" alt="image-20230514163743735" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, turn = A;<br>void TA() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>/* PC=<span class="hljs-number">1</span> */  x = <span class="hljs-number">1</span>;<br>/* PC=<span class="hljs-number">2</span> */  turn = B;<br>/* PC=<span class="hljs-number">3</span> */  <span class="hljs-keyword">while</span> (y &amp;&amp; turn == B) ;<br>            critical_section();<br>/* PC=<span class="hljs-number">4</span> */  x = <span class="hljs-number">0</span>; &#125; &#125;<br>void TB() &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>/* PC=<span class="hljs-number">1</span> */  y = <span class="hljs-number">1</span>;<br>/* PC=<span class="hljs-number">2</span> */  turn = A;<br>/* PC=<span class="hljs-number">3</span> */  <span class="hljs-keyword">while</span> (x &amp;&amp; turn == A) ;<br>            critical_section();<br>/* PC=<span class="hljs-number">4</span> */  y = <span class="hljs-number">0</span>; &#125; &#125;<br></code></pre></td></tr></table></figure><p>证明正确性：直接画出状态机表达出全部状态。</p><h4 id="Model-Checker"><a href="#Model-Checker" class="headerlink" title="Model Checker"></a>Model Checker</h4><p>并发程序 &#x3D; 状态机，画出状态机就可以知道并发程序有没有错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span>:<br>    locked = <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">T1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">yield</span> checkpoint()<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">yield</span> checkpoint()<br>            <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.locked == <span class="hljs-string">&#x27;🔒&#x27;</span>:<br>                <span class="hljs-keyword">yield</span> checkpoint()<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">yield</span> checkpoint()<br>            <span class="hljs-variable language_">self</span>.locked = <span class="hljs-string">&#x27;🔒&#x27;</span><br>            ...<br></code></pre></td></tr></table></figure><p>使用程序去遍历出全部的状态  Model Checker</p><p>没有工具（编程、测试、调试），不做系统</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a><a href="http://jyywiki.cn/OS/2022/slides/5.slides">互斥</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  ...<br>&#125; <span class="hljs-type">lock_t</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span>;<br></code></pre></td></tr></table></figure><p>还是原来难点：<strong>get set 非原子</strong></p><h4 id="自旋锁-spin-lock"><a href="#自旋锁-spin-lock" class="headerlink" title="自旋锁 spin lock"></a>自旋锁 spin lock</h4><p><strong>硬件</strong>能为我们提供一条 “瞬间完成” 的读 + 写指令</p><p> <code>xchg dest, src</code>  原子的实现交换数据，并返回原来的值。 这样就可以实现两个线程之间的锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *addr, <span class="hljs-type">int</span> newval)</span> &#123;<br>  <span class="hljs-type">int</span> result;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;lock xchg %0, %1&quot;</span></span><br><span class="hljs-params">    : <span class="hljs-string">&quot;+m&quot;</span>(*addr), <span class="hljs-string">&quot;=a&quot;</span>(result) : <span class="hljs-string">&quot;1&quot;</span>(newval))</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (xchg(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; xchg(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure><ul><li>处理器保证，带lock的指令可以锁定总线，xchg默认带lock</li><li>两个cpu共享内存时，带lock指令会锁住memory ，硬件实现，一个bit实现bus lock</li><li>cpu有缓存L1，如何保证缓存一致。当一个cpu锁定memory时，需要把别的cpu的缓存都剔除</li></ul><p><code>Load-Reserved/Store-Conditional</code>，硬件里会实现</p><p>Compare-and-Swap：乐观锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">int</span> *addr, <span class="hljs-type">int</span> cmp_val, <span class="hljs-type">int</span> new_val)</span> &#123;   <br>  <span class="hljs-type">int</span> old_val = *addr;<br>  <span class="hljs-keyword">if</span> (old_val == cmp_val) &#123;<br>    *addr = new_val; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺陷</strong>：未获得锁的线程在空转，甚至获取锁的线程被OS切换了，所以需要<strong>不拥堵时</strong>使用</p><p>操作系统内部自己使用：操作系统内核的并发数据结构 (短临界区)；关中断</p><h4 id="互斥锁-Mutex-Lock"><a href="#互斥锁-Mutex-Lock" class="headerlink" title="互斥锁  Mutex Lock"></a>互斥锁  Mutex Lock</h4><p>与其干等，不如把cpu让给别的线程执行，<strong>阻塞</strong></p><p>把锁的实现放到<strong>操作系统</strong>里就好！</p><ul><li><pre><code class="c">syscall(SYSCALL_lock, &amp;lk); // 试图获得 `lk`，但如果失败，就切换到其他线程<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>- ```c<br>  <span class="hljs-built_in">syscall</span>(SYSCALL_unlock, &amp;lk); <span class="hljs-comment">// 释放 `lk`，如果有等待锁的线程就唤醒</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>未得到锁会进入等待队列，释放锁时OS会取出等待队列中一个线程，<strong>OS使用自旋锁</strong>确保自己处理过程是原子的</p><p>上锁失败会睡眠，不占用CPU，但不管有没有竞争都需要进出内核系统调用，带来一定的开销</p><h4 id="Futex-Spin-Mutex"><a href="#Futex-Spin-Mutex" class="headerlink" title="Futex &#x3D; Spin + Mutex"></a>Futex &#x3D; Spin + Mutex</h4><p><code>Fast Userspace muTexes</code>，无竞争情况下，能够避免系统调用的开销</p><p><strong>1.自旋锁</strong> (线程直接共享 locked)</p><ul><li>更快的 fast path<ul><li>xchg 成功 → 立即进入临界区，开销很小</li></ul></li><li>更慢的 slow path<ul><li>xchg 失败 → 浪费 CPU 自旋等待</li></ul></li></ul><p><strong>2.睡眠锁</strong> (通过系统调用访问 locked)</p><ul><li>更快的 slow path<ul><li>上锁失败线程不再占用 CPU</li></ul></li><li>更慢的 fast path<ul><li>即便上锁成功也需要进出内核 (syscall)</li></ul></li></ul><p><strong>3.融合</strong>：先原子指令上锁，失败后系统调用睡眠</p><p>线程库的锁就是这样的锁，但还有很多的<strong>优化</strong>以减少系统调用</p><p>code：Kernel为操作系统需要做的，这里使用while模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Futex</span>:<br>    locked, waits = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment"># Model Checker会按行执行，所以这会被视为一个原子操作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tryacquire</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.locked:<br>            <span class="hljs-comment"># Test-and-set (cmpxchg)</span><br>            <span class="hljs-comment"># Same effect, but more efficient than xchg</span><br>            <span class="hljs-variable language_">self</span>.locked = <span class="hljs-string">&#x27;🔒&#x27;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;🔒&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">release</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.waits:<br>            <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.locked = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">t1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.tryacquire() == <span class="hljs-string">&#x27;🔒&#x27;</span>:     <span class="hljs-comment"># User</span><br>                <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits + <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment"># Kernel</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.waits:      <span class="hljs-comment"># Kernel 实际上这里已经被os剥夺了</span><br>                    <span class="hljs-keyword">pass</span><br>            cs = <span class="hljs-literal">True</span>                         <span class="hljs-comment"># User</span><br>            <span class="hljs-keyword">del</span> cs                            <span class="hljs-comment"># User</span><br>            <span class="hljs-variable language_">self</span>.release()                    <span class="hljs-comment"># Kernel</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">t2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.tryacquire() == <span class="hljs-string">&#x27;🔒&#x27;</span>:<br>                <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits + <span class="hljs-string">&#x27;2&#x27;</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.waits:<br>                    <span class="hljs-keyword">pass</span><br>            cs = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">del</span> cs<br>            <span class="hljs-variable language_">self</span>.release()<br></code></pre></td></tr></table></figure><p>Fast&#x2F;slow paths:性能优化的途径</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a><a href="http://jyywiki.cn/OS/2022/slides/6.slides">同步</a></h3><p>有了基本的互斥锁，现在需要通过他实现一些线程间的同步机制。有锁时默认使用<code>Futex</code></p><p>线程同步：共同达到互相已知的状态</p><p>生产者消费者(解决并发的万能钥匙)：等价于打印左右括号，左括号往队列加资源，右括号消费资源</p><p><strong>自旋锁、互斥锁、条件变量、信号量、管道(通信)</strong></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>count计数左括号，是共享资源需要互斥，使用<code>spin lock</code>实现互斥访问count，并且如果不符合条件就反复询问<br>使用管道输入到python程序进行检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> n, count = <span class="hljs-number">0</span>;<br>mutex_t lk = MUTEX_INIT();<br><br>void Tproduce() &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (count == n) &#123;<br>      mutex_unlock(&amp;lk);<br>      goto retry;<br>    &#125;<br>    count++;<br>    printf(<span class="hljs-string">&quot;(&quot;</span>);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br>void Tconsume() &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>      mutex_unlock(&amp;lk);<br>      goto retry;<br>    &#125;<br>    count--;<br>    printf(<span class="hljs-string">&quot;)&quot;</span>);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="万能的条件变量"><a href="#万能的条件变量" class="headerlink" title="万能的条件变量"></a>万能的条件变量</h4><p>我希望不要循环，在不满足时进行sleep</p><p>条件变量 API：<strong>在不符合某条件时，等待别人通过cv唤醒我</strong>  cv是程序间的暗号  需要访问共享条件当然要加锁</p><ul><li>wait(cv, mutex) 💤  <code>release(mutex)、sleep</code><ul><li>调用时必须保证已经获得 mutex</li><li>醒来时需要获取mutex</li></ul></li><li>signal&#x2F;notify(cv) 💬 私信：走起<ul><li>如果有线程正在等待 cv，则唤醒其中一个线程</li></ul></li><li>broadcast&#x2F;notifyAll(cv) 📣 所有人：走起<ul><li>唤醒全部正在等待 cv 的线程</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == n) cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 睡眠前释放锁；在唤醒后，会重新获取锁</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++; cond_signal(&amp;cv);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) cond_wait(&amp;cv, &amp;lk);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--; cond_signal(&amp;cv);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><br>代码有问题，因为消费者cond_signal(&amp;cv)时会唤醒消费者，因此需要两个条件变量分别用来唤醒P、C<br>或者我直接boradcast唤醒全部，但<span class="hljs-keyword">if</span>检测改成<span class="hljs-keyword">while</span>循环<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumer</span>:<br>    locked, count, log, waits = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tryacquire</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.locked, seen = <span class="hljs-string">&#x27;🔒&#x27;</span>, <span class="hljs-variable language_">self</span>.locked<br>        <span class="hljs-keyword">return</span> seen == <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">release</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.locked = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.tryacquire(): <span class="hljs-keyword">pass</span> <span class="hljs-comment"># mutex_lock()</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># cond_wait</span><br>                _, <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.release(), <span class="hljs-variable language_">self</span>.waits + <span class="hljs-string">&#x27;1&#x27;</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.waits: <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.tryacquire(): <span class="hljs-keyword">pass</span><br><br>            <span class="hljs-variable language_">self</span>.log, <span class="hljs-variable language_">self</span>.count = <span class="hljs-variable language_">self</span>.log + <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-variable language_">self</span>.count + <span class="hljs-number">1</span><br>            <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits[<span class="hljs-number">1</span>:] <span class="hljs-comment"># cond_signal</span><br>            <span class="hljs-variable language_">self</span>.release() <span class="hljs-comment"># mutex_unlock()</span><br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tc1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-number">0</span>:<br>            _, <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.release(), <span class="hljs-variable language_">self</span>.waits + <span class="hljs-string">&#x27;2&#x27;</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.waits: <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-variable language_">self</span>.log, <span class="hljs-variable language_">self</span>.count = <span class="hljs-variable language_">self</span>.log + <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-variable language_">self</span>.count - <span class="hljs-number">1</span><br><br>        <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits[<span class="hljs-number">1</span>:]<br>        <span class="hljs-variable language_">self</span>.release()<br><br><span class="hljs-meta">    @thread</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tc2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-number">0</span>:<br>            _, <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.release(), <span class="hljs-variable language_">self</span>.waits + <span class="hljs-string">&#x27;3&#x27;</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.waits: <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.tryacquire(): <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-variable language_">self</span>.log, <span class="hljs-variable language_">self</span>.count = <span class="hljs-variable language_">self</span>.log + <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-variable language_">self</span>.count - <span class="hljs-number">1</span><br><br>        <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits[<span class="hljs-number">1</span>:]<br>        <span class="hljs-variable language_">self</span>.release()<br></code></pre></td></tr></table></figure><p>两个条件变量实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == n) cond_wait(&amp;c, &amp;lk); <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++; cond_signal(&amp;p);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) cond_wait(&amp;p, &amp;lk);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--; cond_signal(&amp;c);<br>  mutex_unlock(&amp;lk);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="while循环-broadcast"><a href="#while循环-broadcast" class="headerlink" title="while循环+broadcast"></a>while循环+broadcast</h5><p>通用模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;mutex);<br><span class="hljs-keyword">while</span> (!cond) &#123;      cond可以多个条件<br>  wait(&amp;cv, &amp;mutex);<br>&#125;<br>assert(cond);  <span class="hljs-comment">// 互斥锁保证了在此期间条件 cond 总是成立</span><br><br>其他线程条件可能被满足时，就算不满足进入<span class="hljs-keyword">while</span>还是会睡眠<br>broadcast(&amp;cv);<br><br>mutex_unlock(&amp;mutex);<br><br><br><span class="hljs-comment">/// ...计算任务，可能需要更长时间   也就是T(job) &gt;&gt;  T(同步互斥)</span><br></code></pre></td></tr></table></figure><p>作业：打印指定的形状 <code>&lt;&gt;&lt;_</code> 和 <code>&gt;&lt;&gt;_ </code> <a href="http://jyywiki.cn/pages/OS/2022/demos/fish.c">http://jyywiki.cn/pages/OS/2022/demos/fish.c</a></p><p>处理器可以乱序执行，先执行第二条，但13需要顺序执行，硬件实现顺序执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">0</span>   write<br>t = y  <span class="hljs-comment"># 可以先执行</span><br>z = x   read<br></code></pre></td></tr></table></figure><h4 id="信号量PV"><a href="#信号量PV" class="headerlink" title="信号量PV"></a>信号量PV</h4><p>在执行前需要某些东西，没有就睡眠等到有。<code>happens before</code>。<strong>优雅但不全</strong></p><p>最好解决<strong>单一资源</strong>问题，但上面的打印🐟难以实现</p><p>token为资源数量，当token&#x3D;1、0时就代表互斥锁Mutex，没得到就睡眠（但相当于有多把钥匙）</p><p>P： token– if token &lt; 0，线程加入等待队列</p><p>V：token++ if token&lt;&#x3D;0, 唤醒等待队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Semaphore</span>:<br>    token, waits = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">P</span>(<span class="hljs-params">self, tid</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.token &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.token -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits + tid<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">V</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.waits:<br>            <span class="hljs-variable language_">self</span>.waits = <span class="hljs-variable language_">self</span>.waits[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.token += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span> &#123;<br>  P(&amp;empty);   <span class="hljs-comment">// P()返回 -&gt; 得到手环</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); <span class="hljs-comment">// 假设线程安全</span><br>  V(&amp;fill);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> &#123;<br>  P(&amp;fill);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>  V(&amp;empty);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">A -&gt; B      如果使用条件变量，可能出现A已经执行，但B还没进入<br>    s = <span class="hljs-number">0</span><br>    A: V(s)<br>    B: P(S)<br>    <br>join：<br>    s = <span class="hljs-number">0</span><br>    A、B、C: V(s) <br>    main: P(S) * |T|<br></code></pre></td></tr></table></figure><h5 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h5><p>如果想要并行，就需要画出计算图，并让程序按计算图执行：PV很方便</p><p>每条边PV各一次</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404501.png" alt="image-20230526171022426" style="zoom:67%;" /><h5 id="打印🐟"><a href="#打印🐟" class="headerlink" title="打印🐟"></a>打印🐟</h5><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">当前线程想打符号<span class="hljs-string">&#x27;&lt;&#x27;</span> 那就<span class="hljs-function"><span class="hljs-title">P</span>(<span class="hljs-string">&#x27;&lt;&#x27;</span>)</span><br><br>当前线程结束后，根据规则决定谁可以执行 <span class="hljs-function"><span class="hljs-title">V</span>(<span class="hljs-string">&#x27;&gt;&#x27;</span>)   多个就随机</span><br></code></pre></td></tr></table></figure><h5 id="信号量实现条件变量"><a href="#信号量实现条件变量" class="headerlink" title="信号量实现条件变量"></a>信号量实现条件变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">失败：我不能带者锁睡眠，必须要先释放锁，但释放之后不能保证原子性了<br>wait(mutex)&#123;<br>release(mutex)<br><span class="hljs-comment">// 可能被broadcast</span><br>sleep<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>之前实现通信需要共享内存并且锁定，会引发竞争和死锁；因此我们反过来，通过通信来实现共享内存</p><p><code>Do not communicate by sharing memory; instead, share memory by communicating. ——*Effective Go*</code></p><p>管道：不但能同步，还能通信</p><p><code>cat a.txt | wc -l</code> Linux管道就是一种同步机制。 后一个会一边接收一边处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> stream = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">const</span> n = <span class="hljs-number">4</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>    fmt.Println(<span class="hljs-string">&quot;produce&quot;</span>, i)<br>    stream &lt;- i<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    x := &lt;-stream<br>    fmt.Println(<span class="hljs-string">&quot;consume&quot;</span>, x)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>    <span class="hljs-keyword">go</span> produce()<br>  &#125;<br>  consume()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h4><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>直接上吃饭的条件，并用互斥锁保护起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;mutex);<br><span class="hljs-keyword">while</span> (!(avail[lhs] &amp;&amp; avail[rhs])) &#123;<br>  wait(&amp;cv, &amp;mutex);<br>&#125;<br>avail[lhs] = avail[rhs] = <span class="hljs-literal">false</span>;<br>mutex_unlock(&amp;mutex);<br>      <br><span class="hljs-comment">// ...</span><br><br>mutex_lock(&amp;mutex);<br>avail[lhs] = avail[rhs] = <span class="hljs-literal">true</span>;<br>broadcast(&amp;cv);<br>mutex_unlock(&amp;mutex);<br></code></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 失败的尝试，这里会死锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-type">int</span> lhs = (N + id - <span class="hljs-number">1</span>) % N;<br>  <span class="hljs-type">int</span> rhs = id % N;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    P(&amp;locks[lhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;T%d Got %d\n&quot;</span>, id, lhs + <span class="hljs-number">1</span>);<br>    P(&amp;locks[rhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;T%d Got %d\n&quot;</span>, id, rhs + <span class="hljs-number">1</span>);<br>      <br>    <span class="hljs-comment">// ...</span><br><br>    V(&amp;locks[lhs]);<br>    V(&amp;locks[rhs]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 1.直接锁起来</span><br>mutex_lock(&amp;mutex);<br>P(&amp;locks[lhs]);<br>P(&amp;locks[rhs]);<br>mutex_unlock(&amp;mutex);<br><br><span class="hljs-comment">// 2. 只允许四个人上座 numperson=4   需求变了怎么办？</span><br>P(&amp;numperson);<br>P(&amp;locks[lhs]);<br>P(&amp;locks[rhs]);<br><br><br>V(&amp;numperson);<br></code></pre></td></tr></table></figure><p>需求变了：如果一个人要左边两把右边一把，如何设计？   还是条件变量方便，直接改<code>cond</code>就行</p><h4 id="分布与集中"><a href="#分布与集中" class="headerlink" title="分布与集中"></a>分布与集中</h4><p>集中控制而不是各自协调</p><ul><li>可以知道每一个线程具体运行状况，集中管理</li><li><a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">The Google File System</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  send_request(id, EAT);<br>  P(allowed[id]); <span class="hljs-comment">// waiter 会把叉子递给哲学家</span><br>  philosopher_eat();<br>  send_request(id, DONE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Twaiter</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    (id, status) = receive_request();<br>    <span class="hljs-keyword">if</span> (status == EAT) &#123; ... &#125;<br>    <span class="hljs-keyword">if</span> (status == DONE) &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>集中的人压力太大？再分级</li></ul><p>信号量可以被操作系统高效实现，避免了broadcast开销</p><h3 id="真实世界的并发编程"><a href="#真实世界的并发编程" class="headerlink" title="真实世界的并发编程"></a>真实世界的并发编程</h3><p><strong>背景回顾</strong>：我们已经掌握了多种并发控制技术：自旋锁、互斥锁、条件变量、信号量。我们已经可以实现共享内存系统上的任意并发&#x2F;并行计算。然而，大家也在使用这些 “底层” 并发控制时发现使用的困难。那么，真实世界的程序员是怎么实现并发程序的？</p><ul><li><strong>高性能计算</strong> (注重任务分解)中的并行编程 (embarrassingly parallel 的数值计算)</li><li><strong>数据中心</strong>(注重系统调用): (协程、Goroutine 和 channel)</li><li>人工智能时代的<strong>分布式机器学习</strong> (GPU 和 Parameter Server)</li><li><strong>用户身边</strong>的并发编程 (Web 和异步编程) (注重易用性)</li></ul><h4 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h4><p>massive computation  源自数值密集型科学计算任务。通常有固定的计算图</p><ul><li>物理系统模拟<ul><li>天气预报、航天、制造、能源、制药、……</li><li>大到宇宙小到量子，有模型就能模拟</li></ul></li><li>矿厂 (现在不那么热了)<ul><li>纯粹的 hash 计算</li></ul></li><li><a href="http://www.hpc100.cn/top100/21/">HPC-China 100</a></li></ul><p><strong>embarrassingly parallel</strong> ：这类问题可以被分解成多个独立的子问题，每个子问题可以在不同的处理器上并行计算，而不需要进行任何进一步的同步或通信。这种问题的并行化非常简单，因为每个子问题都是相互独立的，不需要进行任何协调或同步。</p><p>通常出现在<strong>科学计算、数据分析、图像处理</strong>等领域。例如，在图像处理中，可以将一张大图像分成多个小块，每个小块可以在不同的处理器上并行处理，最后将结果合并成一张完整的图像。在科学计算中，可以将一个大型计算任务分成多个小任务，每个小任务可以在不同的处理器上并行计算，最后将结果合并成一个完整的计算结果。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404502.png" style="zoom: 67%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404503.png" alt="image-20230529102943340" style="zoom: 50%;" />两个线程画图</p><h4 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h4><p><code>“A network of computing and storage resources that enable the delivery of *shared* applications and data.” (CISCO)</code></p><p>以<strong>数据 (存储)</strong> 为中心</p><ul><li>互联网索引与搜索<ul><li>Google</li></ul></li><li>社交网络<ul><li>Facebook&#x2F;Twitter</li></ul></li><li>支撑各类互联网应用<ul><li>通信 (微信&#x2F;QQ 群人数为什么有上限？)、支付 (支付宝)、游戏&#x2F;网盘&#x2F;……</li></ul></li></ul><h5 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h5><p>我希望高可靠、低延时、多副本的分布式 存储 计算系统</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404504.png" alt="image-20230529103310529" style="zoom:67%;" /><p>举个例子：微信先拉黑，再发朋友圈，如果没有一致性，那么朋友圈可能被拉黑的人看到。亚马逊没一致性可能发两个快递</p><h5 id="单机程序"><a href="#单机程序" class="headerlink" title="单机程序"></a><strong>单机程序</strong></h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404505.png" alt="image-20230529103721001"></p><p>假设有数千&#x2F;数万个请求同时到达服务器……</p><ul><li>线程能够实现并行处理</li><li>但远多于处理器数量的线程导致性能问题<ul><li>切换开销</li><li>维护开销</li></ul></li></ul><h5 id="协程-协作的线程"><a href="#协程-协作的线程" class="headerlink" title="协程(协作的线程)"></a>协程(协作的线程)</h5><p>和线程概念相同 (独立堆栈、共享内存) ，用户态的线程，由程序员主动控制</p><ul><li>但 “一直执行”，直到 <code>yield()</code>   可以视为<strong>函数调用</strong>， 主动放弃处理器<ul><li>有编译器辅助，切换开销低<ul><li>yield() 是函数调用，只需保存&#x2F;恢复 <code>“callee saved”</code> 寄存器（函数调用保存的寄存器）  <code>RBP</code></li><li>线程切换需要保存&#x2F;恢复全部寄存器</li></ul></li><li>但等待 I&#x2F;O 时，其他协程就不能运行了……<ul><li>失去了并行   go优化</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 只可能是 1122 或 2211</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span> &#123; send(<span class="hljs-string">&quot;1&quot;</span>); send(<span class="hljs-string">&quot;1&quot;</span>); yield(); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span> &#123; send(<span class="hljs-string">&quot;2&quot;</span>); send(<span class="hljs-string">&quot;2&quot;</span>); yield(); &#125;<br></code></pre></td></tr></table></figure><p><code>Goroutine</code>：概念上是线程，实现上是协程：在遇到IO且可能等待时，<code>yield</code>切换</p><p>如果是协程，线程sleep后计算机就停止了，但go优化成yield切换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> spinner(<span class="hljs-number">100</span> * time.Millisecond)<br>  <span class="hljs-keyword">const</span> n = <span class="hljs-number">45</span><br>  fibN := fib(n) <span class="hljs-comment">// slow</span><br>  fmt.Printf(<span class="hljs-string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinner</span><span class="hljs-params">(delay time.Duration)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> <span class="hljs-string">`-\|/`</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;\r%c&quot;</span>, r)<br>      time.Sleep(delay)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">2</span> &#123; <span class="hljs-keyword">return</span> x &#125;<br>  <span class="hljs-keyword">return</span> fib(x - <span class="hljs-number">1</span>) + fib(x - <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>go之前，java已经形成了大数据处理系统的生态</p><h4 id="人工智能时代的分布式机器学习"><a href="#人工智能时代的分布式机器学习" class="headerlink" title="人工智能时代的分布式机器学习"></a>人工智能时代的分布式机器学习</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404506.png" alt="image-20230529110833871"></p><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p>数据并行：一部分数据这台机器，一部分那台 <code>model = nn.DataParallel(model) </code><br>模型并行：切割计算图</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404507.png" alt="image-20230529111116782"></p><h5 id="SIMP"><a href="#SIMP" class="headerlink" title="SIMP"></a>SIMP</h5><p><code>Single Instruction, Multiple Threads</code></p><p>CPU：多个cpu，但各自运行各自的，都有pc指针</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404509.png" alt="image-20230529112121783"></p><p>GPU：一个pc控制多个执行流，独立寄存器标记线程号</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404510.png" alt="image-20230529112321136" style="zoom:80%;" /><h5 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404511.png" alt="image-20230529112558826"></p><h5 id="分布式机器学习"><a href="#分布式机器学习" class="headerlink" title="分布式机器学习"></a>分布式机器学习</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404512.png" alt="image-20230529112936378"></p><h4 id="用户身边并发编程"><a href="#用户身边并发编程" class="headerlink" title="用户身边并发编程"></a>用户身边并发编程</h4><p>web2.0：HTML(DOM Tree) + CSS + JS</p><p>特点：不太复杂</p><ul><li>既没有太多计算<ul><li>DOM Tree 也不至于太大 (大了人也看不过来)</li><li>DOM Tree 怎么画浏览器全帮我们搞定了</li></ul></li><li>也没有太多 I&#x2F;O<ul><li>就是一些网络请求</li></ul></li></ul><h5 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h5><p>单线程 + 事件模型</p><ul><li><p>一个线程、按序执行 (run-to-complete)。无并行减少了bug  <strong>主线程执行栈 + 微任务队列</strong></p></li><li><p>耗时的 API (Timer, Ajax, …) 调用会立即返回 + <code>Callback</code></p><ul><li>当Promise被创建时，它处于未完成的状态（pending）。当异步操作完成并且Promise成功解析（resolved）时，或者发生错误导致Promise被拒绝（rejected）时，回调函数会被添加到微任务队列中。</li></ul></li><li><p><strong>坏处</strong>：<code>$.ajax</code> 嵌套 5 层，可维护性已经接近于零了</p></li></ul><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><code>Callback</code>没有很好表示流程图 -&gt;  <code>Promise</code></p><p>Chaining</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;/article/promise-chaining/one.js&quot;</span>)<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;/article/promise-chaining/two.js&quot;</span>) )<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;/article/promise-chaining/three.js&quot;</span>) )<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// scripts are loaded, we can use functions declared there</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; ... &#125; );<br></code></pre></td></tr></table></figure><hr><p>Fork-join</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;A&#x27;</span>) &#125; )<br>b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;B&#x27;</span>) &#125; )<br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;C&#x27;</span>) &#125; )<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([a, b, c]).<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125; )<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装一个函数，用于加载一张图片</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    image.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(image); <span class="hljs-comment">// 图片加载成功，将 Promise 标记为成功</span><br>    &#125;;<br>    image.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Failed to load image&#x27;</span>)); <span class="hljs-comment">// 图片加载失败，将 Promise 标记为失败</span><br>    &#125;;<br>    image.<span class="hljs-property">src</span> = url;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 图片加载任务列表</span><br><span class="hljs-keyword">const</span> imageUrls = [<br>  <span class="hljs-string">&#x27;image1.jpg&#x27;</span>,<br>  <span class="hljs-string">&#x27;image2.jpg&#x27;</span>,<br>  <span class="hljs-string">&#x27;image3.jpg&#x27;</span><br>];<br><br><span class="hljs-comment">// 使用 Promise.all() 来处理多个图片加载任务</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(imageUrls.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> <span class="hljs-title function_">loadImage</span>(url)))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">images</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 所有图片加载完成，可以进行展示</span><br>    images.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">image</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(image); <span class="hljs-comment">// 假设将图片添加到页面中</span><br>    &#125;);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 图片加载过程中出现错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><h5 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async-Await"></a>Async-Await</h5><p> 一种计算图的描述语言.</p><p>通过使用 <code>async</code> 关键字声明一个函数为异步函数(函数会返回一个<code>Promise</code>对象)，我们可以在函数内部使用 <code>await</code> 关键字来等待一个 Promise 对象的解决（resolve）</p><p>更现代、更优雅的方式来处理异步代码，与 <code>.then</code> 方法相比更易于理解和编写(避免嵌套)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">A = <span class="hljs-title function_">async</span> () =&gt; <span class="hljs-keyword">await</span> $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/hello/a&#x27;</span>)<br>B = <span class="hljs-title function_">async</span> () =&gt; <span class="hljs-keyword">await</span> $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/hello/b&#x27;</span>)<br>C = <span class="hljs-title function_">async</span> () =&gt; <span class="hljs-keyword">await</span> $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/hello/c&#x27;</span>)<br>hello = <span class="hljs-title function_">async</span> () =&gt; <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">A</span>(), <span class="hljs-title function_">B</span>(), <span class="hljs-title function_">C</span>()])<br><span class="hljs-title function_">hello</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span>)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fetch failed!&#x27;</span>) &#125; )<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 异步函数示例</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = response.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Failed to fetch data&#x27;</span>);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 调用异步函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before fetchData()&#x27;</span>);<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data:&#x27;</span>, data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error);<br>  &#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After fetchData()&#x27;</span>);<br><br><span class="hljs-comment">// res:</span><br>    <span class="hljs-comment">// Before fetchData()</span><br>    <span class="hljs-comment">// After fetchData()</span><br>    <span class="hljs-comment">// Data: [data from API]</span><br></code></pre></td></tr></table></figure><h3 id="并发bug"><a href="#并发bug" class="headerlink" title="并发bug"></a>并发bug</h3><ul><li>死锁</li><li>数据竞争</li><li>原子性和顺序违反</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">assert mode in [XRay, Electron]<br>assert mirror in [On, Off]<br>assert <span class="hljs-title function_">not</span> <span class="hljs-params">(mode == XRay and mirror == Off)</span><br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>表现明显：程序停止了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">lock(&amp;lk);<br><span class="hljs-comment">// lk = LOCKED;</span><br>lock(&amp;lk);<br><span class="hljs-comment">// while (xchg(&amp;lk, LOCKED) == LOCKED) ;</span><br>多层函数调用、隐藏的控制流（中断）<br>        <br>        <br><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">()</span> &#123;<br>  P(&amp;avail[lhs]);<br>  P(&amp;avail[rhs]);<br>  <span class="hljs-comment">// ...</span><br>  V(&amp;avail[lhs]);<br>  V(&amp;avail[rhs]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Mutual-exclusion - 一张校园卡只能被一个人拥有</li><li>Wait-for - 一个人等其他校园卡时，不会释放已有的校园卡</li><li>No-preemption - 不能抢夺他人的校园卡</li><li>Circular-chain - 形成校园卡的循环等待关系</li></ul><p> <strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源； 允许抢占； <code>Locker order</code>规定获取锁的顺序，必须从小到大（获得编号最大的进程能运行））</li><li><strong>避免死锁</strong>（<strong>银行家</strong>：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（<strong>资源分配图</strong>，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><p>多个线程对同一内存进行读写，先写还是先读产生的结果不同。山寨支付宝判断并修改余额</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404513.png" alt="image-20230530154901555"></p><p>先来先写，多个memory，无法定义谁先来，所以需要避免data race。上锁</p><p><strong>不同的线程</strong>同时访问<strong>同一内存</strong>，且至少有一个是写</p><ul><li>“内存” 可以是地址空间中的任何内存<ul><li>可以是全部变量</li><li>可以是堆区分配的变量</li><li>可以是栈</li></ul></li><li>“访问” 可以是任何代码<ul><li>可能发生在你的代码里</li><li>可以发生在框架代码里</li><li>可能是一行你没有读到过的汇编代码</li><li>可能时一条 ret 指令</li></ul></li></ul><h4 id="原子性违反"><a href="#原子性违反" class="headerlink" title="原子性违反"></a>原子性违反</h4><p>调查100个BUGs，97% 的非死锁并发 bug 都是<strong>原子性</strong>（山寨支付宝）或<strong>顺序错误</strong></p><p> <img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404514.png" alt="image-20230530161346187"></p><h3 id="应对并发bug"><a href="#应对并发bug" class="headerlink" title="应对并发bug"></a>应对并发bug</h3><p>假设程序员会花式犯错</p><p><strong>编译器</strong>：只管翻译代码，不管需求含义</p><p>怎么才能编写出 “正确” (符合 specification) 的程序？</p><ul><li>证明：Annotation verifier (<a href="https://dafny-lang.github.io/dafny/">Dafny</a>), <a href="https://dl.acm.org/doi/10.1145/113446.113468">Refinement types</a></li><li>推测：Specification mining (<a href="http://plse.cs.washington.edu/daikon/">Daikon</a>)</li><li>构造：<a href="https://link.springer.com/article/10.1007/s10009-012-0249-7">Program sketching</a></li><li>编程语言的历史和未来<ul><li>机器语言 → 汇编语言 → 高级语言 → <strong>自然编程语言</strong></li></ul></li></ul><h4 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h4><p>机器永远是对的，代码始终是错的</p><p>防御性编程：把可能不对的情况都检查一遍。<code>assert</code>  大型项目很需要</p><ul><li><p>Peterson 算法中的临界区计数器</p><ul><li><code>assert(nest == 1);</code></li></ul></li><li><p>二叉树的旋转</p><ul><li><code>assert(p-&gt;parent-&gt;left == p || p-&gt;parent-&gt;right == p);</code></li></ul></li><li><p>AA-Deadlock 的检查</p><ul><li><code>if (holding(&amp;lk)) panic();</code></li><li>xv6 spinlock 实现示例</li></ul></li></ul><h4 id="自动运行时检查"><a href="#自动运行时检查" class="headerlink" title="自动运行时检查"></a>自动运行时检查</h4><h5 id="Lockdep死锁检测"><a href="#Lockdep死锁检测" class="headerlink" title="Lockdep死锁检测"></a>Lockdep死锁检测</h5><p><code>Lockdep</code> ：死锁的检查。linux内核</p><p>​每一个锁有一个唯一的site（线程文件行号），上锁解锁日志记录下该site。通过查看所有日志有没有环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LOCK   %s\n&quot;</span>, lk-&gt;site);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="data-race检测"><a href="#data-race检测" class="headerlink" title="data race检测"></a>data race检测</h5><p><code>ThreadSanitizer</code>：运行时的数据竞争检查.编译时实现</p><p>两个进程同时读写同一内存，有没有happens-before关系，没有就存在data race (T1-5 T2-5)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404515.png" alt="image-20230531112908484"></p><h4 id="rule-of-thumb"><a href="#rule-of-thumb" class="headerlink" title="rule of thumb"></a>rule of thumb</h4><ul><li>不实现 “完整” 的检查</li><li>允许存在误报&#x2F;漏报</li><li>但实现简单、非常有用</li></ul><h5 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h5><p>“牺牲” 一些内存单元，来预警 memory error 的发生。栈空间多分配一些<code>canary</code>空间作为保护，值被修改了就异常了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAGIC 0x55555555</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOTTOM (STK_SZ / sizeof(u32) - 1)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span> &#123;</span> <span class="hljs-type">char</span> data[STK_SZ]; &#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">canary_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">stack</span> *s)</span> &#123;<br>  u32 *ptr = (u32 *)s;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CANARY_SZ; i++)<br>    ptr[BOTTOM - i] = ptr[i] = MAGIC;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">canary_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">stack</span> *s)</span> &#123;<br>  u32 *ptr = (u32 *)s;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CANARY_SZ; i++) &#123;<br>    panic_on(ptr[BOTTOM - i] != MAGIC, <span class="hljs-string">&quot;underflow&quot;</span>);<br>    panic_on(ptr[i] != MAGIC, <span class="hljs-string">&quot;overflow&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>msvc 中 debug mode 的 guard&#x2F;fence&#x2F;canary</p><ul><li>未初始化栈: <code>0xcccccccc </code>  烫</li><li>未初始化堆: <code>0xcdcdcdcd </code> 屯</li><li>对象头尾: <code>0xfdfdfdfd</code></li></ul><h5 id="低配lockdep"><a href="#低配lockdep" class="headerlink" title="低配lockdep"></a>低配lockdep</h5><p>统计自旋的次数，超过某个值肯定不正常</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (xchg(&amp;lk, LOCKED) == LOCKED) &#123;<br>  <span class="hljs-keyword">if</span> (count++ &gt; SPIN_LIMIT) &#123;<br>    panic(<span class="hljs-string">&quot;Spin limit exceeded @ %s:%d\n&quot;</span>, __FILE__, __LINE__);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="低配AddressSanitizer"><a href="#低配AddressSanitizer" class="headerlink" title="低配AddressSanitizer"></a>低配AddressSanitizer</h5><p>并发分配内存时，分配完标记一个颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// allocation</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; (i + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(u32) &lt;= size; i++) &#123;<br>  panic_on(((u32 *)ptr)[i] == MAGIC, <span class="hljs-string">&quot;double-allocation&quot;</span>);<br>  arr[i] = MAGIC;<br>&#125;<br><br><span class="hljs-comment">// free</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; (i + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(u32) &lt;= alloc_size(ptr); i++) &#123;<br>  panic_on(((u32 *)ptr)[i] == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;double-free&quot;</span>);<br>  arr[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多处理器与中断"><a href="#多处理器与中断" class="headerlink" title="多处理器与中断"></a>多处理器与中断</h3><p>处理器如何实现多线程？中断</p><p><strong>本讲内容</strong>：操作系统内核实现。</p><ul><li>多处理器和中断</li><li>AbstractMachine API</li><li>50 行实现嵌入式操作系统</li></ul><p>多处理器的状态机模型：状态为内存和每一个状态。执行为<strong>任选</strong>一个<code>cpu</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404516.png" alt="image-20230601105219177"></p><p>如果死循环某个CPU就会卡死，而为什么我们写的死循环程序不会卡死电脑？</p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>下降沿触发的一根线。IF寄存器(interrupter flag) 决定是否响应中断（操作系统可以修改该值）</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404517.png" alt="image-20230601111009780" style="zoom:50%;" /><ul><li>x86 Family<ul><li>询问中断控制器获得中断号 n</li><li>保存 CS, RIP, RFLAGS, SS, RSP 到堆栈</li><li>跳转到 <code>IDT[n]</code> 指定的地址，并设置处理器状态 (例如关闭中断)</li></ul></li></ul><p>关中断实现了 “stop the world”  ，尝试<code>asm volatile (&quot;cli&quot;)</code>被操作系统检测到，会直接报错</p><h4 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h4><p>所有线程都有一块内存用来保存自己的现场</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Context</span> &#123;</span><br>    uint64_ t rax, rbx, rcx, rdx,<br>        rbp, rsi, rdi,<br>        r8，r9，r10, r11,<br>        r12，r13， r14， r15,<br>        rip, cs, rflags,<br>        rsp, ss, rsp0; <br>&#125;;<br></code></pre></td></tr></table></figure><p>中断处理：保存当前的ctx，并返回运行在该cpu上的另一个线程的上下文</p><ul><li><code>tasks[n]</code>是内存中所有线程的状态。next指针把所有状态串联</li><li><code>currents[MAX_CPU]</code> 是每一个cpu当前的状态，都指向tasks中的某一个</li><li><code>current=currents[cpu_current()]</code>是当前cpu状态指针，<code>current-&gt;context = ctx</code>保存现场到内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Task *currents[MAX_CPU];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current currents[cpu_current()]</span><br><br>Context *<span class="hljs-title function_">on_interrupt</span><span class="hljs-params">(Event ev, Context *ctx)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!current) &#123;<br>    current = &amp;tasks[<span class="hljs-number">0</span>];  <span class="hljs-comment">// First trap for this CPU</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    current-&gt;context = ctx; <span class="hljs-comment">// Keep the stack-saved context</span><br>  &#125;<br><br>  <span class="hljs-comment">// Schedule</span><br>  <span class="hljs-keyword">do</span> &#123;<br>    current = current-&gt;next;<br>  &#125; <span class="hljs-keyword">while</span> (!on_this_cpu(current)); <span class="hljs-comment">// ((current - tasks) % cpu_count() != cpu_current());</span><br><br>  <span class="hljs-keyword">return</span> current-&gt;context;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="50行操作系统"><a href="#50行操作系统" class="headerlink" title="50行操作系统"></a>50行操作系统</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;am.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;klib-macros.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CPU 8</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">task</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">task</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">void</span>      (*entry)(<span class="hljs-type">void</span> *);<br>    Context    *context;<br>  &#125;;<br>  <span class="hljs-type">uint8_t</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">8192</span>];<br>&#125; Task;  <span class="hljs-comment">// A &quot;state machine&quot;</span><br><br>Task *currents[MAX_CPU];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current currents[cpu_current()]</span><br><br><span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;  <span class="hljs-comment">// A spin lock</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>   &#123; <span class="hljs-keyword">while</span> (<span class="hljs-type">atomic_xchg</span>(&amp;locked, <span class="hljs-number">1</span>)); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; <span class="hljs-type">atomic_xchg</span>(&amp;locked, <span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tasks.h&quot;</span></span><br><br>Context *<span class="hljs-title function_">on_interrupt</span><span class="hljs-params">(Event ev, Context *ctx)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!current) current = &amp;tasks[<span class="hljs-number">0</span>];  <span class="hljs-comment">// First interrupt</span><br>  <span class="hljs-keyword">else</span> current-&gt;context = ctx;  <span class="hljs-comment">// Save pointer to stack-saved context</span><br>  <span class="hljs-keyword">do</span> &#123;<br>    current = current-&gt;next;<br>  &#125; <span class="hljs-keyword">while</span> ((current - tasks) % cpu_count() != cpu_current());<br>  <span class="hljs-keyword">return</span> current-&gt;context;  <span class="hljs-comment">// Restore a new context</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mp_entry</span><span class="hljs-params">()</span> &#123;<br>  yield();  <span class="hljs-comment">// Self-trap; never returns</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  cte_init(on_interrupt);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(tasks); i++) &#123;<br>    Task *task    = &amp;tasks[i];<br>    Area <span class="hljs-built_in">stack</span>    = (Area) &#123; &amp;task-&gt;context + <span class="hljs-number">1</span>, task + <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">// 栈起始结束地址</span><br>    task-&gt;context = kcontext(<span class="hljs-built_in">stack</span>, task-&gt;entry, (<span class="hljs-type">void</span> *)task-&gt;name); <br>    task-&gt;next    = &amp;tasks[(i + <span class="hljs-number">1</span>) % LENGTH(tasks)];<br>  &#125;<br>  mpe_init(mp_entry);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// User-defined tasks</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    lock();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread-%s on CPU #%d\n&quot;</span>, arg, cpu_current());<br>    unlock();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">volatile</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) ;<br>  &#125;<br>&#125;<br><br>Task tasks[] = &#123;<br>  &#123; .name = <span class="hljs-string">&quot;A&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;B&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;C&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;D&quot;</span>, .entry = func &#125;,<br>  &#123; .name = <span class="hljs-string">&quot;E&quot;</span>, .entry = func &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="fork-execv-exit"><a href="#fork-execv-exit" class="headerlink" title="fork execv exit"></a>fork execv exit</h3><ul><li>应用程序 &#x3D; 纯粹计算（Python 代码） + <code>syscall</code>；  状态机</li><li>操作系统 &#x3D; <code>syscall</code>实现：重要的三个系统调用<ul><li>fork: 对当前状态机状态进行完整复制</li><li>execve: 将当前状态机状态重置为某个可执行文件描述的状态机</li><li>exit: 销毁当前状态机</li></ul></li></ul><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>fork</code>: <strong>完全</strong>复制一份当前的状态 (内存、寄存器现场)，相当于创建了一个新的进程，返回子进程号。<code>unix</code>唯一方法</p><p>因为状态机是复制的，因此总能找到 “父子关系”</p><ul><li>因此有了进程树 (<code>pstree</code>)</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">systemd-+-ModemManager--<span class="hljs-number">-2</span>*[&#123;ModemManager&#125;]<br>        |<span class="hljs-type">-NetworkManager</span>--<span class="hljs-number">-2</span>*[&#123;NetworkManager&#125;]<br>        |<span class="hljs-type">-accounts</span>-daemon--<span class="hljs-number">-2</span>*[&#123;accounts-daemon&#125;]<br>        |<span class="hljs-type">-at</span>-spi-bus-laun-+-dbus-daemon<br>        |                 <span class="hljs-type">`-3</span>*[&#123;<span class="hljs-built_in">at</span>-spi-bus-laun&#125;]<br>        |<span class="hljs-type">-at</span>-spi2-registr--<span class="hljs-number">-2</span>*[&#123;<span class="hljs-built_in">at</span>-spi2-registr&#125;]<br>        |<span class="hljs-type">-atd</span><br>        |<span class="hljs-type">-avahi</span>-daemon---avahi-daemon<br>        |<span class="hljs-type">-colord</span>--<span class="hljs-number">-2</span>*[&#123;colord&#125;]<br>        ...<br></code></pre></td></tr></table></figure><p>1个变成了4个。fork出来的子进程也会执行下面的fork(), 除了x不一样其他都一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> x = fork();<br><span class="hljs-type">pid_t</span> y = fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p>打印了多少个？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>  fork();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>&#125;<br><br>./a.out          <span class="hljs-number">6</span>个<br>./a.out | cat    <span class="hljs-number">8</span>个  因为如果输入到管道，print的信息会放到缓存中，被同时复制<br></code></pre></td></tr></table></figure><h4 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h4><p><code>execv</code> ：</p><ul><li>将当前进程<strong>重置</strong>成一个可执行文件描述状态机的初始状态</li><li>唯一能够执行程序的系统调用，一切程序的<strong>起点</strong>（fork是父进程调用的）</li><li>传入<strong>参数</strong>和<strong>环境变量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename,</span><br><span class="hljs-params">           <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> * <span class="hljs-type">const</span> envp[])</span>;<br><br>ls -al <br><span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-string">&quot; /usr/bin/ls&quot;</span>, [<span class="hljs-string">&quot;ls&quot;</span>， <span class="hljs-string">&quot;-al&quot;</span>]， <span class="hljs-number">0x7ffeaabcda88</span> <span class="hljs-comment">/* 54 vars */</span>)</span> = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>环境变量，默认继承父进程</p><ul><li>使用<code>env</code>命令查看<ul><li><code>PATH</code>: 可执行文件搜索路径</li><li><code>PWD</code>: 当前路径</li><li><code>HOME</code>: home 目录</li><li><code>DISPLAY</code>: 图形输出</li><li><code>PS1</code>: shell 的提示符</li></ul></li><li><code>export</code>: 告诉 shell 在创建子进程时设置环境变量<ul><li>小技巧：<code>export ARCH=x86_64-qemu</code> 或 <code>export ARCH=native</code></li></ul></li></ul><p>strace gcc  gcc会先去找可执行的<code>as</code>汇编器程序，去path里找，所以会输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/local/sbin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ...<br>[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/local/bin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ...<br>[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/sbin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ...<br>[<span class="hljs-meta">pid 28369</span>] execve(<span class="hljs-string">&quot;/usr/bin/as&quot;</span>, [<span class="hljs-string">&quot;as&quot;</span>, <span class="hljs-string">&quot;--64&quot;</span>, ..<br></code></pre></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status)<br>    销毁当前状态机，并允许有一个返回值<br>    子进程终止会通知父进程 (后续课程解释)<br></code></pre></td></tr></table></figure><p> exit 的几种写法 (它们是不同)</p><ul><li>exit(0)   stdlib.h中声明的 libc 函数<ul><li>会调用 <code>atexit</code></li></ul></li><li><code>_exit(0)</code>  glibc 的 syscall wrapper<ul><li>执行 “exit_group” 系统调用终止整个进程 (所有线程)<ul><li>细心的同学已经在 strace 中发现了</li></ul></li><li>不会调用 <code>atexit</code></li></ul></li><li><code>syscall(SYS_exit, 0)</code><ul><li>执行 “<code>exit</code>” 系统调用终止当前线程</li><li>不会调用 <code>atexit</code></li></ul></li></ul><h4 id="shell中运行-a-out"><a href="#shell中运行-a-out" class="headerlink" title="shell中运行.&#x2F;a.out:"></a>shell中运行.&#x2F;a.out:</h4><ol><li>Shell解析命令行输入，发现<code>./a.out</code>是一个可执行文件。</li><li>Shell调用<code>fork()</code>系统调用，创建一个新的子进程。子进程复制父进程的所有资源和代码段。</li><li>子进程调用<code>execve()</code>系统调用，加载并执行<code>a.out</code>可执行文件。<ol><li>如果可执行文件需要进行系统调用，例如读取文件或写入文件，它会使用相应的系统调用，如<code>open()</code>、<code>read()</code>、<code>write()</code>等。</li><li>当可执行文件执行完毕或调用了<code>exit()</code>系统调用来终止进程时，进程会返回到Shell。</li></ol></li><li>shell <code>wail()</code>等待子进程(如果后台运行<code>&amp;</code>就不会等待)</li></ol><p>Shell本身也是一个进程<code>/bin/bash</code>，初始状态读取配置文件<code>~/.bashrc</code>。输入：</p><ul><li>执行内部命令（例如<code>cd</code>或<code>echo</code>）</li><li>执行系统命令（例如<code>ls</code>或<code>grep</code>）（本质上也是可执行文件）</li><li>可执行文件</li></ul><h3 id="Linux中的init"><a href="#Linux中的init" class="headerlink" title="Linux中的init"></a>Linux中的init</h3><ul><li>Linux 操作系统</li><li>Linux 系统启动和 initramfs</li><li>Linux 应用世界的构建</li></ul><p>just for fun</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Hello, everybody out there using minix – I’m doing a (free) operating system (<span class="hljs-keyword">just </span>a hobby, won’t <span class="hljs-keyword">be </span><span class="hljs-keyword">big </span><span class="hljs-keyword">and </span>professional like gnu) for <span class="hljs-number">386</span>(<span class="hljs-number">486</span>) <span class="hljs-built_in">AT</span> <span class="hljs-keyword">clones. </span>This has <span class="hljs-keyword">been </span><span class="hljs-keyword">brewing </span>since April, <span class="hljs-keyword">and </span>is starting to get ready.<br>—— Linus Torvalds (时年 <span class="hljs-number">21</span> 岁)<br></code></pre></td></tr></table></figure><p><code>Minix</code>: 完全用于教学的真实操作系统 1987。Andrew Tanenbaum。  <code>Linux</code> 的起点</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404518.png" alt="image-20230604102002909"></p><h4 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h4><ul><li>加载第一个进程<ul><li>相当于在操作系统中 “放置一个位于初始状态的状态机” **init **    <strong>systemd</strong> </li><li>Single user model (高权限)</li></ul></li><li>包含一些进程可操纵的操作系统对象</li><li>除此之外 “什么也没有”<ul><li>Linux 变为一个中断 (系统调用) 处理程序</li></ul></li></ul><p>Linux Kernel 系统调用上的发行版和应用生态</p><ul><li>系统工具 <a href="https://www.gnu.org/software/coreutils/coreutils.html">coreutils</a>, <a href="https://www.gnu.org/software/binutils/">binutils</a>, <a href="https://systemd.io/">systemd</a>, …</li><li>桌面系统 Gnome, xfce, Android</li><li>应用程序 file manager, vscode, …</li></ul><h4 id="第一个状态机"><a href="#第一个状态机" class="headerlink" title="第一个状态机"></a>第一个状态机</h4><p>1.我们可以控制init程序是谁，比如最简单的<code>helloword</code>。当<code>helloword</code> 退出后，也就是杀死最后一个进程，Kernel panic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">INIT := /init<br><span class="hljs-comment"># INIT := /minimal</span><br><br>run:<br><span class="hljs-comment"># Run QEMU with the installed kernel and generated initramfs</span><br>qemu-system-x86_64 \<br>  -serial mon:stdio \ <br>  -kernel build/vmlinuz \<br>  -initrd build/initramfs.cpio.gz \<br>  -machine accel=kvm:tcg \<br>  -append <span class="hljs-string">&quot;console=ttyS0 quiet rdinit=<span class="hljs-subst">$(INIT)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>2.改回启动Init程序，其中<code>busybox</code> 是一个程序，但包含很多文件 5000行     <code>busybox  vi</code>      <code>busybox  sh</code>，因此我们的init程序就可以使用命令了，再通过软连接就可以直接执行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><span class="hljs-variable">$BB</span> poweroff -f<br><br><span class="hljs-comment"># (2) Run a shell on the init console</span><br><span class="hljs-variable">$BB</span> sh<br><br><span class="hljs-comment"># (3) Rock&#x27;n Roll!</span><br><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br>    <span class="hljs-comment"># /bin/ls -&gt; /bin/busybox</span><br>    <span class="hljs-comment"># /bin/cat -&gt; /bin/busybox</span><br>    <span class="hljs-comment"># /bin/grep -&gt; /bin/busybox</span><br><span class="hljs-built_in">mkdir</span> -p /tmp<br><span class="hljs-built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc  none /proc<br><span class="hljs-built_in">mkdir</span> -p /sys  &amp;&amp; mount -t sysfs none /sys<br><span class="hljs-built_in">mknod</span> /dev/tty c 4 1<br>setsid /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>至此我们通过init启动了一个独立sh，sh中可以执行我们的指令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">如果我们放一个<span class="hljs-keyword">vi</span> &amp; 在后台<br># pstree<br>init---<span class="hljs-keyword">sh</span>---pstree<br>           -<span class="hljs-keyword">vi</span><br>           <br>指令都是指向busybox，busybox通过系统调用的参数(执行的名称)实现不同的命令<br></code></pre></td></tr></table></figure><h4 id="其他工作"><a href="#其他工作" class="headerlink" title="其他工作"></a>其他工作</h4><p>只是一个内存里的小文件系统</p><ul><li>我们 “看到” 的都是被 init 创造出来的<ul><li>加载剩余必要的驱动程序，例如网卡</li><li>根据 fstab 中的信息挂载文件系统，例如网络驱动器</li><li>将根文件系统和控制权移交<code>pivot_root</code>给另一个程序，例如 systemd</li></ul></li></ul><h3 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h3><p>进程的状态由 (M,R) 组成，R为体系结构中决定的，M的具体实现？</p><h4 id="地址空间内容"><a href="#地址空间内容" class="headerlink" title="地址空间内容"></a>地址空间内容</h4><p><code>pmap pid</code>   读取<code>/proc/pid/maps</code>   <code>strace</code>跟踪可以证明</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 一大堆内存，有的rx为代码pc访问  有的r(字符串常量)  有的rw(变量 栈)</span><br>12345:   executable_program<br>Address           Kbytes     RSS   Dirty Mode   Mapping<br>0000000000400000    2048     976     976 r-x--  executable_program<br>0000000000600000    1024     512     512 rw---  executable_program<br>0000000000700000    4096    2048    2048 rw---    [ anon ]<br>00007f9a28345000    4096    2048    2048 r-x--  libc.so.6<br>00007f9a283d4000    2048       0       0 -----  libc.so.6<br>00007f9a285d4000      16      12       0 r----  libc.so.6<br>00007f9a285d8000       4       4       4 rw---  libc.so.6<br>00007f9a285d9000      16       4       4 rw---    [ stack ]<br><br><span class="hljs-comment"># 猜测对不对的上？ 加一些变量代码，然后调试</span><br></code></pre></td></tr></table></figure><p>如果是动态链接呢？有一个加载的过程，在<code>main</code>之前把动态链接库（如libc.so.6）加载到地址空间中</p><p> 系统调用需要陷入内核，但有些简单的(只读的)可以不用陷入内核执行</p><ul><li><code>vvar</code> ：Virtual Variable  存储内核和用户空间之间共享的变量。这些变量包括与时间相关的信息、线程特定的数据等。</li><li><code>vdso</code>：取这些信息的代码，<strong>不进入内核的系统调用</strong></li></ul><h4 id="空间的管理"><a href="#空间的管理" class="headerlink" title="空间的管理"></a>空间的管理</h4><p>程序空间是变化的：操作系统应该提供一个<strong>修改进程地址空间的系统调用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 映射  fd文件描述符 offset偏移量，提供时把文件内容加载到内存</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br><span class="hljs-comment">// 为 malloc/free 提供了机制</span><br><br><span class="hljs-comment">// 修改映射权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>分配8G(可以超过内存)会直接分配，使用时才加入内存发生缺页中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GiB * (1024LL * 1024 * 1024)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *p = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span> GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap: %lx\n&quot;</span>, (<span class="hljs-type">uintptr_t</span>)p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)p == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;cannot map&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  *(p + <span class="hljs-number">2</span> GiB) = <span class="hljs-number">1</span>;<br>  *(p + <span class="hljs-number">4</span> GiB) = <span class="hljs-number">2</span>;<br>  *(p + <span class="hljs-number">7</span> GiB) = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">4</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">6</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">7</span> GiB));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Memory-Mapped File</strong>: 一致性：什么时候将修改写入磁盘？多进程如何共享？</p><h4 id="入侵地址空间"><a href="#入侵地址空间" class="headerlink" title="入侵地址空间"></a>入侵地址空间</h4><p>入侵地址空间就是可以任意操控其他进程</p><ul><li>调试器 (gdb)<ul><li>gdb 可以任意观测和修改程序的状态</li></ul></li><li>Profiler (perf)<ul><li>合理的需求，操作系统就必须支持</li></ul></li></ul><h5 id="金手指"><a href="#金手指" class="headerlink" title="金手指"></a>金手指</h5><p>物理劫持</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202306091404519.png" alt="image-20230605105022909"></p><h5 id="金山游侠"><a href="#金山游侠" class="headerlink" title="金山游侠"></a>金山游侠</h5><p>入侵地址空间，修改<strong>金钱</strong>、<strong>生命</strong>属性</p><p>任何操作系统肯定提供了gdb</p><p>原理为<code>pmap</code>读取内存的内容并修改</p><p>代码扫描所有地址，找出金钱为3000的，消耗一些后找出价钱为2700的，这些地址值都修改就可以修改金钱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">long</span> val;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> <span class="hljs-title">game</span>;</span><br><br>  <span class="hljs-keyword">if</span> (load_game(&amp;game, argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (!feof(<span class="hljs-built_in">stdin</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s %d) &quot;</span>, game.name, game.pid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> release;<br><br>    <span class="hljs-keyword">switch</span> (buf[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-keyword">goto</span> release; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); game.bits = val; reset(&amp;game); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); scan(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); overwrite(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>: reset(&amp;game); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>release:<br>  close_game(&amp;game);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="按键精灵"><a href="#按键精灵" class="headerlink" title="按键精灵"></a>按键精灵</h5><p>大量重复固定任务。这个简单，就是给进程发送键盘&#x2F;鼠标事件</p><ul><li>做个驱动 (可编程键盘&#x2F;鼠标)</li><li>利用操作系统&#x2F;窗口管理器提供的 API<ul><li><a href="https://github.com/jordansissel/xdotool">xdotool</a> (我们用这玩意测试 vscode 的插件)</li><li><a href="https://www.kernel.org/doc/html/latest/input/input.html">evdev</a> (按键显示脚本；主播常用)</li></ul></li></ul><h5 id="变速齿轮"><a href="#变速齿轮" class="headerlink" title="变速齿轮"></a>变速齿轮</h5><p>跳转游戏逻辑更新速度</p><p>程序只是状态机，除了<code>syscall</code>无法感知时间。修改<code>syscall</code>返回值就可以欺骗程序。</p><h5 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改 API 调用的值</span><br>set_alarm(<span class="hljs-number">1000</span> / FPS); <span class="hljs-comment">// 希望改成 100 / FPS</span><br><br><span class="hljs-comment">// 锁定生命值</span><br>hp -= damage; <span class="hljs-comment">// 希望 “消除” 此次修改</span><br><span class="hljs-keyword">if</span> (hp &lt; <span class="hljs-number">0</span>) game_over();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>穿越计算机的迷雾</title>
    <link href="/2023/05/12/book/%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE/"/>
    <url>/2023/05/12/book/%E7%A9%BF%E8%B6%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%B7%E9%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>文章摘要：    文章从基础的电信号表达数字开始，逐步揭示了现代计算机的基本原理。主要包含以下内容：    1. <strong>数字表达与二进制</strong>：电压直接表示数字（如1V代表1）不精确，转而采用二进制（开关状态表示0和1），并介绍二进制加法器的实现逻辑（逐位计算，进位传递）。    2. <strong>电与磁的转换</strong>：电能生磁（用于莫尔斯电报和继电器远距传输），磁也能生电（实现话筒和扬声器的声电转换）。交流电因其易产生、易变压和低损耗成为电力传输主流。    3. <strong>逻辑门与电路设计</strong>：介绍与、或、非、异或等基本逻辑门，通过组合门电路实现加法器、寄存器等核心组件，逐步构建运算器。    4. <strong>存储技术演进</strong>：从继电器到晶体管，再到DRAM（电容存储）和SRAM（触发器存储），以及现代硬盘和固态存储的原理。    5. <strong>计算机核心架构</strong>：      - <strong>寄存器与总线</strong>：存储中间数据，通过总线控制实现数据流通。      - <strong>控制器与指令集</strong>：解析指令，协调运算器和存储器的操作，自动化执行流程。      - <strong>存储器层次</strong>：包括高速缓存（SRAM）、内存（DRAM）和外存（磁盘、固态硬盘）。    6. <strong>扩展技术</strong>：如流水线提升CPU效率，中断机制处理输入输出请求，以及程序计数器和地址寄存器的协同工作。    最终，通过振荡器替代手动操作实现全自动计算，完成从简单电路到通用计算机的演进。</p></blockquote><h3 id="bit入门"><a href="#bit入门" class="headerlink" title="bit入门"></a>bit入门</h3><p>如何用电来表达一个数字：</p><ul><li>1v为1  、2v为2… 但难以计算到底是几v</li><li>开关，0代表无 1代表有。二进制</li></ul><p>如何对二进制实现加法</p><ul><li>对于每一位<ul><li>两个输入一个进位</li><li>一个输出一个进位</li></ul></li><li>多位串联起来<ul><li>低位的进位传递给高位</li></ul></li></ul><h3 id="电与磁"><a href="#电与磁" class="headerlink" title="电与磁"></a>电与磁</h3><p>电能生磁，通过电流通断规律控制衔铁臂上下运动画出莫尔斯电报</p><p>​距离太远？继电器实现不同回路的继电</p><p>磁生电，线圈切割磁感线产生电流：<strong>话筒</strong>  声波-&gt;电流     <strong>扬声器</strong> 电流-&gt;声波   二者可以是同一个东西</p><p>为什么是交流电</p><ul><li>产生更容易，圆周运动</li><li>通过变压器轻松实现升降压，而高压传输损耗更小</li></ul><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><ul><li><a href="https://fasionchan.com/computer/logic-gate/relay-logic-gate/">用电磁继电器实现逻辑门</a> 非(1)、与(2)、或(2)、与非(2)、异或门(<code>!AB+A!B</code>两非两与一或&#x3D;8、或 与非 与 &#x3D; 6)</li></ul><p>同门电路<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450617.png" alt="image-20230511153924305"></p><p>与非<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450618.png" alt="image-20230511154215546" style="zoom: 67%;" /></p><p>异或门</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450619.png" alt="image-20230511152444206" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450620.png" alt="image-20230511152733412"></p><ul><li><p>对全加器列出真值表，化简出逻辑表达式，并使用继电器构造出来，22个-&gt;18个  1940年计数器</p><p><code>S = A ⊕ B ⊕ Cin</code></p><p><code>Cout = (A B) + (Cin (A ⊕ B))</code></p></li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450621.png" alt="image-20230511151739600" style="zoom:80%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450622.png" alt="image-20230511172429980"></p><p>至此我们得到了<strong>运算器</strong></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>为了记录下1bit！！！(后面采用电容存储1bit(DARM 内存；晶体管做触发器SRAM cache))</p><p>二极管：加热的灯丝可以放出电子</p><p>三极管：中间增加一个栅极，可以截断或者放大</p><p><strong>振荡器：</strong>把一个非门的输出接到输入</p><h4 id="触发器："><a href="#触发器：" class="headerlink" title="触发器："></a><strong>触发器：</strong></h4><p>​输出永远相反，而当输入只有一个1时，可以改变输出状态(输入期望也相反)   问题：我只想在想记录时记录</p><p>​输入S置为一后，Q一直会保持1，R(reset)可以将Q置零。都为1不稳定</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450623.png" alt="image-20230511163751743"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450624.png" alt="image-20230511164109382" style="zoom:67%;" /></p><h4 id="D触发器："><a href="#D触发器：" class="headerlink" title="D触发器："></a><strong>D触发器：</strong></h4><p>​增加一个控制端，实现1bit的保存。CP为1时，Q&#x3D;D保存输入，CP为0时，忽略</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450625.png" alt="image-20230511165325821"></p><h4 id="上升沿D触发器："><a href="#上升沿D触发器：" class="headerlink" title="上升沿D触发器："></a><strong>上升沿D触发器</strong>：</h4><p>​CP为上升信号时，触发保存。对于继电器，一次记录可能需要延时1s</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450627.png" alt="image-20230511165731250"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450628.png" alt="image-20230511170247155"></p><h4 id="走马灯：移位寄存器"><a href="#走马灯：移位寄存器" class="headerlink" title="走马灯：移位寄存器"></a><strong>走马灯：移位寄存器</strong></h4><p>​（移位寄存器）振荡器 + 循环连接的上升沿触发器，其中有一个1；每震荡一次1就传递给下一个。<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450629.png" alt="image-20230511170124003"></p><h4 id="寄存器：多个上升D"><a href="#寄存器：多个上升D" class="headerlink" title="寄存器：多个上升D"></a><strong>寄存器：</strong>多个上升D</h4><p>多个CP就可以构成寄存器存储数据</p><h4 id="T触发器："><a href="#T触发器：" class="headerlink" title="T触发器："></a><strong>T触发器：</strong></h4><p>​反转</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450630.png" alt="image-20230511170310516"></p><p>​串联： 二进制计数器，计算上升沿的数量</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450631.png" alt="image-20230511172102638"></p><p>至此我们得到了寄存器，能够缓存一部分数据。</p><p>继电器  -&gt;电子管  -&gt; 晶体管  -&gt;  集成电路</p><h3 id="一连串加法"><a href="#一连串加法" class="headerlink" title="一连串加法"></a>一连串加法</h3><p>之前的加法器只能保证两个输入得到一个输出，但不能连续计算。结合寄存器优化！！</p><p>1.基本思想：使用寄存器保存值，一个数为直接输入，另一个为RA寄存器的值。加法器会<strong>实时</strong>计算两个输入的值</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450632.png" alt="image-20230511190342020"></p><p>2.为了实现连续计算，加法器的输出要直接接到输入</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450633.png" alt="image-20230511190457135"></p><p>​<strong>问题：</strong>共用一条线（<strong>总线</strong>）会冲突，需要添加控制实现轮流使用总线</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450634.png" alt="image-20230511190610102" style="zoom:67%;" /><p>3.添加上总线控制GA，GB，总线控制是<strong>按住</strong>，而寄存器装载是上升沿<strong>按下松开</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450635.png" alt="image-20230511190438862"></p><p>10+3+2</p><p>第一步为装载，2~3为相加</p><ol><li>扳出10（在实际中，取数也是一个自动操作 后面实现），按住GA，延时后按下RA，装载输入1的值为10  </li><li>扳出3， 按住GA，这时候加法器已经得到了实时输出，按下TR，装载输出到寄存器</li><li>再按住GB，代表输出需要占用总线，数据传输到RA时按下RA装载结果，实现一次计算</li><li>重复2过程，扳出数字2…</li></ol><p>4.添加一个<strong>控制器</strong>控制，列出真值表，即可得到控制器电路（K的状态相当于指令，控制器电路需要解析指令）。延时问题后面解决</p><ul><li>上面两个为模式，选择一个</li><li>下面两个为当前模式下的操作，k0~x只有一个为1</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450636.png" alt="image-20230511195305178"></p><p>5.控制器优化，只使用一个控制</p><ol><li><p>既然操作t只有一个为1，那么用循环移位寄存器RR实现</p></li><li><p>延时问题，我现在先让G(控制线先输出)，而数据寄存器R需要再按下开关时才触发</p><p>   松开开关代表切换操作，松开状态下数据参数门打开</p><p>   松开后再按下代表上一个数据已经传过来了，要用快点用，按下瞬间装载数据</p><p>也就是松开实现模式切换，按下实现数据保存</p></li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450637.png" alt="image-20230511195839855"></p><h3 id="全自动加法"><a href="#全自动加法" class="headerlink" title="全自动加法"></a>全自动加法</h3><p>现在还需要手动将数据输入，能不能一次性全部输入：需要先存储  <strong>存储器！！</strong></p><p>单bit存储：输入和输出共用一条线，通过信号控制输入还是输出，G就相当于总线控制(输出器)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450638.png" alt="image-20230511193329800"></p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>把多个bit连一起就可以组成一个大数（一行），多个数就可以组成存储器，需要地址译码器选择哪个数据(门牌号)</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450639.png" alt="image-20230511193502167" style="zoom:67%;" /><p>封装一下：输入：地址引线 RW ， 输出n个bit</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450640.png" alt="image-20230511193521662" style="zoom:50%;" /><h4 id="磁芯"><a href="#磁芯" class="headerlink" title="磁芯"></a>磁芯</h4><p>W：不同的电流方向导致不同的磁场方向</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450641.png" alt="image-20230511193659896" style="zoom:50%;" /><p>R：写入一个0，如果原来是0，读出线上电压变化很小。如果原来是1，磁场变化导致读出线上感应电压大</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450642.png" alt="image-20230511193820128" style="zoom:50%;" /><p>1949年10月21磁芯存储器专利</p><h4 id="自动取数"><a href="#自动取数" class="headerlink" title="自动取数"></a>自动取数</h4><p>需要一个计数器ACC，AR寄存计数器的值<strong>（地址寄存器）</strong>，DR寄存数据<strong>（数据寄存器）</strong></p><ol><li>按下K<del>AR</del>锁存当前地址</li><li>按住K<del>RD</del>读取数据，同时按下KDR寄存数据</li><li>按下K<del>AC</del>实现地址增加</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450643.png" alt="image-20230511201809307"></p><p>同样使用一个循环移位1器和译码器实现上面的逻辑结构，至此按下三下即可取出一个数据到DR寄存器</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450644.png" alt="image-20230511202034724"></p><h4 id="连接加法器"><a href="#连接加法器" class="headerlink" title="连接加法器"></a>连接加法器</h4><p>加法器包含2个操作，存储器包含三个，一共五个</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450645.png" alt="image-20230511202615465"></p><p>将相加还是装载添加到指令中，指令也是从存储器中取，指令通过<strong>EC解析</strong>后，翻译出当前的任务，反过来<strong>影响译码器</strong>，也就是告诉计算机进行的下一步操作。IR + EC + 译码器相当于是控制器</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450646.png" alt="image-20230511203156283" style="zoom:50%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450647.png" alt="image-20230511203046934"></p><p>现代的指令中，数据可以直接包含在指令中。原来的AC更像是现代中的PC指针，指向指令的位置</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450648.png" alt="image-20230511203602817"></p><p>最后，把手动按下K换成一个振荡器，即可实现全自动。需要添加一个中止指令，代表程序结束了</p><p>如何处理进位？额外产生一个进位标志来影响控制器</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450649.png" alt="image-20230512122031198"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><p>SRAM：使用晶体管构建触发器，形成存储器，SRAM，但太贵了6个晶体管一个bit，只用来做cache</p><p>DRAM：使用电容和晶体三极管，2ms刷新一次DRAM，做内存</p><p>ROM：一开始只读，然后可擦除。U盘、固态硬盘</p><p>外存：磁芯 —&gt;  磁盘(机械硬盘 磁头+ 磁道 + 扇区) —&gt;  固态硬盘</p><p>流水线：充分利用CPU和内存，错开执行 取指 译码 运算 写回操作</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305121450650.png" alt="image-20230512125603868"></p><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>CPU从哪里读取数据：IO接口</p><p>什么时候去读：CPU不知道IO接口到底有没有数据</p><ul><li>不停的读：CPU不能干别的事情了</li><li>定时询问</li><li>中断：中断向量号表示谁请求了中断，再根据中断向量表转到相应中断处理逻辑</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis应用及原理</title>
    <link href="/2023/04/15/redis%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/15/redis%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章总结了Redis在社交类项目中的实际应用和技术要点，主要内容包括：  1. <strong>短信登录与用户会话管理</strong>    - 验证码和用户信息存储方案（Session vs Redis）    - 使用ThreadLocal保存用户信息    - 敏感信息处理（DTO对象转换）  2. <strong>商户缓存解决方案</strong>    - 缓存穿透（布隆过滤器&#x2F;空值缓存）    - 缓存雪崩（随机TTL&#x2F;多级缓存）    - 缓存击穿（互斥锁&#x2F;逻辑过期）  3. <strong>优惠券秒杀系统</strong>    - 分布式锁实现（Redis setnx&#x2F;Lua脚本）    - Redisson可重入锁特性    - 异步下单（消息队列）  4. <strong>关注功能实现</strong>    - Set集合存储关系  5. <strong>持久化与高可用</strong>    - RDB和AOF持久化机制    - 主从复制原理    - 哨兵和集群模式  6. <strong>高级特性</strong>    - 管道技术提升吞吐    - 慢查询优化    - 安全配置建议  7. <strong>数据结构优化</strong>    - SDS、ZipList等底层结构    - 内存占用优化策略  文章通过具体代码示例（如分布式锁、缓存策略等）展示了Redis在电商秒杀、社交等场景中的实际应用，并详细分析了各项技术的实现原理和优化思路。</p></blockquote><p>视频：<a href="https://www.bilibili.com/video/BV1cr4y1671t">https://www.bilibili.com/video/BV1cr4y1671t</a></p><p>链接<a href="https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11">https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11</a><br>提取码：eh11</p><p>社交类项目</p><ul><li>短信登陆</li><li>商户查询缓存：缓存雪崩 穿透 击穿</li><li>博客</li><li>优惠券秒杀：计算器 lua 分布式锁 队列</li><li>好友关注：set集合</li></ul><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>前后端分离</p><p>start nginx.exe</p><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><ul><li>user</li><li>user_info</li><li>shop</li><li>shop_type</li><li>blog</li><li>follow</li><li>voucher</li><li>voucher_order</li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>短信登录：验证码，用户信息都是直接存入session</p><p>是否登录：session中不用唯一，而redis是共享的需要唯一</p><p>​1.查看session中有没有某个key（固定,不用返回，如”user”，“code”）   2.查看redis中有没有携带的这个token（动态返回,UUID或者JWT）</p><p>配置拦截器，取出User的同时加入到threadlocal中，以后获得用户  <code>UserHolder.getUser()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(UserDTO user)</span>&#123;<br>        tl.set(user);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">()</span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>去除敏感信息：创建一个小的类，然后copy信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把1中有的都给2，并创建对象</span><br>BeanUtil.copyProperties(user,UserDTO.class))<br></code></pre></td></tr></table></figure><p><strong>redis</strong>：验证码、用户信息都存入redis中。</p><ul><li>用户信息用hash（<code>BeanUtil.beanToMap</code>），添加有效期，登录添加登陆后<strong>更新有效期</strong></li><li>拦截器类没有交给spring，不能注入redis，因此添加一个成员变量</li><li>StringRedisTemplate 需要<strong>保证</strong>hash中key value 都是<strong>string</strong>。所以beantomap时需要对<strong>类型进行转化</strong></li><li>问题：有的请求没有拦截，导致没有刷新。再添加一个。一个全部刷新添加、一个拦截</li></ul><h3 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h3><p>缓存：浏览器缓存 redis缓存 数据库缓存 索引</p><p>问题：数据一致性</p><p>shop、shop_type添加缓存</p><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230325200622115.png" alt="image-20230325200622115"></p><ul><li>低一致性的数据：内存淘汰</li><li>高一致性：主动更新+超时</li></ul><h5 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h5><ol><li>更新数据库的同时更新缓存<ul><li>更新还是删除缓存：<strong>删除比较一致性好</strong>。防止多次更新</li><li>如何保证同时成功失败：单体：事务；分布式：TCC分布式事务</li><li>先更新数据库还是缓存？   都可能有问题<ul><li>先删缓存：A删完缓存来了查询B，B查询完成后写入脏数据到redis</li><li><strong>先数据库</strong>：出问题概率更低（B来的时候没有缓存，B读取数据库，A更新数据并删除redis，B写脏数据到redis），但A写数据库的过程，B查的都是旧数据</li></ul></li></ul></li><li>缓存、数据库整合成一个服务</li><li>先更新缓存、异步更新到数据库</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230325200816783.png" alt="image-20230325200816783"></p><p>所以：查询商品：<strong>添加超时，并且更新后删除缓存</strong></p><p>此外：还可以直接加读写锁，更新时直接加写锁。读取时读redis加读锁，读数据库并更新加写锁  并发251集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... params)</span> &#123;<br>    <span class="hljs-type">SqlPair</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPair</span>(sql, params);<br>    <span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>    lock.writeLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> genericDao.update(sql, params);<br>        map.clear();<br>        <span class="hljs-keyword">return</span> rows;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.writeLock().unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">queryOne</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String sql, Object... params)</span> &#123;<br>    <span class="hljs-type">SqlPair</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPair</span>(sql, params);<br>    <span class="hljs-comment">// 加读锁, 防止其它线程对缓存更改</span><br>    lock.readLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.readLock().unlock();<br>    &#125;<br>    <span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>    lock.writeLock().lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span><br>        <span class="hljs-comment">// 为防止重复查询数据库, 再次验证</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果没有, 查询数据库</span><br>            value = genericDao.queryOne(beanClass, sql, params);<br>            map.put(key, value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.writeLock().unlock();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>Redis和数据库都不存在的数据，不停的请求每次都会打到数据库上。</p><ul><li><strong>缓存空对象</strong>：直接缓存一个空值“”，需要添加TTL。可能照成短期的不一致。  代码写法</li><li><strong>布隆过滤器</strong>：添加一层判断是否纯在。内存少 但实现复杂</li></ul><p>此外还有：数据格式校验、用户权限校验、热点参数限流 cloud</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>同时大量缓存失效或者宕机。</p><ul><li>TTL可以添加随机</li><li>Redis集群</li><li>降级限流 确保数据库安全</li><li>多级缓存</li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>查询数据库但在没有构建出缓存的这段时间，<strong>同时大量重建</strong> 击穿了数据库。</p><p>热点key（高并发），并且重新构建业务比较<strong>复杂</strong>（查询数据库的时间很长，这个时间大家都来查了）。</p><ul><li><strong>互斥锁</strong>：加一个查询锁。没有锁的休息下重试。<strong>可能死锁</strong>  （锁的可能会有问题：加版本 加lua脚本 见秒杀.md）</li><li><strong>逻辑过期</strong>：永不过期防止查不到，并且添加一个逻辑过期时间字段，如果逻辑过期了，就<strong>返回旧值并异步更新</strong>一下（锁）</li></ul><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>setIfAbsent实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">aBoolean</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(aBoolean);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">delete</span> <span class="hljs-operator">=</span> stringRedisTemplate.delete(key);<br>    <span class="hljs-keyword">return</span> delete;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (s.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> JSONUtil.toBean(s, Shop.class);<br>    &#125;<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(!isLock(lockKey))&#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            queryWithMutex(id);<br>        &#125;<br>        <span class="hljs-comment">// double check 没有的话也会访问多次数据库</span><br>        s = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);<br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (s.isEmpty())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(s, Shop.class);<br>        &#125;<br>        <span class="hljs-comment">// 模拟</span><br>        shop = getById(id);<br>        Thread.sleep(<span class="hljs-number">200</span>);<br><br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>)&#123;<br>            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES );<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES );<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        unLock(lockKey);<br>    &#125;<br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h5><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230325211055087.png" alt="image-20230325211055087" style="zoom: 67%;" /><p>RedisData: 包装类保存时间和数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br><br><span class="hljs-comment">// 取出</span><br><span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(s, RedisData.class);<br><span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (JSONObject)redisData.getData();<br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(data, Shop.class);<br></code></pre></td></tr></table></figure><ul><li><strong>先预热下数据</strong>,该数据逻辑上过期了</li><li>redis没有 直接返回</li><li>有 再看下时间要不要重建</li><li>最后修改下数据库，1m发起1000次请求，重建延时为200ms，可以看到后面的数据可以查到真的，前面是脏的</li></ul><p>没有doublecheck但数据库依旧只查询了一次，原因未知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用逻辑过期</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicExpire</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(s, RedisData.class);<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (JSONObject)redisData.getData();<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(data, Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-comment">// 没拿到锁直接返回</span><br>    <span class="hljs-keyword">if</span> (!isLock(lockKey)) &#123;<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br><br>    <span class="hljs-comment">// double check 但没发现影响</span><br>    <span class="hljs-comment">//        s = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br>    <span class="hljs-comment">//        if (s == null || s.isEmpty())&#123;</span><br>    <span class="hljs-comment">//            return null;</span><br>    <span class="hljs-comment">//        &#125;</span><br>    <span class="hljs-comment">//        redisData = JSONUtil.toBean(s, RedisData.class);</span><br>    <span class="hljs-comment">//        data = (JSONObject)redisData.getData();</span><br>    <span class="hljs-comment">//        shop = JSONUtil.toBean(data, Shop.class);</span><br>    <span class="hljs-comment">//        expireTime = redisData.getExpireTime();</span><br>    <span class="hljs-comment">//        if (expireTime.isAfter(LocalDateTime.now()))&#123;</span><br>    <span class="hljs-comment">//            return shop;</span><br>    <span class="hljs-comment">//        &#125;</span><br><br>    CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            saveShop2Redis(id, <span class="hljs-number">20L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            unLock(lockKey);<br>        &#125;<br>    &#125;);<br><br>        <span class="hljs-keyword">return</span> shop;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ul><li>对象-&gt;string类型 TTL</li><li>对象-&gt;string类型 逻辑TTL</li><li><strong>queryWithPassThrough</strong> 空字符串防止缓存穿透<ul><li><code>pre  id  Class</code> -&gt; 对象   null防止缓存穿透，<code>Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit</code>重建</li></ul></li><li><strong>queryWithLogicalExpire</strong> <ul><li><code>pre  id  Class</code> -&gt; 对象    <code>Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit</code>重建</li></ul></li><li><strong>queryWithMutex</strong></li></ul><h3 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h3><p>代金券就是商品</p><p>tb_voucher_order：订单表</p><h4 id="ID生成器"><a href="#ID生成器" class="headerlink" title="ID生成器"></a>ID生成器</h4><p>id没有使用自增：规律性明显、表拆分后自增会冲突</p><p>全局id生成器：唯一、高可用（集群）、高性能、递增、安全</p><p>时间戳用的秒，序列号为一天的自增长（需要一个prefix）：方便统计计量、控制大小</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230404171731277.png" alt="image-20230404171731277"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime.now(); <span class="hljs-comment">// 时间</span><br>now.toEpochSecond(ZoneOffset.UTC); <span class="hljs-comment">// 转为秒</span><br>now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>)); <span class="hljs-comment">// 转为特定格式字符串</span><br><br><br>CountDownLatch 可以实现线程的等待<br>CountDownLatch(<span class="hljs-number">300</span>);<span class="hljs-comment">// 计数</span><br>countDownLatch.countDown();<br>countDownLatch.await();<span class="hljs-comment">// 等待减完 阻塞</span><br></code></pre></td></tr></table></figure><h4 id="优惠券下单"><a href="#优惠券下单" class="headerlink" title="优惠券下单"></a>优惠券下单</h4><p>同样两个表，<strong>普通表</strong>和<strong>秒杀表</strong></p><p>普通表有基本信息（<code>type</code>区分普通还是秒杀），秒杀表扩展 <code>库存 时间</code>。<code>voucher</code>类中有额外字段，用<code>@TableField(exist = false)</code>标识。</p><p>添加优惠券：一个接口  同时添加两个表。</p><h5 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h5><ul><li>悲观锁：直接一个<code>redis.setnx</code>锁</li><li>乐观锁：更新数据时，成功率很低<ul><li>添加版本号，修改前需要查版本号 <code>set stock = stock -1 where version = initVersion</code></li><li>CAS(compare and set)：库存本来就是版本号，<code>where stock = initStock</code> ，但这样会导致<strong>成功率低</strong>；  &#x3D;&#x3D;修改为&#x3D;&#x3D;：<code>where stock &gt; 0</code>  也就是秒杀项目的基础用法</li></ul></li></ul><h5 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h5><ul><li>唯一索引</li><li>加锁: 单机情况<ol><li>sychronized：锁定函数,阻塞的</li><li>缩小范围，提取一人一单开始锁定，并且通过userid标识 <code>synchronized (userId.toString().intern())</code> </li><li>小函数添加事务，提取出真的的代理对象调用小函数。引入依赖、添加注解</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>    <span class="hljs-comment">// 获取代理对象(事务)</span><br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy() ;<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题：</strong>微服务项目，不同服务中的普通线程锁就失败了。无法跨进程</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230405142105457.png" alt="image-20230405142105457"></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p><strong>普通set del</strong> &#x3D;&gt; <strong>加超时</strong> &#x3D;&gt; <strong>加版本</strong> &#x3D;&gt; <strong>加Lua</strong></p><p><code>set lock thread1 NX EX 10</code></p><p>添加<code>SimpleRedisLock</code>类专门处理锁，需要传入name 和 redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标示</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用lua脚本</span><br>        stringRedisTemplate.execute(<br>                UNLOCK_SCRIPT,<br>                Collections.singletonList(KEY_PREFIX + name),<br>                ID_PREFIX + Thread.currentThread().getId());<br>    &#125;<br><br><span class="hljs-comment">// 非原子</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取线程标示</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁中的标示</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-comment">// 判断标示是否一致</span><br>        <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            stringRedisTemplate.delete(KEY_PREFIX + name);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h5><p>数组下标从1开始，需要指明key的数量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> value = ARGV[<span class="hljs-number">1</span>]<br>redis.call(<span class="hljs-string">&#x27;SET&#x27;</span>, key, value)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;OK&#x27;</span><br><br>eval <span class="hljs-string">&quot;local key = KEYS[1]\nlocal value = ARGV[1]\nredis.call(&#x27;SET&#x27;, key, value)\nreturn &#x27;OK&#x27;&quot;</span> <span class="hljs-number">1</span> mykey hello<br><br><br>unlock.lua：<br> <span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])==ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>脚本定义和调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>UNLOCK_SCRIPT.setResultType(Long.class);<br><br>stringRedisTemplate.execute(<br>                UNLOCK_SCRIPT,<br>                Collections.singletonList(KEY_PREFIX + name),<br>                ID_PREFIX + Thread.currentThread().getId());<br>                <br>                <br>UNLOCK_SCRIPT也可以直接交给spring<br></code></pre></td></tr></table></figure><h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h5><ul><li>不可重用 A拿了锁调用B，B也需要锁</li><li>不可重试，只try一次</li><li>超时释放 和 业务时间冲突</li><li>主从一致性，主节点宕机后存在还能没同步到从节点</li></ul><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>1.首先，在 pom.xml 文件中添加 Redisson 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.16.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.在 Spring Boot 应用中，使用 Redisson 的方式通常是通过创建一个 RedissonClient 实例与 Redis 进行通信。RedissonClient 可以根据 Redis 的不同部署方式来进行配置。下面是一个基于单节点的 Redisson 配置示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redisson</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer()<br>                .setAddress(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>)<br>                .setDatabase(<span class="hljs-number">0</span>)<br>                .setPassword(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedissonClient redisson;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisson.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span>+userId);<br>    lock.tryLock(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 阻塞尝试1s，过期时间10s</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 被锁保护的代码区</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="可重用"><a href="#可重用" class="headerlink" title="可重用"></a>可重用</h5><p>Redisson自带可重用，可以打断点看redis中</p><p><strong>实现原理：</strong>添加一个计数，如果是线程值相同，那么说明是<strong>同一个线程</strong>，<strong>可以获取</strong>锁，并<strong>数量+1</strong></p><p>hash结构实现”： <code>lock:order</code>    (  <code>uuid+thread</code> : <code>count</code>)</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230406095939158.png" alt="image-20230406095939158" style="zoom:67%;" /><p>释放锁时，先减，减到零再释放锁</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230406095958023.png" alt="image-20230406095958023" style="zoom: 67%;" /><h5 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h5><ol><li>获取锁成功直接返回，失败会返回过期时间</li><li>获取锁失败，<strong>订阅</strong>别人的释放tread信号</li><li>等到后，再去while true尝试锁，通过<strong>信号量</strong></li></ol><h5 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h5><p>开多台主机，重用保证主机的可靠性。相当于把redis主从机都做了复制</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709085404088.png" alt="image-20230709085404088"></p><h5 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h5><p>jvm中的服务，受到本地性能影响；并且数据可能丢失</p><ul><li>添加任务：往队列中add</li><li>一个BlockQueue以及一个线程池，线程池中一个线程任务为不停的从队列中拿出任务并执行，这样就实现了异步</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709092259943.png" alt="image-20230709092259943"></p><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul><li><p>List：List模拟消息队列，单消费者</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">通过<span class="hljs-keyword">BRPOP </span>实现阻塞的提取任务<br></code></pre></td></tr></table></figure></li><li><p>PubSub：点对点的消息队列，多生产多个消费者，可以实现通过通配符实现订阅</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">subscribe</span><span class="hljs-params">(channel)</span></span>  <br><span class="hljs-function"><span class="hljs-title">psubscribe</span><span class="hljs-params">(pattern)</span></span><br><br><span class="hljs-function"><span class="hljs-title">publish</span><span class="hljs-params">(channel)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709093433217.png" alt="image-20230709093433217"></p><p>​消息堆积有上限，消息可能丢失（如果没有人接受的）</p></li><li><p>Stream：比较完善的模型，是一种新的数据类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">XADD key k v<br><span class="hljs-comment"># 创建名为users的队列，并向其中发送一个消息，内容是: &#123;name= jack , age=21&#125;,并且使用Redis自动生成ID</span><br>XADD <span class="hljs-built_in">users</span> * name jack age 21<br><br>XREAD COUNT 1 STREAM key 0(从哪个消息开始，$为最新)   BLOCK 阻塞   读完不删除<br></code></pre></td></tr></table></figure><p><strong>消费者组：</strong>一个组有多个消费者，共同消费；消息存在标识代表是否处理过，已读未确认的加入pending</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709095146299.png" alt="image-20230709095146299"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709095044594.png" alt="image-20230709095044594"></p><p>XACK s1 g1 id</p></li></ul><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><ul><li>数据丢失   主从 持久化</li><li>并发能力    读写分离</li><li>故障恢复    哨兵检测监控状态</li><li>存储能力    单节点数据太大了，分片集群</li></ul><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707152248244.png" alt="image-20230707152248244"></p><p>为了安全性使用AOF（1s刷盘），RDB（频率不高、空间小）定期手动进行备份</p><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>RDB  Redis Database Backup file    快照（snapshot）持久化方式<br>保存到磁盘,如果docker启动还需要挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">save   <span class="hljs-comment"># 阻塞  用于关机</span><br>bgsave <span class="hljs-comment"># 异步执行 子进程</span><br><br>save 300 10   <span class="hljs-comment"># 100s内有10个key修改了则触发bgsave</span><br>save <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 禁用</span><br><br>dbfilename dump.rdb <span class="hljs-comment"># 文件名</span><br><span class="hljs-built_in">dir</span> ./7001  <span class="hljs-comment">#   相对于 工作目录 的路径</span><br></code></pre></td></tr></table></figure><p>bgsave中fork过程是需要耗时的，需要拷贝内存。实际上是拷贝页表。</p><p>如果在save过程写请求进来，会修改一个副本内存</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707103341469.png" alt="image-20230707103341469"></p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>(Append-Only File)  记录下命令，优先使用AOF恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly <span class="hljs-built_in">yes</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br>appendfsync always <span class="hljs-comment"># 立即磁盘</span><br>appendfsync everysec <span class="hljs-comment"># 先写入缓存，1s写回磁盘默认 </span><br>appendfsync no  <span class="hljs-comment"># 先写入缓存，操作系统写回</span><br></code></pre></td></tr></table></figure><p>同样会在开始前加载，结束后保存</p><p>但：同一个key实际上前面的操作没有意义，<code>bgrewriteaof</code> 异步只保留最后一次</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br></code></pre></td></tr></table></figure><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><h5 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707153026142.png" alt="image-20230707153026142"></p><ul><li>开启RDB  关闭AOF</li><li>拷贝三个配置文件，需要不同的port和dir文件路径  master关闭bind</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">slave</span><br>    SLAVEOF masterip masterport 当前成为成为<span class="hljs-literal">slave</span>     配置文件或者cli执行命令<br><br><span class="hljs-keyword">master</span><br><span class="hljs-title">info</span> replication 显示信息<br></code></pre></td></tr></table></figure><p>至此master可读可写，slave只可以读，master写时会同步到从</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><strong>基于RDB</strong></p><ul><li>第一次判断：master有唯一replid，是数据集的标记，不一致说明是第一次</li><li>是否落后：offset 偏移量代表数据，offset不一致说明数据落后了</li></ul><h6 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h6><p>第一次：全量同步；如果尝试做增量同步失败后<br><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707155755562.png" alt="image-20230707155755562"></p><h6 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h6><p>根据offset，发回repl_backlog差距<br>log是一个环形数组，如果差距写满了，就需要全量同步</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707160256704.png" alt="image-20230707160256704"></p><h5 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h5><ul><li>repl-diskless-sync  yes  # 直接网络发送而不是先磁盘</li><li>适当提高repl_backlog大小</li><li>主从从结构</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707161013987.png" alt="image-20230707161013987"></p><h4 id="故障恢复-哨兵"><a href="#故障恢复-哨兵" class="headerlink" title="故障恢复-哨兵"></a>故障恢复-哨兵</h4><p>哨兵也是一个小集群</p><h5 id="作用和原理"><a href="#作用和原理" class="headerlink" title="作用和原理"></a>作用和原理</h5><ul><li>master宕机，立马更换一个<ol><li>与master断开时间小于配置</li><li>再根据优先级</li><li>最后判断offset</li></ol></li><li>slave宕机重启</li><li>如果发生了更换，客户端放如何知道？  通知客服端</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707161444358.png" alt="image-20230707161444358"></p><h6 id="心跳监控"><a href="#心跳监控" class="headerlink" title="心跳监控"></a><strong>心跳监控</strong></h6><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707161656312.png" alt="image-20230707161656312"></p><h6 id="迁移master"><a href="#迁移master" class="headerlink" title="迁移master"></a><strong>迁移master</strong></h6><ul><li>备选的变成master</li><li>通知其他slave</li><li>原来master配置文件改为slaveof new</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707162012005.png" alt="image-20230707162012005"></p><h5 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h5><p>sentinel.conf</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707162424474.png" alt="image-20230707162424474"></p><p>启动 <code>redis-sentinel  path.conf</code></p><h5 id="感知切换"><a href="#感知切换" class="headerlink" title="感知切换"></a>感知切换</h5><p>redistemplate基于lettuce实现感知自动切换</p><p>不需要配置redis地址，而是sentinel地址</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707163516061.png" alt="image-20230707163516061"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707163637084.png" alt="image-20230707163637084"></p><h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><p>前面的问题：1.海量数据存储  2.高并发的写操作</p><ul><li>多个master 保存不同的数据  通过插槽实现；master之间可以同时执行命令，高性能</li><li>master之间相互检测健康 不需要sentinel；高可用</li><li>访问集群的任意节点，会自动转发到正确节点</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707165307535.png" alt="image-20230707165307535"></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1.启动  master slave所有的都一样, config-file每个人都有自己的  当前启动后相互还没有关系</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707165501735.png" alt="image-20230707165501735"></p><p>2.创建集群</p><p><code>redis-cli --cluster create --cluster-replicas 2 ip1 ip2 ....</code></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create --cluster-replicas <span class="hljs-number">1 127.0.0</span>.<span class="hljs-number">1:7001 127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0.1:7002</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7003 127.0</span>.<span class="hljs-number">0.1:7004</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7005 127.0</span>.<span class="hljs-number">0.1:7006</span><br></code></pre></td></tr></table></figure><p>一个master对应两个slave，前面的ip为master</p><p>查看集群状态 ：<code>redis-cli -p 7001 cluster nodes</code></p><p>连接：<code>redis-cli -c -p 7001</code></p><h5 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h5><p>每一个master都会散列到0~16383个插槽上的一部分</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707170100439.png" alt="image-20230707170100439"></p><p>key的有效部分{hash_tag}（控制某一类在一个redis上）也会hash计算插槽%16384，得到插槽位置：<strong>数据和插槽绑定</strong></p><h5 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h5><p><code>redis-cli --cluster help</code></p><p><code>redis-cli --cluster add-node ip:port  集群ip:port</code></p><p>分配插槽</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli --cluster reshard ip:port  <br>3000 <span class="hljs-comment"># 移动多少个</span><br>to的<span class="hljs-built_in">id</span><br>from的<span class="hljs-built_in">id</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>当一个master宕机？</p><p>集群可以实现自动切换,master宕机换下一个slave，slave也宕机插槽就宕机了</p><p>手动转移：进入到slave  <code>CLUSTER FAILOVER</code>    </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707183846705.png" alt="image-20230707183846705"></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230707184055375.png" alt="image-20230707184055375"></p><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709102813407.png" alt="image-20230709102813407"></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h4><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709103658048.png" alt="image-20230709103658048" style="zoom:50%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709103955153.png" alt="image-20230709103955153"></p><h5 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a>bigkey</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230709104322936.png" alt="image-20230709104322936"></p><h5 id="合适数据结构"><a href="#合适数据结构" class="headerlink" title="合适数据结构"></a>合适数据结构</h5><p>存储对象：</p><ul><li>json字符串  方便</li><li>直接打散，一个字段一个key value  浪费空间</li><li>hash；entry不超过1000 如果太大拆分取模成多个hash</li></ul><h4 id="批处理优化"><a href="#批处理优化" class="headerlink" title="批处理优化"></a>批处理优化</h4><h5 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h5><p>单次：网络延时(ms级)+执行延时(us级)    一次执行多条指令，如mset，但收到指令集的限制</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230710210639496.png" alt="image-20230710210639496"></p><p>pipeline：不受指令限制，一次发送多条指令，不具备原子性</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240312112300103.png" alt="image-20240312112300103" style="zoom:50%;" /><p>问题：在集群下，多个命令（pipeline mset）必须要在同一个插槽，才能映射到一台机器上</p><h5 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h5><p>mset默认情况下如果key在不同节点上，会报错</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230710212320878.png" alt="image-20230710212320878"></p><p>集群下，spring mset就会默认按照插槽划分，并且创建线程异步并行执行（方法三）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230710212834966.png" alt="image-20230710212834966"></p><h4 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h4><h5 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h5><ul><li>缓存的redis实例开启一个单独实例，不需要做持久化</li><li>为了安全性使用AOF，RDB定期手动进行备份</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230710210200037.png" alt="image-20230710210200037"></p><h5 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h5><p>单线程任务，慢查询会影响其他命令</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">slowlog-<span class="hljs-built_in">log</span>-slower-than 默认<span class="hljs-number">10000</span>us   建议<span class="hljs-number">1000</span>  慢查询会放入日志中<br>slowlog-<span class="hljs-built_in">max</span>-<span class="hljs-built_in">len</span> 日志长度<br></code></pre></td></tr></table></figure><p><code>SLOWLOG GET &lt;n&gt;</code> 命令来获取慢查询日志中的最近 N 条记录，或使用 <code>SLOWLOG RESET</code> 命令清空慢查询日志</p><h5 id="命令及安全配置"><a href="#命令及安全配置" class="headerlink" title="命令及安全配置"></a>命令及安全配置</h5><p>在没有密码并且root启动redis时，修改rbd文件指向ssh文件，并设置value为公钥即可</p><ul><li>上线时禁用flushdb， config set 等命令，通过<code>rename command</code></li><li>bind绑定局域网网卡</li><li>开启防火墙</li><li>不要使用root启动</li><li>非默认端口，设置密码</li></ul><h5 id="内存配置"><a href="#内存配置" class="headerlink" title="内存配置"></a>内存配置</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711105909192.png" alt="image-20230711105909192"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711110539096.png" alt="image-20230711110539096"></p><p><code>MEMORY STATS</code> 命令将返回以下统计数据：</p><ul><li><code>peak.allocated</code>：Redis 运行期间分配的内存峰值。</li><li><code>total.allocated</code>：Redis 运行期间分配的总内存量。</li><li><code>startup.allocated</code>：Redis 启动时分配的内存量。</li><li><code>replication.backlog</code>：复制积压缓冲区使用的内存量。</li><li><code>clients.slaves</code>：连接的从节点数量。</li><li><code>clients.normal</code>：连接的普通客户端数量。</li><li><code>aof.buffer</code>：AOF 缓冲区使用的内存量。</li><li><code>lua.caches</code>：Lua 脚本缓存使用的内存量。</li><li><code>overhead.total</code>：Redis 内部开销占用的内存量。</li><li><code>dataset.bytes</code>：数据集占用的内存量。</li><li><code>dataset.keys</code>：数据集中键的数量。</li></ul><h4 id="集群-or-单体"><a href="#集群-or-单体" class="headerlink" title="集群 or 单体"></a>集群 or 单体</h4><p>当部分插槽不可用时（master slave都宕机），默认集群宕机</p><p><code>cluster-require-full-coverage yes</code></p><p>节点中会互相ping监控状态，如果集群数量太多，ping也需要大量的带宽</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711112726811.png" alt="image-20230711112726811"></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">sds.h<br>    SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64  节约内存<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ul><h6 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h6><p>预分配多一点内存可以减少分配次数</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711115356778.png" alt="image-20230711115356778"></p><h5 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br><span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">/* 编码方式，支持存放16位、32位、64位整数*/</span> 升级机制节约内存<br><span class="hljs-type">uint32_t</span> Length; <span class="hljs-comment">/*元素个数*/</span><br><span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">/*整数数组，保存集合数据   实际大小由encoding决定 其实就是一个起点指针*/</span><br>&#125; intset;<br></code></pre></td></tr></table></figure><p>为了方便查找，会<strong>有序、唯一</strong>存放（二分）。根据所占字节以及index索引    start + index * encoding</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711134306850.png" alt="image-20230711134306850"></p><p>如果存放的数超过了范围，会升级。需要将元素移动到合适位置</p><p>适合数据量不大Set，有序方便查找某一个元素是否在集合中</p><h5 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h5><p>key-value pair通过Dict实现，实现原理和java的hashmap很像，同样是2^n^大小的数组+链表</p><p>扩容时触发rehash</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711145018722.png" alt="image-20230711145018722"></p><p>两个ht用于扩容时存放新的hash表</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711145121313.png" alt="image-20230711145121313"></p><h6 id="渐进扩容"><a href="#渐进扩容" class="headerlink" title="渐进扩容"></a>渐进扩容</h6><p>除了扩容，此外如果<code>LoadFactor &lt; 0.1</code>会收缩</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711145634454.png" alt="image-20230711145634454"></p><p>将空间申请到dict.ht[1]，此外标记rehashidx&#x3D;0代表迁移工作开始</p><p><strong>渐进rehash</strong>：每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1, 如果是则将<code>dict.ht[0].table[rehashidx]</code>的entry链表rehash到dict.ht[1]（需要重新计算hash），并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</p><p>如果rehash在进行中，删改查需要在两个table中都去找，增加直接到dict.ht[1]</p><p>最后将ht[0]指向ht[1]</p><h5 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h5><p><strong>连续空间</strong>（所以不能太大；4~64kb）的<strong>双端</strong>链表，<strong>节省内存</strong>和提供<strong>快速的顺序访问</strong></p><ul><li>指针也要占内存（8B），如何节约？ 通过分配连续内存，并记录下前一个entry的长度实现前遍历，当前长度通过encoding记录。更少的内存碎片</li><li>不能随机读取</li><li>适用于<strong>顺序读取(或两端读取)操作频繁，写入操作较少</strong>   以及 <strong>小型集合</strong>（数小、数量少）</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711151947271.png" alt="image-20230711151947271"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240312145711748.png" alt="image-20240312145711748"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711154604922.png" alt="image-20230711154604922"></p><p><strong>entry</strong>：previous用于向前遍历，encoding记录当前长度</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711152433990.png" alt="image-20230711152433990"></p><p><strong>encoding</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711153249122.png" alt="image-20230711153249122"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711153713999.png" alt="image-20230711153713999"></p><h6 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题</h6><p>连续保存多个253B数据：长度保存字段1B或5B，如果前一个过长当前就要变成5B，导致当前entry超过254连锁更新下一个节点</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711155037085.png" alt="image-20230711155037085"></p><h5 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h5><p>ZipList需要连续空间，找不到怎么办？</p><p>QuickList链表连接多个ZipList，兼具链表（非连续空间）数组（节约内存）的优点</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711161528460.png" alt="image-20230711161528460"></p><ul><li><code>list-max-ziplist-size</code>：限制ziplist的entry数量或内存大小</li><li><code>list-compress-depth</code>：是否压缩中间节点以及压缩的深度</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711161941107.png" alt="image-20230711161941107"></p><h5 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h5><p>QuickList需要全部遍历，如何实现LogN随机查询？</p><ul><li>顺序存储</li><li>包含多个指针，指针的跨度不同（最多32级）</li><li>查找过程向右或向下走</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711163132536.png" alt="image-20230711163132536"></p><p>每一个节点有一个下一个节点数组，不同节点数组长度不同</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711163653562.png" alt="image-20230711163653562"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711163720136.png" alt="image-20230711163720136"></p><h5 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h5><p>Redis中的键值都会被封装为RedisObject，头需要16B</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711165735576.png" alt="image-20230711165735576"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711170113298.png" alt="image-20230711170113298"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230711170150903.png" alt="image-20230711170150903"></p><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>数据量小的时候，尽量节约空间；数据量大不得不空间换时间</p><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><ol><li>其基本编码方式是RAW,基于简单动态字符串(SDS)实现，存储上限为512mb。</li><li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码,此时object head与SDS是一段连续空间。 申请内存时只<br>需要调用<strong>1次</strong>内存分配函数,效率更高。（小于44字节，一共分配小于64）</li><li>如果存储的字符串是整数值,并且大小在LONG_ MAX范围内，则会采用INT编码:直接将数据保存在RedisObject的<br>ptr指针位置(刚好8字节) ,不再需要SDS了。</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230717083050523.png" alt="image-20230717083050523"></p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul><li>LinkedList :普通链表，可以从双端访问，内存占用较高，内存碎片较多   3.2之前</li><li>ZipList :压缩列表，可以从双端访问，内存占用低，存储上限低  3.2之前</li><li>QuickList  3.2之后</li></ul><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul><li>唯一 但 不有序</li><li>需要求交集、并集、差集</li></ul><p>需要高效判断元素是否存在：<code>Hash</code>， key来存储元素，value&#x3D;null。如果都是int，会使用<code>intset</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">robj *<span class="hljs-title function_">setTypeCreate</span><span class="hljs-params">(sds value)</span> &#123;<br>    <span class="hljs-comment">//判断value是否是数值类型long long</span><br>    <span class="hljs-keyword">if</span> (i sSdsRepresentableAsLongLong(value,<span class="hljs-literal">NULL</span>) == C. _0K)<br>        <span class="hljs-comment">//如果是数值类型，则采用IntSet编码</span><br>        <span class="hljs-keyword">return</span> createIntsetobject() ;<br>    <span class="hljs-comment">//否则采用默认编码，也就是HT</span><br>    <span class="hljs-keyword">return</span> createSetObject();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230717091331161.png" alt="image-20230717091331161"></p><p>元素少直接用zipList，两个entry 分别保存element和score；score小的在前面</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240312155344282.png" alt="image-20240312155344282"></p><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><ul><li>Hash结构默认采用ZipList编码，用以节省内存。ZipList中相邻的两个entry 分别保存field和value</li><li>当数据量较大时，Hash结构会转为HT编码，也就是Dict, 触发条件有两个:<ul><li>ZipList中的元素 数量超过了hash-max-ziplist-entries (默认512)</li><li>ZipList中的任意entry大小超 过了hash-max-ziplist-value ( 默认64字节)</li></ul></li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230717090812839.png" alt="image-20230717090812839"></p><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><h5 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h5><p>一直等</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230720160353433.png" alt="image-20230720160353433"></p><h5 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h5><p>请求时，如果数据不存在，不阻塞<br>还是不断询问，存在大量无效的询问</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230720160417403.png" alt="image-20230720160417403"></p><p>优化：一个线程监听多个FD，并且在就绪时得到通知</p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>linux中最早的多路复用策略</p><p>只返回数量。知道有FD就绪了，但不知道是谁，需要遍历全部FD数组，查看谁变成了1</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230724220743572.png" alt="image-20230724220743572"></p><ul><li>fd_set需要拷贝两次，用户-&gt;内核-&gt;用户</li><li>每次需要遍历全部获取到底哪些就绪了</li><li>最多1024个</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240312161810513.png" alt="image-20240312161810513"></p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>使用一个数组保存（实现数量不被限制了，fds在内核中会转为链表；但太长会影响性能），同样返回就绪的数量</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230724221019443.png" alt="image-20230724221019443"></p><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ol><li>使用<code>epoll_create</code>创建一个<code>epoll</code>实例(<strong>内核中</strong>)，返回一个文件描述符。</li><li>使用<code>epoll_ctl</code>将需要监听的文件描述符注册到<code>epoll</code>实例中，设置关注的事件类型（比如可读、可写等）。</li><li>使用<code>epoll_wait</code>等待事件的发生，当文件描述符上的事件状态发生变化时，<code>epoll_wait</code>会返回就绪的文件描述符到用户空间的events中。</li></ol><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230724221457501.png" alt="image-20230724221457501"></p><ul><li><code>CTL</code>添加时，只添加到红黑树一次；<code>wait</code>只拷贝就绪的event，减少拷贝</li><li>只返回就绪的，不用遍历</li><li>使用红黑树提高CRUD性能</li><li>LevelTriggered: 简称LT。当FD有数据可读时，会重复通知多次,直至数据处理完成。是Epoll的默认模式</li><li>EdgeTriggered:简称ET。当FD有数据可读时，只会被通知一-次, 不管数据是否处理完成</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240312163852835.png" alt="image-20240312163852835" style="zoom:50%;" /><h5 id="epoll服务端"><a href="#epoll服务端" class="headerlink" title="epoll服务端"></a>epoll服务端</h5><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230725090111123.png" alt="image-20230725090111123"></p><h5 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h5><p>在数据好了的时候通过信号通知</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314153110963.png" alt="image-20240314153110963"></p><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>交给内核去拷贝数据</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314153206242.png" alt="image-20240314153206242"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>都包含两个部分：等待数据就绪、拷贝数据</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314153236150.png" alt="image-20240314153236150"></p><h4 id="redis网络模型"><a href="#redis网络模型" class="headerlink" title="redis网络模型"></a>redis网络模型</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230725090632140.png" alt="image-20230725090632140"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314155003680.png" alt="image-20240314155003680"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314155134295.png" alt="image-20240314155134295" style="zoom:50%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314160627286.png" alt="image-20240314160627286"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314161213466.png" alt="image-20240314161213466"></p><ul><li>epoll中监听包含SSFD读（接受新连接;<code>tcpAccepthandler</code>）、FD读（每一个客户端来了请求;<code>readQueryFromClient</code>）、FD写（写返回值给客户端；<code>sendReplyToClient</code>）  都包含了一个回调处理器</li><li>瓶颈在于io，包含接受命令以及返回结果</li></ul><p><strong>多线程：</strong></p><ul><li>多线程读取客户端中socket数据并且解析成命令</li><li>多线程去clients_pending_write中取结果</li></ul><h4 id="通信协议RESP"><a href="#通信协议RESP" class="headerlink" title="通信协议RESP"></a>通信协议RESP</h4><ul><li>客户端发送请求</li><li>服务端接受执行命令并返回</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314163514595.png" alt="image-20240314163514595"></p><p>使用socket实现发送和接收</p><h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><p>一个dict存key-value，另一个key-ttl</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314203756099.png" alt="image-20240314203756099"></p><ul><li>惰性删除：操作时才判断是否删除</li><li>周期删除：定时任务serverCron删除（低频大量）、fast beforeSleep在每个事件循环都会执行 (高频少量)</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314204822767.png" alt="image-20240314204822767"></p><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><p>在内存不够时，主动删除部分key, <code>processCommand</code>前会执行</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314205242909.png" alt="image-20240314205242909"></p><p>LRU和LFU在redisObject里记录了，因此后面删除的时候其实时拉取了一些随机样本（eviction_pool）来比较，而不是所有样本的LRU</p><p>LFU记录的是一个概率统计值，并且有使用定时衰减</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314221335497.png" alt="image-20240314221335497"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240314221659158.png" alt="image-20240314221659158"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reids</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B站秒杀项目</title>
    <link href="/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/03/20/B%E7%AB%99%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这是一个秒杀系统的学习项目，核心目标是实现高性能、高并发的秒杀功能，同时解决超卖和重复抢购问题。项目基于Spring Boot框架，整合了MyBatis、Redis、RabbitMQ等技术，并逐步优化性能。    主要内容包括：    1. <strong>秒杀功能实现</strong>      - <strong>防止超卖</strong>：通过数据库乐观锁（update原子操作）和Redis预减库存（利用Redis原子性）实现。      - <strong>防止重复抢购</strong>：通过唯一索引（用户+商品ID）或Redis缓存验证。    2. <strong>优化策略</strong>      - <strong>减少数据库访问</strong>：使用Redis缓存库存、订单信息等。      - <strong>优化并发瓶颈</strong>：引入内存标记减少Redis访问，利用MQ异步处理请求，降低数据库压力。      - <strong>静态页面优化</strong>：采用前后端分离（页面静态化），通过Ajax加载动态数据，减少服务端渲染压力。    3. <strong>技术实现</strong>      - <strong>分布式会话管理</strong>：使用Redis存储用户Session或Token，支持多服务共享登录状态。      - <strong>压测与调优</strong>：JMeter模拟高并发请求，分析并优化QPS（从637提升至3209）。      - <strong>安全措施</strong>：验证码、接口限流（令牌桶算法）、隐藏秒杀地址等，防止恶意请求。    4. <strong>关键问题与解决方案</strong>      - <strong>超卖问题</strong>：Redis预减库存+数据库乐观锁双重保障，确保库存不超扣。      - <strong>性能瓶颈</strong>：本地化Redis（避免网络延迟）、MQ削峰填谷、内存标记优化。      - <strong>分布式锁</strong>：通过Redis+Lua脚本实现原子操作，避免并发问题。    5. <strong>系统扩展</strong>      - 支持动态调整商品库存（如Nacos配置下发）。      - 网关层限流（如Sentinel）保护后端服务。    该项目从基础实现逐步优化至高并发方案，涵盖数据库设计、缓存策略、异步处理、安全防护等核心要点，适用于学习分布式系统与高并发场景的解决方案。</p></blockquote><h1 id="B站秒杀项目"><a href="#B站秒杀项目" class="headerlink" title="B站秒杀项目"></a>B站秒杀项目</h1><ul><li><a href="https://www.bilibili.com/video/BV1sf4y1L7KE">视频地址</a></li><li>代码：<a href="https://github.com/Goinggoinggoing/seckill-study">https://github.com/Goinggoinggoing/seckill-study</a></li><li>项目来源：程序员来了666 <a href="https://gitee.com/guizhizhe/seckill_demo">https://gitee.com/guizhizhe/seckill_demo</a> ， 添加了一些中间过程接口以及注释</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个简单的秒杀项目，并不断的优化</p><ol><li><p>在该项目中核心就是秒杀的实现：不能超卖、不能重复抢</p><ul><li>不能超卖在doSeckill1中通过update的排他性实现(乐观锁)。而在doSeckill2中通过redis预减库存(redis的原子性实现)</li><li>不能重复抢通过唯一索引实现，默认建表时没有添加，压测可以把用户加少点商品多一点就可以复现重复购买</li></ul></li><li><p>优化不过就是把数据库的重复访问，能放到redis就放到redis；而如果访问redis太多了就再加一层内存标记</p></li><li><p>redis和mysql要么都在远程，要么都在本地，否则可能会出现redis缓存优化了但QPS没提升</p></li></ol><p>秒杀的接口有三个，先在goodsdetail中启用doSeckill1</p><ol><li><p>doSeckill1:  对应到 <strong>P43</strong>，update排他+唯一索引实现秒杀(没有做order页面静态化)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 到这里为了实现不超卖（减少库存的同时判断库存数量）且单一下单（唯一索引）</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">seckillGoodsResult</span> <span class="hljs-operator">=</span> itSeckillGoodsService.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;TSeckillGoods&gt;()<br>        .setSql(<span class="hljs-string">&quot;stock_count = &quot;</span> + <span class="hljs-string">&quot;stock_count-1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;goods_id&quot;</span>, goodsVo.getId())<br>        .gt(<span class="hljs-string">&quot;stock_count&quot;</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">//大于零才下单</span><br>);<br><span class="hljs-comment">// 防超卖，直接结束，很关键</span><br><span class="hljs-keyword">if</span> (!seckillGoodsResult) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 否则下单事务直接结束。update是排他锁，一定不会超卖</span><br>&#125;<br><br><span class="hljs-comment">// 同时做了一些优化： 下单后存入redis，加快是否重复下单判断。</span><br></code></pre></td></tr></table></figure></li><li><p>doSeckill2：对应到 <strong>P53</strong>，         order界面静态化 +  redis预减库存 + 内存标记 + MQ</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">0.页面静态化（在前后端分离项目里默认就做了）<br>1.用redis预减库存（减少数据库访问），redis是原子操作，可以防止超卖；<br>2.满足还有库存后进入MQ队列；  <br>3.我还想减少redis访问次数：引入内存标记。<br></code></pre></td></tr></table></figure></li><li><p>doSeckill ：最终秒杀方案          一些安全上的优化</p></li></ol><p>对应到发起请求界面static\goodsDetail.html 52~67行</p><p>前后端结合项目，两种处理页面方式，二者对比可以看orderDetail页面</p><ol><li>前端页面在template下，通过controller返回访问，并<code>model.add添加数据</code>。<code>h:text=&quot;$&#123;goods.goodsName&#125;&quot;</code>页面取出数据， 不可直接访问页面</li><li>在static下的页面可直接访问，并在页面加载时ajax请求返回json数据，<code>$(&quot;#goodsName&quot;).text(goods.goodsName);</code>根据id注入数据。（代码中的方式，相当于静态化了，视频中一开始是上面的方式，后面才做的静态化）</li></ol><h2 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h2><ol><li>项目框架搭建<ol><li>SpringBoot环境搭建</li><li>集成Thymeleaf,RespBean</li><li>MyBatis</li></ol></li><li>分布式会话<ol><li>用户登录<ol><li>设计数据库</li><li>明文密码二次MD5加密</li><li>参数校验+全局异常处理</li></ol></li><li>共享Session<ol><li>SpringSession</li><li>Redis</li></ol></li></ol></li><li>功能开发<ol><li>商品列表</li><li>商品详情</li><li>秒杀</li><li>订单详情</li></ol></li><li>系统压测<ol><li>JMeter</li><li>自定义变量模拟多用户</li><li>JMeter命令行的使用</li><li>正式压测<ol><li>商品列表</li><li>秒杀</li></ol></li></ol></li><li>页面优化<ol><li>页面缓存+URL缓存+对象缓存</li><li>页面静态化，前后端分离</li><li>静态资源优化</li><li>CDN优化</li></ol></li><li>接口优化<ol><li>Redis预减库存减少数据库的访问</li><li>内存标记减少Redis的访问</li><li>RabbitMQ异步下单<ol><li>SpringBoot整合RabbitMQ</li><li>交换机</li></ol></li></ol></li><li>安全优化<ol><li>秒杀接口地址隐藏</li><li>算术验证码</li><li>接口防刷</li></ol></li><li>主流的秒杀方案</li></ol><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><table><thead><tr><th>技术</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>Spring Boot</td><td>2.6.4</td><td></td></tr><tr><td>MySQL</td><td>8</td><td></td></tr><tr><td><a href="https://github.com/baomidou/generator">MyBatis Plus</a></td><td>3.5.1</td><td></td></tr><tr><td>Swagger2</td><td>2.9.2</td><td>Swagger-models2.9.2版本报错，使用的是1.5.22</td></tr><tr><td><a href="https://doc.xiaominfo.com/">Kinfe4j</a></td><td>2.0.9</td><td>感觉比Swagger UI漂亮的一个工具，访问地址是ip:端口&#x2F;doc.html</td></tr><tr><td>Spring Boot Redis</td><td></td><td></td></tr></tbody></table><p>快（高性能） 准（一致性） 稳（高可用）</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>spring 模板，并添加相应依赖，再添加mybatisplus</p><p>配置mybatis-plus  datasource  log</p><p>创建controller service mapper 和mapper.xml， @MapperScan Dao层</p><p>新建测试接口测试</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建数据库表以及mapper service controller层</p><p>​pass  &#x3D;  MD5(MD5(pass名为+salt) + salt2)，前端传过来的时候也加密一次。这里salt2是存在数据库里的</p><p>创建一个项目作为逆向生成工具项目，勾选spring web，添加mybatis plus，官网代码生成器</p><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>&#x2F;doLogin</p><p>导入登录界面，前端传密码前用md5加密一下</p><p>添加通用返回类以及枚举对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RespBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RespBeanEnum</span> &#123;<br>    <span class="hljs-comment">//通用</span><br>    SUCCESS(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>),<br>    ERROR(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;服务端异常&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>校验在service中，还可以导入<code>spring-boot-starter-validation</code>包然后通过注解<code>@NotNull</code>实现校验。</p><ul><li><p>service如果出现异常，抛出并且<code>全局异常处理</code></p></li><li><p>登录成功后存一个uuid到session，并用cookie(直接返回也可以)返回给前端，前端每次都带上这个；或者返回一个token，前端每次携带</p></li><li><p>添加<code>spring-session-data-redis</code>依赖后可以将session自动存入redis中实现分布式session，</p></li><li><p>或者直接存数据到redis, key为uuid，通过cookie传来。之后相当于每次<strong>通过uuid拿到用户信息</strong>。导入<code>redis</code>包，配置 ip port等，配置类实现redis序列化，object序列化为json</p></li><li><p>使用配置MVC，继承 <code>WebMvcConfigurer</code>实现mvc的配置</p><p>​配置自定义参数配置， 每次取出user传入参数（这里只做了取出参数User，没有拦截请求）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903365.png" alt="image-20230315100229300"></p><p>​    还可以配置拦截器，添加拦截器，拦截哪些请求。（也可以拦截器直接实现参数，自己代码）</p></li></ul><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p><strong>界面</strong>：商品列表 商品详情 订单 </p><p><strong>表</strong>：商品表 订单表 秒杀商品表（秒杀活动很多，添加一个标识字段不合适）  秒杀订单表</p><p><code>秒杀表</code>：商品ID、秒杀库存、开始结束时间</p><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><p>名称 图片 价格 秒杀价 秒杀库存</p><p>由于需要显示的数据包含<code>商品表</code>和<code>秒杀商品表</code>，添加vo继承商品表添加额外信息</p><p><code>toList</code>接口返回商品列表，还需要添加<strong>mvc静态资源映射</strong> ：<code>addResourceHandlers</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903366.png" alt="image-20230307190839362"></p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p>需要知道秒杀是否开始结束，后端通过时间判断返回给前端一个状态（未开始、进行中、已结束）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903367.png" alt="image-20230307193103679"></p><h3 id="秒杀功能"><a href="#秒杀功能" class="headerlink" title="秒杀功能"></a>秒杀功能</h3><p>&#x2F;doSeckill1  传统秒杀</p><p>传入user，goodsId</p><ul><li>判断该goodsId是否还有库存，库存是看秒杀商品表， <code>进一步：redis预减</code></li><li>判断该userId是否购买过goodId（查看秒杀订单表）：&#x3D;&#x3D;优化：查询redis&#x3D;&#x3D;</li><li>都没问题时，减库存，生成订单，生成秒杀订单          <code>进一步：加入队列</code></li></ul><p>代码中，前端页面需要将接口改为doSeckill1</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>建表，需要额外秒杀商品表（价格、库存、开始结束时间）、秒杀订单（商品id、订单id）</li><li>登录，存入信息到redis，key为时间戳，访问通过cookie携带</li><li>全局异常处理处理业务异常，拦截器拦截未登录用户（cookie时间戳不合理），静态资源配置</li><li>商品列表、商品详情页，秒杀功能</li></ul><h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>jmeter</p><ul><li>QPS：每秒请求次数</li><li>TPS：每秒事务（吞吐量）次数</li><li>一个页面一个TPS可能多次QPS</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202303221903368.png" alt="image-20230314094536441"></p><p>但windos和linux相差可能很多</p><p><strong>配置mysql：</strong>为了安全性创建新用户xx，打开阿里云安全组，关闭防火墙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">CREATE USER &#x27;xx&#x27;@&#x27;%&#x27; IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br>grant <span class="hljs-attribute">all</span> on *.* <span class="hljs-selector-tag">to</span> &#x27;xx&#x27;@&#x27;%&#x27;;<br><br>sudo firewall-cmd <span class="hljs-attr">--list-ports</span><br>sudo firewall-cmd <span class="hljs-attr">--add-port</span>=<span class="hljs-number">3306</span>/tcp <span class="hljs-attr">--permanent</span><br>sudo firewall-cmd <span class="hljs-attr">--reload</span><br></code></pre></td></tr></table></figure><p><strong>配置redis</strong>  (使用docker)，并配置远程访问以及持久化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"># 持久化<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/data<br>mkdir -<span class="hljs-selector-tag">p</span> /root/docker/redis/conf<br>vi /root/docker/redis/conf/redis<span class="hljs-selector-class">.conf</span><br>    # bind <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>    protected-mode no<br>    appendonly yes<br>requirepass <span class="hljs-number">123123</span><br><br>docker run <span class="hljs-attr">--name</span> my_redis -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v /root/docker/redis/data:/data -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf <br><br>redis-server /etc/redis/redis.conf：在容器内执行的命令，启动 Redis 服务，并使用 /etc/redis/redis.conf 作为配置文件。<br><br></code></pre></td></tr></table></figure><p>安装jmeter，配置encodin，导入配置，放到bin目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./jmeter.sh -n -t first.jmx -l result.jtl<br>result.jtl 拿到win 聚合报告下查看<br></code></pre></td></tr></table></figure><p>部署java 到docker容器中,但我mysql redis都装在宿主机，需要合并网络不好访问，所以还是部署出来（或者用dockercompose部署）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"># 使用 openjdk 作为基础镜像<br><span class="hljs-selector-tag">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><br># 设置工作目录<br>WORKDIR /app<br><br># 将打包好的jar复制到容器中<br>COPY target/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar /app/seckill-demo-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar<br><br># 暴露应用程序端口，起提示作用<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动应用程序<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app/seckill-demo-0.0.1-SNAPSHOT.jar&quot;</span>]<br><br>docker build -t myapp:v1 .<br>docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> myapp:v1<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：postman可以携带cookie请求成功，但浏览器不可以（跨域）</p><p>​现在没有拦截未登录用户，如果未携带cookie会导致User空指针异常</p><p><strong>小结</strong></p><ul><li>本地项目数据库、redis都用云的，并打包一份项目放到云上</li><li>云上部署，本地运行压测程序进行压测（标准应该云上压测，但比较麻烦）</li></ul><h3 id="配置文件导入多用户"><a href="#配置文件导入多用户" class="headerlink" title="配置文件导入多用户"></a>配置文件导入多用户</h3><ul><li><p>再创建一个用户，登录后把uuid保存下来，放到文件里逗号分隔</p></li><li><p>csv数据文件设置 <strong>定义</strong>变量名称<code>userTicket</code>, <code>$&#123;userTicket&#125;</code> 取出</p></li><li><p>测试&#x2F;user&#x2F;info接口，看下是不是 <strong>返回不同用户</strong></p></li><li><p>商品列表：5000 10 ：460</p></li></ul><p>生成100个用户，并且登录返回ticket,这里也可以生成用户用java，请求用python</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/createuser&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;压测创建配置文件&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;TUser&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//生成用户</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="hljs-comment">//            TUser tUser = new TUser();</span><br><span class="hljs-comment">//            tUser.setId(1233L + i);</span><br><span class="hljs-comment">//            tUser.setNickname(&quot;user&quot; + i);</span><br><span class="hljs-comment">//            tUser.setSalt(&quot;1a2b3c&quot;);</span><br><span class="hljs-comment">//            tUser.setPassword(&quot;05314c6fbe1d0cdb5eab4e80f1bda30a&quot;);</span><br><span class="hljs-comment">//            list.add(tUser);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        tUserService.saveBatch(list);</span><br><span class="hljs-comment">//        System.out.println(&quot;create user&quot;);</span><br><br>        <span class="hljs-comment">//读取用户</span><br>        list = tUserService.list();<br><br>        <span class="hljs-comment">//登录，生成UserTicket</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">urlString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8080/login/doLogin&quot;</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\13000\\Desktop\\config.txt&quot;</span>);<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            file.delete();<br>        &#125;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rw&quot;</span>);<br>        randomAccessFile.seek(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(urlString);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">httpURLConnection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>            httpURLConnection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            httpURLConnection.setDoOutput(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getOutputStream();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mobile=&quot;</span> + tUser.getId() + <span class="hljs-string">&quot;&amp;password=c38dc3dcb8f0b43ac8ea6a70b5ec7648&quot;</span>;<br>            outputStream.write(params.getBytes());<br>            outputStream.flush();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> httpURLConnection.getInputStream();<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buff)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                byteArrayOutputStream.write(buff, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            inputStream.close();<br>            byteArrayOutputStream.close();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">respone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteArrayOutputStream.toByteArray());<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-type">RespBean</span> <span class="hljs-variable">respBean</span> <span class="hljs-operator">=</span> mapper.readValue(respone, RespBean.class);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">userTicket</span> <span class="hljs-operator">=</span> (String) respBean.getObject();<br>            System.out.println(<span class="hljs-string">&quot;create userTicket:&quot;</span> + tUser.getId());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> tUser.getId() + <span class="hljs-string">&quot;,&quot;</span> + userTicket;<br>            randomAccessFile.seek(randomAccessFile.length());<br>            randomAccessFile.write(row.getBytes());<br>            randomAccessFile.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;write to file :&quot;</span> + tUser.getId());<br>        &#125;<br>        randomAccessFile.close();<br>        System.out.println();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="测试秒杀接口"><a href="#测试秒杀接口" class="headerlink" title="测试秒杀接口"></a>测试秒杀接口</h3><p>&#x2F;doSeckill2</p><p>存在超卖问题！！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-对象缓存redis"><a href="#1-对象缓存redis" class="headerlink" title="1.对象缓存redis"></a>1.对象缓存redis</h3><p>通过uuid缓存User对象，数据跟新后要删除redis</p><h3 id="2-页面缓存redis"><a href="#2-页面缓存redis" class="headerlink" title="2.页面缓存redis"></a>2.页面缓存redis</h3><p>把整个页面缓存到redis </p><p>​本来是<code>return ”goodsList“</code> 返回页面   - - 》》优化成 <code>渲染出整个页面</code>再返回，并缓存整个页面。<code>toList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/toList&quot;, produces = &quot;text/html;charset=utf-8&quot;, method = RequestMethod.GET)</span><br><span class="hljs-meta">@ResponseBody</span> <span class="hljs-comment">// 之前是返回字符串走mvc，现在是直接返回html文本</span><br><br>    <span class="hljs-comment">// 先看redis有没有</span><br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;goodsList&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br>    <span class="hljs-comment">// 数据还是先放到model</span><br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    model.addAttribute(<span class="hljs-string">&quot;goodsList&quot;</span>, itGoodsService.findGoodsVo());<br>    <span class="hljs-comment">// 手动渲染goodsList这个界面</span><br>    <span class="hljs-type">WebContext</span> <span class="hljs-variable">webContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());<br>    html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">&quot;goodsList&quot;</span>, webContext);<br><br>    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html)) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;goodsList&quot;</span>, html, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">return</span> html;<br></code></pre></td></tr></table></figure><h3 id="3-页面静态化"><a href="#3-页面静态化" class="headerlink" title="3.页面静态化"></a>3.页面静态化</h3><p>前后端分离</p><ul><li>静态页面放到static下，可以直接&#x2F;path.html访问，加载页面时请求返回json数据 <code>goodsDetail2</code> -&gt; <code>detail</code></li><li>之前跳转是<code>/goods/toDetail?goodsId=1</code>访问接口，现在是<code>/Detail.html?goodsId=1</code>直接访问页面，但加载页面时多一步ajax请求数据</li><li>前端加载数据 根据id注入: <code>$(&quot;#goodsName&quot;).text(goodsVo.goodsName); </code>  本来是Thymeleaf <code>th:text= &quot;$&#123;goodsVo.goodname&#125;&quot;</code></li></ul><p>orderDetial页面同理：</p><ul><li>原来发起doseckill1请求，成功加载数据return detaii跳转页面，失败返回到错误页面（代码就是这样）</li><li>现在发起doseckill2请求，成功后弹框问是否跳转到static下的detaii.html，然后再发起ajax请求加载detail</li></ul><h3 id="4-静态资源缓存"><a href="#4-静态资源缓存" class="headerlink" title="4.静态资源缓存"></a>4.静态资源缓存</h3><p>配置后static下的<code>goodsDetail.html</code>将被缓存，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment">#静态资源处理</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-comment">#启动默认静态资源处理，默认启动</span><br>    <span class="hljs-attr">add-mappings:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">cache:</span><br>      <span class="hljs-attr">cachecontrol:</span><br>        <span class="hljs-comment">#缓存响应时间，单位秒</span><br>        <span class="hljs-attr">max-age:</span> <span class="hljs-number">3600</span><br>    <span class="hljs-attr">chain:</span><br>      <span class="hljs-comment">#资源配链启动缓存，默认启动</span><br>      <span class="hljs-attr">cache:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启动资源链，默认禁用</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用压缩资源（gzip，brotil）解析，默认禁用</span><br>      <span class="hljs-attr">compressed:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment">#启用h5应用缓存，默认禁用</span><br>      <span class="hljs-attr">html-application-cache:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/static/</span><br></code></pre></td></tr></table></figure><h3 id="5-问题解决"><a href="#5-问题解决" class="headerlink" title="5.问题解决"></a>5.问题解决</h3><p>判断是否重复抢购，存入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TSeckillOrder tSeckillOrder = (TSeckillOrder) redisTemplate.opsForValue().get(&quot;order:&quot; + user.getId() + &quot;:&quot; + goodsId);<br></code></pre></td></tr></table></figure><p>单纯在减库存时判断商品库存是否为负，为负不再继续，解决超卖。<code>update会加行级别排他锁</code> &#x3D;&#x3D;影响并发量&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">seckillGoodsResult</span> <span class="hljs-operator">=</span> itSeckillGoodsService.update(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;TSeckillGoods&gt;()<br>                                                          .setSql(<span class="hljs-string">&quot;stock_count = &quot;</span> + <span class="hljs-string">&quot;stock_count-1&quot;</span>)<br>                                                          .eq(<span class="hljs-string">&quot;goods_id&quot;</span>, goodsVo.getId())<br>                                                          .gt(<span class="hljs-string">&quot;stock_count&quot;</span>, <span class="hljs-number">0</span>)<br>                                                         );<br><span class="hljs-keyword">if</span> (!seckillGoodsResult) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订单表加唯一索引(user, goodid)防止单一用户多抢，<code>@Transactional</code>。</p><p>至此：单一购买以及超卖问题都解决了</p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>doseckill2</p><ul><li><p>redis预减库存（原子）</p></li><li><p>内存标记减少redis访问</p></li><li><p>用队列进行缓冲</p></li><li><p>静态化 + MQ + redis: QPS：<code>637-&gt;571</code>   反而下降了 </p></li><li><p><strong>分析原因</strong>：数据库在本地但redis在云上，导致redis读取过慢，<strong>redis本地</strong>后**<code>1933 -&gt; 3209</code>**，p55</p></li></ul><h3 id="1-预减库存"><a href="#1-预减库存" class="headerlink" title="1.预减库存"></a>1.<strong>预减库存</strong></h3><ul><li>加载时加入库存量 ;redis是&#x3D;&#x3D;原子操作&#x3D;&#x3D;，减库存时不会有并发问题，保证进入MQ的都是有库存的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().decrement(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br><span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>)&#123;<br>    EmptyStockMap.put(goodsId, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 内存标记</span><br>    redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;seckillGoods:&quot;</span> + goodsId);<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-内存标记："><a href="#2-内存标记：" class="headerlink" title="2.内存标记："></a>2.<strong>内存标记：</strong></h3><p>在访问redis前，使用一个map标记商品是否还有库存，减少redis访问（分布式会不会有问题？？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存标记，减少Redis的访问</span><br><span class="hljs-keyword">if</span> (EmptyStockMap.get(goodsId)) &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.EMPTY_STOCK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-消息队列："><a href="#3-消息队列：" class="headerlink" title="3.消息队列："></a>3.<strong>消息队列：</strong></h3><p>有库存要加入mq，传入参数中</p><ul><li>配置文件定义队列和交换机</li><li>MQSender文件封装发送方法</li><li>返回给前端排队中状态码</li><li>MQReceiver完成下单，再判断下库存、重复抢购</li></ul><h3 id="4-前端轮询："><a href="#4-前端轮询：" class="headerlink" title="4.前端轮询："></a><strong>4.前端轮询：</strong></h3><p> 下单后等待，添加一个接口查询是否下单成功</p><h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a><strong>lua脚本：</strong></h3><p>&#x2F;&#x2F; 减少和增加不是原子的，但会有问题吗？？：redis库存可能负数，但不会超卖</p><p><code>setIfAbsent</code> ：setnx实现加锁，存在以下问题：</p><ul><li>异常了<strong>锁不会销毁</strong>：增加一个5s超时时间</li><li>如果处理时间超过了5s，会导致<strong>删别人的锁</strong>：value是版本号，保证删的是自己加的版本</li><li>（获取版本号 比较 删除）<strong>不是原子操作</strong>：lua脚本实现redis原子化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> valueOperations.setIfAbsent(<span class="hljs-string">&quot;k1&quot;</span>, value, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">if</span> (isLock) &#123;<br>        valueOperations.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) valueOperations.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + name);<br>        <span class="hljs-comment">//操作结束，删除锁</span><br>        System.out.println(valueOperations.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Boolean) redisTemplate.execute(redisScript, Collections.singletonList(<span class="hljs-string">&quot;k1&quot;</span>), value);<br>        System.out.println(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;有线程在使用，请稍后再试&quot;</span>);<br>    &#125;<br>&#125;<br><br>lua：<br> <span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])==ARGV[<span class="hljs-number">1</span>] then<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>验证码，存入redis <code>.set(&quot;captcha:&quot; + tUser.getId() + &quot;:&quot; + goodsId, captcha.text() )</code></li><li>对同一用户和商品生成一个唯一地址，拿地址再下单。获取地址需要验证码，地址同样redis</li><li>限流 （网关）</li></ul><p><strong>单接口简单限流</strong>：直接redis，存在5s最后临界问题  ； 漏桶算法；令牌桶算法（令牌不断生成到桶里）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">制访问次数，<span class="hljs-number">5</span>秒内访问<span class="hljs-number">5</span>次<br><span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>captcha = <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br><span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>    valueOperations.set(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId(), <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>    valueOperations.increment(uri + <span class="hljs-string">&quot;:&quot;</span> + tuser.getId());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通用：</strong>拦截器+注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">需要限制的接口 <br><span class="hljs-meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器：去出注解中的参数进行判断。同时把user参数的写入也加进来，存入ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>        <span class="hljs-comment">// 参数User</span><br>        <span class="hljs-type">TUser</span> <span class="hljs-variable">tUser</span> <span class="hljs-operator">=</span> getUser(request, response);<br>        UserContext.setUser(tUser);<br>        <br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">AccessLimit</span> <span class="hljs-variable">accessLimit</span> <span class="hljs-operator">=</span> hm.getMethodAnnotation(AccessLimit.class);<br>        <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> accessLimit.second();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> accessLimit.maxCount();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needLogin</span> <span class="hljs-operator">=</span> accessLimit.needLogin();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span> (needLogin) &#123;<br>            <span class="hljs-keyword">if</span> (tUser == <span class="hljs-literal">null</span>) &#123;<br>                render(response, RespBeanEnum.SESSION_ERROR);<br>            &#125;<br>            key += <span class="hljs-string">&quot;:&quot;</span> + tUser.getId();<br>        &#125;<br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(key);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>            valueOperations.set(key, <span class="hljs-number">1</span>, second, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; maxCount) &#123;<br>            valueOperations.increment(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            render(response, RespBeanEnum.ACCESS_LIMIT_REACHED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>网关过滤</p><p>2s 100w请求，20w商品。令牌桶。没获得令牌的直接失败</p><p>快速生成订单：redis （分片） ，再mq</p><p>超卖：分布式锁redisson。加锁解锁消耗：集群</p><p>nacos动态下发商品数量</p><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>框架搭建<ul><li>Thymeleaf, RespBean</li><li>设计数据库 </li><li>全局异常 、通用返回、通用参数</li></ul></li><li>开发<ul><li>商品列表</li><li>商品详情</li><li>订秒杀</li><li>订单详情</li></ul></li><li>压测<ul><li>配置环境</li><li>多用户</li></ul></li><li>优化 页面、对象</li><li>进一步优化Redis预减、内存标记、MQ</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立博客</title>
    <link href="/2023/03/20/%E5%BB%BA%E7%AB%99/"/>
    <url>/2023/03/20/%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>摘要：    本文介绍了基于Hexo框架和Fluid主题搭建个人博客的步骤及配置方法。选择Hexo的原因是已安装Node.js环境，操作便捷；Fluid主题因其简洁性和美观性（优于Next主题）符合博客的笔记整理定位，支持首页、归档、多级分类和搜索功能。    主要步骤包括：   1. <strong>环境准备</strong>：安装Node.js和Hexo脚手架（<code>npm install -g hexo-cli</code>），初始化博客（<code>hexo init</code>）。   2. <strong>本地调试</strong>：通过<code>hexo g</code>生成文件，<code>hexo s</code>本地预览（默认端口4000）。   3. <strong>部署到GitHub Pages</strong>：      - 创建<code>用户名.github.io</code>仓库，配置<code>_config.yml</code>中的Git部署信息（类型、仓库地址、分支）。      - 安装Git插件（<code>hexo-deployer-git</code>），运行<code>hexo d</code>推送代码。   4. <strong>主题配置</strong>：      - 安装Fluid主题（<code>npm install hexo-theme-fluid</code>），修改<code>_config.yml</code>指定主题和语言（<code>zh-CN</code>）。      - 重新生成并启动以应用更改。   5. <strong>文章管理</strong>：      - 通过Front Matter设置标题、标签、分类、置顶（<code>sticky</code>）、封面图（<code>index_img</code>）等属性。      - 启用<code>post_asset_folder</code>自动生成资源文件夹存放图片，支持<code>&#123;% asset_img %&#125;</code>语法或图床（如GitHub+PicGo）解决本地与博客图片路径不一致问题。额外提到的服务包括评论系统（如Valine）和数据库支持，但未展开细节。    （注：原文中的代码块和符号如<code>$1</code>因不完整或重复已略去，不影响核心流程。）</p></blockquote><h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>首先优先选择Hexo是因为Node.js已经安装好了，比较方便</p><p>主题选择：Fluid</p><ul><li><p>主题需要简洁，因为博客定位是笔记记录整理</p></li><li><p>需要有一定的美观（因为这个放弃了next主题）</p></li><li><p>基本的页面：首页 归档 分类(支持多级分类) 、标签、搜索功能</p></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><ol><li>安装Nodejs</li><li>安装脚手架<code>npm install -g hexo-cli</code></li></ol><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog   <span class="hljs-comment"># 初始化博客</span><br><span class="hljs-built_in">cd</span> blog<br>npm instal<br><br><br>hexo new fistt <span class="hljs-comment"># 创建第一个页面 填写内容</span><br><br>hexo g <span class="hljs-comment"># 生成文件</span><br>hexo s <span class="hljs-comment"># 启动  localhost:4000可以查看博客</span><br></code></pre></td></tr></table></figure><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><ol><li><p>新建 <code>用户名.github.io</code> 的仓库</p></li><li><p>配置博客推送到对应仓库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span>  <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Goinggoinggoing/Goinggoinggoing.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p><code>npm install hexo-deployer-git --save</code>  安装git部署插件</p></li><li><p><code>hexo d</code> 推送到仓库</p></li></ol><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><ol><li><p><code>npm install --save hexo-theme-fluid</code></p></li><li><p>修改_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <br>hexo s <br></code></pre></td></tr></table></figure></li></ol><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>​<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a></p><h4 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">开发</span>, <span class="hljs-string">项目</span>]<br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 但可以通过链接访问</span><br><span class="hljs-attr">sticky:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 文章排序顺序 越大越前</span><br><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span> <span class="hljs-comment"># 封面图</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post_banner.jpg</span>  <span class="hljs-comment">#顶部图</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br><br></code></pre></td></tr></table></figure><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><ul><li>修改博客配置文件，<code>post_asset_folder: true</code>，使得每次生成文章时默认携带一个同名文件夹，用来存放图片</li><li>引用图片： <code>![](test.png)</code>   或  <code>&#123;% asset_img test.png 图片引用方法一 %&#125;</code></li><li>存在的问题：本地typora记笔记是记录到  name.asset&#x2F;test.png，这样从本地到博客需要转换很麻烦</li></ul><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>​搭建github图床，每次本地完成后通过PicGo一键上传到图床，即可访问图片</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20230402195401606.png" alt="image-20230402195401606"></p><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a> </p><p><a href="https://waline.js.org/guide/get-started/">快速上手 | Waline</a></p><p>数据库：<a href="https://console.leancloud.app/apps/GEluhFhlvVVyi1wC9RzB0vSk-MdYXbMMI/">t1 · LeanCloud</a></p><p>服务器：<a href="https://vercel.com/goinggoinggoings-projects/waline/settings/domains">waline - Overview – Vercel</a></p><p>管理界面：<a href="https://comment.bytewaver.top/ui">https://comment.bytewaver.top/ui</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_淡淡的说非的博客-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2023/03/17/mysql/"/>
    <url>/2023/03/17/mysql/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>该文章详细介绍了MySQL数据库的基础与高级知识，分为上下两篇：</p></blockquote><p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL视频</a></p><p>下面是对章节与视频的对应关系和学习建议</p><p>【MySQL上篇：基础篇】<br>【第1子篇：数据库概述与MySQL安装篇】<br>p01-p11<br>学习建议：零基础同学必看，涉及理解和Windows系统下MySQL安装</p><p>【第2子篇：SQL之SELECT使用篇】<br>p12-p48<br>学习建议：学习SQL的重点，必须重点掌握，建议课后练习多写</p><p>【第3子篇：SQL之DDL、DML、DCL使用篇】<br>p49-p73<br>学习建议：学习SQL的重点，难度较SELECT低，练习写写就能掌握</p><p>【第4子篇：其它数据库对象篇】<br>p74-p93<br>学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。<br>在工作中，根据公司需要进行学习即可。</p><p>【第5子篇：MySQL8新特性篇】<br>p94-p95<br>学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。<br>在工作中，根据公司需要进行学习即可。</p><p>【MySQL下篇：高级篇】<br>【第1子篇：MySQL架构篇】<br>p96-p114<br>学习建议：涉及Linux平台安装及一些基本问题，基础不牢固同学需要学习</p><p>【第2子篇：索引及调优篇】<br>p115-p160<br>学习建议：面试和开发的重点，也是重灾区，需要全面细致的学习和掌握</p><p>【第3子篇：事务篇】<br>p161-p186<br>学习建议：面试和开发的重点，需要全面细致的学习和掌握</p><p>【第4子篇：日志与备份篇】<br>p187-p199<br>学习建议：根据实际开发需要，进行相应内容的学习</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：也是执行顺序<br>SELECT ...,....,...<br>FROM ...,...,....<br>WHERE 多表的连接条件<br>AND 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br>#方式2：<br>SELECT ...,....,...<br>FROM ... JOIN ...<br>ON 多表的连接条件<br>JOIN ...<br>ON ...<br>WHERE 不包含组函数的过滤条件<br>AND/OR 不包含组函数的过滤条件<br>GROUP BY ...,...<br>HAVING 包含组函数的过滤条件<br>ORDER BY ... ASC/DESC<br>LIMIT ...,...<br></code></pre></td></tr></table></figure><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><ul><li>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。</li><li>然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。</li><li>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。</li><li>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。</li><li>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。</li><li>最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。</li><li>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT<br><br>SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5<br>FROM player JOIN team ON player.team_id = team.team_id # 顺序 1<br>WHERE height &gt; 1.80 # 顺序 2<br>GROUP BY player.team_id # 顺序 3<br>HAVING num &gt; 2 # 顺序 4<br>ORDER BY num DESC # 顺序 6<br>LIMIT 2 # 顺序 7<br></code></pre></td></tr></table></figure><h3 id="基础select"><a href="#基础select" class="headerlink" title="基础select"></a>基础select</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql">别名：空行 或 as<br>DISTINCT 去重<br>空值：null <br>着重号：`order`<br>显示表结构：desc employees; <br><br>比较运算符：<br>= ：<br>1 = &#x27;1&#x27;  字符串会被转为整数<br>都是字符串会比较ANSI编码<br>!=<br>    ISNULL<br>    IS Not NULL<br>    BETWEEN x AND y<br>    IN<br>    NOT IN<br>    LIKE  % _<br>RLIKE 正则表达式<br>逻辑运算符<br>NOT 或 !<br>AND 或 &amp;&amp;<br>OR 或 ||<br>XOR<br><br>排序<br>ORDER BY x ASC(DESC), y ASC  多列排序在x相同才比y<br>分页<br>LIMIT [位置偏移量,] 行数     LIMIT 20,10; <br>UNION<br>连接两次查询<br><br>连接<br>SELECT emp.employee_id, dep.department_name<br>    FROM employee emp, department dep<br>    WHERE emp.`department_id` = dep.`department_id`;<br><br>JOIN / INNER JOIN   <br>    LEFT JOIN<br>    RIGHT JOIN<br>    FULL JOIN<br>    最后加上<br>    ON 条件<br>    USING 名称要对应并且值相等<br>    <br>    <br>    还有连接方式是直接选出来后where =条件连接，inner join（inner join即join）和=等号结果一样，但实现原理完全不同，join是基于hashtable连接比较，而=直接就是取笛卡尔集再过滤，所以后者效率低，是O(N^2)，前者是O(LogN)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">聚合函数<br>AVG()<br>SUM()<br>MAX()<br>MIN()<br>count(*) count(1) count(列名)<br>MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 <br>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。<br><br>GROUP BY 分组<br>SELECT的字段必须声明在GROUP BY或者聚合函数<br>HAVING 过滤分组<br>WITH ROLLUP 对统计出来的结果再求和，多一行<br><br><br></code></pre></td></tr></table></figure><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="~文件目录"></a>~文件目录</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055458.png" alt="image-20230224113320725"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055459.png" alt="image-20230225090438227"></p><ul><li>Mysql5.7：ibd默认96KB，6个页</li><li>Mysql8.0：ibd默认112KB，结合了frm</li></ul><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="~逻辑架构"></a>~逻辑架构</h2><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055460.png" alt="image-20230222201134751"></p><ol><li><strong>连接层</strong>TCP握手建立连接，确认账号密码。通过线程池分配线程</li><li><strong>服务层</strong>生成解析树，优化器生成执行计划完成优化 &#x3D;&#x3D;选取-投影-连接&#x3D;&#x3D;</li><li><strong>引擎层</strong>插件式存储引擎层，负责数据的提取和存储  show engines；</li></ol><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055461.png" alt="image-20230222202520557" style="zoom: 80%;" /><ol><li><p><strong>缓存</strong></p><p>缓存必须一模一样，命中率低；更新后还可能失效</p><p><code>show global variables like &quot;%query_cache_type%&quot;;  show status like &#39;%Qcache%&#39;;</code></p></li><li><p><strong>解析器</strong></p><p><strong>词法分析</strong>识别关键字</p><p><strong>语法分析</strong>查看是否满足mysql语法，然后生成语法树</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055462.png" alt="image-20230222203631132"></p></li><li><p><strong>优化器</strong></p><p>找到这其中最好的执行计划。</p><p>比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from test1 join test2 using(ID)<br>where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;<br><br>方案1：可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判<br>断 test2 里面 name的值是否等于 &#x27;mysql高级课程&#x27;。<br><br>方案2：可以先从表 test2 里面取出 name=&#x27;mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1，<br>再判断 test1 里面 name的值是否等于 zhangwei。<br><br>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化<br>器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。<br>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。<br></code></pre></td></tr></table></figure></li><li><p>执行器</p></li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="~存储引擎"></a>~存储引擎</h2><h3 id="①引擎"><a href="#①引擎" class="headerlink" title="①引擎"></a>①引擎</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines;<br>show variables like &#x27;%storage_engine%&#x27; 或 SELECT @@default_storage_engine;<br>SET DEFAULT_STORAGE_ENGINE=MyISAM;   修改 my.cnf 文件：default-storage-engine=MyISAM<br><br></code></pre></td></tr></table></figure><p>不同的表可以设置不同的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建<br>CREATE TABLE 表名(<br>建表语句;<br>) ENGINE = 存储引擎名称;<br>修改<br>ALTER TABLE 表名 ENGINE = 存储引擎名称;<br></code></pre></td></tr></table></figure><h3 id="②引擎介绍"><a href="#②引擎介绍" class="headerlink" title="②引擎介绍"></a>②引擎介绍</h3><p> 5.5之后，默认InnoDB </p><h4 id="1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>1 InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul><li>事务型引擎。确保事务的完整提交(Commit)和回滚(Rollback)。 </li><li>行锁，更新一条数据只锁定一行</li><li>更新和删除效率高</li><li>外键</li><li><code>处理效率差一些，对内存要求(索引即数据，索引和数据存储在一起)</code></li></ul><h4 id="2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="2 MyISAM 引擎：主要的非事务处理存储引擎"></a>2 MyISAM 引擎：主要的非事务处理存储引擎</h4><ul><li>读速度快，针对select insert</li><li>count(*)等数据有额外存储</li></ul><h4 id="3-Archive-引擎：用于数据存档"><a href="#3-Archive-引擎：用于数据存档" class="headerlink" title="3 Archive 引擎：用于数据存档"></a>3 Archive 引擎：用于数据存档</h4><ul><li>只有插入和查询，适合存储大量独立历史记录</li><li>数据压缩，比MyISAM小75&amp;</li></ul><h4 id="4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><h4 id="5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><h4 id="6-Memory-引擎：置于内存的表"><a href="#6-Memory-引擎：置于内存的表" class="headerlink" title="6 Memory 引擎：置于内存的表"></a>6 Memory 引擎：置于内存的表</h4><p>索引数据结构(B+) InnoDB数据结构  设计原则 性能分析工具 优化 数据库设计</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="~索引的数据结构"></a>~索引的数据结构</h2><h3 id="①-索引介绍"><a href="#①-索引介绍" class="headerlink" title="① 索引介绍"></a>① 索引介绍</h3><p>查找一个数据：遍历 索引二叉树(保存value, 地址)  减少磁盘IO</p><p><strong>定义</strong>：为了高效获取数据的数据结构  </p><p>在存储引擎中实现，不同引擎可以不一样结构</p><p><strong>优点</strong>：</p><ol><li><p>类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。 </p></li><li><p>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p></li><li><p>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </p></li><li><p>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。‘</p></li></ol><p><strong>缺点：</strong></p><ol><li>创建和维护需要时间</li><li>索引需要磁盘空间</li><li>提高查询速度 但 降低 &#x3D;&#x3D;更新速度&#x3D;&#x3D;</li></ol><blockquote><p>频繁更新，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><h3 id="②-InnoDB中的索引"><a href="#②-InnoDB中的索引" class="headerlink" title="② InnoDB中的索引"></a>② InnoDB中的索引</h3><h4 id="普通查找"><a href="#普通查找" class="headerlink" title="普通查找"></a>普通查找</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;<br></code></pre></td></tr></table></figure><p>数据以页的形式存储，一页默认为16KB，查找时按照页逐步加载到内存</p><ol><li>数据在一页中（记录物理不连续，单链表，通过页目录实现二分）<ul><li>以主键搜索条件：主键通常为递增的 -&gt; 在 &#x3D;&#x3D;页目录 二分&#x3D;&#x3D; 定位对应槽 ，然后对槽内遍历</li><li>其他列：每一条记录为单链表连接(<strong>逻辑上连续</strong>)， 依次遍历</li></ul></li><li>很多页（页间双向链表连接）<ol><li>首先遍历页。<strong>没有索引无法快速定位</strong></li><li>再查找相应记录</li></ol></li></ol><h4 id="索引雏形"><a href="#索引雏形" class="headerlink" title="索引雏形"></a>索引雏形</h4><p>以<code>ROW_FORMAT = Compact </code>行格式创建表，表的每一条记录处理基本信息还有 是否最大 下一条地址 其他等，以下一条地址串联记录。</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055463.png" alt="image-20230223094205438" style="zoom: 50%;" /><p>为了针对主键设计索引，需要实现主键递增（主键不是自增的有个隐藏主键）</p><ul><li><p>页内是递增的，&#x3D;&#x3D;单向链表&#x3D;&#x3D;</p></li><li><p>页之间主键也是递增的，&#x3D;&#x3D;双向链表&#x3D;&#x3D;</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055464.png" alt="image-20230223094947963"></p></li></ul><blockquote><p>如果具体查找某一个主键还是得遍历全部页，然后页内二分，因此加一层。<br>加一个目录（目录可以连续存放）保存最小值，两次查找</p></blockquote><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055465.png" alt="image-20230223095322576" style="zoom: 67%;" /><h5 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h5><p>将目录转为页，<strong>实现快速定位数据页。</strong>目录也是页，用record_type&#x3D;1.通过&#x3D;&#x3D;页目录&#x3D;&#x3D;实现二分</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055466.png" alt="image-20230223100558168"></p><h5 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h5><p>一个目录页放不下，多个目录页。具体哪一个目录页要遍历，下面优化</p><h5 id="迭代3"><a href="#迭代3" class="headerlink" title="迭代3"></a>迭代3</h5><p>再往上迭代套娃，<strong>实现快速定位是哪个目录页</strong>。一个页为一次IO。总共3次IO</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055467.png" alt="image-20230223101559060"></p><h5 id="B-TreeB-Tree"><a href="#B-TreeB-Tree" class="headerlink" title="B+TreeB+Tree"></a>B+TreeB+Tree</h5><p>上面的结构就是3层的B+树，可以迭代任意层，但最多不超过4层（最多4次IO）</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055468.png" alt="image-20230223102937530" style="zoom: 33%;" /><p>假设存放记录的页可以100条，目录项的页为1000（页大小16KB，一条记录包含指针8KB主键8KB）条：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。 </li><li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。 </li><li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li><li>一般2-4层，根节点常驻内存，所以1-3次磁盘操作</li></ul><p>页内数据通过&#x3D;&#x3D;链表&#x3D;&#x3D;连接，使用页目录实现&#x3D;&#x3D;二分法&#x3D;&#x3D;定位</p><p>同行页间通过&#x3D;&#x3D;双向链表&#x3D;&#x3D;连接</p><h4 id="常见索引"><a href="#常见索引" class="headerlink" title="常见索引"></a>常见索引</h4><h5 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h5><p><strong>基本的数据存储方式</strong>（叶子节点存放全部记录）。 <code>索引即数据，数据即索引   .ibd文件</code></p><p>在创建时自动构建出来–B+树。</p><blockquote><p> 术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起，只有一种存储方式所以聚簇索引只有一个</p></blockquote><ul><li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li></ul><ul><li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式(<del>UUID MD5 HASH</del>)，否则将会出现页分裂</li><li><code>更新主键的代价很高</code> ，一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h5 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h5><p>想以别的列作为搜索条件，需要以别的列构建B+树。</p><p>叶子节点存储<strong>索引列</strong>和<strong>主键</strong>。目录项存储<strong>索引列</strong>和<strong>页号</strong>（实际上是索引列和主键联合，后面会说 为保证唯一）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055470.png" alt="image-20230223154220793"></p><p>查询要查两次（<strong>回表</strong>）：先根据筛选条件在普通索引上定位id，再拿id再聚集索引上定位行</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055471.png" alt="image-20230223153459920" style="zoom:50%;" /><h5 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h5><p>以c2和c3同时作为排列规则，优先c2，然后c3。别的和二级索引等价</p><h4 id="InnoDB注意事项"><a href="#InnoDB注意事项" class="headerlink" title="InnoDB注意事项"></a>InnoDB注意事项</h4><p><strong>1.根节点位置不变</strong><br>一开始根节点存放数据，满了后复制一份数据存储到别的地址，然后根节点升一级。此外，根节点常驻内存</p><p><strong>2.目录项记录的唯一性</strong><br>二级索引中<code>索引列 + 页号</code>搭配，索引列不唯一插入走哪条路就不知道了。所以默认会将<code>索引列+主键+页号</code>搭配，索引列和主键类似构建了一个联合索引。</p><p><strong>3.一个页面至少两条数据</strong></p><h3 id="③-MyISAM中索引"><a href="#③-MyISAM中索引" class="headerlink" title="③ MyISAM中索引"></a>③ MyISAM中索引</h3><p>索引与数据<strong>分离</strong> .myd存储数据（无序）， .myi存储索引</p><p>B树索引使用存储引擎如表所示：</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 <strong>地址</strong> 。&#x3D;&#x3D;相当于二级索引，但第二次是直接去磁盘&#x3D;&#x3D;</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055472.png" alt="image-20230223160434464" style="zoom: 67%;" /><p>​<code>这里是针对主键构建的，还可以根据c2，c3都构建。</code></p><p><strong>对比：</strong></p><ul><li>InnoDB对聚簇索引只需要查找一次，二级索引需要两次。MYISAM都是两次，但第二次很快</li><li>MYISAM索引文件分离</li><li>MYISAM可以没有主键</li></ul><h3 id="④-索引的代价"><a href="#④-索引的代价" class="headerlink" title="④ 索引的代价"></a>④ 索引的代价</h3><ul><li>空间：每一个索引都是一颗b+树</li><li>时间：增删改需要额外维护树结构</li></ul><h3 id="⑤-数据结构选择"><a href="#⑤-数据结构选择" class="headerlink" title="⑤ 数据结构选择"></a>⑤ 数据结构选择</h3><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>hashmap O(1)</p><ol><li>Hash只能进行&#x3D;和in的查询，不能进行范围查询(退化到O n)</li><li>无序 不能order by</li><li>联合索引时，hash值是一起构建的，无法拆开利用</li><li>重复值过多，冲突很多</li></ol><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>HASH索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>但Innodb也可以结合Hash，例如当某个条件WHERE a &#x3D; XXX经常访问时，将该条件对应地址直接存在hash中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul><li>一个节点只能有两个子节点</li><li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点</li><li>不平衡时退化</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055473.png" alt="image-20230223163719556" style="zoom:50%;" /><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>平衡二叉树且高度差小于1</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055474.png" alt="image-20230223163957242"></p><p>还可以变成多叉树来降低高度</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>每一个节点最多M个子节点，M称为树的阶。<strong>非叶子节点也存放数据</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055475.png" alt="image-20230223164347661"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2,M]。 </li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ol><p> 数据是一块的实现相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><strong>B+ 树和 B 树的<code>差异</code>在于以下几点：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 </li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中（小从小到大顺序链接）。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li></ol><p><strong>不在中间节点放数据，好处</strong></p><ul><li>数据都在叶子，查询效率稳定</li><li>非叶子无数据，可以存储更多数据，<strong>更矮胖</strong></li><li><strong>范围查找</strong>：叶子节点上直接进行范围查找效率高</li></ul><p>B树层数与节点数关系见：<a href="#B+Tree">B+Tree</a>，整课树能达到GB，不会全部加载到内存，只有根节点是常驻内存的</p><h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="~InnoDB数据存储结构"></a>~InnoDB数据存储结构</h2><p>索引是在存储引擎中实现的，存储引擎<strong>负责数据的读取和写入</strong></p><p>InnoDB将<strong>数据划分为页</strong>（16KB），页是磁盘和内存交换的&#x3D;&#x3D;基本单位&#x3D;&#x3D;，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%innodb_page_size%&#x27;;<br></code></pre></td></tr></table></figure><p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p><ul><li>页和页间<code>双向链表</code></li><li>页内数据按主键值<code>单向链表</code></li></ul><h3 id="①-上层结构"><a href="#①-上层结构" class="headerlink" title="① 上层结构"></a>① 上层结构</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055476.png" alt="image-20230224111638558" style="zoom:67%;" /><ul><li><p><strong>区</strong>：包含64个&#x3D;&#x3D;<strong>连续</strong>&#x3D;&#x3D;的页，<code>16*16KB = 1MB</code></p><p>范围查询时需要连续访问多个页，通过数据连续<strong>减少磁盘读取时间</strong> 10ms -&gt; 0.4ms</p><ul><li>随机读取 <code>单页10ms</code>(6ms寻道3ms等待1ms传输)</li><li>顺序读取 40MB&#x2F;s吞吐量，40&#x2F;16kb可以读取2560页，<code>单页0.4ms</code></li></ul></li><li><p><strong>段</strong>：多个区，数据库分配的基本单位：创建表、索引时分配。逻辑概念</p><p><strong>叶子节点</strong>放在一个区里，<strong>非叶子节点</strong>页在一个区里，区的集合叫做段</p></li><li><p><strong>碎片区：</strong>每次创建索引都会申请两整块区，太浪费。为了节约空间<code>碎片区内的页</code>可以服务于不同的段，当达到<code>32个碎片区</code>页面后，就申请完整的区。</p></li><li><p><strong>表空间</strong>：最高层逻辑容器，一个数据库由多个表空间：系统表空间、用户表空间等</p><ul><li><p>独立表空间: 即每张表有一个独立的表空间 .ibd  show variables like ‘innodb_file_per_table’</p></li><li><p>系统表空间 : 系统中所有表的索引外键路径等信息，也用B+树整合为表：<code>数据字典</code></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055477.png" alt="image-20230225102558798"></p></li></ul></li></ul><h3 id="②-页内结构"><a href="#②-页内结构" class="headerlink" title="② 页内结构"></a>② 页内结构</h3><p>数据页的 <code>16KB</code> 大小的存储空间被划分为<strong>七个部分</strong>：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055478.png" alt="image-20230224113534470" style="zoom:67%;" /><h4 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h4><p>File Header：页编号、页类型（Undo日志 数据页等）、上一页下一页、校验和（hash 文件-&gt;checksum）、日志位置</p><p>File Trailer：校验和（头尾一样代表完整）、日志位置</p><h4 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><p><strong>数据记录：</strong> 空闲空间-&gt;用户记录</p><p>最大最小记录：为了能构建B+树，同时是整个链表的首尾</p><h4 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h4><p><strong>页目录</strong>：记录分组（<code>直接二分空间太大，跳表</code>），每组4-8个(一个槽)，每个组拿出一个最大值排列出来，然后二分。</p><ul><li>最小记录单成组，最大记录4-8个</li><li>满9就拆分，所以很多都是4个</li></ul><p>页目录就负责记录下每组最大记录的（<code>地址偏移、最大值</code>）</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055479.png" alt="image-20230224121819782" style="zoom:67%;" /><p><strong>页面头部</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055480.png" alt="image-20230224122712920" style="zoom: 33%;" /><h3 id="③-行格式"><a href="#③-行格式" class="headerlink" title="③ 行格式"></a>③ 行格式</h3><p>链表记录的组合方式，为了链表有效组合，需要提供一定的额外信息，<strong>变长字段长度</strong>和<strong>NULL</strong>在&#x3D;&#x3D;InnoDB行格式&#x3D;&#x3D;讲</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055481.png" alt="image-20230224120801440" style="zoom: 50%;" /><p><strong>记录头信息</strong>(5bit)</p><ul><li>delete_mask 是否删除。逻辑删除，同时链表跳过它，并且修改组的数量最值。如果有新数据进来就覆盖一下</li><li>n_owned 每一组最后一条记录负责记下组内的记录个数</li><li>heap_no 页内位置编号  01是最小和最大记录</li><li>record_type 是否为叶子节点</li><li>next_record 链表next，记录偏移量</li></ul><h3 id="④-InnoDB行格式"><a href="#④-InnoDB行格式" class="headerlink" title="④ InnoDB行格式"></a>④ InnoDB行格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table emp3(id int)  row_format=compact;<br>alter table emp3 row_format=compact;<br></code></pre></td></tr></table></figure><ol><li><p>COMPACT</p><ul><li><strong>变长字段长度列表</strong>：对于变长字段不知道实际的长度<code>VARCHAR(8)</code>，需要有一个位子记录下实际上的长度 逆序</li><li><strong>NULL值列</strong>：对于可能为NULL的列，NULL在存储中如果用特殊字符表示会浪费空间，直接用bit位来标识是不是NULL</li><li><strong>记录头信息</strong>：同上</li><li><strong>隐藏列</strong>：<strong>row_id</strong>(行ID，无主键和Unique键时生成)  <strong>transaction_id</strong>(事务ID)  <strong>roll_pointer</strong>(回滚指针)</li></ul><p>.ibd文件讲解</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055482.png" alt="image-20230225091537989"></p><p><strong>行溢出：</strong></p><p>​对于varchar，最长共65535字节: 65532 + 2(长度值) + 1(null值)</p><p>​16KB&#x3D;16384字节，存不下varchar，所以compact存一部分然后存在别的地方，保存下地址</p></li><li><p>Dynamic(MySQL5.7)和Compressed</p><p>Dynamic行溢出只存地址不存数据，Compressed还会用zlib压缩数据</p></li><li><p>Redundant</p><p>字段偏移列表：所有列的偏移地址，等价于变长+NULL，但纯在冗余（对于非varchar）</p></li></ol><h2 id="索引创建"><a href="#索引创建" class="headerlink" title="~索引创建"></a>~索引创建</h2><p>创建完成，.ibd文件会增大</p><h3 id="①-索引基本操作"><a href="#①-索引基本操作" class="headerlink" title="① 索引基本操作"></a>① 索引基本操作</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li><p>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是<strong>普通索引</strong>、<strong>唯一索引</strong>（UNIQUE）、<strong>主键索引</strong>(UNIQUE+NOT NULL 唯一)、<strong>全文索引</strong>（提高大数据量的检索速度，被solr、ElasticSearch代替）。 </p></li><li><p>按照<code>物理实现</code>方式 ，索引可以分为 2 种：<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>。 </p></li><li><p>按照<code>作用字段个数</code> 进行划分，分成<strong>单列索引</strong>和<strong>联合索引</strong>。</p></li></ul><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong>隐式：</strong><code>主键、Unique、外键</code> 会自动添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE dept(<br>dept_id INT PRIMARY KEY AUTO_INCREMENT, # <br>dept_name VARCHAR(20)<br>);<br><br>CREATE TABLE emp(<br>emp_id INT PRIMARY KEY AUTO_INCREMENT, # 主键<br>emp_name VARCHAR(20) UNIQUE, # unique<br>dept_id INT,<br>CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) # 外键<br>)<br></code></pre></td></tr></table></figure><p><strong>显式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name [col_name data_type]<br>[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |<br>DESC]<br></code></pre></td></tr></table></figure><ul><li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </li><li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </li><li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li><li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li><li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li><li>ASC 或 DESC 指定升序或者降序的索引值存储。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INDEX (book_name)<br>INDEX multi_idx(book_id, book_name)<br>UNIQUE INDEX book_n(book_name)<br><br>SHOW INDEX FROM test3 \G # 查看全部索引<br><br>EXPLAIN select * from book where book_name = &quot;mysql&quot; # 查看是否用上索引<br></code></pre></td></tr></table></figure><h4 id="添加删除索引"><a href="#添加删除索引" class="headerlink" title="添加删除索引"></a>添加删除索引</h4><p><strong>添加</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_na ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]<br>[index_name] (col_name[length],...) [ASC | DESC]<br>ALTER TABLE book5 ADD INDEX book_n (book_name) ;<br><br>CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name<br>ON table_name (col_name[length],...) [ASC | DESC]<br></code></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_na DROP INDEX index_name;<br><br>DROP INDEX index_name ON table_na;<br><br># 唯一索引不能删除 起约束作用<br></code></pre></td></tr></table></figure><h3 id="②-8-0索引新特性"><a href="#②-8-0索引新特性" class="headerlink" title="② 8.0索引新特性"></a>② 8.0索引新特性</h3><h4 id="降序索引"><a href="#降序索引" class="headerlink" title="降序索引"></a>降序索引</h4><p>MySQL 8.x开始支持降序 DESC，之前版本的会被忽略。<code>多个列排序</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));<br></code></pre></td></tr></table></figure><p>查询时<code>order by a,b desc</code>，没有降序的化效果很差，需要文件排序</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055483.png" alt="image-20230226085758361"></p><h4 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h4><p>索引设置为隐藏索引，查询优化器<code>忽略这个索引</code>（更新时索引树还是会更新）。可以用来<code>验证某个索引性能</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tablename<br>ADD INDEX indexname (propname [(length)]) INVISIBLE; # 添加隐藏索引<br><br>ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引<br>ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引<br></code></pre></td></tr></table></figure><h3 id="③-索引的设计原则"><a href="#③-索引的设计原则" class="headerlink" title="③ 索引的设计原则"></a>③ 索引的设计原则</h3><p>数据准备 100W条</p><h4 id="适合创建索引"><a href="#适合创建索引" class="headerlink" title="适合创建索引!"></a>适合创建索引!</h4><h5 id="唯一字段"><a href="#唯一字段" class="headerlink" title="唯一字段"></a>唯一字段</h5><p>业务上具有唯一特性的字段，即使是组合字段，也<code>必须建成唯一索引</code>。</p><blockquote><p>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。（来源：Alibaba） </p></blockquote><h5 id="频繁where字段"><a href="#频繁where字段" class="headerlink" title="频繁where字段"></a>频繁where字段</h5><p>277ms-&gt;20ms</p><h5 id="经常-GROUP-BY-和-ORDER-BY-的列"><a href="#经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="经常 GROUP BY 和 ORDER BY 的列"></a>经常 GROUP BY 和 ORDER BY 的列</h5><h5 id="DISTINCT-字段"><a href="#DISTINCT-字段" class="headerlink" title="DISTINCT 字段"></a>DISTINCT 字段</h5><h5 id="多表JOIN时"><a href="#多表JOIN时" class="headerlink" title="多表JOIN时"></a>多表JOIN时</h5><ul><li><code>连接表的数量尽量不要超过 3 张</code></li><li><code>对 WHERE 条件创建索引</code></li><li><code>对用于连接的字段创建索引</code></li></ul><h5 id="使用前缀创建索引"><a href="#使用前缀创建索引" class="headerlink" title="使用前缀创建索引"></a>使用前缀创建索引</h5><p>不使用整个字符串构建。虽然不能精确查询，但查个大概然后回表查询完整的字符串。<strong>排序时用不上</strong></p><ul><li><code>太长存储空间太大</code></li><li><code>太长比较时需要占用更多时间</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 截取长度的选择：根据区分度    一般20 就可以达到90%以上<br>select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度<br>count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度<br>from shop<br></code></pre></td></tr></table></figure><h5 id="区分度高-散列性高"><a href="#区分度高-散列性高" class="headerlink" title="区分度高(散列性高)"></a>区分度高(散列性高)</h5><p><code>select count(distinct a) / count(*) from t1</code>，超过33%就不错的索引了</p><p>相对应的，像性别字段就不要添加索引</p><h5 id="最频繁的列放到联合索引的左侧"><a href="#最频繁的列放到联合索引的左侧" class="headerlink" title="最频繁的列放到联合索引的左侧"></a>最频繁的列放到联合索引的左侧</h5><p>对应最左前缀原则。</p><h5 id="多个字段都要创建时，联合索引更优"><a href="#多个字段都要创建时，联合索引更优" class="headerlink" title="多个字段都要创建时，联合索引更优"></a>多个字段都要创建时，联合索引更优</h5><ul><li>减少开销：一个联合索引<code>(c1,c2,c3)</code>，相当于<code>(c1)</code>,<code>(c1,c2)</code>,<code>(c1,c2,c3)</code>三个索引</li><li>覆盖索引：<code> select col1,col2,col3 from test where col1=1 and col2=2</code>，无需回表</li><li>效率高：索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1&#x3D;1 and col2&#x3D;2 and  col3&#x3D;3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从100w条数据中找到符合col2&#x3D;2 and col3&#x3D; 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w * (10% *10% *10%)&#x3D;1w，效率提升可想而知！</li></ul><h4 id="限制索引数量"><a href="#限制索引数量" class="headerlink" title="限制索引数量"></a>限制索引数量</h4><p>单表不超过六个：</p><ul><li>索引占用空间</li><li>更新时间</li><li>查询时，优化器需要对可能用到的索引进行比较，太多会降低性能</li></ul><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="~性能分析工具"></a>~性能分析工具</h2><h3 id="①-优化步骤"><a href="#①-优化步骤" class="headerlink" title="① 优化步骤"></a>① 优化步骤</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055484.png" alt="image-20220627162248635"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055485.png" alt="image-20220627162345815"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055486.png" alt="image-20230226135825018" style="zoom:50%;" /><h3 id="②-查看系统性能-status"><a href="#②-查看系统性能-status" class="headerlink" title="② 查看系统性能 status"></a>② 查看系统性能 status</h3><p><code>SHOW STATUS</code> ：查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。 %是通配符任意匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;<br></code></pre></td></tr></table></figure><ul><li><p>Connections：连接MySQL服务器的次数。 </p></li><li><p>Uptime：MySQL服务器的上线时间。 </p></li><li><p>&#x3D;&#x3D;Slow_queries&#x3D;&#x3D;：慢查询的次数。 </p></li><li><p>Innodb_rows_read：Select查询返回的行数 </p></li><li><p>Innodb_rows_inserted：执行INSERT操作插入的行数 </p></li><li><p>Innodb_rows_updated：执行UPDATE操作更新的 行数 </p></li><li><p>Innodb_rows_deleted：执行DELETE操作删除的行数 </p></li><li><p>Com_select：查询操作的次数。 </p></li><li><p>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </p></li><li><p>Com_update：更新操作 的次数。 </p></li><li><p>Com_delete：删除操作的次数。</p></li><li><p>&#x3D;&#x3D;last_query_cost&#x3D;&#x3D;：查看最后一次操作查询了多少张<strong>数据页</strong>。</p><ul><li>建立了索引，可以有效减少访问的页数。回表的化页数还要增加</li><li>页数多页不用担心，1.页可以在缓冲池或内存中、2.批量顺序读取速度也很快</li></ul></li></ul><h3 id="③-定位执行慢的-SQL：慢查询日志"><a href="#③-定位执行慢的-SQL：慢查询日志" class="headerlink" title="③ 定位执行慢的 SQL：慢查询日志"></a>③ 定位执行慢的 SQL：慢查询日志</h3><p>超过<code>long_query_time</code>的SQL会记录下，默认10s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%slow_query_log%&#x27;; # 是否打开 以及 保存地址<br>set global slow_query_log=&#x27;ON&#x27;; # 打开<br><br> show variables like &#x27;%long_query_time%&#x27;; # 时间阈值<br> <br> # 设置时间<br> #测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并<br>mysql &gt; set global long_query_time = 1;<br>mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;<br>mysql&gt; set long_query_time=1;<br>mysql&gt; show variables like &#x27;%long_query_time%&#x27;;<br></code></pre></td></tr></table></figure><p><code>show status like &#39;slow_queries&#39;</code> 显示有多少sql超时了</p><p> <code>mysqldumpslow</code> ：日志分析工具，给日志文件就可以定位sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#得到返回记录集最多的10个SQL<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log<br><br>#得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log<br><br>#得到按照时间排序的前10条里面含有左连接的查询语句<br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log<br><br>#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more<br></code></pre></td></tr></table></figure><h3 id="④-PROFILE"><a href="#④-PROFILE" class="headerlink" title="④ PROFILE"></a>④ PROFILE</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;profiling&#x27;;<br>set profiling = &#x27;ON&#x27;;<br>show profiles; # 近几个查询<br>show profile; # 最近一个的细节   各个阶段耗时<br>show profile cpu,block io for query 2<br></code></pre></td></tr></table></figure><h3 id="⑤-EXPLAIN"><a href="#⑤-EXPLAIN" class="headerlink" title="⑤ EXPLAIN"></a>⑤ EXPLAIN</h3><p>不考虑各种Cache、不能显示优化工作、不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 </p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055487.png" alt="image-20220628212049096" style="zoom: 80%;" /><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE s1 (<br>    id INT AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    common_field VARCHAR(100),<br>    PRIMARY KEY (id),<br>    INDEX idx_key1 (key1),<br>    UNIQUE INDEX idx_key2 (key2),<br>    INDEX idx_key3 (key3),<br>    INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br><br>CREATE TABLE s2 (<br>    id INT AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    common_field VARCHAR(100),<br>    PRIMARY KEY (id),<br>    INDEX idx_key1 (key1),<br>    UNIQUE INDEX idx_key2 (key2),<br>    INDEX idx_key3 (key3),<br>    INDEX idx_key_part(key_part1, key_part2, key_part3)<br>) ENGINE=INNODB CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。<br># Function<br>DELIMITER //<br>CREATE FUNCTION rand_string1(n INT)<br>RETURNS VARCHAR(255) #该函数会返回一个字符串<br>BEGIN<br>DECLARE chars_str VARCHAR(100) DEFAULT<br>&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;<br>    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;<br>    DECLARE i INT DEFAULT 0;<br>    WHILE i &lt; n DO<br>        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));<br>        SET i = i + 1;<br>    END WHILE;<br>    RETURN return_str;<br>END //<br>DELIMITER ;<br><br># 存储过程<br>DELIMITER //<br>CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    SET autocommit = 0;<br>    REPEAT<br>    SET i = i + 1;<br>    INSERT INTO s1 VALUES(<br>        (min_num + i),<br>        rand_string1(6),<br>        (min_num + 30 * i + 5),<br>        rand_string1(6),<br>        rand_string1(10),<br>        rand_string1(5),<br>        rand_string1(10),<br>        rand_string1(10));<br>    UNTIL i = max_num<br>    END REPEAT;<br>    COMMIT;<br>END //<br>DELIMITER ;<br><br>DELIMITER //<br>CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    SET autocommit = 0;<br>    REPEAT<br>    SET i = i + 1;<br>    INSERT INTO s2 VALUES(<br>        (min_num + i),<br>        rand_string1(6),<br>        (min_num + 30 * i + 5),<br>        rand_string1(6),<br>        rand_string1(10),<br>        rand_string1(5),<br>        rand_string1(10),<br>        rand_string1(10));<br>    UNTIL i = max_num<br>    END REPEAT;<br>    COMMIT;<br>END //<br>DELIMITER ;<br><br># 调用<br>CALL insert_s1(10001,10000);<br>CALL insert_s2(10001,10000);<br></code></pre></td></tr></table></figure><h4 id="各列作用☆"><a href="#各列作用☆" class="headerlink" title="各列作用☆"></a>各列作用☆</h4><p>一条语句可多个select，一个select可from多个表，一个表一行记录</p><ol><li><p>&#x3D;&#x3D;<strong>table</strong>&#x3D;&#x3D;</p><p>对应表，每行记录都对应一个表。可能有临时表</p><p><code>EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code> Union会构建临时表去重，一共3个</p></li><li><p>&#x3D;&#x3D;<strong>id</strong>&#x3D;&#x3D;</p><p>对应select个数，如子查询就有多个select</p><p>按照id从小到大执行，同一id前面的是驱动表</p></li><li><p><strong>&#x3D;&#x3D;select_type&#x3D;&#x3D;</strong>  小查询在整个大查询扮演的角色</p><ol><li>simple：简单 以及JOIN <code>EXPLAIN SELECT * FROM s1;</code>  <code>EXPLAIN SELECT * FROM s1 INNER JOIN s2;</code> </li><li>PRIMARY ：UNION最左边，子查询最外面的 <code>EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</code> s1</li><li>UNION：UNION剩下的 s2</li><li>UNION RESULT：UNION产生的临时表</li><li>SUBQUERY ：子查询里面<code>EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#39;a&#39;;</code></li><li>等等p137</li></ol></li><li><p>&#x3D;&#x3D;partition&#x3D;&#x3D;(分区相关)</p></li><li><p>&#x3D;&#x3D;type&#x3D;&#x3D; ☆</p><p>执行查询时的访问方法：<code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p><ul><li><p><code>system</code> 一条记录且数据统计精准（MyISAM、Memory）</p></li><li><p><code>const</code> 主键或唯一二级索引与常数等值匹配</p></li><li><p><code>eq_ref</code> 连接时，被驱动表是通过主键或者唯一二级索引列</p></li><li><p><code>ref</code> 普通的二级索引列与常量进行等值匹配</p></li><li><p><code>index_merge</code> 条件为or时，同时用上多个索引</p></li><li><p>…</p></li><li><p><code>range</code> 索引的范围查询  <code>c1 IN (&#39;a&#39;, &#39;b&#39;)</code>   <code>c1 &gt; &#39;a&#39;</code>  <code>c1 LIKE &#39;abc%&#39;;</code></p></li><li><p><code>index</code> 索引覆盖，但需要扫描全部记录  <code>EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#39;a&#39;;</code></p><p>​原因：扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></li><li><p><code>ALL</code> 全表扫描</p><p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>SQL 性能优化的目标：<strong>至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。</strong>（阿里巴巴 开发手册要求）</p></li></ul></li><li><p>&#x3D;&#x3D;possible_keys&#x3D;&#x3D;和&#x3D;&#x3D;key&#x3D;&#x3D;</p><p><code>可能用到的索引</code> 和 <code>实际用的</code>   ：<code>EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key3 = &#39;a&#39;;</code></p></li><li><p>&#x3D;&#x3D;key_len&#x3D;&#x3D; ☆</p><p>用上的索引字节长度，<strong>检查是否充分利用索引</strong>，主要针对联合索引。加上了变长和null</p><p>长度为 2个索引列 * （数据长度<em>3 utf-8 + 2变长字段 + 1null）  606 &#x3D; 2 * （100</em>3+2+1）</p><p><code>EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39;; </code>   606 </p></li><li><p>&#x3D;&#x3D;ref&#x3D;&#x3D;</p><p>和索引列比较的结构是什么：const、s1.id、func等</p><p><code>WHERE s2 = &#39;a&#39;;</code>  <code>s1 INNER JOIN s2 ON s1.id = s2.id;</code>    <code>INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</code></p></li><li><p>&#x3D;&#x3D;rows&#x3D;&#x3D;☆</p><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p></li><li><p>&#x3D;&#x3D;filtered&#x3D;&#x3D;</p><p>加入条件时，剩下数据的比例。在驱动表中剩下越少，循环下一张表次数也就越少</p></li><li><p>&#x3D;&#x3D;Extra&#x3D;&#x3D;☆</p><ul><li><p><code>No tables used</code> </p></li><li><p><code>Impossible WHERE</code> where 永远false</p></li><li><p><code>Using where</code> 普通列</p></li><li><p><code>No matching min/max row</code> 有聚合函数但没有数据</p></li><li><p><code>Using index</code> 索引覆盖</p></li><li><p><code>Using index condition</code>   索引完后，先过滤key1 LIKE ‘%a’再去主表查询，<code>索引条件下推</code></p><p>​SELECT * FROM s1 WHERE key1 &gt; ‘z’ AND key1 LIKE ‘%a’; </p></li><li><p><code>Using join buffer (Block Nested Loop)</code>  被驱动表无索引，使用内存加速 <code>基于块的嵌套循环算法</code></p></li><li><p><code>Using filesort</code> 对普通列order by，需在内存或磁盘排序。慢！</p></li><li><p><code>Using temporary</code> 使用临时表：DISTINCT、 GROUP BY、UNION。<code>代价很大，最好使用索引来替代临时表</code></p></li></ul></li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><ol><li>传统格式</li><li>JSON格式  EXPLAIN FORMAT&#x3D;JSON</li><li>TREE格式  EXPLAIN FORMAT&#x3D;tree</li><li>Workbench可视化  快速查看</li></ol><h3 id="⑥-SHOW-WARNINGS"><a href="#⑥-SHOW-WARNINGS" class="headerlink" title="⑥ SHOW WARNINGS"></a>⑥ SHOW WARNINGS</h3><p><strong>查看完整SQL语句</strong>，涉及到内查询等优化器可能会帮我们优化掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * from s1 where key1 in (select key2 from s2 where common_field = &#x27;a&#x27;);<br>show warnings; # 内查询优化成了连接<br></code></pre></td></tr></table></figure><h3 id="⑦-trace：分析优化器执行"><a href="#⑦-trace：分析优化器执行" class="headerlink" title="⑦ trace：分析优化器执行"></a>⑦ trace：分析优化器执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启，结果保存到information_schema.optimizer_trace中<br>SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;<br>set optimizer_trace_max_mem_size=1000000;<br><br>select * from student where id &lt; 10;<br><br>select * from information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><h3 id="⑧-sys-schema-：MySQL监控分析视图"><a href="#⑧-sys-schema-：MySQL监控分析视图" class="headerlink" title="⑧ sys schema ：MySQL监控分析视图"></a>⑧ sys schema ：MySQL监控分析视图</h3><p>查询需要消耗大量资源。查询结果来自  全部的数据库  的 全部的表</p><p>索引情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查询冗余索引<br>select * from sys.schema_redundant_indexes;<br>#2. 查询未使用过的索引<br>select * from sys.schema_unused_indexes;<br>#3. 查询索引的使用情况<br>select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted<br>from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p>表相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 查询表的访问量<br>select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from<br>sys.schema_table_statistics group by table_schema,table_name order by io desc;<br># 2. 查询占用bufferpool较多的表<br>select object_schema,object_name,allocated,data<br>from sys.innodb_buffer_stats_by_table order by allocated limit 10;<br># 3. 查看表的全表扫描情况<br>select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p>语句相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 监控SQL执行的频率<br>select db,exec_count,query from sys.statement_analysis<br>order by exec_count desc;<br>#2. 监控使用了排序的SQL<br>select db,exec_count,first_seen,last_seen,query<br>from sys.statements_with_sorting limit 1;<br>#3. 监控使用了临时表或者磁盘临时表的SQL<br>select db,exec_count,tmp_tables,tmp_disk_tables,query<br>from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0<br>order by (tmp_tables+tmp_disk_tables) desc;<br></code></pre></td></tr></table></figure><p>IO相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查看消耗磁盘IO的文件<br>select file,avg_read,avg_write,avg_read+avg_write as avg_io<br>from sys.io_global_by_file_by_bytes order by avg_read limit 10;<br></code></pre></td></tr></table></figure><p>Innodb 相关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 行锁阻塞情况<br>select * from sys.innodb_lock_waits;<br></code></pre></td></tr></table></figure><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="~索引优化与查询优化"></a>~索引优化与查询优化</h2><p>需要调优的角度：</p><ul><li>索引失效、没有充分利用到索引——建立索引  <code>物理查询优化</code></li><li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化 <code>逻辑查询优化</code></li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表</li></ul><h3 id="①-数据准备"><a href="#①-数据准备" class="headerlink" title="① 数据准备"></a>① 数据准备</h3><p><code>学员表</code> 插 <code>50万</code> 条，<code> 班级表</code> 插 <code>1万</code> 条。</p><h3 id="②-索引失效案例☆"><a href="#②-索引失效案例☆" class="headerlink" title="② 索引失效案例☆"></a>② 索引失效案例☆</h3><p>用B+树推理出来即可！</p><h4 id="2-1-全值匹配我最爱"><a href="#2-1-全值匹配我最爱" class="headerlink" title="2.1 全值匹配我最爱"></a>2.1 全值匹配我最爱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 没有索引时全部遍历<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;<br></code></pre></td></tr></table></figure><h4 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h4><p>最左边能匹配就能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_age_classid_name ON student(age,classId,name);<br><br># 能用<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId=4;<br><br># 不能用<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=4 AND student.age=30 AND student.name = &#x27;abcd&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h4><p>主键<code>AUTO_INCREMENT</code> ，防止<strong>页面分裂</strong>：把本页中的一些记录移动到新创建的这个页中</p><h4 id="2-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#2-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="2.4 计算、函数、类型转换(自动或手动)导致索引失效"></a>2.4 计算、函数、类型转换(自动或手动)导致索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_name ON student(NAME);<br># 可以用上<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;<br><br># 函数千奇百怪，不知道返回什么，所以用不上<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-5-类型转换导致索引失效"><a href="#2-5-类型转换导致索引失效" class="headerlink" title="2.5 类型转换导致索引失效"></a>2.5 类型转换导致索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;<br># 使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h4><p>联合索引，范围查询的后面列无法用上索引。但<code>c2 like &#39;c%&#39;</code>后面的可以用上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CAll proc_drop_index(&#x27;atguigudb2&#x27;, &#x27;student&#x27;);<br>CREATE INDEX idx_age_classid_name ON student(age,name,classId);<br><br># 用不上 key_len=68<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 3 and name &gt; &#x27;c&#x27; and classId = 20;<br># 用得上 key_len=73<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 3 and name like &#x27;c%&#x27; and classId = 20;<br></code></pre></td></tr></table></figure><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。创建的联合索引中，务必把范围涉及到的字段写在最后</p></blockquote><h4 id="2-7-不等于-或者-索引失效"><a href="#2-7-不等于-或者-索引失效" class="headerlink" title="2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效</h4><p>不等于不能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name &lt;&gt; &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#2-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="2.8 is null可以使用索引，is not null无法使用索引"></a>2.8 is null可以使用索引，is not null无法使用索引</h4><p>道理同上</p><blockquote><p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p><p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p></blockquote><h4 id="2-9-like以通配符-开头索引失效"><a href="#2-9-like以通配符-开头索引失效" class="headerlink" title="2.9 like以通配符%开头索引失效"></a>2.9 like以通配符%开头索引失效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;%ab&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>拓展：Alibaba《Java开发手册》 </p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h4 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h4><p>or纯在非索引导致失效，and不会</p><p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 加入只有age有索引<br># 未使用到索引<br>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;<br></code></pre></td></tr></table></figure><h4 id="2-11-数据库和表的字符集统一使用utf8mb4"><a href="#2-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="2.11 数据库和表的字符集统一使用utf8mb4"></a>2.11 数据库和表的字符集统一使用utf8mb4</h4><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p><h3 id="③-关联查询优化"><a href="#③-关联查询优化" class="headerlink" title="③ 关联查询优化"></a>③ 关联查询优化</h3><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><p>不是绝对的左边为驱动表，如果左边有索引可能会变成被驱动表</p><p>驱动表<code>Using joion buffer</code> 使用缓存；添加索引被驱表可以走索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;<br></code></pre></td></tr></table></figure><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>优化器选择驱动表，选择有索引的或者大表作为被驱动表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;<br></code></pre></td></tr></table></figure><h4 id="JOIN原理"><a href="#JOIN原理" class="headerlink" title="JOIN原理"></a>JOIN原理</h4><p>MySQL5.5版本之前，只有嵌套循环。后来引入BNLJ算法优化嵌套查询。8.0.18引入Hash Join</p><h5 id="1-Simple-Nested-Loop-Join"><a href="#1-Simple-Nested-Loop-Join" class="headerlink" title="1.Simple Nested-Loop Join"></a>1.Simple Nested-Loop Join</h5><p>简单嵌套循环连接：相当于两层循环。比较了<code>A * B</code>次，读取了A+AB次记录。</p><h5 id="2-Index-Nested-Loop-Join"><a href="#2-Index-Nested-Loop-Join" class="headerlink" title="2. Index Nested-Loop Join"></a>2. Index Nested-Loop Join</h5><p>索引嵌套循环连接：被驱表走索引然后回表。比较<code>A*height</code>，读取了<code>A+B(match)</code></p><h5 id="3-Block-Nested-Loop-Join"><a href="#3-Block-Nested-Loop-Join" class="headerlink" title="3.Block Nested-Loop Join"></a>3.Block Nested-Loop Join</h5><p>块嵌套循环连接：引入块join buffer，把驱动表（分成一个个块）放在缓存中。被驱动一次比较一块驱动表记录，相当于外层循环变小了</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055488.png" alt="image-20230304103951379"></p><p>通过<code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>比较了<code>A * B</code>，读取了 <code>A + 块数*B</code>，访问磁盘次数少了</p><blockquote><p> join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p></blockquote><h5 id="4-Hash-Join"><a href="#4-Hash-Join" class="headerlink" title="4. Hash Join"></a>4. Hash Join</h5><p><strong>等值连接</strong>。对BNLJ进一步优化，针对小表直接建立Hash表，大表每一条比较时间降低到O1</p><p>如果能完全放下小表，时间为A+B。如果不能放下需分块，相当于大表还是一次比较一整块记录，但时间优化到O1</p><h3 id="④-子查询"><a href="#④-子查询" class="headerlink" title="④ 子查询"></a>④ 子查询</h3><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM student stu1<br>WHERE stu1.`stuno` IN (<br>SELECT monitor<br>FROM class c<br>WHERE monitor IS NOT NULL<br>)<br># 优化<br>EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c<br>ON stu1.`stuno` = c.`monitor`<br>WHERE c.`monitor` is NOT NULL;<br></code></pre></td></tr></table></figure><h3 id="⑤-排序"><a href="#⑤-排序" class="headerlink" title="⑤ 排序"></a>⑤ 排序</h3><p><code>FileSort</code> （内存中，占CPU）或 <code>Index</code> 排序。</p><p>还可以使用联合索引，where用一部分，order后一部分， <code>WHERE a = const AND b = const ORDER BY c</code></p><p>是否用所以还需要看排序代价，不大可以直接排序</p><h4 id="双路和单路排序"><a href="#双路和单路排序" class="headerlink" title="双路和单路排序"></a>双路和单路排序</h4><p>双路：只拿排序列数据，排完序后再全部遍历取出需要列。</p><p>单路：直接所有需要列区排序，但需要更多<code>sort_buffer_size</code>，默认1MB。如果数据量大于<code>max_length_for_sort_data</code>（1024~8192B）转用单路。</p><p>所以select * 在这是大忌。</p><ul><li>where效率高于having，能写在where限定的条件就不要写在having中了 </li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内</li></ul><h3 id="⑥-优化分页查询"><a href="#⑥-优化分页查询" class="headerlink" title="⑥ 优化分页查询"></a>⑥ 优化分页查询</h3><p><code>select * from sutdent limit 1000000,10</code>这种头疼问题</p><p>本来需要回表&gt;1000000，现在只需要回表10；使用连接优化子查询</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055489.png" alt="image-20230304122824862"></p><h3 id="⑦-索引覆盖"><a href="#⑦-索引覆盖" class="headerlink" title="⑦ 索引覆盖"></a>⑦ 索引覆盖</h3><p><code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> </p><p>索引覆盖可以提高速度，回表的IO很可能是随机IO（数据不连续）。但有维护代价，业务DBA（业务数据架构师）的工作。</p><p>此外，就算使用！&#x3D;导致索引失效，如果可以索引覆盖还是会去使用索引，因为二级索引更小遍历代价更低。</p><h3 id="⑧-索引条件下推"><a href="#⑧-索引条件下推" class="headerlink" title="⑧ 索引条件下推"></a>⑧ 索引条件下推</h3><p>​&#x3D;&#x3D;先过滤再回表&#x3D;&#x3D;</p><p>通常针对联合索引，(c1, c2, c3)   c1能使用但c2 c3用不了。c1用完索引后先c2 c3遍历过滤后再回表。</p><p>ICP的开启和关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set optimizer_switch = &#x27;index_condition_pushdown=on&#x27;  或者off<br><br>执行语句时关闭<br>select /*+ no_icp (table_name) */ * from table_name  where ...<br></code></pre></td></tr></table></figure><h3 id="⑨-其他优化策略"><a href="#⑨-其他优化策略" class="headerlink" title="⑨ 其他优化策略"></a>⑨ 其他优化策略</h3><h4 id="exists-和-in"><a href="#exists-和-in" class="headerlink" title="exists 和 in"></a>exists 和 in</h4><p>exists用外表驱动内表，拿一条条外表数据去内表查（相关子查询）       适合外小内大<br>in反过来，先查询内表，再拿数据去外表走索引                        </p><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h4><p><code>SELECT COUNT(*) 、 SELECT COUNT(1)</code>基本等价，效率相等，&#x3D;&#x3D;自动选取小空间的二级索引&#x3D;&#x3D;。MyISAM维护了变量</p><p><code>SELECT COUNT(具体字段)</code>尽量建立二级索引。</p><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT(*)"></a>SELECT(*)</h4><ul><li>需要先查询数据字典将*转换为列名</li><li>无法使用覆盖索引</li><li>空间更大</li></ul><h4 id="LIMIT-1"><a href="#LIMIT-1" class="headerlink" title="LIMIT 1"></a>LIMIT 1</h4><p>在确定数据唯一，并且无唯一索引时，可以提前结束扫描，加速。</p><h4 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h4><p>COMMIT 所释放的资源： </p><ul><li>回滚段上用于恢复数据的信息 </li><li>被程序语句获得的锁 </li><li>redo &#x2F; undo log buffer 中的空间 </li><li>管理上述 3 种资源中的内部花费</li></ul><h3 id="⑩-淘宝数据库，主键如何设计的？"><a href="#⑩-淘宝数据库，主键如何设计的？" class="headerlink" title="⑩ 淘宝数据库，主键如何设计的？"></a>⑩ 淘宝数据库，主键如何设计的？</h3><h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><ol><li><p><strong>可靠性不高</strong></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。 </p></li><li><p>**安全性不高 **</p><p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。 </p></li><li><p><strong>性能差</strong> </p><p>自增ID的性能较差，需要在数据库服务器端生成。 </p></li><li><p><strong>交互多</strong> </p><p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。 </p></li><li><p>**局部唯一性 **</p><p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p></li></ol><h4 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h4><p>会员卡中的卡号：但如果用户注销了，购买记录还会给新的人。</p><p>身份证号：隐私问题等</p><blockquote><p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote><h4 id="淘宝的主键设计"><a href="#淘宝的主键设计" class="headerlink" title="淘宝的主键设计"></a>淘宝的主键设计</h4><p>淘宝的订单号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1550672064762308113<br>1481195847180308113<br>1431156171142308113<br>1431146631521308113<br><br>猜测：订单ID = 时间 + 去重字段 + 用户ID后6位尾号<br></code></pre></td></tr></table></figure><h4 id="推荐主键设计"><a href="#推荐主键设计" class="headerlink" title="推荐主键设计"></a>推荐主键设计</h4><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p><p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h5><p>32个16进制数，纯数占用16B。实际占用36B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）<br><br>时间：100ns区别。秒在前面所以不是自增<br>36字节：字符串存储，且带有无用字符-<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055490.png" alt="image-20230305102015371"></p><h5 id="改造UUID"><a href="#改造UUID" class="headerlink" title="改造UUID"></a><strong>改造UUID</strong></h5><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0</p><p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的<code>-</code>字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>MySQL8.0提供<code>uuid_to_bin</code>，<code>bin_to_uuid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @uuid = UUID();<br>SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);<br></code></pre></td></tr></table></figure><h5 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h5><p>mybatis-plus默认，并且会将id自动set到实体对象中</p><ol><li>能满足高并发分布式系统环境下ID不重复</li><li>基于时间戳，可以保证基本有序递增</li><li>不依赖第三方的库或者中间件</li><li>生成效率极高</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> - <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0000000000</span> <span class="hljs-number">0</span> - <span class="hljs-number">0000000000</span> - <span class="hljs-number">000000000000</span><br><br>符号位             时间戳                                机器码      序列号<br><span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span><br>                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span><br>                | sequence;<br></code></pre></td></tr></table></figure><ul><li>41位存储毫秒级时间戳，这个时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的ID生成器开始使用的时间，一般为项目创建时间，就是下面实现中代码的twepoch 属性，生成器根据时间戳插值进行初次尝试创建ID。</li><li>10位存储机器码，最多支持1024台机器，当并发量非常高，同时有多个请求在同一毫秒到达，可以根据机器码进行第二次生成。机器码可以根据实际需求进行二次划分，比如两个机房操作可以一个机房分配5位机器码。</li><li>12位存储序列号，当同一毫秒有多个请求访问到了同一台机器后，此时序列号就派上了用场，为这些请求进行第三次创建，最多每毫秒每台机器产生2的12次方也就是4096个id，满足了大部分场景的需求。</li></ul><blockquote><p>在Web开发中需要跟js打交道，而js支持最大的整型范围为53位，超过这个范围就会丢失精度，53之内可以直接由js读取，超过53位就需要转换成字符串才能保证js处理正确。</p><p>或者53位存储的话，32位存储秒级时间戳，5位存储机器码，16位存储序列化，这样每台机器每秒可以生产65536个不重复的id。</p></blockquote><h2 id="数据库设计规则"><a href="#数据库设计规则" class="headerlink" title="~数据库设计规则"></a>~数据库设计规则</h2><p>什么数据 什么表、crud时的约束检查、减低数据冗余度、方便数据库维护使用</p><p>表结构的调整代价很大</p><h3 id="①-范数"><a href="#①-范数" class="headerlink" title="① 范数"></a>① 范数</h3><p>关系型数据库的基本原则。但有时为了提高性能还会破坏规则，反规范化（降低冗余度，但业务可能复杂了）</p><p>六种：</p><ul><li>第一范式：列不能再分</li><li>第二范式：非主属性消除部分依赖</li><li>第三范式：非主属性消除传递依赖（平衡）</li><li>巴斯-科德范式：候选键只有一个，或者每个候选键都是单属性。主属性消除部分依赖</li><li>第四范式：不存在多组 多值依赖（一对多）：职工表（职工id，孩子姓名，职工课程），需要拆开</li><li>第五范式：理论研究</li></ul><p>找出所有码 -&gt; 主属性、非主属性 -&gt; 检查部分函数依赖 -&gt; 检查传递函数依赖</p><h4 id="键和相关概念"><a href="#键和相关概念" class="headerlink" title="键和相关概念"></a>键和相关概念</h4><ul><li><code>超键</code>：能唯一标识元组的属性集</li><li><code>候选键</code>：超键且不包括多余属性，可以多个 ；码</li><li><code>主键</code>：从候选键中选一个</li><li><code>外键</code>：R1中的属性不是R1的主键，而是R2的</li><li><code>主属性</code>：所有候选键中的所有属性</li><li><code>非主属性</code></li></ul><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>每个字段都<strong>不能拆分</strong>了，如不能把电话、姓名、地址都放到一个字段中。</p><p>first name，lastname是否拆分要看具体的业务需求</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><strong>所有非主键完全依赖于候选键</strong>，如果存在<code>部分依赖，则抽出来新建表</code></p><p>成绩表：要想知道成绩，完全依赖于（学号、课程号）</p><p>在学生的成绩表中，不再放学生的地址等信息</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>非主属性C直接相关于主属性A，而不能依赖于其他非主属性B：主属性A-&gt;非主属性B-&gt;非属性C</p><p><strong>员工表</strong>中只放部门编号，不放部门其他信息，这些信息可以通过join查询获得</p><p><strong>商品表</strong>中只放商品类别id，不放类别名称</p><h3 id="②-反范式"><a href="#②-反范式" class="headerlink" title="② 反范式"></a>② 反范式</h3><p><code>业务优先</code>，增加冗余字段来提高读性能。空间换时间。<code>冗余字段修改需要同步</code></p><p><strong>员工表</strong>的查询经常要部门名称，加进来；商品表同理。<strong>违反了第三范式</strong></p><p><strong>学生表</strong>和<strong>课程评论表</strong>，查询课程的评论时经常要用学生名称</p><p>学生表100w，评论表100w</p><p>查询某课程的前10000条评论的姓名和评论；反范式化后，把学生姓名加入评论表</p><p>0.1 -&gt; 0.036</p><p>&#x3D;&#x3D;条件&#x3D;&#x3D;：冗余字段不常修改  且  查询时必要</p><h2 id="数据库其他调优"><a href="#数据库其他调优" class="headerlink" title="~数据库其他调优"></a>~数据库其他调优</h2><p>从更大的层面来优化，主要就是下面这张表。垂直分库分表、读写分离</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055491.png" alt="image-20230307161933988"></p><p><strong>目标</strong>：吞吐量更大、响应速度更快</p><p><strong>问题发现</strong>：用户反馈、日志</p><h3 id="①-调优步骤"><a href="#①-调优步骤" class="headerlink" title="① 调优步骤"></a>① 调优步骤</h3><h4 id="1-合适的DBMS"><a href="#1-合适的DBMS" class="headerlink" title="1.合适的DBMS"></a>1.合适的DBMS</h4><p>事务以及安全性要求高，选择SQL Server、Oracle。单表可以存储上亿条数据。</p><h4 id="2-优化表设计"><a href="#2-优化表设计" class="headerlink" title="2.优化表设计"></a>2.优化表设计</h4><p>尽量遵循第三范式 并且 适当运用反范式</p><p>数据类型选择合适的</p><h4 id="3-优化逻辑查询"><a href="#3-优化逻辑查询" class="headerlink" title="3.优化逻辑查询"></a>3.优化逻辑查询</h4><p>SQL的重写：子查询变join</p><h4 id="4-优化物理查询"><a href="#4-优化物理查询" class="headerlink" title="4.优化物理查询"></a>4.优化物理查询</h4><p>索引</p><h4 id="5-使用Redis缓存"><a href="#5-使用Redis缓存" class="headerlink" title="5.使用Redis缓存"></a>5.使用Redis缓存</h4><p>redis支持持久化，除了内存还可以将数据放到硬盘上</p><h4 id="6-库级优化"><a href="#6-库级优化" class="headerlink" title="6.库级优化"></a>6.库级优化</h4><p>站在数据库维度进行优化。</p><p>多台机器读写分离、<code>分库分表</code>切割数据库</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055491.png" alt="image-20230307161933988"></p><h3 id="②-优化MySQL服务器"><a href="#②-优化MySQL服务器" class="headerlink" title="② 优化MySQL服务器"></a>② 优化MySQL服务器</h3><p>硬件层面：<code>大内存</code>、<code>高速磁盘系统(SCSI -&gt; SSD) </code>，<code>合理分布磁盘I/O</code>，<code>配置多处理器</code></p><p>MySQL参数：<code>innodb_buffer_pool_size (表、索引)</code>、<code>key_buffer_size </code>、<code>table_cache </code>、<code>query_cache_size(查询缓存、8.0没有)</code>、<code>sort_buffer_size(排序)</code>、<code>join_buffer_size(join缓存)</code>、<code>max_connections(默认151)</code></p><h3 id="③-表结构优化"><a href="#③-表结构优化" class="headerlink" title="③ 表结构优化"></a>③ 表结构优化</h3><h4 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a>冷热数据分离</h4><p>拆分：<code>会员表</code> 存储会员登录认证信息，该表中有很多字段，如<code>id、姓名、密码、地址、电 话、个人描述</code>字段。其中<code>地址、电话、个人描述</code>等字段并不常用，可以将这些不常用的字段分解出另一个表。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055492.png" alt="image-20230307161748616"></p><h4 id="增加中间表"><a href="#增加中间表" class="headerlink" title="增加中间表"></a>增加中间表</h4><p>经常需要联合查询的数据，直接多开一个中间表</p><h4 id="增加冗余字段"><a href="#增加冗余字段" class="headerlink" title="增加冗余字段"></a>增加冗余字段</h4><p>反范数</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>整数</strong>：通常int，unsigned要用就用</p><p><strong>TIMESTAMP</strong>：TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p><p><strong>DECIMAL</strong>代替FLOAT和DOUBLE存储精确浮点数：精准的浮点数、4B存储9位，且可以存储比bigint大的整型数据</p><h3 id="④-大表优化"><a href="#④-大表优化" class="headerlink" title="④ 大表优化"></a>④ 大表优化</h3><h4 id="1-限定查询的范围"><a href="#1-限定查询的范围" class="headerlink" title="1 限定查询的范围"></a>1 限定查询的范围</h4><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p><h4 id="2-读-写分离"><a href="#2-读-写分离" class="headerlink" title="2 读&#x2F;写分离"></a>2 读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055493.png" alt="image-20230307161543744"></p><h4 id="3-垂直拆分"><a href="#3-垂直拆分" class="headerlink" title="3.垂直拆分"></a>3.垂直拆分</h4><p>冷热数据分离，也可以是经常使用的放一起</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055494.png" alt="image-20230307161824905"></p><h4 id="4-水平拆分"><a href="#4-水平拆分" class="headerlink" title="4.水平拆分"></a>4.水平拆分</h4><p>数据量尽量控制在1000w以内</p><p>按某个属性如年份划分到不同的表</p><p>但表数据还是同一个机器上，并发量还是上不去，还是<code>分库</code>比较好。</p><p>拆分会带来逻辑、部署、运维的复杂度</p><h2 id="事务"><a href="#事务" class="headerlink" title="~事务"></a>~事务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055495.png" alt="image-20230311180107196"></p><p>MySQL中，只有InnoDB支持事务。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><strong>ACID</strong></h4><p><strong>原子性（atomicity）：</strong> 不可分割</p><p><strong>一致性（consistency）：</strong> 数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。</p><p><strong>隔离型（isolation）：</strong><code>不能被其他事务干扰</code>，<strong>锁</strong>来实现。下小节为对应隔离级别</p><p><strong>持久性（durability）：</strong> 提交后<code>永久改变</code>。通过 <code>事务日志</code>（<code>重做日志</code> 和 <code>回滚日志</code>）来实现</p><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>提交或者中止是一个事务生命周期的结束</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055496.png" alt="image-20230311175427170" style="zoom: 50%;" /><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 显式事务会关闭自动提交<br>BEGIN;<br>#或者<br>START TRANSACTION (READ ONLY \ READ WRITE);<br><br>SAVEPOINT savepoint_name<br># 将事务回滚到某个保存点。 事务还没结束<br>ROLLBACK TO [SAVEPOINT]<br><br>## 结束事务<br># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>COMMIT;<br># 回滚事务。即撤销正在进行的所有没有提交的修改<br>ROLLBACK;<br></code></pre></td></tr></table></figure><h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;autocommit&#x27;; <br>ON # 每个语句自动提交事务<br>SET autocommit = on\1 ;  OFF\0<br></code></pre></td></tr></table></figure><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>在并发场景下（若干个客户端连接），如何处理隔离</p><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><ol><li><p><strong>脏写</strong>（ Dirty Write ）：B在更新时，A先更新且commit了，但B rollback了，吞掉了A的更新。（实际上A需要排队）</p></li><li><p><strong>脏读</strong>（ Dirty Read ）：读取到了还没commit的数据</p></li><li><p><strong>不可重复读</strong>（ Non-Repeatable Read ）：一个事务两次读之间，值被别的人commit改了，导致每次读取不一样</p></li><li><p><strong>幻读</strong>（ Phantom ）：两次读之间，<code>插入</code>了一些新行（幻影记录）。</p></li></ol><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>解决上面的问题</p><p>1.<strong>读未提交</strong>（Read uncommitted）：内存有直接读内存</p><p>​    这种事务隔离级别下，select语句不加锁。</p><p>​    此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。</p><p>2.<strong>读已提交</strong>（Read committed）：读磁盘  Oracle</p><p>​    可避免 脏读 的发生。</p><p>​    在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。</p><p>3.<strong>可重复读</strong>（Repeatable read）：MySql  <code>SHOW VARIABLES LIKE &#39;tx_isolation&#39;;</code> <code>transaction_isolation</code></p><p>​    事务开始前尽可能创建快照（内存）。</p><p>​查询时<strong>先在快照区</strong>中查找数据的快照，如果快照区中没有该数据的快照，MySQL 就会<strong>再 undo 日志</strong>中查找该数据最新的修改操作，并将其还原到快照区中，然后再将数据返回给事务</p><p>​mysql其实也可以解决幻读，在锁里讲</p><p>4.<strong>串行化</strong>（Serializable ）：</p><p>​    可避免幻读</p><p>​加了行X锁，比如s1查询了id&#x3D;3的数据，s2的插入就会阻塞</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055497.png" alt="image-20230311183443046"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql，想永久修改需要修改配置文件<br>SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;<br>#其中，隔离级别格式：<br>&gt; READ-UNCOMMITTED<br>&gt; READ-COMMITTED<br>&gt; REPEATABLE-READ<br>&gt; SERIALIZABLE<br></code></pre></td></tr></table></figure><blockquote><p>隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。存储引擎层 (innodb) 生成</p><ul><li><p>REDO LOG 称为 <code>重做日志 </code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的<strong>持久性</strong>。</p><p><code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。</p></li><li><p>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的<strong>原子性</strong>、一致性。</p><p> <code>逻辑操作</code> 日志，INSERT则会记录一条对应DELETE。用于 <code>事务的回滚</code>和 <code>一致性非锁定读</code></p></li></ul><p>COMMIT用REDO实现，ROLLBACK用UNDO实现。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055498.png" alt="image-20230313105558624"></p><h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h3><p>保证事务的<strong>持久性</strong>。</p><ul><li>首先需要读取<code>磁盘</code> -&gt; 内存中的<code>Buffer Pool</code></li><li>发生修改更先更新<code>Buffer Pool</code>，再更新<code>磁盘</code>；更新了但没写入磁盘的叫<code>脏页</code>。</li><li>内存是正确的，但刷盘是比较慢的且可能宕机， 为了保证磁盘数据是正确的：<ol><li>疯狂一直刷盘（代价大），并且事务修改不相邻页面时，IO是<code>随机IO</code></li><li>引入redo日志</li></ol></li></ul><p>WAL技术 (<code>Write-Ahead Logging</code>)：先写日志（写入了就算事务成功），再写磁盘。</p><p>实现更低频率更高速度的刷盘：</p><ul><li>低频：redo日志占用的<code>空间小</code>（存储表空间ID、页号、偏移量以及需要更新的值）</li><li>高速：<code>顺序IO</code></li></ul><h4 id="redo特点"><a href="#redo特点" class="headerlink" title="redo特点"></a>redo特点</h4><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>一个事务多条语句,一条语句多条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><h4 id="redo日志组成"><a href="#redo日志组成" class="headerlink" title="redo日志组成"></a>redo日志组成</h4><ul><li><code>重做日志的缓冲 (redo log buffer)</code>：内存 <code>innodb_log_buffer_size</code> 16MB</li><li><code>重做日志文件 (redo log file) </code>：mysql&#x2F;data&#x2F;ib_logfile0  ib_logfile1</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055499.png" alt="image-20230312214754687"></p><blockquote><p>先持久化日志，再持久化数据(在commit后才会持久化)</p></blockquote><p>至此，关键的刷盘变成了<code>步骤3</code>，由参数<code>innodb_flush_log_at_trx_commit</code>控制</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。</li><li><code>设置为2</code> ：表示每次事务提交时都只把 <code>redo log buffer</code> 内容写入 <code>page cache</code>（OS对写入磁盘的优化，由OS决定，有小概率宕机），不进行同步。由os自己决定什么时候同步到磁盘文件。此时MYSQL挂了不影响</li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步（写入<code>page cache</code>并<code>同步磁盘</code>）（ 默认值，持久性的保证 ）</li></ul><p>此外：系统默认master thread每隔<strong>1s</strong>进行一次重做日志的同步：<code>redo log buffer</code>到<code>page cache</code>，然后刷盘</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055500.png" alt="image-20230312223435328"></p><p>或者写满<code>innodb_log_buffer_size</code>后刷盘。</p><h4 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h4><p>一个原子操作为一个<code>Mini-Transaction</code>，如一次插入。但一次插入可能移动多条数据，对应多个redo</p><p>一个MTR里的多个redo需要放在一起（不可分割），但一个事务内的多个MTR可以分割存放</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055501.png" alt="image-20230313101247985" style="zoom:67%;" /><p>t1、t2为两个事务，mtr_t1_1由多条redo组成<br>buffer由block组成，一个block512字节 <code>innodb_log_block_size</code>，对应一个扇区的大小</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055502.png" alt="image-20230313101924121"></p><p>头包含指针、已使用多少等信息</p><h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><ul><li><p><code>innodb_log_group_home_dir</code> 文件路径</p></li><li><p><code>innodb_log_files_in_group</code> 默认2组</p></li><li><p><code>innodb_log_file_size</code>  单个 redo log 文件设置大小，默认值为 <code>48M</code> </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055503.png" alt="image-20230313104804144"></p><p><code>write pos</code>指针（终点）：当前插入点</p><p><code>checkpoint</code>指针（起点）：checkpoint 和 write pos 之间为在内存中但还没写入磁盘，故障后需要恢复这部分数据</p></li><li><p><code>innodb_flush_log_at_trx_commit</code> 刷盘策略</p></li></ul><h4 id="施放时间"><a href="#施放时间" class="headerlink" title="施放时间"></a>施放时间</h4><ul><li>redo log 在事务的执行过程中不断记录。通常在事务提交时buffer-&gt;file。</li><li>理论上redo log file中的文件在数据写入磁盘（图4）后可以释放</li></ul><h3 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h3><p>更新数据前先更新undo log。在系统表空间，也可以使用独立表空间</p><p><strong>原子性：</strong>要么都做，要么都不做。可能发生意外，如何<code>逻辑恢复</code>到之前状态</p><ul><li>服务器错误、断电</li><li>手动ROLLBACK</li></ul><p>增删改都要记录反向操作</p><blockquote><p> undo日志为了实现持久化，需要同样会<strong>产生redo日志</strong>。</p></blockquote><p>在内存数据更新前先更新undo</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC</strong>（多版本并发控制）。当读取一条被占用的数据时，用undo读取之前的信息</li></ul><h4 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h4><p><code>innodb_undo_logs</code>个回滚段。一个回滚段多个页，一个页（可服务于多个事务，重用防止浪费）存放undo记录，</p><h4 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h4><ol><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。 （避免脏读）</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。（避免不可重复读）</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，可覆盖</li></ol><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li>正常提交就是提交，redo log file写入了就持久化了。在正常情况下rollback，根据undo日志回滚</li><li>如果没commit且没redo log file但宕机了，数据只内存中，不用改磁盘，事务结束</li><li>如果没commit但有redo log file宕机了，可以选择rollback，或者继续事务</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055505.png" alt="image-20230313161236154"></p><p>行格式中，每行数据都会有一个<code>事务id</code>，以及<code>回滚指针</code>（指向undo的指针）</p><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>undo log在操作过程中串联起来，记录下数据差异，回滚时逆向进行</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055506.png" alt="image-20230313161721869"></p><ol><li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除 </li><li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </li><li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </li><li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>实现事务的<code>隔离性</code></p><p>并发访问时的安全性</p><h3 id="并发事务情况"><a href="#并发事务情况" class="headerlink" title="并发事务情况"></a>并发事务情况</h3><ul><li><strong>读-读</strong> ：无影响</li><li><strong>写-写</strong>：<code>脏写</code>  <strong>必须加锁</strong>。 先来的加锁，后来的排队。先来的完成后把后来的激活</li><li><strong>读-写</strong>：<code>脏读、不可重复读、幻读</code>    <strong>重点关注</strong></li></ul><h3 id="读写解决"><a href="#读写解决" class="headerlink" title="读写解决"></a>读写解决</h3><ol><li>读（MVCC），写（加锁）。下章</li><li>读写都加锁。但插入的数据无法加，无法解决幻读 ；读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ol><p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是<strong>业务在某些特殊情况</strong>下，要求必须采用 <code>加锁 </code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h3 id="锁的类别"><a href="#锁的类别" class="headerlink" title="锁的类别"></a>锁的类别</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055507.png" alt="image-20230313164720406"></p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>InnoDB可以加表上、也可以加行上</p><ul><li><p>共享锁S：读也可以加X锁，这里是手动加锁。(MVCC中的当前读)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT   LOCK IN SHARE MODE<br>SELECT   FOR UPDATE (nowait 锁了就直接返回、不等待)<br></code></pre></td></tr></table></figure></li><li><p>排他锁X：写锁，会阻断X和S。有S时也不能加X。一直等到超时</p><ul><li>DELETE：X锁</li><li>INSERT：<code>隐式锁</code>，因为一开始没有空间</li><li>UPDATE：<ul><li>修改了主键：先del再insert</li><li>空间没有变：X锁</li><li>空间变化了：相当于修改主键，先del再insert</li></ul></li></ul></li></ul><h4 id="表-行-页-锁"><a href="#表-行-页-锁" class="headerlink" title="表 行 页 锁"></a>表 行 页 锁</h4><p>粒度越小，开销越大，并发性越高。InnoDB提供到行锁</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p><strong>不依赖于存储引擎</strong>，策略一样</p><h6 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h6><p>表锁：InnoDB一般在崩溃恢复时才加，MyISAM默认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">`LOCK TABLES t READ`   `S锁`<br>`LOCK TABLES t WRITE`  `X锁` <br><br># 查看<br>SHOW OPEN TABLES; # 主要关注In_use字段的值<br>或者<br>SHOW OPEN TABLES where In_use &gt; 0;<br><br>UNLOCK TABLES; # 使用此命令解锁当前加锁的表<br></code></pre></td></tr></table></figure><p>MyISAM&#x3D;&#x3D;默认会在执行CRUD时对整个表加锁&#x3D;&#x3D;，只能读-读，导致查询性能下降的原因。InnoDB不加</p><p>注意加锁后，不能操作别的表了</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055508.png" alt="image-20230316144257602"></p><h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>InnoDB原本想加表锁，需要遍历全部数据查看有没有行锁</p><p>A加了行X锁后，自动加一个表的<code>X意向锁</code>（代表A有意向去操作整张表）其他人B就加不了表锁。  存储引擎 <code>维护</code> </p><p>也就是B加锁前，除了看有没有锁，还要看有没有同级别的意向锁的存在</p><ul><li><strong>协调</strong>多粒度锁共存，方便在加表锁时，查看有没有行锁</li></ul><h6 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h6><p><code>AUTO_INCREMENT</code></p><p>多并发下如何实现自增</p><p>直接加锁 等、</p><h6 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h6><p>DDL操作加锁：别人在读数据时，你不能改表结构</p><h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><ul><li><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</li><li><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</li></ul><p>① <strong>记录锁</strong>（Record Locks）</p><p>​<code>LOCK_REC_NOT_GAP</code>，就是正常的X、S锁。只有S-S共享</p><p>​例：一个事务在更新（自动加X），另一个不可以<code>select .. lock in share mode</code>，但可以直接读（MVCC）</p><p>② <strong>间隙锁</strong>（Gap Locks）</p><p>​在RR级别下<strong>解决幻读</strong></p><p>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t WHERE id BETWEEN 100 AND 200；<br>查询后，100~200之间加上间隙锁，禁止再插入数据<br></code></pre></td></tr></table></figure><p>③ <strong>临键锁</strong>（Next-Key Locks）</p><p>​一个<code>记录锁</code>和一个<code>gap锁</code>的合体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin;<br>select * from student where id &lt;=8 and id &gt; 3 for update;<br></code></pre></td></tr></table></figure><h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><p>页锁就是在 <code>页的粒度</code> ，粒度在表和行之间</p><h4 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h4><p><strong>悲观锁：</strong>认为别人会影响自己，总是加锁阻塞其他线程。数据库实现 <code>synchronized</code>  <code>ReentrantLock</code> </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055509.png" alt="image-20230316161045465"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055510.png" alt="image-20230316161155532"></p><p>加锁后等待时间较长，所有扫描到的数据都会锁定，因此必须要索引</p><p><strong>乐观锁</strong></p><p>不上锁。</p><p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version=version+1 WHERE version=version</code> 。version不一样说明别人修改过了</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055511.png" alt="image-20230316161722838"></p><p>上面可能会导致失败太多，再更新。减库存前先判断</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055512.png" alt="image-20230316161931349"></p><p><code>乐观锁</code> 适合 <code>读操作多</code> ，悲观锁相反</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055513.png" alt="image-20230316162041048"></p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>整个数据库只读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Flush tables with read lock<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055514.png" alt="image-20230316163506070"></p><ol><li>互斥条件：资源不能被共享，即每个资源一次只能被一个进程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完后自己释放。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h5 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h5><p><strong>方式1：</strong>等待，直到超时（<code>innodb_lock_wait_timeout</code>&#x3D;50s)。不太好</p><p><strong>方式2：</strong>使用死锁检测处理死锁程序， <code>wait-for graph</code>算法</p><p>需要存储全部事务构建的锁信息，构建等待图，存在环就存在死锁</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055515.png" alt="image-20230316164435644" style="zoom: 80%;" /><p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p><p>复杂度还是比较高</p><h3 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h3><p>InnoDB使用锁信息来跟踪行级锁。锁信息（<code>lock_t</code>）存储在锁管理器（<code>lock manager</code>），去锁管理器中查询该行是否被锁定。</p><p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055516.png" alt="image-20220714132306208"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息 </code>：</p><p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个 事务的指针</p><p><code>2. 索引信息</code> ：</p><p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code> ：</p><p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><ul><li><code>Space ID</code> ：记录所在表空间。</li><li><code>Page Number</code> ：记录所在页号。</li><li><code>n_bits </code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul><p><code>4. type_mode</code> ：</p><p>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055517.png" alt="image-20220714133319666"></p><ul><li>锁的模式（ <code>lock_mode</code> ），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code> 。 </li><li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code> 。 </li><li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code> 。 </li><li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code> 。 </li><li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code> 。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（ <code>lock_type</code> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC </code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（ <code>rec_lock_type</code> ），使用其余的位来表示。只有在 <code>lock_type</code> 的值为 <code>LOCK_REC</code> 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code> 。</li><li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code> 。</li><li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code> 。</li><li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code> 属性呢？基于内存空间的节省，所以把 <code>is_waiting</code> 属性放到了 <code>type_mode</code> 这个32 位的数字中：<ul><li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code> ：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code> ：</p><p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits</code> 属性 表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no</code> 属性，伪记录 <code>Infimum</code> 的 <code>heap_no</code> 值为 0 ， <code>Supremum</code> 的 <code>heap_no</code> 值为 1 ，之后每插入一条记录， <code>heap_no</code> 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no</code> ，即一个比特位映射 到页内的一条记录。</p><h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询正在被锁阻塞的sql语句。<br>SELECT * FROM information_schema.INNODB_TRX\G;<br># 查询锁等待情况<br>SELECT * FROM data_lock_waits\G;<br># 查询锁的情况<br>SELECT * from performance_schema.data_locks\G;<br></code></pre></td></tr></table></figure><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC （Multiversion Concurrency Control），隔离级别我们可以设置，MVCC是如何实现隔离级别(RM和RR)</p><p>解决<code>读-写</code>冲突，读不加锁。读为<strong>快照读</strong>，写为<strong>当前读</strong></p><p>组成：<code>隐藏字段</code>、<code>undo日志</code>、<code>ReadView</code></p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>基本的<code>select</code>。隔离级别不是串行级别</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>为读到最新数据，加锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁，锁上后别人不能修改<br>SELECT * FROM student FOR UPDATE; # 排他锁<br>INSERT INTO student values ... # 排他锁<br>DELETE FROM student WHERE ... # 排他锁<br>UPDATE student SET ... # 排他锁<br></code></pre></td></tr></table></figure><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><h4 id="隔离级别-1"><a href="#隔离级别-1" class="headerlink" title="隔离级别"></a>隔离级别</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055518.png" alt="image-20230317134757906" style="zoom:67%;" /><h4 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h4><ul><li>隐藏字段包含：<ul><li><code>trx_id</code> ：最后一次修改的事务id</li><li><code>roll_pointer</code>: 操作的记录信息</li></ul></li><li>Undo Log版本链：包含历史信息</li></ul><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>如事务8插入了一条数据</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055519.png" alt="image-20230317135028917"></p><p>此时两个事务分别进行2次修改，注意他们不能同时更新，只能一个commit后再一个更新：<code>写锁</code></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055520.png" alt="image-20230317135251185" style="zoom:67%;" /><p>在完成后，第一条为记录，历史版本串成了undo日志</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055521.png" alt="image-20230317135348858"></p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p><p><strong>ReadView</strong>: <strong>事务</strong>在进行<strong>快照读</strong>时产生的 <strong>读视图</strong>（一对一）。有一个数组记录活跃事务ID</p><ul><li><code>READ UNCOMMITTED</code> ：读未提交，就是最新数据。&#x3D;&#x3D;不使用&#x3D;&#x3D;</li><li><code>READ COMMITTED</code>：每次读之前都会新生成一个视图</li><li><code>REPEATABLE READ</code>：第一次读时生成</li><li><code>SERIALIZABLE</code>：从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。并发度急剧下降，不建议使用。</li></ul><h4 id="ReadView组成"><a href="#ReadView组成" class="headerlink" title="ReadView组成"></a>ReadView组成</h4><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><p><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在<strong>CUD</strong>才会为 事务分配事务id，否则在<strong>R</strong>事务中的事务id值都默认为0。</p></blockquote></li><li><p><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p></li><li><p><code>up_limit_id</code> ，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>为什么需要: 如果读到了在trx_ids中的，或者大于low_limit_id，什么数据被修改了，那就要回滚undo读历史版本</p><p>up_limit_id 作用就是方便比较，小于up_limit_id 的就可以直接读</p></blockquote><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p><code>trx_ids</code> ：   [<code>up_limit_id</code>  …     ]   <code>low_limit_id</code> </p><p><strong>规则：</strong></p><ul><li>快照读：如果改事务读到的行记录的<code>trx_id</code>&gt;&#x3D;<code>low_limit_id</code> || <code>trx_id</code> in <code>trx_ids</code> ,   说明这个行版本在事务创建后被修改过，就需要沿着Undo<strong>一直倒退</strong>到事务创建时的版本：<code>trx_id</code>&lt;<code>low_limit_id</code> || <code>trx_id</code> not in <code>trx_ids</code> 。</li><li>当前读：必须读取最新版本，也就是直接读到的数据</li></ul><p>步骤判断：</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><p>再根据生成规则，<code>READ COMMITTED</code>(每次读生成)  <code>REPEATABLE READ</code>(事务生成时生成)，这两种隔离级别都实现了。</p><h4 id="幻读解决"><a href="#幻读解决" class="headerlink" title="幻读解决"></a>幻读解决</h4><p><strong>快照读：</strong>插入的数据一定是活跃的事务或未来的事务：<code>trx_id</code>&gt;&#x3D;<code>low_limit_id</code> || <code>trx_id</code> in <code>trx_ids</code> ，也不能倒退版本，根据规则就被MVCC直接忽略了</p><p><strong>当前读：</strong>MVCC无法解决。A查询id&gt;3,B插入id&#x3D;6，A更新id&#x3D;6(当前读)，至此之后A都会读到幻影记录6.</p><p>​解决办法：在A查询id&gt;3时，自动添加<strong>间隙锁</strong>(RR并且有索引)。</p><p><a href="https://blog.csdn.net/Edwin_Hu/article/details/124392174">MVCC 幻读问题</a></p><p><a href="https://blog.csdn.net/Edwin_Hu/article/details/124392174">间隙锁原理</a></p><h2 id="事务总结"><a href="#事务总结" class="headerlink" title="事务总结"></a>事务总结</h2><p><strong>原子性：</strong> <code>undo日志</code>实现回滚，保证操作原子性</p><p><strong>隔离型：</strong>读-读、读-写（锁 或者 MVCC+锁）、写-写(锁)</p><p><strong>持久性：</strong> <code>redu日志</code>实现，数据持久化前，先把操作持久化</p><p>目标：<strong>一致性：</strong>  数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.bilibili.com/video/BV1vg411p7uJ">字节数据库优化</a>  <a href="https://mp.weixin.qq.com/s/CaSVhAJgycjjbCxAkII2ZA">慢 SQL 分析与优化</a></p><p><strong>InnoDB</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062055522.png" alt="image-20221206102707216"></p><p><strong>回表查询</strong>：先根据筛选条件在普通索引上定位id，再拿id再聚集索引上定位行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shenjian&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> id, name, sex <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shenjian&#x27;</span>; 需要回表<br></code></pre></td></tr></table></figure><p>limit: 先查询全部数据，再进行过滤   优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">（全部sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span>的数据要回表）<br><span class="hljs-keyword">SELECT</span> o1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span> LIMIT <span class="hljs-number">10000</span>,<span class="hljs-number">10</span> <br><br>（只回表<span class="hljs-number">10</span>条数据）<br><span class="hljs-keyword">SELECT</span> o1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders o1<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> sn<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XD12345678&#x27;</span> LIMIT <span class="hljs-number">10000</span>,<span class="hljs-number">10</span>) o2<br><span class="hljs-keyword">ON</span> o1.id <span class="hljs-operator">=</span> o2.id;<br></code></pre></td></tr></table></figure><p>不使用子查询：先查外表，外表大很慢</p><p>IN代替or：IN会将数组先排序，然后用二分去查找</p><p>少用select *</p><p>where groupby having  先where过滤</p><p>exists和in区别，要用<strong>小表驱动大表</strong>，因为是以驱动表建立for循环　<strong>被驱动表走索引</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">exists用外表驱动内表，拿一条条外表数据去内标查       适合外小内大<br>in反过来，先查询内表，再拿数据去外表走索引<br>子查询in exists:https:<span class="hljs-comment">//blog.csdn.net/wpc2018/article/details/122948692</span><br></code></pre></td></tr></table></figure><p>join的驱动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>）当连接查询没有<span class="hljs-keyword">where</span>条件时<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> 前面的表是驱动表，后面的表是被驱动表<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 后面的表是驱动表，前面的表是被驱动表<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">join</span> 会自动选择表数据比较少的作为驱动表<br>straight_join(≈<span class="hljs-keyword">join</span>) 直接选择左边的表作为驱动表（语义上与<span class="hljs-keyword">join</span>类似，但去除了<span class="hljs-keyword">join</span>自动选择小表作为驱动表的特性）<br><br><span class="hljs-number">2</span>）当连接查询有<span class="hljs-keyword">where</span>条件时，带<span class="hljs-keyword">where</span>条件的表是驱动表，否则是被驱动表<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不渲染的文章</title>
    <link href="/2023/01/01/book/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/01/01/book/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这本书涵盖了网络协议栈、服务器编程以及相关优化策略的内容，涵盖了TCP协议栈、服务器编程的API、程序框架、IO单元、逻辑单元多线程多进程等内容，还包括了性能优化与检测。书中详细介绍了数据链路层、网络层、传输层和应用层的功能：数据链路层负责局域网内的可靠传输，基于MAC地址；网络层实现跨网络传输，负责路由选择和逻辑寻址，使用IP地址标识设备，并通过路由器转发数据包；传输层提供端到端的通信服务，通过端口号区分应用程序，实现可靠性传输或高效传输，并提供流量控制、拥塞控制等功能；应用层直接面向用户和应用程序，定义数据格式和交互规则，如HTTP请求&#x2F;响应模型。操作系统通过Socket API为应用程序提供访问协议栈的接口，如send和read函数用于数据的传输和接收。书中还提到无状态、无连接、不可靠的特性。</p></blockquote><p>大部分内容APUE和UNP里面都有讲过，不过这本书也讲到了那两本书里面所没有的知识，比如epoll、Reactor&#x2F;Proactor模式和进程池等东西。</p><ul><li>1～4 tcp协议栈</li><li>5～15 服务器编程<ul><li>5～7 API</li><li>8 程序框架</li><li>9～12 io单元</li><li>13～15 逻辑单元多线程多进程</li></ul></li><li>16 ～17服务器性能优化检测</li></ul><h3 id="tcp-ip协议栈"><a href="#tcp-ip协议栈" class="headerlink" title="tcp-ip协议栈"></a>tcp-ip协议栈</h3><ul><li><strong>数据链路层</strong>： <ul><li>局域网LAN内相邻设备通讯，确保数据在物理介质上的可靠传输。</li><li>基于MAC地址。</li></ul></li><li><strong>网络层</strong>： <ul><li>跨网络传输，核心任务是<strong>路由选择</strong>和<strong>逻辑寻址</strong>。</li><li>使用<strong>IP地址</strong>标识设备，将传输层的数据段封装为<strong>数据包（Packet）</strong>，并通过路由器在不同网络间转发。</li><li>Identification Flags 和Fragment offset 实现拆包重组。</li></ul></li><li><strong>传输层</strong>：<ul><li>提供<strong>端到端（进程到进程）的通信服务</strong>，通过<strong>端口号</strong>区分不同应用程序。</li><li>实现<strong>可靠性传输</strong>（如TCP）或<strong>高效传输</strong>（如UDP）。</li><li>提供流量控制、拥塞控制、错误恢复等功能。</li></ul></li><li><strong>应用层：</strong><ul><li>直接面向用户和应用程序，提供具体的网络服务。</li><li>定义数据格式和交互规则（如HTTP请求&#x2F;响应模型）。</li></ul></li></ul><p><img src="/./Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20240329150618349.png" alt="image-20240329150618349"></p><p><img src="/./Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20250515105703672.png" alt="image-20250515105703672"></p><p>数据链路层、网络层和传输层在内核中实现，os提供api是的应用程序能够使用这些协议服务：socket</p><ul><li>send：将应用程序数据从用户缓冲区复制到TCP&#x2F;UDP内核缓冲区</li><li>read：从TCP&#x2F;UDP内核缓冲区复制到用户缓冲区</li></ul><h4 id="ip层"><a href="#ip层" class="headerlink" title="ip层"></a>ip层</h4><p><img src="/./Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20250515114824580.png" alt="image-20250515114824580"></p><p>无状态、无连接、不可靠</p><h4 id="tcp层"><a href="#tcp层" class="headerlink" title="tcp层"></a>tcp层</h4><p><img src="/./Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20250515135856704.png" alt="image-20250515135856704"></p><p><img src="/./Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.assets/image-20250515135838985.png" alt="image-20250515135838985"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot笔记</title>
    <link href="/2022/12/30/springboot/"/>
    <url>/2022/12/30/springboot/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文介绍了SpringBoot如何简化项目配置和开发流程，以及其核心特性和常用功能的实现方法。主要内容包括：  SpringBoot相比传统Spring的优势：内嵌Tomcat、单一容器、自动配置、无需XML文件，通过约定简化Maven依赖管理。主要约定包括单一入口类（含main方法）和固定位置的配置文件（application.yml&#x2F;properties）。  项目创建方式：可通过继承spring-boot-starter-parent父项目统一管理版本，或直接依赖spring-boot-starter-web。核心注解@SpringBootApplication组合了配置加载、自动配置和组件扫描功能。  配置管理：支持多环境配置（dev&#x2F;test&#x2F;prod），支持外部配置文件启动；通过@Value单个注入或@ConfigurationProperties批量注入属性；提供热部署插件devtools。  核心功能实现： 1. 对象管理：通过@Configuration+@Bean替代XML配置，沿用@Service等注解创建对象 2. Web开发：需引入tomcat-embed-jasper支持JSP，配置视图解析器 3. 数据访问：整合MyBatis只需配置数据源、Mapper路径和别名包 4. 事务管理：直接使用@Transactional注解 5. 单元测试：@SpringBootTest支持，注意JUnit版本差异  其他关键特性： - 日志系统：默认集成Logback，可分级配置 - AOP实现：通过@Aspect注解定义切面和通知 - 拦截器配置：实现WebMvcConfigurer接口 - 文件上传：配置Multipart属性限制大小 - 异常处理：@ControllerAdvice统一处理 - 跨域支持：@CrossOrigin注解或全局配置CorsFilter - 配置加密：使用jasypt保护敏感信息 - RESTful接口：通过HTTP方法区分CRUD操作  文中还包含具体配置示例和代码片段，展示了从基础配置到高级功能的全套解决方案。SpringBoot通过”约定优于配置”理念，显著降低了Spring应用的开发复杂度。</p></blockquote><h3 id="0-对比"><a href="#0-对比" class="headerlink" title="0.对比"></a>0.对比</h3><p>模板化的大量配置文件，不需要tomcat运行。遵循约定，简化配置</p><p>springboot只是进一步的升级，简化项目搭建和开发。引入依赖，几行配置</p><p>springboot 微框架 &#x3D; springmvc 控制器+ spring core项目管理</p><ul><li>spring存在父容器spring.xml,子容器springmvc.xml。springboot只有一个</li><li>内嵌tomcat</li><li>简化maven，自动配置spring springmvc，没有xml</li></ul><p>约定：</p><ul><li>只有一个入口类 xxxxApplication.java，在所有子包目录之上； 需要main项目启动函数</li><li>配置文件：根目录resources中application.yml | application.properties</li></ul><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050658.png" alt="image-20221216212408119" style="zoom: 80%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050660.png" alt="image-20221216202540351"></p><h3 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h3><ol><li><pre><code class="xml">创建spring项目，勾选springweb or创建maven项目继承父项目 便于维护版本&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">   <br><span class="hljs-number">2.</span> 配置文件变成小树叶<br><br><span class="hljs-number">3.</span> ```java<br>   @SpringBootApplication 入口类，整个项目的总入口<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AdminApplication</span> &#123;<br>   <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>           <span class="hljs-comment">// 入口类对象，参数（可以动态设置参数，如端口等）</span><br>           SpringApplication.run(AdminApplication.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">args</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>写一个@RestController</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs j'a'v">@SpringBootApplication<br>    @SpringBootConfiguration  加载spring springmvc环境<br>    @EnableAutoConfiguration  开启自动配置 自动配置核心注解，配置spring以及第三方环境 <br>    @ComponentScan 组件扫描 当前包以及子包 <br>    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;<br></code></pre></td></tr></table></figure><h3 id="2-多配置文件"><a href="#2-多配置文件" class="headerlink" title="2.多配置文件"></a>2.多配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br> <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># 规定走dev环境</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>      <br></code></pre></td></tr></table></figure><p>多环境情况：application为公共的</p><p>​application.yml          application-test.yml        application-dev.yml       application-prod.yml </p><p>此外，以外部生产配置文件启动（包含数据库隐私等）</p><p>java -jar –spring.config.location &#x3D; filepath  xxx.jar</p><h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h3><p>springboot 微框架 &#x3D; springmvc 控制器</p><p>​ + spring  管理项目对象</p><p><strong>spring创建对象</strong></p><ol><li>&lt; bean &gt;</li><li>注解实现创建对象，需要扫描@Componet ，只是名称不同，为了更好的理解</li></ol><ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p><strong>Springboot</strong>：</p><ol><li><p>@configuration 定义配置类   相当于xml。 </p><p>​里面@Bean ，用在方法上，返回值交给工厂。默认方法名是id（或者@bean(“beanid”)）。 相当于&lt; bean&gt;</p></li><li><p>注解实现创建对象，启动时自动扫描了     指定名称: @Service(“helloImpl”)   @Qualifier(value &#x3D; “helloImpl”)</p><ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul></li></ol><h3 id="4-属性注入"><a href="#4-属性注入" class="headerlink" title="4.属性注入"></a>4.属性注入</h3><p>和spring一样，但都通过注解实现。包含引用类型和基本类型</p><ol><li><p>@Value(“${user.name}”)   @Value(“xiaoming”)     单个注入</p><ul><li>数组也可以直接注入，yml逗号隔开</li><li>maps: “{‘aa’:’你好’}”   #{${maps}}</li></ul></li><li><p>批量注入，用在类上， @ConfigurationProperties(“spring.datasource”)</p><p>自动找spring.datasource里面的属性，按名称注入到类的属性中，需要提供set方法</p></li></ol><p>@Autowired</p><h3 id="5-JSP集成"><a href="#5-JSP集成" class="headerlink" title="5.JSP集成"></a>5.JSP集成</h3><p>引入依赖 tomcat-embed-jasper ，解析jsp</p><p>java同级的webapp文件夹 </p><p>原来springmvc有视图解析器，现在是设置配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span><br></code></pre></td></tr></table></figure><p>通过插件启动，以防idea找不到jsp</p><h3 id="6-整合Mybatis"><a href="#6-整合Mybatis" class="headerlink" title="6.整合Mybatis"></a>6.整合Mybatis</h3><p>0.引入依赖 </p><ul><li>spring-boot-starter-web</li><li>mysql驱动  druid数据源</li><li>mybatis-spring-boot-starter</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.配置数据源</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>  <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>  <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/challenge2?serverTimezon=UTC&amp;userUnicode=true&amp;characterEncoding=utf-8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <br><span class="hljs-string">等价</span><br><span class="hljs-string">&lt;!--使用spring数据源--&gt;</span><br><span class="hljs-string">&lt;bean</span> <span class="hljs-string">id=&quot;dataSource&quot;</span> <span class="hljs-string">class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;driverClassName&quot;</span> <span class="hljs-string">value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;url&quot;</span> <span class="hljs-string">value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;username&quot;</span> <span class="hljs-string">value=&quot;root&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;password&quot;</span> <span class="hljs-string">value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="hljs-string">&lt;/bean&gt;</span><br></code></pre></td></tr></table></figure><p>2.创建Factory,指定mapper文件的位置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.dhu.yarn.entity</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com.dhu.yarn/mapper/*.xml</span><br>  <span class="hljs-comment"># 下滑线转大写 </span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">等价</span><br><span class="hljs-string">&lt;bean</span> <span class="hljs-string">id=&quot;sqlSessionFactory&quot;</span> <span class="hljs-string">class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br>    <span class="hljs-string">&lt;!--数据源--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;dataSource&quot;</span> <span class="hljs-string">ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;!--mapper--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;mapperLocations&quot;</span> <span class="hljs-string">value=&quot;classpath:com/kuang/mapper/*.xml&quot;&gt;&lt;/property&gt;</span><br>    <span class="hljs-string">&lt;!--绑定mybatis配置文件--&gt;</span><br>    <span class="hljs-string">&lt;property</span> <span class="hljs-string">name=&quot;configLocation&quot;</span> <span class="hljs-string">value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span> <span class="hljs-string">(可以不要)</span><br><span class="hljs-string">&lt;/bean&gt;</span><br></code></pre></td></tr></table></figure><p>3.@MapperScan(“com.xun.dao”)  扫描Dao接口所在的包，同时创建bean 。可能爆红但不影响</p><p>or  @Mapper一个一个创建添加，让mybatis找到，表示他是用来访问数据库的 ，对应Mapper接口。同时可以创建bean</p><p>​@Repository只可以创建普通bean，所以只起标识作用。单独使用bean of type BookMapper that could not be found.</p><p>等价</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不用配置开启事务，直接在serviceImpl上@Transactional</p><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot2ApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test 用在Spring Boot <span class="hljs-number">2.2</span>.X以后   JUnit <span class="hljs-number">5</span><br><span class="hljs-keyword">import</span> org.junit.Test用在<span class="hljs-number">2.2</span>.x之前     添加 <span class="hljs-meta">@RunWith(SpringRunner.class)</span> 否则注释将被忽略 <br></code></pre></td></tr></table></figure><p>@Autowired service 层 ，调试单个service函数很快</p><h3 id="8-热部署"><a href="#8-热部署" class="headerlink" title="8.热部署"></a>8.热部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--热部署--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--是否不能传递--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>2. 勾选Build project automatically     修改了就编译生成.class文件<br>3. ctrl+alt+s，进入设置，然后选择高级设置，在Compiler下勾选 Allow auto-make to restart even if developed application is currently running    自动加载新的class到jvm<br><br>ctrl s保存后，等待日志<br></code></pre></td></tr></table></figure><h3 id="9-日志"><a href="#9-日志" class="headerlink" title="9.日志"></a>9.日志</h3><p>默认集成logback，和log4j作用一样</p><p>日志级别：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050661.png" alt="image-20221219112645808" style="zoom: 80%;" /><p>rootLogger默认</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050662.png" alt="image-20221219113216242" style="zoom:80%;" /><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">info</span>  <span class="hljs-comment">#如果修改为debug， 信息变多了</span><br>    <span class="hljs-attr">com.baizhi.mapper:</span> <span class="hljs-string">debug</span> <span class="hljs-comment"># 把mapper层设置为debug，可以显示sql日志</span><br>  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次都要生成</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(当前类.class);<br>logger.info(<span class="hljs-string">&quot;12312&quot;</span>) # 代替sout<br>logger.error(<span class="hljs-string">&quot;端口冲突,异常信息：&#123;&#125; &#123;&#125;&quot;</span>, <span class="hljs-string">&quot;第一个参数&quot;</span>, <span class="hljs-string">&quot;第二个参数&quot;</span>);<br><br>注解实现<br><span class="hljs-meta">@Slf4j</span><br>log.info(<span class="hljs-string">&quot;测试log-------------------------&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="10-小项目"><a href="#10-小项目" class="headerlink" title="10.小项目"></a>10.小项目</h3><p>密码要md5（不可逆）加密保存，登录时将将密码转换后进行对比。传统项目成功后存入session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newpassword</span> <span class="hljs-operator">=</span> DigestUtils.md5DigestAsHex(password.getBytes(StandardCharsets.UTF_8))<br></code></pre></td></tr></table></figure><p>出现业务错误时，抛出异常</p><p>controller除了返回到页面，还包含跳转到别的controlle，注意使用forward还是redirect。</p><p>​如添加完成员工接口后redirect到查询接口，查询完成后forward到显示界面</p><h3 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11.AOP"></a>11.AOP</h3><p><strong>spring</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">附加操作 继承接口<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>              System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">配置bean；配置切入点，组装切面<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aop.Log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--   切入点   execution:执行的位置     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserserviceImpl.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot</strong></p><p>  无xml文件</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--aop日志--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写切面类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// spring配置类  spring.xml</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 这个类是切面类 aop:config</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspectConfig</span> &#123;<br>    <br>    <span class="hljs-comment">// 切入点</span><br>    <span class="hljs-meta">@within(&quot;execution(com.xun.springboot2.controller.*)&quot;)</span> <span class="hljs-comment">//类级别</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.xun.springboot2.controller.*.*(..))&quot;)</span> <span class="hljs-comment">//方法级别</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">controllerLog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 切面 = 通知（Advice）+ 切入点（pointcut）</span><br>    <span class="hljs-meta">@Before(&quot;controllerLog()&quot;)</span>  <span class="hljs-meta">@After</span>    还可以针对注解生效<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Around(&quot;controllerLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;around start&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> proceedingJoinPoint.proceed(); <span class="hljs-comment">// 需要返回方法中的数据</span><br>        System.out.println(<span class="hljs-string">&quot;around end&quot;</span>);<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="12-拦截器"><a href="#12-拦截器" class="headerlink" title="12.拦截器"></a>12.拦截器</h3><p><strong>spring</strong>：编写类，return true放行。然后注入bean并且配置拦截哪些请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拦截器注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以写多个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.JWTInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  或者分开 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span> = <span class="hljs-string">&quot;beanname&quot;</span>&gt;</span><br>    &lt;/mvc:interceptor &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot</strong></p><ol><li>编写类，return true放行。&#x2F;&#x2F; 多个拦截器是栈结构，pre1  pre2  do  post2  post1</li><li>编写配置类，implements WebMvcConfigurer    (原来写在springmvc.xml里，现在实现WebMvcConfigurer，WebMvcConfigurer里面包含很多mvc的配置方法，如addResourceHandlers)<ul><li>使用哪个拦截器</li><li>拦截哪些</li><li>排除哪些</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JWTInterceptor</span>())<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/image/**&quot;</span>)<br>            .order(<span class="hljs-number">1</span>) <span class="hljs-comment">// 先执行</span><br>        ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-文件上传下载"><a href="#13-文件上传下载" class="headerlink" title="13.文件上传下载"></a>13.文件上传下载</h3><p>上传到服务器本地、阿里云oss  </p><p>打包成jar时，不能上传到项目内部的某个文件夹，因此直接上传到机器一个固定目录（配置文件注入）</p><p>本地和生产不同，使用多个配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">发送</span> <span class="hljs-string">multipart/form-data</span><br><span class="hljs-string">接受</span> <span class="hljs-string">MultipartFile</span> <span class="hljs-string">f</span><br><br><br><span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">300MB</span> <span class="hljs-comment"># 单个文件大小</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">500MB</span> <span class="hljs-comment"># 设置总上传的数据大小</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启</span><br></code></pre></td></tr></table></figure><p><strong>下载</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062050663.png" alt="image-20221225202709373"></p><h3 id="14-异常处理"><a href="#14-异常处理" class="headerlink" title="14.异常处理"></a>14.异常处理</h3><p>传统的：继承HandlerExceptionResolver，不同异常不同if处理</p><p><strong>springboot:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span>        <span class="hljs-comment">// 默认监控全部controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalException</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(BusinessException.class)</span> <span class="hljs-comment">// 处理哪个异常</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">handleBusinessException</span><span class="hljs-params">(HttpServletRequest request, BusinessException ex)</span> &#123;<br>        log.error(<span class="hljs-built_in">this</span>.getClass()+<span class="hljs-string">&quot;业务异常：&quot;</span>+ex.getMessage()+<span class="hljs-string">&quot; 代码:&quot;</span>+ex.getCode());<br>        <span class="hljs-keyword">return</span> Result.error(ex.getCode(), ex.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-CORS"><a href="#15-CORS" class="headerlink" title="15.CORS"></a>15.CORS</h3><p> 跨域资源共享</p><p>源：协议 域名 端口。默认情况下，不同源不能互相访问。ajax  </p><p>controller类上@CrossOrigin 允许跨域访问</p><p>全局配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> CorsConfiguration <span class="hljs-title function_">buildConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        <span class="hljs-comment">// 1允许服务端访问</span><br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 2允许任何头</span><br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 3允许任何方法（post、get等）</span><br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.setMaxAge(<span class="hljs-number">600L</span>);<br>        <span class="hljs-comment">// 4 允许withCredentials报文头</span><br>        corsConfiguration.setAllowCredentials(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> corsConfiguration;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, buildConfig());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-加密"><a href="#16-加密" class="headerlink" title="16.加密"></a>16.加密</h3><p>jasypt对密码进行加密。提供一个类进行加密和解密，需要配置密钥，没有密钥解密会失败。在运行时传参输入密钥</p><p>使用：ENC(加密后字符串)</p><h3 id="17-传参"><a href="#17-传参" class="headerlink" title="17.传参"></a>17.传参</h3><p> 参考sping里springmvc传参</p><h3 id="18-restful"><a href="#18-restful" class="headerlink" title="18.restful"></a>18.restful</h3><p>用访问方法指明操作，put要id和User，先查再改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getAllUsers</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId)</span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId,</span><br><span class="hljs-params">                                                   <span class="hljs-meta">@RequestBody</span> User userDetails)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Boolean&gt; <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(value = &quot;id&quot;)</span> Long userId)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring笔记</title>
    <link href="/2022/12/20/spring/"/>
    <url>/2022/12/20/spring/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>本文主要介绍了Spring框架的几个核心概念和技术，包括IOC（控制反转）和DI（依赖注入）、AOP（面向切面编程）、Spring对MyBatis的整合以及SpringMVC的基础知识。  1. <strong>IOC和DI</strong>    - IOC将对象的创建权交给Spring工厂，通过配置文件管理对象的创建和依赖关系。DI维护对象之间的关系，通常通过setter方法或构造器注入实现。  2. <strong>AOP</strong>    - AOP的底层原理是动态代理，用于实现如日志、事务等横切关注点。AOP通过定义切面（通知+切入点）来实现对特定方法的增强。  3. <strong>Spring整合MyBatis</strong>    - Spring通过SqlSessionFactoryBean和MapperScannerConfigurer简化了MyBatis的配置，实现了对MyBatis的整合管理。  4. <strong>声明式事务</strong>    - 使用DataSourceTransactionManager和@Transactional注解实现事务管理，保证了数据操作的原子性和一致性。  5. <strong>SpringMVC</strong>    - SpringMVC通过DispatcherServlet统一处理请求，配合视图解析器和控制器实现MVC模式。提供了灵活的请求映射和数据绑定机制。  总结来看，Spring框架通过IOC和AOP等核心技术，结合对MyBatis和MVC的支持，提供了一个强大且灵活的企业级应用开发平台。其模块化设计和丰富的集成能力大大简化了Java EE应用的开发复杂度。</p></blockquote><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>1.IOC and DI</p><p>​将new的权力交给spring，由工厂提供对象，同时通过DI维护对象与对象之间的关系</p><p>2.AOP</p><p>​底层原理：动态代理的封装</p><p>​通过产生动态代理来实现附加操作，来减少代码冗余</p><p>​切面 &#x3D; 通知(额外功能) + 切入点(加在哪里，哪些service类的哪些方法)</p><p>​通知和切入点可以随意组合成切面</p><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>项目管理框架，不是替换别的框架，而是将框架进行<strong>整合</strong>管理</p><ul><li><p>众多设计模式：工程 代理 策略 单例…</p></li><li><p>开源</p></li><li><p>轻量级</p></li><li><p>SSH：Struct2 + Spring +Hibernate</p></li><li><p>SSM: SpringMvc + Spring + Mybatis</p></li></ul><p>对组件（controller service Dao ）进行对象管理（创建 使用 销毁），entity通常不交给spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">原来： <span class="hljs-keyword">new</span> 去创建，然后调用<br>userDao = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>userDao.save()<br>现在：xml配置bean，然后直接取出来<br></code></pre></td></tr></table></figure><ol><li><p>导入依赖   org.springframework下的spring-webmvc</p></li><li><p>配置applicationContext.xml</p><p>bean来管理对象的创建，class指定类UserDaoImpl，id唯一<strong>标识</strong>在spring容器中取出来（最好首字母小写）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;init.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启动工程，绑定xml文件,取出bean</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;init/applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">usertest</span> <span class="hljs-operator">=</span> (UserDao)context.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br>        usertest.save(<span class="hljs-string">&quot;小明&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h3><ol><li><p><strong>IOC</strong>（Inversion of Control）控制反转        </p><p>由手动new变为配置文件配置，交给spring工厂。在tomcat中，也是该思想帮助我们创建了response对象</p><p>原理Class.forName(“UserDaoImpl”).newInstance()   反射调用构造方法</p></li><li><p><strong>AOP</strong>面向切面</p></li></ol><p><strong>DI</strong>：dependency Injection    IOC的补充</p><p>​存在嵌套service调用dao，也就是serviceImpl中需要拿到daoImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String name)</span> &#123;<br>        userDao.save(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​都要先声明一个成员对象，然后 </p><p>​<strong>原来</strong>：new UserDaoImpl()；</p><p>​<strong>现在</strong>：需要set方法，在配置中完成赋值操作（注入）      set注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ref：工程里的标识 bean的id，name：注入哪个属性<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>IOC <strong>创建对象</strong>，DI <strong>维护对象与对象之间的关系</strong></p><h3 id="3-注入"><a href="#3-注入" class="headerlink" title="3. 注入"></a>3. 注入</h3><p>除了一个对象的注入，其他的用的很少</p><ol><li>set 注入    property标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. 对象注入 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> /&gt;</span>        <br>2. String、日期、八种基本类型 value注入<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>   <br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2012/12/12 23:54:57&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  日期需要/ :格式<br>3. array list set<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbys&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span> 这里不同<br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  字符串用value<br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  类用ref<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>map<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">key-ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span> 类<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>properties  无序键值对集合<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;driver&quot;</span>&gt;</span>com.mysqljdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;姓名&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造注入       constructor-arg 标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用公开的有参构造方法  index代表参数的位置<br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br><br>如果想单独赋值某些元素，就要对应的构造方法，很麻烦！！<br></code></pre></td></tr></table></figure><ol start="3"><li>自动注入      autowire &#x3D; ”byType“  “byName”</li></ol><p>底层是set  需要在组件标签上开启</p><p><code>Autowired</code> 属于 Spring 内置的注解，<strong>默认</strong>的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （<strong>接口的实现类</strong>）。</p><p><strong>问题：</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</p><p><code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><h3 id="4-工厂特征"><a href="#4-工厂特征" class="headerlink" title="4.  工厂特征"></a>4.  工厂特征</h3><p>默认单例，多次getBean还是同一个。 struct2用成员对象存储信息，所以这时要多例   bean中scope &#x3D; “prototype”</p><p>原理： <strong>反射</strong> + 构造方法</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>单例：工厂启动时创建，正常关闭工程时销毁 context.close()</p><p>多例：getBean时创建，创建完成后脱离spring的管理，jvm去销毁</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">自己写的方法<br>init-<span class="hljs-keyword">method</span>=&quot;&quot; <span class="hljs-title function_">destroy</span>-<span class="hljs-title function_">method</span>=&quot;&quot;<br></code></pre></td></tr></table></figure><p>好处：</p><ol><li>解耦合，更换类只需要修改配置文件</li><li>减少内存占用</li><li>建立对象与对象之间的关系   打开配置文件就可看到</li></ol><h3 id="5-代理"><a href="#5-代理" class="headerlink" title="5. 代理"></a>5. 代理</h3><p>代理对象：完成传化，也可以附加操作，同时也可以中断</p><p>​好处：原始业务逻辑不变，同时可以附加</p><ol><li>代理对象和原始逻辑对象实现相同的接口</li><li>代理对象 依赖 原始业务逻辑对象</li></ol><p>原始逻辑中，除了<strong>具体事务</strong>，还有开启事务、提交事务、回滚事务的方法。后面这部分是重复的</p><p>在代理中，负责处理这些额外的方法，同时需要调用原始对象。总体的处理逻辑不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>sout(<span class="hljs-string">&quot;开启事务&quot;</span>)<br>userService.save(name)<br>out(<span class="hljs-string">&quot;结束事务&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>每一个业务对象都开发一个代理对象，上面的逻辑</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在程序运行中自动生成</p><p>getSqlSession().getMapper(UserMapper.class).getUser(); 这一步也是通过代理实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader(); 类加载器<br><span class="hljs-number">2.</span> Class[] classes = &#123;UserService.class&#125; 目标对象的接口数组 <br><span class="hljs-number">3.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandleer</span>() 附加操作 额外功能<br>proxy = (UserServic)Proxy.newProxyInstance(classLoader, classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandleer</span>()&#123;<br><span class="hljs-comment">// 代理过程 处理代理的实例  这里执行附加操作</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 附加 开启事务，打印信息等操作</span><br>        log(method.getName());<br>        <span class="hljs-comment">// 反射, 执行具体事务  哪个目标类的method </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>(), args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+msg);<br>    &#125;<br>&#125;);   生成动态对象<br>    <br>porxy.save();  直接调用<br></code></pre></td></tr></table></figure><p>封装成通用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-comment">// 被代理的接口， 一个动态代理 可以代理 多个类，只要是同一接口</span><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTarget</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回代理类</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 类加载器  被代理类接口  InvocationHandler</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(),<br>                target.getClass().getInterfaces(),<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 代理过程 处理代理的实例  这里执行附加操作</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//附加</span><br>        log(method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+msg);<br>    &#125;<br>&#125;<br><br>---------<br><span class="hljs-comment">// 真实角色</span><br><span class="hljs-type">ServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceImpl</span>();<br><br><span class="hljs-type">ProxyInvocationHandler</span> <span class="hljs-variable">phi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyInvocationHandler</span>();<br><span class="hljs-comment">// 设置要代理的对象</span><br>phi.setTarget(service);<br><span class="hljs-comment">// 得到代理对象 是一个接口</span><br><span class="hljs-type">Service</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Service) phi.getProxy();<br><br>proxy.add();<br></code></pre></td></tr></table></figure><h3 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6.   AOP"></a>6.   AOP</h3><p>Aspect Oriented Programing    <strong>核心就是动态代理</strong></p><p>附加操作：如日志打印，每个controller都加的话<strong>代码冗余</strong></p><p>通过<strong>动态代理</strong>完成<strong>附加操作</strong>(通知、Advice)。开发通知类，配置切入点</p><p>通知（Advice）：前置通知、后置通知、环绕通知、异常通知</p><p>切入点（pointcut）：指定通知应用在哪里。一般用于业务层</p><p><strong>切面</strong>（Aspect）：<strong>通知</strong>（Advice）+ <strong>切入点</strong>（pointcut）</p><ol><li><p>导入依赖</p></li><li><p>开发通知   继承接口 MethodIntercept MethodBeforeAdvice  ..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置切面 .xml</p><ul><li><p>注册通知类bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aop.Log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>组装切面，aop输入时会导入一些依赖。先定义切入点，切哪个类的哪个方法；再把通知类和切入点组装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--   切入点   execution:执行的位置     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserserviceImpl.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;logbefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>被切的类都会创建代理对象，之后.getBean(“UserserviceImpl”)返回的是proxy，和5中动态代理一样，但每个被切的类不用单独创建</p></li></ol><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>MethodInterceptor</p><p>计算运行时间 、处理异常</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046861.png" alt="image-20221206190215566"></p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046862.png" alt="image-20221206190819126"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046863.png" alt="image-20221206190916792"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046864.png" alt="image-20221206191123649" style="zoom:67%;" /><h3 id="7-复杂对象"><a href="#7-复杂对象" class="headerlink" title="7.  复杂对象"></a>7.  复杂对象</h3><ul><li>简单对象：可以直接new的对象，因此可以直接通过&lt; bean &gt;交给spring</li><li>复杂对象：不能直接new，接口Connction、抽象类Calendar</li></ul><p>Implements FactoryBean&lt;类名&gt;</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046865.png" alt="image-20221207202622749"></p><h3 id="8-整合mybatis"><a href="#8-整合mybatis" class="headerlink" title="8.整合mybatis"></a>8.整合mybatis</h3><p>spring：项目管理</p><p>mybatis：持久层CRUD。把mybatis中的对象创建交给spring</p><p><strong>mybatis写法：</strong>  .xml包含 <strong>数据源</strong> 以及 <strong>mapper注册</strong> 。 sqlSessionFactory &#x3D;》sqlSession &#x3D;》 usermapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>配置文件mybatis.xml 包含数据源信息(数据库账号密码等)<br><span class="hljs-number">2.</span>从配置文件.xml得到SqlSessionFactory，再openSession生成SqlSession执行sql语句 (封装成工具类)<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// get factory</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// get SqlSession</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br><br><span class="hljs-number">3.</span>编写Dao接口，接口实现类（.xml）<br>    <br><span class="hljs-number">4.</span>注册Mapper.xml<br>    &lt;mappers&gt;<br>        &lt;mapper resource=<span class="hljs-string">&quot;com/kuang/dao/userMapper.xml&quot;</span>/&gt;<br>    &lt;/mappers&gt;<br>    <br><span class="hljs-number">5.</span>测试，调用工具类得到SqlSession，再调用getMapper，该mapper执行函数完成查询<br><span class="hljs-comment">// 获得对象</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><span class="hljs-comment">// getMapper</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>List&lt;User&gt; userList = mapper.getUserList();<br></code></pre></td></tr></table></figure><h4 id="8-1拿到sqlSessionFactory"><a href="#8-1拿到sqlSessionFactory" class="headerlink" title="8.1拿到sqlSessionFactory"></a>8.1拿到sqlSessionFactory</h4><p>SqlSessionFactoryBuilder 读配置文件，构建Factory</p><p>sqlSessionFactory <strong>核心对象</strong>, 因此整合的核心就是接管这个！！！</p><p>sqlSession</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSessionFactory 是接口，因此利用第七节的方法完成配置，并把xml文件位置通过依赖注入到bean中<br><br>spring将这个类封装了，叫做SqlSessionFactoryBean<br>注入.xml，细粒度化，把dataSource分开了，同时配置mapperLocations；mybatis.xml中配置日志等其他对象(可以不要)<br><span class="hljs-comment">&lt;!--使用spring数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mapper--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--绑定mybatis配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span> (可以不要)<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>到这一步拿出sqlSessionFactory，就可以取出sqlSession.getmapper操作数据库<br>但我们的核心是在Dao部分，所以不想每次拿Dao时都先拿出sqlSessionFactory，想直接拿出Dao<br></code></pre></td></tr></table></figure><h4 id="8-2整和Dao"><a href="#8-2整和Dao" class="headerlink" title="8.2整和Dao"></a>8.2整和Dao</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">factory中指向mapper文件<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进一步封装，就可以直接getBean(UserDao)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">sqlSessionFactory和userDao绑定，就可以直接getMapper，等价 @Mapper，每一个都要写。@Repository没有用<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>这里每一个Dao都要配置，直接只写一个mapperscan可以解决  等价 @MapperScan<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者将sqlsession作为一个成员放到UserDaoImpl中，间接调用，狂神的课程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserMapper</span>&#123;<br>    <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">return</span> mapper.getUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sqlSession--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--实现类--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.mapper.UserMapperImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-Service事务"><a href="#9-Service事务" class="headerlink" title="9.Service事务"></a>9.Service事务</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">用DataSourceTransactionManager实现事务，自己写<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>  -&gt;  写环绕通知  -&gt;  用spring的环绕通知（细粒度）<br></code></pre></td></tr></table></figure><p>service直接注入Dao即可，但需要<strong>处理事务</strong></p><h4 id="9-1-编程式"><a href="#9-1-编程式" class="headerlink" title="9.1.编程式"></a>9.1.编程式</h4><p>每个impl中注入事务管理对象实现</p><p>JDBC中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.setAutoCommit(<span class="hljs-literal">false</span>);<br>connection.commit();<br>connection.rollback();<br></code></pre></td></tr></table></figure><p>datasouce中可以取出connection,但是service中的connection和dao中的<strong>可能不是同一个</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046866.png" alt="image-20221208142531461" style="zoom:67%;" /><p><strong>DataSourceTransactionManager</strong>：全局事务管理，使得service和Dao连接对象相同，控制数据源的线程安全问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>serviceImpl中，添加transactionManager， .commit()   .rollback()。每一个serviceImpl都要写，<strong>用AOP解决冗余</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046867.png" alt="image-20221208143608607"></p><h4 id="9-2-声明式事务"><a href="#9-2-声明式事务" class="headerlink" title="9.2 声明式事务"></a>9.2 声明式事务</h4><p>aop实现事务处理</p><p>自己写：环绕通知，大家都一样的，所以spring封装了</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046868.png" alt="image-20221208145557943"></p><p>封装后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务通知，等价于自己写的环绕通知 tx:advice为特殊标签 对通知做细粒度管控--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--在什么情况下添加事务， 细粒度--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span>/&gt;</span> 方法名需要对应上<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置切入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tranPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.mapper.*.*(..))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:pointcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;tranPointCut&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:advisor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-3事务传播"><a href="#9-3事务传播" class="headerlink" title="9.3事务传播"></a>9.3事务传播</h4><p>业务层中调用别的业务，可以把事务传播过去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">OrderService.save()&#123;<br>userService.update();<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> /&gt;</span> <br>  propagation=&quot;&quot;<br>    REQUIRED：外层没有则开启，有则融入             增删改  默认<br>    SUPPORTS：外层没有不开，有则融入；实现事务传播  查询<br>    REQUIRE_NEW: 自己开一个新的 隔开              银行日志，总是要个新的<br>    NOT_SUPPORTED: 不用事务<br>  isolation=&quot;&quot;<br>  read-only<br>  time-out: 事务超时 -1永不超时 秒<br></code></pre></td></tr></table></figure><p>行锁为一条数据，在同一事务中多次查询，不会受到别人update印象</p><p>表锁为表的数据，多一条少一条不受印象</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046869.png" alt="image-20221208161551569"></p><h3 id="10-日志"><a href="#10-日志" class="headerlink" title="10.日志"></a>10.日志</h3><p>log4j</p><p>ERROR WARN INFO DEBUG</p><p>配置文件在resource根目录下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">log4j<span class="hljs-selector-class">.logger</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-class">.baizhi</span>.dao=DEBUG 展示sql<br></code></pre></td></tr></table></figure><h3 id="11-注解"><a href="#11-注解" class="headerlink" title="11.注解"></a>11.注解</h3><h4 id="装配"><a href="#装配" class="headerlink" title="装配"></a>装配</h4><p>service太多了，每次都要添加</p><p><strong>前置条件：开启注解扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定注解生效的包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>@component</strong>(value &#x3D; “指定id”)，装配到Spring中，等价与&lt; bean&gt;, 唯一标识为类名小写</p><ul><li>Dao  **@Repository (只是告诉spring要加这个bean，和mybatis无关)   ** @Mapper 和 @MapperScan结合使用为了结合spring和mybatis。如果不加@Repository可能爆红 但能正常运行</li><li>Service     <strong>@Service</strong></li><li>controller  <strong>@ Controller</strong></li></ul><p><strong>@Scope</strong>(value&#x3D;”singleton\prototype”)  单例多例</p><h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><p><strong>对象注入</strong> 属性或者set方法上。在属性上用时可以不用添加set方法，底层会自动提供set方法</p><p>​@<strong>Autowired</strong>  默认类型</p><p>​ @<strong>Qualifier</strong>(value &#x3D; “cat1”)  指定名称</p><p>JavaEE</p><p>​@<strong>Resource</strong>  默认名字，找不到再类型</p><p><strong>基本类型注入</strong></p><p>​@Value(“XX”)         @Value(“${spring.datasource.username}”)</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>@<strong>transactional</strong>(propagation &#x3D; , )  添加事务，加载类或者单个方法    <strong>serviceimpl</strong>上加</p><p>不需要事务通知对象以及添加切面，但还是添加开启注解事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>&lt;/tx:annotation-driven &gt; <br></code></pre></td></tr></table></figure><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046870.png" alt="image-20221208170805881" style="zoom:67%;" /><p>Dao还是扫描进行装配的</p><p>P21整合SM</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>MVC中的C层，控制器框架。代替struts2</p><h3 id="0-Struct2"><a href="#0-Struct2" class="headerlink" title="0.Struct2"></a>0.Struct2</h3><p>1.C层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ActionSupport</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Product&gt; productList; <span class="hljs-comment">// 成员变量传递结果 相当于model.add</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 处理获取商品列表的逻辑，这里直接模拟</span><br>        productList = ProductService.getProductList();<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Product&gt; <span class="hljs-title function_">getProductList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> productList;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.路由：封装servlet，Struts2的前端控制器DispatcherServlet接收并分发到对应的Action处理。</p><p>定义名为<code>productList</code>的Action，并将其关联到<code>ProductAction</code>类中的<code>list()</code>方法。当请求到达<code>/productList</code>时，Struts2会调用<code>list()</code>方法并将结果返回到<code>productList.jsp</code>页面中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;productList&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.ProductAction&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/WEB-INF/views/productList.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.V层：配置Struts2的视图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Product List<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>ID<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Description<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:iterator</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;productList&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;price&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s:property</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:iterator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><p>在servlet基本思想中，编写一个控制器，就要去web.xml中去注册，<strong>在SpringMVC中，使用dispatchservlet拦截所有</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>loginout<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiao.servlet.user.LogoutServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>loginout<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/jsp/logout.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置web.xml（拦截全部的请求）   配置springmvc.xml      编写controller(component-scan)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046871.png" alt="image-20221212145632004"></p><ol><li><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.注册DispatcherServlet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span><br><span class="hljs-comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>springmvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--处理器映射器 定位到方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--处理器适配器  解析参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span>  包含映射器、适配器  实验发现是必须要<br></code></pre></td></tr></table></figure></li><li><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">手动配置，这里的id就是访问的路径<br>&lt;bean id=<span class="hljs-string">&quot;/helloserv&quot;</span> class=<span class="hljs-string">&quot;com.kuang.controller.Helloservlet&quot;</span>&gt;&lt;/bean&gt;<br><br>或者 不可以同时配置<br><br>&lt;!-- 注解扫描 --&gt;<br>&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span>/&gt;<br><br><span class="hljs-meta">@Controller</span> <span class="hljs-comment">// 注入bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/helloserv&quot;)</span> <span class="hljs-comment">// 访问路径</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(Model model)</span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello annotation&quot;</span>);   <span class="hljs-comment">//model</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//view</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在 Controller 中，根据业务逻辑查询出需要显示的动态数据，并将其封装成一个 Model 对象。</li><li>将 Model 对象作为参数传递给模板引擎（根据返回值定位页面），通过 Thymeleaf 的表达式语言 ${} 将动态数据注入到 HTML 模板中。</li><li>Thymeleaf 模板引擎会根据 HTML 模板中定义的逻辑和数据，生成渲染后的 HTML 页面，并将其返回给客户端浏览器。</li><li>客户端浏览器接收到 HTML 页面后，根据 HTML 标签和 CSS 样式渲染页面，并显示给用户。</li></ul><p>想访问一个商品列表页面：</p><ol><li>controller定义toList接口，</li><li>加载数据到model里，return “toList”跳转到toList.html，thymeleaf会自动渲染数据进入页面对应的${}</li></ol><h3 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2.跳转"></a>2.跳转</h3><p>servlet</p><ul><li>forward 请求转发 地址栏不变，获得商品列表后转发到商品界面</li><li>redirect 重定向</li></ul><p>controller -&gt; 页面       </p><ul><li>默认返回就是forward</li><li>重定向return “redirect:&#x2F;index.jsp”  不经过视图解析器</li></ul><p>controller -&gt; controller </p><ul><li>return “forward:&#x2F;path”</li><li>return “redirect:&#x2F;path”</li></ul><h3 id="3-参数接受"><a href="#3-参数接受" class="headerlink" title="3.参数接受"></a>3.参数接受</h3><p>vo：专门用来传值的对象</p><p>struts2：成员变量接收参数 多例</p><p>springmvc：</p><p>@RequestBody 反序列化 @ResponseBody 序列化成json </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">局部变量，无线程安全问题，单例<br><br><span class="hljs-comment">// restful风格</span><br><span class="hljs-meta">@RequestMapping(&quot;/test2/&#123;pageNo&#125;“)</span><br><span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageNo 将URL中的占位符参数绑定到控制器处理方法的入参<br>    <br><span class="hljs-meta">@RequestParam</span> String name  Url Form表<br>User user  url中自动对应<br><br><span class="hljs-meta">@RequestBody</span> User user  Body中raw格式下的json参数 <br></code></pre></td></tr></table></figure><p>前端可以混用，一个在params，一个在data</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title class_">RequestParam</span> <span class="hljs-title class_">String</span> resourceId,<br>@<span class="hljs-title class_">RequestParam</span> <span class="hljs-title class_">String</span> examId,<br>@<span class="hljs-title class_">RequestBody</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">UpdateExamAnswer</span>&gt; examAnswerList,<br>@<span class="hljs-title class_">RequestParam</span>(value = <span class="hljs-string">&quot;writeType&quot;</span>, defaultValue = <span class="hljs-string">&quot;0&quot;</span>) int writeType<br><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-variable constant_">BASE_URL</span> + <span class="hljs-string">&#x27;/submit_all_save&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      resourceId,   <span class="hljs-comment">// 普通字符 拼接到url      @RequestParam</span><br>      examId,<br>      writeType<br>    &#125;,<br>    <span class="hljs-attr">data</span>: questionRes <span class="hljs-comment">// json格式    @RequestBody</span><br>  &#125;)<br></code></pre></td></tr></table></figure><p>此外，以上默认post为<code>application/json</code>格式发送接受数据</p><ol start="2"><li><code>application/x-www-form-urlencoded</code> 前端URLSearchParams或Qs.Stringify(data)      后端@RequestParam或不加</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>数据格式：loginName=lst&amp;password=<span class="hljs-number">1</span><br><br>百分号编码：<br>丁 十六进制下是<span class="hljs-number">0</span>xE4B881占<span class="hljs-number">3</span>字节<br>转成字符串‘E4B881’，占六字节<br>每两个字节前加上百分号前缀，得到字符串“%E4%B8%<span class="hljs-number">81</span>”，占九个字节（十六进制下是<span class="hljs-number">0</span>x244534254238253831）<br>把这九个字节拼接到数据包里，这样就可以传输“非ascii字符的  utf8编码的 十六进制表示的 字符串的 百分号形式”<br></code></pre></td></tr></table></figure><p>3.<code>multipart/form-data</code>  前端FormData格式，后端@RequestParam或不加</p><h3 id="4-返回参数："><a href="#4-返回参数：" class="headerlink" title="4.返回参数："></a>4.返回参数：</h3><p>request（单次请求）  session(浏览器) application(全体用户共享)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">forward跳转<br>    Model model 对request的封装，作用一样<br>         model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello annotation&quot;</span>);   <br>取出：$&#123;requestScope.msg&#125;<br>redirect<br>    <span class="hljs-number">1.</span>地址栏拼接 <br>    <span class="hljs-number">2.</span>session  req.getSession.setAttribute<br></code></pre></td></tr></table></figure><h3 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h3><p>javaweb：filter过滤器，可以拦截一切资源。springmvc只能拦截controller</p><p>编写拦截器类，再注册：注入bean，定义拦截的地方。（或者定义和拦截写在一起）</p><p>这里继承<strong>HandlerInterceptor</strong>，有<strong>处理前</strong>，（controller）处理后，清理后</p><p>AOP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 放行OPTIONS请求</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(request.getMethod())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(token == <span class="hljs-literal">null</span>)&#123;<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;未携带token&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                JWTUtils.verity(token);<br>                <span class="hljs-comment">// 未出错 放行</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">catch</span> (SignatureVerificationException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;无效签名&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token过期&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (AlgorithmMismatchException e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token算法不一致&quot;</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;token无效&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        map.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-number">500</span>);<br>        map.put(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(map);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        response.getWriter().println(json);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--拦截器注入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以写多个拦截器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.JWTInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  或者分开 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span> = <span class="hljs-string">&quot;beanname&quot;</span>&gt;</span><br>    &lt;/mvc:interceptor &gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h3><p>编写异常处理类，<strong>注册bean</strong>就行。可以根据不同的异常if判断处理不同逻辑 </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046872.png" alt="image-20221216183658625"></p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p>这里7.a scan可以只扫描service下的，因为mapper和controller都扫描了；mapper可以不使用注解（mapperscanconfig是和spring整合的；等价在springboot中使用了@Mapper或@MapperScan）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046873.png" alt="image-20221215092403942"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046874.png" alt="image-20221216205759155"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--扫描service下的包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    这里使用注解实现--&gt;</span><br>    <span class="hljs-comment">&lt;!--将service层装入--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;bookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启注解事务生效--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><br><span class="hljs-tag">            <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br>    <span class="hljs-comment">&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.ab 让mvc在服务器启动时创建工厂(提供service Dao)。</p><p>实际项目中，可以把所有的文件整合到一起applicationContext，在servlet中配置</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046875.png" alt="image-20221215093143429"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046876.png" alt="image-20221216210140557"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062046877.png" alt="image-20221216210029653"></p><p>C:\Users\13000\Desktop\study\vue-spring\2.vue-spring\7.springmvc\0代码———————————-\ssmbuild</p><p>spring.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br><span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span></span><br><span class="hljs-tag">                              <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="hljs-comment">&lt;!--数据库连接池</span><br><span class="hljs-comment">    dbcp 半自动化操作 不能自动连接</span><br><span class="hljs-comment">    c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 关闭连接后不自动commit --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 获取连接超时时间 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="hljs-comment">&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.kuang.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--service相关--&gt;</span><br><span class="hljs-comment">&lt;!--配置声明式事务，开启注解事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>&lt;/tx:annotation-driven &gt; <br><br><span class="hljs-comment">&lt;!--扫描service下的包, 也可以手动写入bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.service&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--将service层装入--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;bean id=&quot;bookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span><br></code></pre></td></tr></table></figure><p>springmvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注解扫描 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kuang.controller&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>web.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatchservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatchservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要介绍了计算机网络通信的基础概念和技术原理，涵盖从物理层到应用层的各个层级，以及数据传输的相关机制。    1. <strong>网络分层结构</strong>：从物理层（比特传输）、数据链路层（帧组装）、网络层（数据包路由）、传输层（可靠数据传输）到会话层、表示层和应用层（协议数据处理），逐层解释其功能和作用。    2. <strong>数据传输机制</strong>：      - <strong>HUB与交换机</strong>：HUB采用广播方式发送数据，半双工工作；交换机通过MAC地址表定向转发数据，支持全双工。      - <strong>MAC地址与IP路由</strong>：数据包传递过程中，IP地址不变，而MAC地址会根据不同网络节点（交换机、路由器）动态变化。      - <strong>ARP协议</strong>：负责IP地址到MAC地址的转换，使用缓存优化查询效率。      - <strong>差错检测</strong>（CRC）、<strong>可靠传输</strong>（ARQ协议）及流量控制（滑动窗口、超时重传）。    3. <strong>网络互联与路由</strong>：      - 路由器负责不同子网间的数据转发，路由表包含目标网络、子网掩码、下一跳和接口信息。      - <strong>RIP协议</strong>（基于距离向量）和<strong>OSPF协议</strong>（基于链路状态）分别用于构建和优化路由表。    4. <strong>TCP&#x2F;IP关键机制</strong>：      - <strong>三次握手（建立连接）</strong>和<strong>四次挥手（终止连接）</strong>确保通信可靠性。      - <strong>拥塞控制</strong>（慢启动、拥塞避免、快重传、快恢复）和流量管理（接收窗口调节发送速度）。    5. <strong>应用层协议</strong>：HTTP（TCP&#x2F;80）、HTTPS（TCP&#x2F;443，加密+认证）、DNS（UDP&#x2F;53）、SMTP（TCP&#x2F;25）等，对比TCP（可靠）与UDP（高效）的适用场景。    6. <strong>HTTPS安全机制</strong>：结合非对称加密（证书验证服务器身份）和对称加密（数据传输），依赖CA机构确保公钥真实性。    7. <strong>Web请求流程</strong>：DNS解析、TCP连接、HTTP请求、服务器处理、资源加载和页面渲染，涉及状态码（2xx成功、3xx重定向、4xx客户端错误、5xx服务器错误）的应用。    整体围绕网络架构、通信协议、路由优化及安全传输展开，系统梳理了数据从传输到应用的关键技术点。</p></blockquote><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213652.png" alt="image-20210808133147935" style="zoom:67%;" /><p>MAC首部 + IP首部 + TCP首部 + TCP数据</p><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213424.png" alt="image-20230408150044809"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>多台机器如何传输： 数据要有标识来源MAC地址(from to)</p><ul><li>HUB集线器：直接转发给全部机器，不能同时发送，需要CSMA&#x2F;CD，半双工</li><li>交换机：有一张MAC地址和端口的表（自学习），定向转发。通过网线可以实现全双工</li></ul><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h4><p>​多址接入、载波监听、碰撞检测</p><p>​往返时间为2t，每个数据包要大于2t发送时间（最短有效帧长）。所有小于等于2t的都丢弃。</p><p>​1KM往返10us；10Mbit&#x2F;s ，512bit(64B)最短帧长，总线不能超过5120m。考虑衰减：2500m</p><p>​64<em>8&#x2F;10^7^  &gt;&#x3D;   5120 * 2 &#x2F; 2</em>10^8^</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">以太网的最小帧长是通过争用期计算出来的。一个站点开始发送数据后，最多经过时间 <span class="hljs-number">2</span>τ(两倍的端-端时延)就可知道是否发生了碰撞 即一端发送一个帧，在无限接近另一端的位置发生了碰撞，然后碰撞信息再从碰撞位置传递回来，刚好就是一个往返以太网的端到端往返时延<span class="hljs-number">2</span>τ称为争用期，或碰撞窗口 ，如果经过争用期还没有检测到碰撞，就可以肯定这次发送不会发生碰撞为什么最短帧的大小取决于争用期时长？因为如果最短帧的传输时间小于争用期（比如<span class="hljs-number">30</span>μs），那么就会导致发送完这个帧之后，在不知道帧有没有传送成功的情况下（至少需要<span class="hljs-number">51.2</span>μs来确定）又发送了下一个帧。反之，如果最短帧的传输时间大于争用期，由于碰撞信息一定可以在帧发送完之前传到，就可以保证只有在上一个帧没有发生碰撞，正确传输的情况下才会发送下一个帧。对于最大长度为<span class="hljs-number">2500</span>米的<span class="hljs-number">10</span>Mbps 网络和四个中继器（来自<span class="hljs-number">802.3</span>规范），在最坏的情况下，往返时间（包括通过四个中继器的传播时间）被确定为接近<span class="hljs-number">50</span>微秒。因此，允许的最短帧必须至少花费这么长的时间来传输。在<span class="hljs-number">10</span>Mbps时，一个比特需要<span class="hljs-number">100</span>纳秒，所以<span class="hljs-number">500</span>比特是保证工作的最小帧。为了增加一些安全边际，这个数字被四舍五入到<span class="hljs-number">512</span>比特即<span class="hljs-number">64</span>字节，相应的，以太网的争用期长度也被确定为<span class="hljs-number">51.2</span> μs  据此规定以太网帧长≥ <span class="hljs-number">64</span> 字节，长度小于<span class="hljs-number">64</span>字节的帧为无效帧<br></code></pre></td></tr></table></figure><p><strong>ARP</strong> ： IP-》MAC</p><p><strong>差错检验：</strong> CRC</p><p><strong>可靠传输：</strong>ARQ停止等待、回退N帧（可以发多个）、选择重传（可以不按序接收）</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>设备太多了交换机的表记录不下来。通过路由器构建多个网络间的连接，一个路由器有多个接口(ip)对应多个子网</p><p><strong>通信方式</strong></p><ul><li>子网间通信：发给默认网关。由某路由器根据路由表转发</li><li>同一子网通信：直接通过交换机</li></ul><p><strong>路由表：</strong>目的网络地址、子网掩码、下一跳(下一个路由表ip地址)、接口</p><p>​我想访问IP通过子网掩码后，如果于路由表的目的网络地址对应上了，则转发到下一跳</p><p><strong>路由表如何构建：</strong> 单个目标网络可能有多个路径，如何选取最优</p><ul><li><strong>RIP</strong>(小型网络)。额外维护一个<strong>距离信息</strong>。每30s邻居向自己发送（可达地址+距离），如果距离更短则更新下一条和距离。坏消息传得慢</li><li><strong>OSPF</strong>。每个路由搜集全部路由联络信息LSA，构建LSDB(Link State DataBase)掌握全网的拓扑结构，然后构建权重有向图，再计算最短路径</li></ul><p><strong>传输过程中，IP地址(4*8 )不变，但MAC地址一直在变</strong></p><p><strong>NAT</strong>：内网访问外网，分配临时IP</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>​<strong>应用间通信</strong></p><p>​端口区分应用：FTP 21、TELNET 23、 SMTP 25、 DNS 53、 HTTP 80、 HTTPS 443 </p><p>TCP<strong>可靠传输</strong>：发送需要确认 （滑动窗口）、超时重传</p><ol><li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li><li>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</li></ol><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p><strong>三次握手</strong>：防止假如a发了两次请求，第一次以为失败了，而b接受了两次请求，第二次一直在等a浪费时间。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213425.png" alt="image-20230419102228437"></p><p><strong>四次挥手</strong>：1 a发出关闭请求，2 b发出响应确认，并半关闭状态不断发送信息， 3 最后发送关闭请求。a确认关闭请求</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213426.png" alt="image-20230419102236858"></p><h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>可靠传输通过<strong>发送需要确认</strong>(确认序号)和<strong>超时重传</strong>来实现，为提高效率使用滑动窗口</p><ul><li><strong>滑动窗口</strong>：以发送但未确认的最大字节数。接收方接受窗口如果接受到无序的数据先缓存</li><li><strong>超时重传：</strong> 指数加权移动RTT，不考虑超时重传的报文</li></ul><h4 id="流量拥塞控制"><a href="#流量拥塞控制" class="headerlink" title="流量拥塞控制"></a>流量拥塞控制</h4><p><strong>流量控制:</strong> 不断回发<strong>接收方</strong>的窗口大小</p><p><strong>拥塞控制</strong>（拥塞窗口大小）：<strong>慢启动（指数）、拥塞避免（线性）、快重传 （3个ack后立即重发）、快恢复（对于快重传情况，拥塞后直接从新门限开始）</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191213427.png" alt="image-20210808142023374" style="zoom: 80%;" /><p>发送窗口 &#x3D; min(接收窗口，拥塞窗口)</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用  应用层运输层</strong></p><p>电子邮箱SMTPTCP</p><p>远程访问 TELNETTCP</p><p>万维网HTTPTCP</p><p>文件传输FTPTCP</p><p>域名解析DNSUDP</p><p>IP电话专用协议UDP</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ARP协议-Address-Resolution-Protocol"><a href="#ARP协议-Address-Resolution-Protocol" class="headerlink" title="ARP协议 (Address Resolution Protocol)"></a>ARP协议 (Address Resolution Protocol)</h3><p>封装成帧时，通过ARP将IP-&gt;MAC地址。ARP 高速缓存中有就拿，没有就广播询问</p><h3 id="RIP-Routing-Information-Protocol-距离矢量路由协议"><a href="#RIP-Routing-Information-Protocol-距离矢量路由协议" class="headerlink" title="RIP (Routing Information Protocol, 距离矢量路由协议)"></a>RIP (Routing Information Protocol, 距离矢量路由协议)</h3><p>维护路由器一张表：目的网络 、距离、下一跳     坏消息传得慢</p><h3 id="NAT-Network-Address-Translation-网络地址转换"><a href="#NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="NAT (Network Address Translation, 网络地址转换)"></a>NAT (Network Address Translation, 网络地址转换)</h3><p>将内网IP地址转化为临时外网IP地址，保持到NAT转换表中。</p><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li></ol><ul><li>服务器发公钥给浏览器，浏览器随机数（传输密钥）加密后传给浏览器，浏览器再私钥解密得到 传输密钥（<code>非对称+对称加密</code>  、如果只非对称加密，浏览器的数据会被窃取）</li><li>问题：如果中间人用窃取公钥并拦截，并生成自己的公钥发给浏览器，作为中间商，就会出问题</li><li>如何确定浏览器收到的公钥是服务器给的：（域名、第三方机构、服务器公钥）给CA，CA添加数字签名（内容-&gt;hash-&gt;私钥加密）后给浏览器。浏览器解密（CA的公钥，浏览器信任的CA机构）看是否和明文hash一致</li></ul><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p><p>保存Sessionid的方式可以采用Cookie，请求时携带。如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol><li>浏览器查询 DNS，获取IP</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2021/09/08/%E6%9C%BA%E7%BB%84/"/>
    <url>/2021/09/08/%E6%9C%BA%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要介绍了计算机组成原理的基础知识，内容涵盖以下核心内容：    1. <strong>计算机体系结构</strong>：从ENIAC手动接线到冯·诺依曼结构（指令存储、运算器为中心），再到现代以存储器为中心的架构演变。介绍指令执行流程（取指、分析、执行）及高级语言到机器指令的转换。    2. <strong>数据表示与运算</strong>：包括数值转换（十进制、二进制、十六进制）、校验方式（奇偶校验、海明码、循环冗余校验CRC），以及定点数、浮点数（IEEE 754标准）的表示与运算规则（补码、移位、溢出判断）。    3. <strong>存储系统</strong>：存储器层次结构（Cache、主存、辅存）、DRAM刷新机制、存储器扩展技术（字&#x2F;位扩展），以及Cache映射方式（全相联、直接映射、组相联）和替换算法（FIFO、LRU等）。    4. <strong>中央处理器（CPU）</strong>：组成（ALU、CU、寄存器、中断系统）、指令周期（取指、间址、执行、中断）、控制方式（同步&#x2F;异步&#x2F;联合）及微程序控制（水平型&#x2F;垂直型微指令）。    5. <strong>总线与I&#x2F;O系统</strong>：总线分类（数据&#x2F;地址&#x2F;控制）、仲裁方式（链式查询、计数器定时、独立请求）、I&#x2F;O控制（程序查询、中断、DMA、通道技术）及外部设备（磁盘、SSD、光盘的存取原理）。    全文贯穿硬件与软件的协同设计思想，强调通过优化结构（如流水线、Cache、总线协议）提升性能，并解析了计算机从底层数据存储到高层指令执行的全流程逻辑。</p></blockquote><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304061952053.png" alt="image-20210531150601852"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062002396.png" alt="image-20210531111032467" style="zoom: 67%;" /><p>软件</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012811.png" alt="image-20210531111208860" style="zoom:67%;" /><p>硬件</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012813.png" alt="image-20210531112655239"></p><h3 id="1-冯诺依曼"><a href="#1-冯诺依曼" class="headerlink" title="1.冯诺依曼"></a>1.冯诺依曼</h3><p>ENIAC手动接线代表指令。冯诺依曼将指令存储起来</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012814.png" alt="image-20210531113110649" style="zoom: 80%;" /><p><strong>运算器</strong>为中心，数据要经过运算器。</p><p>现代的将<strong>存储器</strong>为中心</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012815.png" alt="image-20210531113528807"></p><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>取存数据的程，现代这两个寄存器继承到了cpu里面</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012816.png" alt="image-20210531113844906" style="zoom:50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012817.png" alt="image-20210531113937808" style="zoom:50%;" /></p><p>通过<strong>译码器</strong>将地址转为one hot，1的那个为接通</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012818.png" alt="image-20210531153111051"></p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012819.png" alt="image-20210531114435559"></p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012820.png" alt="image-20210531114630517"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>a * b + c 的执行过程，高级语言转为指令存放到内存中。这里的指令是单地址指令</p><p>根据pc从内存取指令(初始0)   <strong>-&gt;</strong>   分析指令（操作码）    <strong>-&gt;</strong>   执行指令内容      <strong>指令和数据都是来自存储体</strong>   </p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012821.png" alt="image-20210531115304027"></p><p>将机器指令转换为多条微指令</p><p>高级语言  -&gt;（编译）  汇编语言    -&gt;  操作系统  -&gt;（汇编） 机器语言 01   -&gt;    微指令</p><p>或者直接将高级语言转为机器语言（python）逐句翻译</p><h4 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012822.png" alt="image-20210531151536611"></p><h4 id="波特率比特率"><a href="#波特率比特率" class="headerlink" title="波特率比特率"></a>波特率比特率</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012823.png" alt="image-20210607222453605"></p><h3 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h3><h4 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h4><p>十进制转其他</p><p>​整数除基取余</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012824.png" alt="image-20210601113732024"></p><p>​小数乘基取整</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012825.png" alt="image-20210601113850208"></p><p>二进制转其他（4、8、16）：多位一组，分组转换</p><h4 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h4><p>用二进制表达十进制数，当超过10时需要加6修正</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012826.png" alt="image-20210601114659976"></p><h4 id="3-ASCII"><a href="#3-ASCII" class="headerlink" title="3.ASCII"></a>3.ASCII</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012827.png" alt="image-20210601114946178" style="zoom: 50%;" /><p>汉字7445个，需要2B</p><h4 id="4-校验"><a href="#4-校验" class="headerlink" title="4.校验"></a>4.校验</h4><p><strong>奇校验</strong>：加完校验1的个数为<strong>奇数个</strong>，一般放前面</p><p><strong>海明校验</strong>：p的位置为2^n，标记出出错位置</p><p>d为数据，p为校验码<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012828.png" alt="image-20210601120945066"></p><p>pi为d为1的下标上第i为异或得到，共需要大约log2位用来校验<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012829.png" alt="image-20210601121114649"></p><p><strong>循环冗余校验CRC ：</strong></p><p>有一个给出的生成多项式，最高为x次<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012830.png" alt="image-20210601121801336">，转为二进制被除数1101有x+1位，将数据左移x位后除以该数（模二除），得到的余数就是校验位。发送   移位后的数  加上  余数。</p><p>校验：数据模二除多项式，余数为零</p><h4 id="5-数据表示"><a href="#5-数据表示" class="headerlink" title="5.数据表示"></a>5.数据表示</h4><p>无符号数： 0 ~ 2^n-1</p><p>有符号数：一位表示符号</p><p>定点小数：纯小数。0. x，再加一位表示符号<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012831.png" alt="image-20210601122710917" style="zoom:67%;" /></p><p>原码：有符号数<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012832.png" alt="image-20210601123056307">，加减计算需要讨论符号</p><p>反码：负数按位取反</p><p><strong>补码</strong>：负数按位取反，末尾加一（原理上是用溢出值减绝对值）。计算直接加</p><p>移码：加上128后，转为无符号机器数。比较大小</p><p><strong>移位：</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012833.png" alt="image-20210601131324554" style="zoom: 67%;" /><p><strong>溢出判断</strong></p><p>​1.通过符号判断</p><p>​2.进位判断法：V&#x3D; S异或C 其中S为符号位产生的进位,C为最高有效位产生的进位。 </p><p>​3.双符号位： V&#x3D;Sf1 Sf2 + 其中,Sf1和Sf2分别为最高符号位及第二符号位。</p><h4 id="求补电路："><a href="#求补电路：" class="headerlink" title="求补电路："></a>求补电路：</h4><p>将补码表示的<strong>带符号数</strong>转换成 <strong>无符号绝对值</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012834.png" alt="image-20210601171422268"></p><h4 id="绝对值乘法"><a href="#绝对值乘法" class="headerlink" title="绝对值乘法"></a>绝对值乘法</h4><p>acc中保存当前进位，MQ高位保存结果以及低位未计算的乘数，当乘数都移出去后，结果就是ACC MQ</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012835.png" alt="image-20210601154034355"></p><h4 id="绝对值除法"><a href="#绝对值除法" class="headerlink" title="绝对值除法"></a>绝对值除法</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012836.png" alt="image-20210601160052898"></p><p>ACC中放当前值，MQ中放结果</p><h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012837.png" alt="image-20210601161602994" style="zoom: 80%;" /><p>规格化，M左移使得最高位有效</p><p>溢出时，将M右移</p><p><strong>IEEE 754</strong>       <img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012838.png" alt="image-20210601163257381"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012839.png" alt="image-20210601165117606">)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012840.png" alt="image-20210601163002198"></p><p>浮点数运算：小阶向大阶看齐</p><h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>Arithmetic and logic unit  算数、逻辑、移位</p><p>与非：<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012841.png" alt="image-20210601165845453">现实容易实现</p><p>异或：<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012842.png" alt="image-20210601165936688">和加法的逻辑类似</p><p>全加器：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012843.png" alt="image-20210601170821403" style="zoom:50%;" /><p>多位串行：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012844.png" alt="image-20210601171144274" style="zoom:80%;" /><p>并行</p><p>组内并行，组间串行</p><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><p>读取过程：地址线先传送地址数据到MAR，略微等待后<strong>片选线</strong>和<strong>读写控制线</strong>给出信号，将数据读入MDR中</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012845.png" alt="image-20210602131615023"></p><p>实际上，地址是有<strong>行选和列选</strong>（需要的线少一倍），刷新时是以行为单位。</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012846.png" alt="image-20210602133806204" style="zoom:50%;" /><p>地址线连接MAR（行列分别传入），数据线连接MDR</p><p><strong>寻址方式：</strong>按字、字节、半字、双字寻址</p><p><strong>存储方法：</strong></p><p>​小段方式：先放低位字节，低位在左</p><p>​大段方式：先放高位，高位在左</p><h4 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h4><p>辅存不和cpu直接通信，主存RAM+ROM</p><h5 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h5><p>Random Access Memory</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012847.png" alt="image-20210602133519525"></p><p>刷新时间：2ms要都刷新过一次。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012848.png" alt="image-20210602134144186"></p><h5 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h5><p>Read only Memory</p><p>保存必要信息，非易失。保存os在辅存中的位置，开机必要信息</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012849.png" alt="image-20210603102734100" style="zoom: 67%;" /><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="位扩展："><a href="#位扩展：" class="headerlink" title="位扩展："></a><strong>位扩展</strong>：</h5><p>​进行位数的扩充（加大字长） 一个存储器对应byte中的一位</p><p>​例:使用16K<em>1的存储器芯片组成16K</em>8位的存储器</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012851.png" alt="image-20210603104237304"></p><h5 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法:"></a><strong>字扩展法</strong>:</h5><p>​进行字向扩充(位数不变)  需要先选择取哪个存储器</p><p>​例如：用16K*8位的芯片组成64K *8位的存储器</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012852.png" alt="image-20210603104254082"> </p><p>​A0~A13为地址选择 A14 A15为芯片选择（2:4译码器）</p><h5 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法:"></a>字位同时扩展法:</h5><p>​一个存储器的容量为M<em>N位,若使用 l</em>k位的芯片(l&lt;M,K&lt;N),需要在字向和位向同时进行扩展. 此时共需(M&#x2F;l)*(N&#x2F;k)个存储器芯片</p><h4 id="多体并行存储体"><a href="#多体并行存储体" class="headerlink" title="多体并行存储体"></a>多体并行存储体</h4><p>低位交叉编址</p><p>（右图）将相邻的单元放到不同的存储体中，这样<strong>不需要等待恢复时间</strong>再去读取下一个（流水线）</p><p>需要满足当再一次读取到M0时，M0已经恢复</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012853.png" alt="image-20210603112354973" style="zoom: 67%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012854.png" alt="image-20210603111717030"></p><p>宏观上扩展了4倍</p><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>空间局部性原理（访问的都是相近的元素）</p><p>cache和主存可以<strong>以块为单位</strong>交流</p><p>标记项：cache是从主存中<strong>哪里来的</strong>、cache<strong>是否有效</strong></p><h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>​随便放，查找时遍历查看</p><h5 id="直接映射："><a href="#直接映射：" class="headerlink" title="直接映射："></a><strong>直接映射：</strong></h5><p>​主存第j块和Cache第i块有如下函数关系:</p><p>​i&#x3D; j mod m (m为Cache中总块数)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012855.png" alt="image-20210604111316459"></p><p>​访问过程：依据cache块号直接去查找，看表中对应保存的<strong>组号</strong>与主存中组号是否一样。</p><p>​空间利用率低,命中率也低，硬件实现简单,成本低.</p><h5 id="组相联映射："><a href="#组相联映射：" class="headerlink" title="组相联映射："></a><strong>组相联映射：</strong></h5><p>​将cache分组，主存必须放入对应组中，但组内可以随意放置</p><h5 id="替换与修改"><a href="#替换与修改" class="headerlink" title="替换与修改"></a>替换与修改</h5><p>RAND FIFO  LRU（最近最少使用）  LFU(历史次数)</p><p>写回法：脏位决定是否需要写回</p><p>全写法：有一个缓冲同时修改</p><h4 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h4><p>将访问外存（逻辑地址）映射到主存（物理地址）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012856.png" alt="image-20210604115521773"></p><h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012857.png" alt="image-20210604165949832" style="zoom:67%;" /><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012858.png" alt="image-20210604152403058"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012859.png" alt="image-20210604153414463" style="zoom: 80%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012860.png" alt="image-20210604153350576" style="zoom:67%;" /></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012861.png" alt="image-20210604160201175"></p><h4 id="指令的址方式"><a href="#指令的址方式" class="headerlink" title="指令的址方式"></a>指令的址方式</h4><p>1.顺序寻址方式 2.跳跃寻址方式</p><h4 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h4><p>用寻址特征表明现在的寻址方式</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012862.png" alt="image-20210604161158449" style="zoom:67%;" /><p>立即寻址</p><p>寄存器寻址 </p><p>直接寻址</p><p>寄存器间接寻址</p><p>基址寻址（BR）面向操作系统，内容操作系统确定，有利于<strong>多道程序数据块</strong></p><p>变址寻址（IX）用于循环程序，<strong>数组</strong>的偏移</p><p>相对寻址（PC）  （PC）+A  <strong>跳转指令</strong></p><p>寄存器寻址：（SP）保存栈顶指针</p><p>间接寻址</p><h4 id="CISC、RISC"><a href="#CISC、RISC" class="headerlink" title="CISC、RISC"></a>CISC、RISC</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012863.png" alt="image-20210604165458037"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012864.png" alt="image-20210604165743389"></p><h3 id="5-CPU"><a href="#5-CPU" class="headerlink" title="5.CPU"></a>5.CPU</h3><p>ALU+CU+寄存器+中断系统</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012865.png" alt="image-20210605121433796" style="zoom:67%;" /><h4 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h4><p>cpu<strong>内部总线</strong>完成内部数据传输；MAR，MDR要和<strong>内外总线</strong>都要连接</p><p>还有一种结构为：寄存器之间通过<strong>专用线</strong>连接</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012866.png" alt="image-20210605122928712"></p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>一个机器周期（CPU周期）是一次存取周期</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h4 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h4><p>取指、取数</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012868.png" alt="image-20210605132815242" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012869.png" alt="image-20210605132849850" style="zoom: 67%;" /></p><h4 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h4><p><strong>cpu控制方式：</strong></p><p>​同步控制方式、异步控制方式、联合控制方式</p><p>同步：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012867.png" alt="image-20210605123401431" style="zoom: 67%;" /><h5 id="硬布线：RISC"><a href="#硬布线：RISC" class="headerlink" title="硬布线：RISC"></a><strong>硬布线：</strong>RISC</h5><p><strong>节拍发生器</strong>：将时钟转为节拍</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012870.png" alt="image-20210605141903363" style="zoom:50%;" /><p><strong>安排微操作的时钟节拍</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012871.png" alt="image-20210605135938501"></p><p><strong>设计电路</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012872.png" alt="image-20210605141448990"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012873.png" alt="image-20210605141717000"></p><h5 id="微程序：CISC"><a href="#微程序：CISC" class="headerlink" title="微程序：CISC"></a>微程序：CISC</h5><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012874.png" alt="image-20210605154140727" style="zoom:50%;" /><p>​将微指令保存到控制存储器CM中（CPU内部，ROM实现，一条条已经写好的），类似于指令的保存执行</p><p>​水平型：可以同时执行。垂直型：类似机器指令</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012875.png" alt="image-20210605151805913"></p><p>​<strong>操作控制字段</strong>：标记一个个微操作，</p><p>​<strong>直接表示法</strong>：为1就执行 需要很长   <strong>快</strong></p><p>​<strong>编码表示法</strong></p><p>​<strong>混合</strong><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012876.png" alt="image-20210605152026694" style="zoom:50%;" />组内互斥</p><p>​<strong>顺序控制字段</strong>：下一条微指令是 跳转 还是 顺序 </p><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>将这几个过程重叠起来，并行运行</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012877.png" alt="image-20210605160344293" style="zoom: 67%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012878.png" alt="image-20210605160349615"></p><p><strong>问题：</strong></p><p>​时间不一样：全部统一为最长的时间</p><p><strong>冲突：</strong></p><p>​硬件：</p><p>​       结构相关（资源冲突）：硬件资源满足不了  <strong>同时需要访问内存</strong></p><p>​编程：</p><p>​   数据相关（数据冲突）：一条指令依赖前一条指令的执行结果(数据)却无法得到 c&#x3D;a+b； c++;</p><p>​ <strong>硬件直接暂停   添加空指令</strong>  <strong>数据旁路</strong>  <strong>编译优化</strong></p><p>​控制相关（控制冲突）：流水线遇到分支(if) 指令或其他改变PC值的指令</p><p>​（acm算法运行为非流水执行过程。）</p><h3 id="6-总线"><a href="#6-总线" class="headerlink" title="6.总线"></a>6.总线</h3><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012879.png" alt="image-20210607212721351" style="zoom:67%;" /><p>​<strong>分时  共享</strong></p><p>​机械特性、电器特性、功能特性、时间特性</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​串行、并行（宽度高、频率低） </p><p>​(内部总线、系统总线（数据、地址、控制）、I&#x2F;O总线) <strong>轮询</strong></p><p>​单总线双总线（速度不同，进行分离）</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012880.png" alt="image-20210607213949316" style="zoom:50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012881.png" alt="image-20210607213918796" style="zoom:50%;" /></p><p>​三总线（提高io速度）       <strong>DMA控制器</strong>控制高速传输（不用CPU），别的<strong>中断</strong>（鼠标键盘）实现</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012882.png" alt="image-20210607214207930" style="zoom: 67%;" /><p>4总线</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012883.png" alt="image-20210607225218682"></p><p>​地址总线(AB)—其宽度可表明地址空间范围  32位寻址范围2^32 4G</p><p>​数据总线(DB)—其宽度可表明一次读写的二进制位数  32位4B</p><p>​控制总线(CB)— 包括各种控制命令(如存储器读 写、I&#x2F;O读写)、请求信号与仲裁信号、中断请求与应答 等。</p><p>​<strong>复用AB和DB</strong></p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>​时钟周期T：机器的时钟周期     时钟频率：1&#x2F;T</p><p>​传输周期：N个时钟周期：申请、寻址、传输、结束工作频率：1&#x2F;N</p><p>​总线宽度：DB宽度</p><p>​总线带宽：每秒传输的B ，工作频率 * 总线带宽 &#x2F; 8</p><h4 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h4><h5 id="集中总裁"><a href="#集中总裁" class="headerlink" title="集中总裁"></a>集中总裁</h5><p>​<strong>链式查询</strong>：BR BG BS ，  <strong>BG按顺序查询，距离近的优先级高</strong></p><p>​<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012884.png" alt="image-20210607220159388" style="zoom: 67%;" /></p><p>​<strong>计算器定时查询</strong>：独立的BG线，计数器每次加1代表访问下一个IO ， log n</p><p>​<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012885.png" alt="image-20210607220536152" style="zoom:67%;" /></p><p>​<strong>独立请求</strong>：需要排队、速度快。独立的BG线</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012886.png" alt="image-20210607220713828" style="zoom:67%;" /><h5 id="分布式仲裁："><a href="#分布式仲裁：" class="headerlink" title="分布式仲裁："></a><strong>分布式仲裁</strong>：</h5><p>​不需要中央仲裁器，每个潜在的主 方功能模块都有自己的仲裁号和仲裁器</p><p>​将总裁号发到总裁总线上去比较</p><h4 id="总线操作"><a href="#总线操作" class="headerlink" title="总线操作"></a>总线操作</h4><p>​申请分配（请求、仲裁）、寻址阶段、传输阶段、结束阶段</p><p>​<strong>同步定时方式</strong>：根据时钟的<strong>上升沿</strong>控制节奏</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012887.png" alt="image-20210607222304595" style="zoom:50%;" /><p>​<strong>异步定时方式</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012888.png" alt="image-20210607222129667" style="zoom: 50%;" /><p>​<strong>半同步通信</strong>：加控制信号，当数据没传到位时等待</p><p>​<strong>分离式通信：</strong>将准备数据时，总线控制权交出来</p><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012889.png" alt="image-20210607224104543"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012890.png" alt="image-20210607224633259"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012891.png" alt="image-20210607224925037"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012892.png" alt="image-20210607225022641"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012893.png" alt="image-20210607225726363"></p><h3 id="7-IO"><a href="#7-IO" class="headerlink" title="7.IO"></a>7.IO</h3><p>CPU<strong>管理外围设备</strong>有几种方式：</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012894.png" alt="image-20210626104910735" style="zoom:67%;" /><p>IO指令由CPU产生，用来控制IO；通道指令为通道产生，具体执行</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012895.png" alt="image-20210626103906731" style="zoom:67%;" /><h4 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h4><p>​输入： 鼠标键盘    输出 ：显示器打印机</p><p>​外存</p><p><strong>磁表面存储</strong> </p><p>​串行读取</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012896.png" alt="image-20210626110114399" style="zoom:67%;" /><p>​</p><p><strong>磁盘</strong></p><p>​按照扇区读取，寻道-&gt;旋转-&gt;传输时间。利用便宜可以实现加速或者冗余</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012897.png" alt="image-20210626110421321"></p><p><strong>光盘</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012898.png" alt="image-20210626111615777" style="zoom:50%;" /><p><strong>固态硬盘</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012899.png" alt="image-20210626111746131" style="zoom:67%;" /><h4 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h4><p>控制、读取io其实就是访问响应寄存器</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012900.png" alt="image-20210626112849731" style="zoom:67%;" /><p>如何定位编址？统一编址、独立编址（主存的编址和IO的编址是否在一起）</p><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>​比如每秒查询鼠标30次，询问鼠标有没有数据。查到了还需要等待鼠标传输数据</p><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012902.png" alt="image-20210626114555456" style="zoom: 67%;" /><p>在指令完成后，查看中断源寄存器是否有1，有1就进入中断</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012903.png" alt="image-20210626182320701" style="zoom:67%;" /><p>实现<strong>优先级</strong></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012904.png" alt="image-20210626184052004" style="zoom:67%;" /><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304062012905.png" alt="image-20210626184644527"></p><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>​接收IO请求，向CPU发出占用总线的请求</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习CV</title>
    <link href="/2021/08/20/dl/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV/"/>
    <url>/2021/08/20/dl/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0CV/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>抱歉，我无法访问您提供的链接内容。由于您没有提供需要摘要的具体文章内容或文本，我无法生成摘要。    如果您希望我为指定内容提供摘要，您可以直接粘贴相关的文本或具体信息，我可以为您整理一个简洁的总结（不超过1000字）。    如果是其他问题，请明确说明，我会尽力帮助！</p></blockquote><p><a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p><a href="https://course.d2l.ai/zh-v2/">课程安排 - 动手学深度学习课程 (d2l.ai)</a></p><h1 id="动手学深度学习"><a href="#动手学深度学习" class="headerlink" title="动手学深度学习"></a>动手学深度学习</h1><p>AI map</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151329785.png" alt="image-20230515132921268" style="zoom:67%;" /><h3 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>torch.cat((X, Y), dim=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 合并</span><br>a.T <span class="hljs-comment"># 转置</span><br>a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>) <br>a.mean() a.numel()<br><br>torch.dot(x,y) <span class="hljs-comment"># 向量点积</span><br>torch.mv(A,x)  <span class="hljs-comment"># 矩阵*向量</span><br>torch.mm(A,A)  <span class="hljs-comment"># 矩阵乘</span><br>torch.norm(A)  <span class="hljs-comment"># 二范数</span><br><br><span class="hljs-comment"># 广播机制自动扩展</span><br>a = torch.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>))<br>b = torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>a+b<br><br><span class="hljs-comment"># 内存机制</span><br>X = Y<span class="hljs-comment"># id相同</span><br>Y += X     <span class="hljs-comment"># id(Y)不变</span><br><br>X = Y.clone() <span class="hljs-comment">#id 变了</span><br>Y = Y + X  <span class="hljs-comment"># id(Y)变了</span><br><br><span class="hljs-comment"># numpy 相互转换</span><br>A = torch.tensor(A)<br>A = A.numpy()<br></code></pre></td></tr></table></figure><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建数据csv文件</span><br>os.makedirs(os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>), exist_ok=<span class="hljs-literal">True</span>)<br>data_file = os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;house_tiny.csv&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_file, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="hljs-comment"># 列名</span><br>    f.write(<span class="hljs-string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="hljs-comment"># 每行表示一个数据样本</span><br>    f.write(<span class="hljs-string">&#x27;2,NA,106000\n&#x27;</span>)<br><br><span class="hljs-comment"># 读取csv</span><br>data = pd.read_csv(data_file)<br>data = data.fillna(data.mean())  <span class="hljs-comment"># 处理数值中的NA</span><br><span class="hljs-built_in">print</span>(data)<br>data = pd.get_dummies(data, dummy_na=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将数据转为0 1，添加新的列</span><br>torch.tensor(data.values)<br></code></pre></td></tr></table></figure><h4 id="向量求导"><a href="#向量求导" class="headerlink" title="向量求导"></a>向量求导</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151334475.png" alt="image-20210729204049868" style="zoom:50%;" /><h4 id="正向累积与反向求导"><a href="#正向累积与反向求导" class="headerlink" title="正向累积与反向求导"></a>正向累积与反向求导</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335071.png" alt="image-20210715122123643"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335072.png" alt="image-20210715122132742" style="zoom:50%;" /><h4 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">x =  torch.arange(<span class="hljs-number">4.0</span>)<br>x.requires_grad_(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 等价于 `x = torch.arange(4.0, requires_grad=True)`</span><br>y = <span class="hljs-number">2</span> * torch.dot(x, x) <span class="hljs-comment"># loss一般为标量</span><br>y.backward() <span class="hljs-comment"># 反向传播</span><br>x.grad<br>tensor([ <span class="hljs-number">0.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">12.</span>])<br><br><span class="hljs-comment"># 梯度分离计算</span><br>x.grad.zero_()<br>y = x * x<br>u = y.detach()      <span class="hljs-comment"># u不计算梯度,相当于常数，从计算图剥离</span><br>z = u * x<br>z.<span class="hljs-built_in">sum</span>().backward()  <span class="hljs-comment">#非标量求sum，使得标量</span><br>x.grad == u<br></code></pre></td></tr></table></figure><p>sinx 和 sinx的求导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x=torch.arange(<span class="hljs-number">0.</span>,<span class="hljs-number">10.</span>,<span class="hljs-number">0.1</span>)x.requires_grad_(<span class="hljs-literal">True</span>)y=torch.sin(x)y.<span class="hljs-built_in">sum</span>().backward()plt.plot(x.detach(), y.detach())plt.plot(x.detach(), x.grad)<br></code></pre></td></tr></table></figure><p>帮助文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span>(torch.ones)<br></code></pre></td></tr></table></figure><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>模型：y &#x3D; &lt;x,w&gt; + b</p><p>损失：（y-y)^2^ </p><p>关于w求导，有显示解</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335073.png" alt="image-20210729210215127" style="zoom:50%;" /><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335074.png" alt="image-20210729210517365" style="zoom: 50%;" /><h5 id="BGD"><a href="#BGD" class="headerlink" title="BGD"></a><strong>BGD</strong></h5><p>(Batch Gradient Descent)</p><p>​使用全部数据集</p><h5 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a><strong>SGD</strong></h5><p>（stochastic gradient descent）</p><p>​使用1个数据</p><h5 id="MBGD"><a href="#MBGD" class="headerlink" title="MBGD"></a>MBGD</h5><p>（mini-batch Gradient Descent）</p><p>​使用batchsize</p><h5 id="动量法："><a href="#动量法：" class="headerlink" title="动量法："></a><strong>动量法：</strong></h5><p>梯度更新 &#x3D; 当前的梯度方向*0.1  +  之前的累加 (v) *0.9  (u) ，还可以逃出局部最优解   <strong>0.9</strong></p><h5 id="自适应梯度法"><a href="#自适应梯度法" class="headerlink" title="自适应梯度法"></a><strong>自适应梯度法</strong></h5><p><strong>RMSProp：</strong>调整学习率  <strong>0.999</strong></p><p>​对震荡方向减小变化，非震荡方向增大变化，变化值保存到r中,用梯度的平方表示震荡</p><h5 id="adam："><a href="#adam：" class="headerlink" title="adam："></a><strong>adam</strong>：</h5><p>​动量法+自适应+修正解决冷启动</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335075.png" alt="image-20210801153746463" style="zoom: 80%;" /><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>1.生成数据</p><p>2.生成batchsize迭代器</p><p>3.参数与模型定义 net &#x3D; nn.Sequential(nn.Linear(2, 1))</p><p>4.损失函数与优化 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 损失函数默认是batch中 平均</span><br>nn.MSELoss() <br>torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><span class="hljs-keyword">or</span> <br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>param -= lr * param.grad / batch_size<br></code></pre></td></tr></table></figure><ul><li>初始化参数</li><li>重复，直到完成<ul><li>计算损失                                           <strong>l&#x3D;loss(net(X), y)</strong></li><li>计算梯度 g←∂(w,b)1|B|∑i∈Bl(x(i),y(i),w,b)g←∂(w,b)1|B|∑i∈Bl(x(i),y(i),w,b)   <strong>l.backward()</strong></li><li>更新参数 (w,b)←(w,b)−ηg               <strong>trainer.step()</strong></li></ul></li></ul><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h4><p>softmax转为概率，交叉熵来衡量概率区别</p><h4 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h4><p>784输入 ， 10输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist_train = torchvision.datasets.FashionMNIST(root=<span class="hljs-string">&quot;../data&quot;</span>, train=<span class="hljs-literal">True</span>,                                                transform=trans,                                                download=<span class="hljs-literal">True</span>)train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="hljs-literal">True</span>,                             num_workers=get_dataloader_workers())<br></code></pre></td></tr></table></figure><p>自定义croos_entropy需要先softmax，后面还需要sum；torch的都不用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">X</span>):    <br>    X_exp = torch.exp(X)    <br>    partition = X_exp.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)    <br>    <span class="hljs-keyword">return</span> X_exp / partition  <br><span class="hljs-comment"># 这里应用了广播机制</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">net</span>(<span class="hljs-params">X</span>):    <br>    <span class="hljs-keyword">return</span> softmax(np.dot(X.reshape((-<span class="hljs-number">1</span>, W.shape[<span class="hljs-number">0</span>])), W) + b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):    <br>    <span class="hljs-keyword">return</span> -np.log(y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y])<br>y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y] <span class="hljs-comment"># 取出每个实际标签的得分</span><br></code></pre></td></tr></table></figure><p>net</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>一次epoch训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch3</span>(<span class="hljs-params">net, train_iter, loss, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;训练模型一个迭代周期（定义见第3章）。&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将模型设置为训练模式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.train()<br>    <span class="hljs-comment"># 训练损失总和、训练准确度总和、样本数</span><br>    metric = Accumulator(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-comment"># 计算梯度并更新参数</span><br>        y_hat = net(X)<br>        l = loss(y_hat, y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            <span class="hljs-comment"># 使用PyTorch内置的优化器和损失函数</span><br>            updater.zero_grad()<br>            l.backward()<br>            updater.step()<br>            metric.add(<br>                <span class="hljs-built_in">float</span>(l) * <span class="hljs-built_in">len</span>(y), accuracy(y_hat, y),<br>                y.size().numel())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用定制的优化器和损失函数</span><br>            l.<span class="hljs-built_in">sum</span>().backward()<br>            updater(X.shape[<span class="hljs-number">0</span>])<br>            metric.add(<span class="hljs-built_in">float</span>(l.<span class="hljs-built_in">sum</span>()), accuracy(y_hat, y), y.numel())<br>    <span class="hljs-comment"># 返回训练损失和训练准确率</span><br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">2</span>], metric[<span class="hljs-number">1</span>] / metric[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>多次epoch，传入网络，训练数据，测试数据，loss，迭代次数，优化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_ch3</span>(<span class="hljs-params">net, train_iter, test_iter, loss, num_epochs, updater</span>):<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)        <span class="hljs-comment"># 每次epoch后进行一次评估        test_acc = evaluate_accuracy(net, test_iter)</span><br></code></pre></td></tr></table></figure><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>Multilayer Perceptro</p><p>线性分类器只能产生线性分类器，XOR函数不能拟合</p><p>多层线性＋激活函数 sigmoid tanh relu</p><p>SVM多超参数不敏感，用起来更简单</p><p>深层比浅层更好训练</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335076.png" alt="image-20210802172049923" style="zoom:50%;" /><h4 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h4><p>训练误差，泛化误差</p><p>训练集 、验证集、 测试集</p><p>训练集训练参数，验证集来选择模型超参数</p><h5 id="k折交叉验证"><a href="#k折交叉验证" class="headerlink" title="k折交叉验证"></a>k折交叉验证</h5><p>​小数据集：K次模型训练和验证，每次在K−1个子集上进行训练，并在剩余的一个子集验证，K次实验的结果取平均来估计训练和验证误差。k&#x3D;5、10</p><h5 id="过拟合欠拟合"><a href="#过拟合欠拟合" class="headerlink" title="过拟合欠拟合"></a>过拟合欠拟合</h5><p>过拟合：模型相比于数据过于复杂</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335077.png" alt="image-20210803135322068"></p><p>模型输入为x^0  x^1  x^2 ….</p><p>当模型给到了x^20次方时，会过拟合</p><h4 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h4><p><strong>手动实现</strong>：loss中加上一个损失，lambd&#x3D;8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">l = loss(net(X), y) + lambd *  torch.<span class="hljs-built_in">sum</span>(w.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br>l.<span class="hljs-built_in">sum</span>().backward()<br>d2l.sgd([w, b], lr, batch_size)<br></code></pre></td></tr></table></figure><p><strong>迭代器</strong>：weight_decay &#x3D; 0.001</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 都有衰减</span><br>trainer = torch.optim.SGD(net.parameters(),weight_decay = wd, lr=lr)<br><span class="hljs-comment"># 偏置参数没有衰减。</span><br>trainer = torch.optim.SGD([&#123;<br>    <span class="hljs-string">&quot;params&quot;</span>: net[<span class="hljs-number">0</span>].weight,<span class="hljs-string">&#x27;weight_decay&#x27;</span>: wd&#125;, &#123;<br>    <span class="hljs-string">&quot;params&quot;</span>: net[<span class="hljs-number">0</span>].bias&#125;], <br>    lr=lr)<br><br>trainer.zero_grad()<br>l = loss(net(X), y)<br>l.backward()<br>    trainer.step()<br></code></pre></td></tr></table></figure><p>L1: torch.sum( torch.abs(w) )</p><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>全连接上，比L2好一点</p><p>随机中间层变成0，p概率。总体期望不能变，需要除以(1-p) ;       p&#x3D;0.5  0.1  0.9</p><p><strong>自己实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dropout_layer</span>(<span class="hljs-params">X, dropout</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt;= dropout &lt;= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 在本情况中，所有元素都被丢弃。</span><br>    <span class="hljs-keyword">if</span> dropout == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> torch.zeros_like(X)<br>    <span class="hljs-comment"># 在本情况中，所有元素都被保留。</span><br>    <span class="hljs-keyword">if</span> dropout == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> X<br>    mask = (torch.Tensor(X.shape).uniform_(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &gt; dropout).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> mask * X / (<span class="hljs-number">1.0</span> - dropout)<br><br>H1 = <span class="hljs-variable language_">self</span>.relu(<span class="hljs-variable language_">self</span>.lin1(X.reshape((-<span class="hljs-number">1</span>, <span class="hljs-variable language_">self</span>.num_inputs))))<br><span class="hljs-comment"># 只有在训练模型时才使用dropout，测试时直接跳过</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.training == <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 在第一个全连接层之后添加一个dropout层</span><br>    H1 = dropout_layer(H1, dropout1)<br></code></pre></td></tr></table></figure><p><strong>torch</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.Dropout(p=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><h4 id="数据稳定性"><a href="#数据稳定性" class="headerlink" title="数据稳定性"></a>数据稳定性</h4><p>梯度消失和梯度爆炸：sigmoid导数 ： y(1-y)      当多个相乘后就可能很小；</p><p>乘法变加法：ResNet LSTM</p><p>权重初始化、激活函数选择</p><h4 id="房价预测"><a href="#房价预测" class="headerlink" title="房价预测"></a>房价预测</h4><p>数据量较少，k折交叉验证</p><p>1.数据列标准化，并填空值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">numeric_features = all_features.dtypes[all_features.dtypes != <span class="hljs-string">&#x27;object&#x27;</span>].index<br>all_features[numeric_features] = all_features[numeric_features].apply(    <span class="hljs-keyword">lambda</span> x: (x - x.mean()) / (x.std()))<br><span class="hljs-comment"># 在标准化数据之后，所有数据都意味着消失，因此我们可以将缺失值设置为0</span><br>all_features[numeric_features] = all_features[numeric_features].fillna(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>2.非数据onehot，NAN也算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">all_features = pd.get_dummies(all_features, dummy_na=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>3.损失函数mse、评价指标如下、迭代器adam(学习率不敏感)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335078.png" alt="image-20210809134630261"></p><p>对于少量数据k验证，使用多层感知机后发现过拟合了</p><h3 id="房价预测-1"><a href="#房价预测-1" class="headerlink" title="房价预测"></a>房价预测</h3><p>数组大：对大数值log</p><p>文本特征：onehot是不行的，需要将文本求特征</p><p>训练数据前6月，公榜后3个月，私榜再后3个月</p><p>只取数字-&gt;取文本unique较少的部分</p><p>3层线性加L2，lr0.02，损失函数越来越多<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335079.png" alt="image-20210809191439398" style="zoom:50%;" /></p><p>4层线性，lr&#x3D;0.05,测试集误差在0.3左右<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335080.png" alt="image-20210809191904988" style="zoom:50%;" /></p><p>lr&#x3D;0.02 L2&#x3D;0.001<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335081.png" alt="image-20210809192441435" style="zoom:50%;" />L2&#x3D;0<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335082.png" alt="image-20210809192626754" style="zoom:50%;" /></p><p>5层 lr&#x3D;0.02<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335083.png" alt="image-20210809192835180" style="zoom: 33%;" />batchsize128<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335084.png" alt="image-20210809193317967" style="zoom:50%;" /></p><p>4层 0.05, 0, 128<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335085.png" alt="image-20210809193927803" style="zoom:50%;" /></p><h3 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h3><h4 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h4><p>二维全连接加限制</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335086.png" alt="image-20210810114817749" style="zoom:67%;" /><p>平移不变性：卷积核不依赖于位置<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335087.png" alt="image-20210810111608989" style="zoom:50%;" /></p><p>局部性：只由周围一定范围影响，限制ab范围</p><p><strong>二维互相关运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d</span>(<span class="hljs-params">X, K</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;计算二维互相关运算。&quot;&quot;&quot;</span><br>    h, w = K.shape<br>    Y = torch.zeros((X.shape[<span class="hljs-number">0</span>] - h + <span class="hljs-number">1</span>, X.shape[<span class="hljs-number">1</span>] - w + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">1</span>]):<br>            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> Y<br></code></pre></td></tr></table></figure><p><strong>卷积层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Conv2D</span>(nn.Module):    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, kernel_size,bias=<span class="hljs-literal">False</span></span>):        <br>        <span class="hljs-built_in">super</span>().__init__()        <br>        <span class="hljs-variable language_">self</span>.weight = nn.Parameter(torch.rand(kernel_size))        <br>        <span class="hljs-variable language_">self</span>.bias = nn.Parameter(torch.zeros(<span class="hljs-number">1</span>))        <br>        <span class="hljs-variable language_">self</span>.is_bias = bias    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):        <br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_bias:            <br>            <span class="hljs-keyword">return</span> corr2d(x, <span class="hljs-variable language_">self</span>.weight) + <span class="hljs-variable language_">self</span>.bias        <br>        <span class="hljs-keyword">else</span>:            <br>            <span class="hljs-keyword">return</span> corr2d(x, <span class="hljs-variable language_">self</span>.weight)<br></code></pre></td></tr></table></figure><p><strong>实验：</strong>训练一个边缘卷积核，包括使用自己的卷积层</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335088.png" alt="image-20210810131342542"></p><p>一般2p &#x3D; k - 1，在这种情况下且原来大小w能被s整除，w &#x3D; w&#x2F;s ,  s影响计算量</p><p><strong>多输入通道</strong>：ci每一个输入通道一个核，求和后得到一个输出  ( ci * h * w) * ( ci * h * w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d_multi_in</span>(<span class="hljs-params">X, K</span>):<br>    <span class="hljs-comment"># 先遍历 “X” 和 “K” 的第0个维度（通道维度），再把它们加在一起</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(d2l.corr2d(x, k) <span class="hljs-keyword">for</span> x, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X, K))<br></code></pre></td></tr></table></figure><p><strong>多输出通道</strong>：c0每个输出多次求多输入通道     ( ci * h * w)    *  ( c0 * ci * h * w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">corr2d_multi_in_out</span>(<span class="hljs-params">X, K</span>):<br>    <span class="hljs-comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span><br>    <span class="hljs-comment"># 最后将所有结果都叠加在一起</span><br>    <span class="hljs-keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> K], <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335089.png" alt="image-20210810134504645"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335090.png" alt="image-20210810134730194" style="zoom:50%;" /><p>参数量：C * C * H * W</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>使用经典网络还是自己设计：使用经典，微调         resnet</p><p>3 * 3可以提取空间信息； 1 * 1可以做通道融合   ，二者结合当卷积可以节约计算量</p><p>1d卷积可以处理文本</p><p>3d卷积处理视频或深度图片</p><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>对于每一个输出通道进行，最大、平均。通常步长等于核大小</p><p><strong>减小运算量、增大感受野、非极大抑制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="hljs-built_in">max</span>()<br></code></pre></td></tr></table></figure><p>池化现在用的越来越少，卷积中可以加stride。数据加了增强，不需要池化来消除便宜</p><p>缩小两倍，尺寸不变：nn.MaxPool2d(kernel_size&#x3D;2,stride&#x3D;2)   vgg</p><p>​nn.MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;1)         googlenet</p><h3 id="经典网络"><a href="#经典网络" class="headerlink" title="经典网络"></a>经典网络</h3><p>机器学习：<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335091.png" alt="image-20210810155949246" style="zoom:50%;" /></p><p>关键是特征提取，然后SVM等</p><h4 id="0-LeNet"><a href="#0-LeNet" class="headerlink" title="0.LeNet"></a>0.LeNet</h4><p>和MLP比起来，模型量小了，overfitting小了</p><p>​conv -&gt; subsampling-&gt;conv-&gt;subsampling-&gt;FC-&gt;FC-&gt;FC     2conv+3FC</p><p>lr 0.9-&gt;0.5  sigmoid-&gt;ReLU     acc上升0.876</p><h4 id="1-AlexNet"><a href="#1-AlexNet" class="headerlink" title="1.AlexNet"></a>1.AlexNet</h4><p><strong>dropout   ReLU  MaxPooling   数据增强</strong></p><p>10倍参数，250倍计算量LeNet</p><p>​5个conv + 3个FCN（Dropout）</p><p>acc 0.883</p><h4 id="2-VGG"><a href="#2-VGG" class="headerlink" title="2.VGG"></a>2.VGG</h4><p>vgg块：多个3*3卷积 + 池化            每次宽高减半，通道加倍</p><p>最后同样3个FCN（Dropout）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">conv_arch11 = ((<span class="hljs-number">1</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">512</span>))<br>conv_arch16 = ((<span class="hljs-number">2</span>, <span class="hljs-number">64</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">512</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">vgg_block</span>(<span class="hljs-params">num_convs, in_channels, out_channels</span>):<br>    layers = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layers.append(nn.Conv2d(in_channels, out_channels,<br>                                kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br>        layers.append(nn.ReLU())<br>        in_channels = out_channels<br>    layers.append(nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br></code></pre></td></tr></table></figure><p>这里降低vgg11通道数进行训练，batchsize&#x3D;16，训练了1h，过拟合明显</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">train</span> acc <span class="hljs-number">0</span>.<span class="hljs-number">964</span>, test acc <span class="hljs-number">0</span>.<span class="hljs-number">928</span><br></code></pre></td></tr></table></figure><h4 id="3-NIN"><a href="#3-NIN" class="headerlink" title="3.NIN"></a>3.NIN</h4><p>第一个FC的参数量太大了，很容易<strong>过拟合</strong>。NIN完全<strong>放弃全连接</strong></p><p>NIN块：卷积+2个1*1卷积，然后加maxpool。</p><p>最后留10通道<strong>每个通道</strong>全局最大池化<strong>nn.AdaptiveAvgPool2d(1)</strong>, 全局池化也可以用来中间降低复杂度，但收敛更慢</p><h4 id="4-GoogleNet"><a href="#4-GoogleNet" class="headerlink" title="4.GoogleNet"></a>4.GoogleNet</h4><p>inception输入输出大小不变,步长都是1。block：多个Inception后加一个maxpool</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335092.png" alt="image-20210810200812388" style="zoom: 50%;" /><p>大量使用1 * 1 ，最后1024通道GlobalAvgPool后传入FC。并行通道提升网络复杂度</p><p>前两大段卷积提取，降低8倍大小。</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335093.png" alt="image-20210810202558830" style="zoom:50%;" /><p>v2使用batch normalization</p><p>v3修改inception，使用3*3级联代替5 *5，和使用1 * 3、3 * 1卷积</p><p>v4使用残差</p><h4 id="5-归一化"><a href="#5-归一化" class="headerlink" title="5.归一化"></a>5.归一化</h4><p>通过一个batch中的均值和方差来提高<strong>数值稳定性</strong>。固定小批量中的均值和方差，加速收敛速度但不改变准确率。</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335094.png" alt="image-20210811130833324"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335095.png" alt="image-20210811135140140" style="zoom:67%;" /><p>全连接对batch求     mean &#x3D; X.mean(dim&#x3D;0)         预测时就只有一个，所以用全局的</p><p>卷积层对某一通道所有元素所有batch求   mean &#x3D; X.mean(dim&#x3D;(0, 2, 3), keepdim&#x3D;True)</p><p>u σ在<strong>推理</strong>时使用<strong>全局</strong>的，在训练中不断动量更新。<strong>训练</strong>时为当前数据的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 训练模式下，用当前的均值和方差做标准化</span><br><span class="hljs-attr">X_hat</span> = (X - mean) / torch.sqrt(var + eps)<br><span class="hljs-comment"># 更新移动平均的均值和方差</span><br><span class="hljs-attr">moving_mean</span> = momentum * moving_mean + (<span class="hljs-number">1.0</span> - momentum) * mean<br><span class="hljs-attr">moving_var</span> = momentum * moving_var + (<span class="hljs-number">1.0</span> - momentum) * var<br></code></pre></td></tr></table></figure><p>γ β是归一化层参数，不断训练</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Y = <span class="hljs-built_in">gamma</span> * X_hat + <span class="hljs-built_in">beta</span>  <span class="hljs-meta"># 缩放和移位</span><br><span class="hljs-keyword">return</span> Y<br></code></pre></td></tr></table></figure><p>参数：输入维度、全连接还是卷积</p><p>原论文：<strong>梯度爆炸和梯度消失在引入bn层之后基本解决</strong></p><p>用在LeNet上 原来50epoch现在只需要10epoch来达到0.875</p><h4 id="6-RestNet"><a href="#6-RestNet" class="headerlink" title="6.RestNet"></a>6.RestNet</h4><p><strong>函数角度：</strong>不断加大模型的复杂度，并且包括原来的内容</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335096.png" alt="image-20210811140847581" style="zoom: 67%;" /><p><strong>梯度角度：</strong>前面的w还是能更新，处了乘法边还有一条边。</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335097.png" alt="image-20210811152206875" style="zoom: 50%;" /><p>Residual块：主干2个卷积；如果加通道，分支1*1卷积改变通道和大小。有原大小 和 大小减半通道加倍两种</p><p>​卷积 归一  激活 卷积 归一  +x   激活</p><p>resnet_block：多个Residual（2个），第一个进行通道加倍大小减半，别的为普通的</p><p><strong>res18</strong>：单次卷积 + 4个block（第一个不改通道） + AdaptiveAvgPool2d FC</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335098.png" alt="image-20210811150840115"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res18：<br>train acc <span class="hljs-number">0.996</span>, test acc <span class="hljs-number">0.918</span> 明显过拟合，但精度特别高<br><span class="hljs-number">658.9</span> examples/sec<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">res34</span>:<br><span class="hljs-attribute">train</span> acc <span class="hljs-number">0</span>.<span class="hljs-number">983</span>, test acc <span class="hljs-number">0</span>.<span class="hljs-number">903</span><br><span class="hljs-attribute">369</span>.<span class="hljs-number">8</span> examples/sec<br></code></pre></td></tr></table></figure><p> 改良版：“批量归一化、激活和卷积”结构</p><p><strong>Res50</strong>：Bottleneck：先卷积缩小通道，再用3*3卷积（stride在这一层），最后再扩大通道</p><p>in_places：输入通道数</p><p>places：中转小通道数，输出通道为expansion  * places</p><p>stride&#x3D;1：是否缩小</p><p>downsampling&#x3D;False：级联Bottleneck的第一个需要，表示通道是否变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_layer</span>(<span class="hljs-params">self, in_places, places, block, stride</span>):<br>        layers = []<br>        <span class="hljs-comment"># 进去in_places，出来places * expansion。所以downsampling</span><br>        <span class="hljs-comment"># stride第一个layer时=1 </span><br>        layers.append(Bottleneck(in_places, places,stride, downsampling =<span class="hljs-literal">True</span>))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, block):<br>            layers.append(Bottleneck(places*<span class="hljs-variable language_">self</span>.expansion, places))<br><br>        <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br>    <br>ResNet50([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>])  ResNet101([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">23</span>, <span class="hljs-number">3</span>])  ResNet512([<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">36</span>, <span class="hljs-number">3</span>])<br><span class="hljs-variable language_">self</span>.layer1 = <span class="hljs-variable language_">self</span>.make_layer(in_places = <span class="hljs-number">64</span>, places= <span class="hljs-number">64</span>, block=blocks[<span class="hljs-number">0</span>], stride=<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">self</span>.layer2 = <span class="hljs-variable language_">self</span>.make_layer(in_places = <span class="hljs-number">256</span>,places=<span class="hljs-number">128</span>, block=blocks[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br><span class="hljs-variable language_">self</span>.layer3 = <span class="hljs-variable language_">self</span>.make_layer(in_places=<span class="hljs-number">512</span>,places=<span class="hljs-number">256</span>, block=blocks[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br><span class="hljs-variable language_">self</span>.layer4 = <span class="hljs-variable language_">self</span>.make_layer(in_places=<span class="hljs-number">1024</span>,places=<span class="hljs-number">512</span>, block=blocks[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="7-DenseNet"><a href="#7-DenseNet" class="headerlink" title="7.DenseNet"></a>7.DenseNet</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335099.png" alt="image-20210811154128250" style="zoom:67%;" /><p>DenseBlock：卷积后和卷积前进行堆叠 ，num_convs(堆叠次数), input_channels, growth_rate(每次成长通道数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_convs):<br>        layer.append(conv_block(<br>            num_channels * i + input_channels, num_channels))<br>    <span class="hljs-variable language_">self</span>.net = nn.Sequential(*layer)<br><span class="hljs-keyword">for</span> blk <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.net:<br>    Y = blk(X)<br>    <span class="hljs-comment"># 连接通道维度上每个块的输入和输出</span><br>    X = torch.cat((X, Y), dim=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="kaggle"><a href="#kaggle" class="headerlink" title="kaggle"></a>kaggle</h4><p><a href="https://www.kaggle.com/competitions/classify-leaves">https://www.kaggle.com/competitions/classify-leaves</a></p><p><a href="https://www.kaggle.com/sheepwang/leaf-classification-eda-model">https://www.kaggle.com/sheepwang/leaf-classification-eda-model</a></p><p>类型处理：转为集合再转列表再排序，最后放入字典中class2idx</p><p>timm模型库</p><p><strong>模型融合：</strong>softmax融合或者3模型投票</p><p><strong>tta</strong>：自动将测试图片进行变换</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335100.png" alt="image-20210822223718937"></p><p><a href="https://blog.csdn.net/weixin_38208912/article/details/104976458">图像分类竞赛——Test Time Augmentation（TTA）_再困也得吃的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install ttach <span class="hljs-comment">#Test Time Augmentation</span><br>tta_model = tta.ClassificationTTAWrapper(model, tta.aliases.five_crop_transform(),  merge_mode=<span class="hljs-string">&#x27;mean&#x27;</span>)<br>y_hat = tta_model(x)<br></code></pre></td></tr></table></figure><p>lr &#x3D; 0.1 波动很大，lr太大了</p><p>resnet34预训练   lr &#x3D; 0.01  SGD<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335101.png" alt="image-20210811205844447" style="zoom: 80%;" /></p><p>resnet34无预训练  lr &#x3D; 0.01<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335102.png" alt="image-20210811212948245" style="zoom:50%;" /></p><p>自己的resnet34 lr &#x3D; 0.01<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335103.png" alt="image-20210811215448723" style="zoom:50%;" /></p><p>自己的resnet50  lr &#x3D; 0.01<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335104.png" alt="image-20210811221815881" style="zoom: 50%;" /></p><p>网络：efficientnet_pytorch , seresnext50_32x4d,  resnet50,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">!pip install timm<br>model_1 = timm.create_model(<span class="hljs-string">&#x27;seresnext50_32x4d&#x27;</span>, pretrained=<span class="hljs-literal">True</span>)<br>model_1.fc = nn.Linear(model_1.fc.in_features, <span class="hljs-number">176</span>)<br></code></pre></td></tr></table></figure><p>renet34       1e-4     64</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335105.png" alt="image-20210812015137028" style="zoom:67%;" /><h5 id="resnet50"><a href="#resnet50" class="headerlink" title="resnet50"></a>resnet50</h5><p>​b&#x3D;128（最大）  3.5mins       b&#x3D;16 6mins               b&#x3D;16 7mins 本地</p><p>​本地的5轮达到最佳0.884，云端大约0.94</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">k折 train:<span class="hljs-number">0.9831</span>  test：<span class="hljs-number">0.9082</span> 最好的有<span class="hljs-number">0.93</span>        score:<span class="hljs-number">0.92204</span><br></code></pre></td></tr></table></figure><h5 id="efficientb5"><a href="#efficientb5" class="headerlink" title="efficientb5"></a>efficientb5</h5><p>​             b&#x3D;32          epo&#x3D;5:     </p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335106.png" alt="image-20210812112126130" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">k折  train:<span class="hljs-number">0.9727</span>  test:<span class="hljs-number">0.9418</span>   Score: <span class="hljs-number">0.93613</span><br></code></pre></td></tr></table></figure><p>数据增广+ 标准化  + cos （主要效果）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train acc:<span class="hljs-number">0.9988</span>, test acc:<span class="hljs-number">0.9548</span>            score：<span class="hljs-number">0.96386</span><br></code></pre></td></tr></table></figure><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335107.png" alt="image-20210813231542618" style="zoom: 67%;" /><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">工业实际与打比赛的要求确实不一样，工业更多专注数据质量（数据每天都在变化），打比赛是调模型（因为是死数据），工业是<span class="hljs-number">85</span>%精度可以部署测试，然后不断增强数据质量，不断喂大量数据，基本<span class="hljs-number">3</span>个月-半年后，模型基本可以达到<span class="hljs-number">95</span>%以上是没问题的，然后部署生产环境，闭环落地！<br>工业界<span class="hljs-number">80</span>%时间在和数据打交道<br></code></pre></td></tr></table></figure><h4 id="多GPU"><a href="#多GPU" class="headerlink" title="多GPU"></a>多GPU</h4><p>GPU batchsize越大，越能发挥性能。但需要的epoch更多</p><p>数据并行性：batchsize分到不同gpu上，最后梯度一起求和求平均</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335108.png" alt="image-20210813133655919" style="zoom: 67%;" /><p>模型并行性：一个模型太大了放不下</p><h5 id="all-reduce"><a href="#all-reduce" class="headerlink" title="all_reduce"></a>all_reduce</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将梯度信息累加起来</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">allreduce</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        data[<span class="hljs-number">0</span>][:] += data[i].to(data[<span class="hljs-number">0</span>].device)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        data[i] = data[<span class="hljs-number">0</span>].to(data[i].device)<br></code></pre></td></tr></table></figure><p>训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_batch</span>(<span class="hljs-params">X, y, device_params, devices, lr</span>):<br>    X_shards, y_shards = split_batch(X, y, devices)<br>    <span class="hljs-comment"># 在每个GPU上分别计算损失</span><br>    ls = [loss(lenet(X_shard, device_W), y_shard).<span class="hljs-built_in">sum</span>()<br>          <span class="hljs-keyword">for</span> X_shard, y_shard, device_W <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>              X_shards, y_shards, device_params)]<br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> ls:  <span class="hljs-comment"># 反向传播在每个GPU上分别执行</span><br>        l.backward()<br>    <span class="hljs-comment"># 将每个GPU的所有梯度相加，并将其广播到所有GPU</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(device_params[<span class="hljs-number">0</span>])):<br>            allreduce([device_params[c][i].grad <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(devices))])<br>    <span class="hljs-comment"># 在每个GPU上分别更新模型参数</span><br>    <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> device_params:<br>        d2l.sgd(param, lr, X.shape[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 在这里，我们使用全尺寸的小批量</span><br></code></pre></td></tr></table></figure><p>简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = nn.DataParallel(net, device_ids=devices)<br>X, y = X.to(devices[<span class="hljs-number">0</span>]), y.to(devices[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h4><p>需要网络通信：先本地all_reduce，网络通信再all_reduce</p><p>t  &#x3D;  max( 计算时间， 通信时间 )。但增加batchsize需要更多epoch</p><p>读取速度也可能慢：多进程</p><h3 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h3><h4 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">需要PIL.Image.<span class="hljs-built_in">open</span>()读入RGB图像<br><br>transform = transforms.Compose([<br>    <span class="hljs-comment">#transforms.Resize(256),      短边到256，长边跟着变</span><br>    <span class="hljs-comment">#transforms.CenterCrop(224),  取出正方形</span><br>    transforms.Resize(<span class="hljs-number">224</span>),<br>    transforms.CenterCrop(<span class="hljs-number">224</span>),  <span class="hljs-comment"># 取出正方形</span><br>    transforms.RandomHorizontalFlip(p=<span class="hljs-number">0.5</span>),   <span class="hljs-comment">#随机水平翻转</span><br>    transforms.RandomVerticalFlip(p=<span class="hljs-number">0.5</span>),     <span class="hljs-comment">#除了水平竖直反转之外其他的处理方法貌似都会降低acc</span><br>    <span class="hljs-comment">#transforms.RandomResizedCrop((224, 224), scale=(0.7, 1),ratio(0.75,1.25)),  随机裁剪为不同的大小scale和宽高比ratio，然后缩放所裁剪得到的图像为制定的大小</span><br>    <span class="hljs-comment">#transforms.RandomCrop((60, 120)), # 随机剪裁</span><br>    <span class="hljs-comment"># transforms.ColorJitter(0.3, 0.3, 0.2), # 修改亮度、对比度和饱和度</span><br>    <span class="hljs-comment">#transforms.RandomRotation(180), # 依degrees 随机旋转一定角度   10</span><br>    transforms.ToTensor(),<br>    transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br><br>test_augs = torchvision.transforms.Compose([<br>    torchvision.transforms.Resize(<span class="hljs-number">256</span>),<br>    torchvision.transforms.CenterCrop(<span class="hljs-number">224</span>),<br>    torchvision.transforms.ToTensor(),<br>    transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br></code></pre></td></tr></table></figure><h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>神经网络前面卷积网络是<strong>特征提取</strong>，利用已经训练好的网络来训练我们的数据。</p><p>底层的信息为更好的特征，可以固定住</p><p>微调前面的参数，重点fc参数  ，learning_rate &#x3D; 5e-5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_trainer</span>(<span class="hljs-params">net, learning_rate, param_group = <span class="hljs-literal">True</span></span>)<br><span class="hljs-keyword">if</span> param_group:<br>        params_1x = [param <span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net.named_parameters()<br>             <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;fc.weight&quot;</span>, <span class="hljs-string">&quot;fc.bias&quot;</span>]]<br>        <br>        trainer = torch.optim.SGD([&#123;<span class="hljs-string">&#x27;params&#x27;</span>: params_1x&#125;,<br>                                   &#123;<span class="hljs-string">&#x27;params&#x27;</span>: net.fc.parameters(),<br>                                    <span class="hljs-string">&#x27;lr&#x27;</span>: learning_rate * <span class="hljs-number">10</span>&#125;],<br>                                lr=learning_rate, weight_decay=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">else</span>:<br>        trainer = torch.optim.SGD(net.parameters(), lr=learning_rate,<br>                                  weight_decay=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">return</span> trainer<br></code></pre></td></tr></table></figure><h4 id="detect"><a href="#detect" class="headerlink" title="detect"></a>detect</h4><p>COCO数据集：80类，330k张，1.5M个物体</p><p><strong>画框</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#@save</span><br>dog_bbox = [<span class="hljs-number">60.0</span>, <span class="hljs-number">45.0</span>, <span class="hljs-number">90.0</span>, <span class="hljs-number">100.0</span>]<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#@save  # 将边界框 (左上x, 左上y, 右下x, 右下y) 格式转换成 matplotlib 格式：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bbox_to_rect</span>(<span class="hljs-params">bbox, color</span>):<br>    <span class="hljs-comment"># ((左上x, 左上y), 宽, 高)</span><br>    <span class="hljs-keyword">return</span> plt.Rectangle(<br>        xy=(bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>]), width=bbox[<span class="hljs-number">2</span>]-bbox[<span class="hljs-number">0</span>], height=bbox[<span class="hljs-number">3</span>]-bbox[<span class="hljs-number">1</span>],<br>        fill=<span class="hljs-literal">False</span>, edgecolor=color, linewidth=<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 显示一个边框</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_bbox</span>(<span class="hljs-params">ax, img, box</span>):<br>    ax.imshow(img)<span class="hljs-comment"># 图片</span><br>    ax.axes.add_patch(bbox_to_rect(box, <span class="hljs-string">&#x27;blue&#x27;</span>))<span class="hljs-comment"># 框</span><br><br>img = plt.imread(<span class="hljs-string">&#x27;../img/catdog.jpg&#x27;</span>)<br>fig = plt.figure() <span class="hljs-comment"># 画布</span><br>ax1 = fig.add_subplot(<span class="hljs-number">111</span>) <span class="hljs-comment"># 画1行1列个图形的第1个</span><br>show_bbox(ax1, img, dog_bbox)<br></code></pre></td></tr></table></figure><p>香蕉：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">    最多物体数量   标号，框<br>(torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[32, 3, 256, 256]</span>), torch<span class="hljs-selector-class">.Size</span>(<span class="hljs-selector-attr">[32, 1,           5]</span>))<br></code></pre></td></tr></table></figure><p>13 * 13 * 3*（20+1+4）<br>    3个框 20个种类  1是否有物体  4调整框</p><p>IoU：交集比上并集</p><p>锚框和边缘框对应</p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335109.png" alt="image-20210814193726246" style="zoom:50%;" /><p>生成锚框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># (1, 3, h, w) [0.75, 0.5, 0.25], [1, 2, 0.5]      s√r  和 s /√r  每像素点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_prior</span>(<span class="hljs-params">data, sizes, ratios</span>):<br>    <span class="hljs-keyword">return</span> [x,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(x,<span class="hljs-number">4</span>)  (y,<span class="hljs-number">4</span>)   返回(x, y) IoU 矩阵<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">box_iou</span>(<span class="hljs-params">boxes1, boxes2</span>):<br></code></pre></td></tr></table></figure><p>将anchors根据iou分配到真实框上，小于阈值分配-1。注意分配顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save 一个数组a[i]=j 对于每个锚框i，分配的真实边界框j,分配阈值iou_threshold</span><br>(x,<span class="hljs-number">4</span>)  (y,<span class="hljs-number">4</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">assign_anchor_to_bbox</span>(<span class="hljs-params">ground_truth, anchors, device, iou_threshold=<span class="hljs-number">0.5</span></span>):<br></code></pre></td></tr></table></figure><p>两组对应框之间的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save  (x,4)  (x,4)   -&gt;  (x, 4)  中心、wh的偏移</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">offset_boxes</span>(<span class="hljs-params">anchors, assigned_bb, eps=<span class="hljs-number">1e-6</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对锚框偏移量的转换。&quot;&quot;&quot;</span><br>    c_anc = box_corner_to_center(anchors)<br>    c_assigned_bb = box_corner_to_center(assigned_bb)<br>    offset_xy = <span class="hljs-number">10</span> * (c_assigned_bb[:, :<span class="hljs-number">2</span>] - c_anc[:, :<span class="hljs-number">2</span>]) / c_anc[:, <span class="hljs-number">2</span>:]<br>    offset_wh = <span class="hljs-number">5</span> * torch.log(eps + c_assigned_bb[:, <span class="hljs-number">2</span>:] / c_anc[:, <span class="hljs-number">2</span>:])<br>    offset = torch.cat([offset_xy, offset_wh], axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> offset<br></code></pre></td></tr></table></figure><p>将网络中锚框与真实框对应，求出偏移值、mask和 真实类别+1（0为背景，iou小于阈值）</p><p>​一个真实框可以有多个anchor</p><p>​未分配的则是assign_anchor_to_bbox阈值不达标的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-comment"># (b, num_anchors, 4)        (b, num_labels, 5)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_target</span>(<span class="hljs-params">anchors, labels</span>):<br>    <span class="hljs-keyword">return</span> 偏移，mask，类别<br>(b,num_anchors*<span class="hljs-number">4</span>)   (b,num_anchors*<span class="hljs-number">4</span>)    (n,num_anchors)<br>其中负类（小于阈值的anchor）的偏移被mask消除了<br></code></pre></td></tr></table></figure><p>nms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-comment"># 传入(nums,4) (nums) 返回留下的预测框下标数组  [x]</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nms</span>(<span class="hljs-params">boxes, scores, iou_threshold</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对预测边界框的置信度进行排序。&quot;&quot;&quot;</span><br>    B = torch.argsort(scores, dim=-<span class="hljs-number">1</span>, descending=<span class="hljs-literal">True</span>)<br>    keep = []  <span class="hljs-comment"># 保留预测边界框的指标</span><br>    <span class="hljs-keyword">while</span> B.numel() &gt; <span class="hljs-number">0</span>:<br>        i = B[<span class="hljs-number">0</span>]<br>        keep.append(i)<br>        <span class="hljs-keyword">if</span> B.numel() == <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span><br>        iou = box_iou(boxes[i, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>),<br>                      boxes[B[<span class="hljs-number">1</span>:], :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)).reshape(-<span class="hljs-number">1</span>)<br>        inds = torch.nonzero(iou &lt;= iou_threshold).reshape(-<span class="hljs-number">1</span>)<br>        B = B[inds + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> torch.tensor(keep, device=boxes.device)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#                     (b,classes+1,n)  (b,n*4)   (b,n,4)     (NMS阈值)    (背景阈值)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multibox_detection</span>(<span class="hljs-params">cls_probs, offset_preds, anchors, nms_threshold=<span class="hljs-number">0.5</span>,</span><br><span class="hljs-params">                       pos_threshold=<span class="hljs-number">0.009999999</span></span>):<br>    这里将背景的conf设为<span class="hljs-number">1</span>-conf，类别设为-<span class="hljs-number">1</span><br>    返回 (b, outn, classes+conf+4pos)<br></code></pre></td></tr></table></figure><h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><p>RCNN&#x2F;  FastR-CNN&#x2F;  FasterR-CNN   精度高速度慢。</p><p>SSD</p><p>YOLO</p><p>CenterNet</p><p>高精度图片中小物体的分类。卫星图片。需要特殊处理，有一套成熟方法</p><h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>per &#x3D; len(sizes) + len(ratios) - 1  每个像素点的anchor个数</p><p>每一次blk后，生成num_an (h * w * per)个锚框，同时输入到卷积网络每个像素点输出per*(classes+1)个类别预测和per * 4位置预测。所以每个blk有1个主网络blk，2个分支pred。低层框比较小 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">blk_forward</span>(<span class="hljs-params">X, blk, size, ratio, cls_predictor, bbox_predictor</span>):<br>    Y = blk(X)<br>    anchors = d2l.multibox_prior(Y, sizes=size, ratios=ratio) <span class="hljs-comment"># 生成anchors框 不同层不一样</span><br>    cls_preds = cls_predictor(Y)   <span class="hljs-comment"># 框的类别预测</span><br>    bbox_preds = bbox_predictor(Y) <span class="hljs-comment"># 框的位置偏移</span><br>    <span class="hljs-keyword">return</span> (Y, anchors, cls_preds, bbox_preds)<br></code></pre></td></tr></table></figure><p>(Y,   anchors,                 cls_preds,                                        bbox_preds) </p><p>Y，[1, num_anchors,  4],   [b,  per* (classes+1),  h,  w],    [b,  per * 4,  h,  w]</p><p><strong>总体网络</strong>：由于不同维度h，w不一样，所以将后面的打平堆叠，打平前permute(0, 2, 3, 1)  将c放到最后一维度。将blk返回值堆叠；类别还需要reshape出c+1用来预测；anchors 直接在dim&#x3D;1cat，返回</p><p><strong>anchors</strong>  [1, num_an, 4],   <strong>cls_preds</strong>  [b, num_an, classes+1],    <strong>bbox_preds</strong>  [b, num_an*4]</p><p>(32^2^+16^2^+8^2^4^2^+1^2^)×4&#x3D;5444   ，4是per，底数是特征图宽</p><p>得到全部anchors后与预测Y对应 **multibox_target(anchors, Y)**，返回 bbox_offset, bbox_mask, class_labels。代表着真实的标签</p><p>（这里anchors每张图<strong>都一样</strong>，但留下来算loss的需要满足和label大于阈值） Y：[b, 5]</p><p>bbox_offset与bbox_preds  计算L1损失函数     需要mask去除背景的偏移损失</p><p>class_labels与cls_preds       计算分类损失</p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>类别损失：交叉熵 由于有多个框，直接reshape到batch维度上。最后dim&#x3D;1取mean求出每张图平均损失值 [b]</p><p>偏移损失：L1loss。乘上mask后传入，最后取mean</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">cls_loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br>bbox_loss = nn.L1Loss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_loss</span>(<span class="hljs-params">cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks</span>):<br>    batch_size, num_classes = cls_preds.shape[<span class="hljs-number">0</span>], cls_preds.shape[<span class="hljs-number">2</span>]<br>    cls = cls_loss(cls_preds.reshape(-<span class="hljs-number">1</span>, num_classes),<br>                   cls_labels.reshape(-<span class="hljs-number">1</span>)).reshape(batch_size, -<span class="hljs-number">1</span>).mean(dim=<span class="hljs-number">1</span>)<br>    bbox = bbox_loss(bbox_preds * bbox_masks,<br>                     bbox_labels * bbox_masks).mean(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> cls + bbox<br></code></pre></td></tr></table></figure><h5 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">X</span>):<br>    net.<span class="hljs-built_in">eval</span>()<br>    anchors, cls_preds, bbox_preds = net(X.to(device))<br>    cls_probs = F.softmax(cls_preds, dim=<span class="hljs-number">2</span>).permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)        <span class="hljs-comment"># 计算出概率 移到dim=1</span><br>    <span class="hljs-comment"># 把框加上偏移，非极大抑制，背景抑制后返回[b,x,classes+conf+4pos]</span><br>    output = d2l.multibox_detection(cls_probs, bbox_preds, anchors)<br>    <span class="hljs-comment"># 只留下框</span><br>    idx = [i <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output[<span class="hljs-number">0</span>]) <span class="hljs-keyword">if</span> row[<span class="hljs-number">0</span>] != -<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> output[<span class="hljs-number">0</span>, idx]<br><span class="hljs-number">5444</span>  -nms&gt;   <span class="hljs-number">449</span>  -背景抑制&gt;  <span class="hljs-number">51</span>   -输出再次抑制&gt;    <span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><h5 id="改进："><a href="#改进：" class="headerlink" title="改进："></a><strong>改进：</strong></h5><p>平滑l1：</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335110.png" alt="image-20210816153354419"></p><p>focal 损失函数：重点在正样本但预测概率小的损失</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335111.png" alt="image-20210816153128924"></p><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>​特别长的物体：设置<strong>ratio</strong></p><p>​怕L2loss特别大，超出范围</p><p>​多个<strong>loss</strong>相加，需要<strong>加权重</strong>使得loss数量级差不多</p><p>​NMS的计算量特别大，需要特殊技巧</p><p>​backbone还是预训练的图片分类模型</p><p>​树莓派上跑detect用yolo</p><p>​没有固定现状的物体检测（土壤）：语义分割</p><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><p>数据集VOC2012        自动驾驶车辆和医疗图像诊断</p><p>color2label数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#@save</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_colormap2label</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;构建从RGB到VOC类别索引的映射。&quot;&quot;&quot;</span><br>    colormap2label = torch.zeros(<span class="hljs-number">256</span> ** <span class="hljs-number">3</span>, dtype=torch.long)<br>    <span class="hljs-keyword">for</span> i, colormap <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(VOC_COLORMAP):<br>        colormap2label[<br>            (colormap[<span class="hljs-number">0</span>] * <span class="hljs-number">256</span> + colormap[<span class="hljs-number">1</span>]) * <span class="hljs-number">256</span> + colormap[<span class="hljs-number">2</span>]] = i<br>    <span class="hljs-keyword">return</span> colormap2label<br><br><span class="hljs-comment">#@save  传入的是tensor 0~255 (c, h, w)   传出id</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_label_indices</span>(<span class="hljs-params">colormap, colormap2label</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;将VOC标签中的RGB值映射到它们的类别索引。&quot;&quot;&quot;</span><br>    colormap = colormap.permute(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>).numpy().astype(<span class="hljs-string">&#x27;int32&#x27;</span>)<br>    idx = ((colormap[:, :, <span class="hljs-number">0</span>] * <span class="hljs-number">256</span> + colormap[:, :, <span class="hljs-number">1</span>]) * <span class="hljs-number">256</span><br>           + colormap[:, :, <span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> colormap2label[idx]<br></code></pre></td></tr></table></figure><p>随机剪裁： feature和label放到一起进行，(c,h,w)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">voc_rand_crop</span>(<span class="hljs-params">feature, label, height, width</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;随机裁剪特征和标签图像。&quot;&quot;&quot;</span><br>    rect = torchvision.transforms.RandomCrop.get_params(<br>        feature, (height, width))<br>    feature = torchvision.transforms.functional.crop(feature, *rect)<br>    label = torchvision.transforms.functional.crop(label, *rect)<br>    <span class="hljs-keyword">return</span> feature, label<br></code></pre></td></tr></table></figure><p>过滤：滤去小于剪裁大小的图片，在dataset init时就需要去除样本id数组</p><p>人的语义分割比较容易，但是光线影响很大。应该比较成熟了 </p><p>在3d语义分割的情况下，存在深度图，理论上分割更容易</p><p>自动驾驶：距离       速度、加速度      十几二十个摄像头 模型融合。特斯拉纯视觉， google、国内激光雷达</p><h4 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h4><p>转置卷积实现尺寸变大，也有最近邻插值，双线性插值（初始化核）</p><p><strong>卷积</strong>：一群值转化为一个值的关系</p><p><a href="https://blog.csdn.net/lanadeus/article/details/82534425">轻松理解转置卷积(transposed convolution)或反卷积(deconvolution)_lanadeus-CSDN博客_转置卷积</a></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335112.png" alt="image-20210816214009010"></p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335113.png" alt="image-20210816213950481" style="zoom:67%;" /><p><strong>转置卷积：</strong>原来一个值转化为一群值的对应关系，值上与原来无关（<strong>从信息论的角度看,卷积是不可逆的.所以这里说的并不是从output矩阵和kernel矩阵计算出原始的input矩阵.而是计算出一个保持了位置性关系的矩阵.</strong>)</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335114.png" alt="image-20210816215400555"></p><p>超参数相同时，形状为逆变换</p><p>理解：填充k-p-1后， stride为将原矩阵在行列之间插s-1零行，再做传统卷积</p><p>转置卷积的等价乘法矩阵 &#x3D; 卷积核的乘法矩阵.T</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d2l.corr2d(X, K) == torch.matmul(W, X.reshape(-<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>trans_conv(Y, K) == torch.matmul(W.T, Y.reshape(-<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>计算方法：1.相乘相加  2.倒转 扩充 正常卷积</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335116.png" alt="image-20210817141016427" style="zoom: 50%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335117.png" alt="image-20210817140913096" style="zoom: 50%;" /></p><p>FCN转置卷积： k-2p-s&#x3D;0  双线性插值初始化</p><p>损失函数：直接cross_entropy ,分类维度在x的第二维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.rand((<span class="hljs-number">32</span>, <span class="hljs-number">21</span>, <span class="hljs-number">320</span>,<span class="hljs-number">480</span>))<br>y = torch.ones((<span class="hljs-number">32</span>, <span class="hljs-number">320</span>, <span class="hljs-number">480</span>)).long()<br>F.cross_entropy(x, y)  <span class="hljs-comment"># nn.CrossEntropyLoss()(x, y)</span><br></code></pre></td></tr></table></figure><p>训练时，由于loss在一个batch上取平均值，比d2l小，所以要调大lr，否者会陷入<strong>局部最优</strong>，输出全黑</p><h4 id="样式迁移"><a href="#样式迁移" class="headerlink" title="样式迁移"></a>样式迁移</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202305151335118.png" alt="image-20210817141542897" style="zoom: 80%;" /><p>网络提取特征后，某些层上的<strong>特征相似</strong>：gram矩阵       内容相似：直接对应位置MSE</p><p>内容特征深层次越好（忽略细节） [25]   风格特征多层结合[0, 5, 10, 19, 28]</p><p><strong>风格矩阵：</strong></p><p>​对角线元素提供了不同特征图（a1，a2 … ，an）各自的信息，其余元素提供了不同特征图之间的相关信息。</p><p>contents_Y,  styles_Y是提前准备好的。X为输入也是调整的对象，初始化为内容图img.weight.data.copy_(X.data)</p><p><strong>迭代：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将X输入到网络中提取特征</span><br>contents_Y_hat, styles_Y_hat = extract_features(X, content_layers, style_layers)<br><span class="hljs-comment"># 根据特征与提前准备好的特征相比较，计算出损失</span><br>contents_l, styles_l, tv_l, l = compute_loss(<br>    X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)<br></code></pre></td></tr></table></figure><p><strong>loss：</strong>分为3部分, 内容（均方差）、风格（风格矩阵W *W.T的均方差)、平滑度损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">content_weight, style_weight, tv_weight = <span class="hljs-number">1</span>, <span class="hljs-number">1e3</span>, <span class="hljs-number">10</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_loss</span>(<span class="hljs-params">X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram</span>):<br>    <span class="hljs-comment"># 分别计算内容损失、样式损失和总变差损失</span><br>    contents_l = [content_loss(Y_hat, Y) * content_weight <span class="hljs-keyword">for</span> Y_hat, Y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>        contents_Y_hat, contents_Y)]<br>    styles_l = [style_loss(Y_hat, Y) * style_weight <span class="hljs-keyword">for</span> Y_hat, Y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<br>        styles_Y_hat, styles_Y_gram)]<br>    tv_l = tv_loss(X) * tv_weight<br>    <span class="hljs-comment"># 对所有损失求和</span><br>    l = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span> * styles_l + contents_l + [tv_l]) <span class="hljs-comment"># 一个长列表</span><br>    <span class="hljs-keyword">return</span> contents_l, styles_l, tv_l, l<br></code></pre></td></tr></table></figure><p>大图片迁移：用小图迁移后，放大然后作为起始</p><h3 id="牛仔行头检测"><a href="#牛仔行头检测" class="headerlink" title="牛仔行头检测"></a>牛仔行头检测</h3><p>样本不平衡</p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
      <category>动手学深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>GPT摘要</strong></p><p>这篇文章主要介绍了操作系统的基本概念、功能和管理机制。文章首先阐述了操作系统的定义、功能（控制硬件软件资源、组织调度、提供接口环境）和特征（并发、共享、虚拟、异步）。然后详细讨论了操作系统的发展阶段（人工、单道、多道、分时、实时）和用户接口类型（命令、程序、图形界面）。  在进程管理方面，文章区分了作业、程序和进程的概念，重点介绍了进程的特性（动态性、并发性、独立性、异步）和PCB结构，并比较了进程与线程的不同（资源分配调度单位 vs 轻量级调度单位）。进程调度算法包含FCFS、SJF、HRRN等基本算法，以及轮转、优先级、多级反馈队列等高级算法。  内存管理部分详细讲解了不同分配方式（单一连续、固定分区、动态分区）及其优缺点，特别是外部&#x2F;内部碎片问题。重点介绍了分页和分段机制，包括虚拟内存概念、页表映射、缺页中断处理等实现原理，并对比了页面置换算法（FIFO、LRU、LFU、Clock等）。  在文件系统方面，文章解释了文件的组织方式（顺序、索引）和存储结构（连续、链接）。设备管理部分介绍了磁盘调度算法（FCFS、SSTF、SCAN等）。最后归纳了20个关键问题，包括操作系统的定义、启动过程、系统调用、进程调度、死锁处理、内存管理和常见操作系统比较等核心知识点。</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>控制硬件软件资源</li><li>合理组织调度资源</li><li>为软件提供接口和环境</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218610.png" alt="image-20230407133023066"></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>并发：宏观上同时运行</li><li>共享：并发进程共同享用资源 </li><li>虚拟：一个物理实体对应多个逻辑</li><li>异步：进程走走停停</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218611.png" alt="image-20230407132853257"></p><h4 id="os不同时期发展"><a href="#os不同时期发展" class="headerlink" title="os不同时期发展"></a><strong>os不同时期发展</strong></h4><p>​人工、单道、多道、分时（时间片多用户）、实时</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218612.png" alt="image-20230407132654765"></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>​用户接口；联机（cmd）、脱机（程序）、图形化</p><p>​程序接口：系统调用组成。程序调用相应功能系统调用</p><p>​大内核（模块集中）、微内核</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218614.png" alt="image-20230407133249113"></p><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p>作业比程序更广泛，包含程序、数据和作业说明书</p><p><strong>程序</strong>是个静态的概念，<strong>进程</strong>是程序的一次执行</p><p><strong>进程</strong>：对并发执行的程序的控制和描述，资源分配调度的基本单位，动态性、并发性、独立性、异步</p><p><strong>拥有资源</strong>（代码段 数据段  IO），<strong>唯一</strong>PCB</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218615.png" alt="image-20230407133644813"></p><p><strong>状态</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218616.png" alt="image-20210807140817329"></p><p><strong>编译</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218617.png" alt="image-20210807141320862"></p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218618.png" alt="image-20230407133959202"></p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218619.png" alt="image-20230407134144875"></p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>​进程：处理机资源最小单位        创建、撤销和切换代价大</p><p>​线程：处理机调度单位         轻量级进程    TCB          QQ中与不同好友聊天</p><p>​临界资源与临界区</p><h4 id="调度层次分类"><a href="#调度层次分类" class="headerlink" title="调度层次分类"></a>调度层次分类</h4><ul><li>​高级调度（作业调度）：外存到内存 并分配资源   根据JCB  (CPU、磁盘、内存等资源)</li><li>​中级调度（内存调度）：阻塞程序调入外存，提高利用率和吞吐量     </li><li>​低级调度（进程调度）：分配<strong>cpu</strong>          （抢占、非抢占）</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218620.png" alt="image-20230407134438270"></p><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218621.png" alt="image-20230407134721361"></p><h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><ul><li>​先来先服务FCFS</li><li>​短作业优先SJF</li><li>​高响应比HRRN    (等待+服务时间)&#x2F;服务时间</li><li>​优先级调度PSA</li></ul><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul><li>​轮转RR</li><li>​优先级（抢占、非抢占）</li><li>​多级反馈队列：高优先级时间片短，未完成则降级</li></ul><h5 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h5><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占）</li><li>​优先倒置（1.不让抢占临界区  2.优先度继承）</li></ul><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>只允许一个进程使用的资源，硬件实现方法</p><p>​1.关中断</p><p>​2.bool变量标识，while等待 ；    swap对换 原理一样         <strong>忙碌等待</strong></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​<strong>PV操作</strong></p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>​    <strong>常见问题</strong>：生产者消费者、进餐、读写     （互斥加紧范围小）</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​<strong>条件</strong>：互斥、请求和保持、不可抢占、循环等待</p><p>​<strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源、允许抢占）</li><li><strong>避免死锁</strong>（银行家：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（资源分配图，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><p><strong>银行家</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218622.png" alt="image-20230407100403822"></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218623.png" alt="image-20230407100418486"></p><p><strong>资源分配图</strong></p><p>去掉所有已经出边（申请了的资源），查看某个进程P是否所有的出边（need）都能满足，能满足则该进程运行，释放所有资源。最后是否能都运行。其实就是判断是否存在<strong>安全序列</strong>。否则就会产生环</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218624.png" alt="image-20230407100722191"><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218625.png" style="zoom:80%;" /></p><h2 id="3-内存"><a href="#3-内存" class="headerlink" title="3.内存"></a>3.内存</h2><h4 id="内存分配（连续）"><a href="#内存分配（连续）" class="headerlink" title="内存分配（连续）"></a>内存分配（连续）</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218626.png" alt="image-20230407103230820"></p><ul><li><p><strong>单一连续分配</strong>（单程序）</p></li><li><p><strong>固定分区分配</strong>（区域固定但大小不等，一个程序一个区） 分区表维护状态  存在<strong>内部碎片</strong>  不能共享</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218627.png" alt="image-20230407101903055" style="zoom:67%;" /><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218628.png" alt="image-20230407101958427" style="zoom: 67%;" /></p></li><li><p><strong>动态分区分配</strong>（根据进程大小分配，空闲表，空闲区由一个双向指针连接起来），存在<strong>外部碎片</strong>（太小没人用）  回收直接合并前后空闲区</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218629.png" alt="image-20230407102352685"></p><p>紧凑：各个进程挪位，挪出一个连续空闲区域。把蓝色部分合并</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218630.png" alt="image-20230407103058745"></p></li></ul><h5 id="顺序方法"><a href="#顺序方法" class="headerlink" title="顺序方法"></a>顺序方法</h5><p>​首次适应FF：开头开始找到就用   循环首次适应NF：从上一次开始</p><p>​最佳适应BF：分配最小的能用的           最坏适应WF：分配最大的区域</p><h5 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h5><ul><li>​快速适应：多个按大小划分的链表（2kb，5kb..）</li><li>​伙伴系统：多个链表大小为2^i^ ，不存在该大小区域则拆分2^i+1^链表</li></ul><p>​用哈希来寻找表头指针</p><h4 id="分页管理（离散）"><a href="#分页管理（离散）" class="headerlink" title="分页管理（离散）"></a>分页管理（离散）</h4><p><strong>优点：</strong></p><ol><li>解决外部碎片</li><li>非连续分配，且不用的可以先不分配，解决程序大小受限问题</li></ol><p>​内存以页面为单位，地址&#x3D;页号+页内地址   ， 页面大小1kb~8kb</p><p>​所以程序的<strong>逻辑地址</strong>都转为<strong>分页地址</strong>。</p><p>​<strong>页表</strong>：程序中页号（逻辑地址 连续）与内存页号（物理地址 不连续）<strong>对应关系</strong>，存放在内存中。PCB中的PTR保持页表起始地址。 页表在<strong>内存管理单元</strong>（MMU）中，每个进程都有</p><p>​每次访问需要访问两次内存，引入<strong>快表</strong>（高速缓冲寄存器） ；查询时间  <strong>2t + λ - t*a</strong> </p><p>​<strong>多级列表</strong>：将页表空间离散，2^20^  &#x3D;  2^10^  * 2^10^</p><p>​4GB内存空间 每个页4kb，共2^20^条； 每一个条目需要4B 则需要2^20^ * 4 B &#x3D; 4 MB 的页表空间</p><p>​转为二级后：2^10^ * 4B  + 2^10^ * 2^10^ * 4B  &#x3D; 4KB + 4MB。但二级页表是可以不存在，所以<strong>节约</strong>并且<strong>离散化</strong>了空间</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218631.png" alt="image-20230407120032813"></p><p>​</p><h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p>​满足编程上要求，主程序、子程序、数据段。需要段表实现虚拟到物理</p><p>​当用户共享一段内存时，只需要一个段表，而分页需要多个</p><p><strong>对比：</strong></p><p>打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。</p><p>第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。</p><p>第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>​页表中的标志位标记是否在内存中</p><p>​时间、空间<strong>局部性</strong></p><p>​作业的页面可能不在内存中，需要从外存调入，产生一个缺页中断</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218632.png" alt="image-20230407104638679"></p><p>​分配规则：规定分配局部置换（单程序内换）、可变分配局部置换（一起换）、可变分配局部置换（动态加页）</p><h5 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法!"></a>置换算法!</h5><ul><li>​最佳置换算法 （理论算法、无法实现）</li><li>​先进先出</li><li>​最久未使用LRU   链表头尾</li><li>​最少使用LFU（页面访问表 +1）   </li><li>​    Clock算法  （第一次置为零不换出，第二次&#x3D;0则 换出）</li></ul><h2 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h2><p>文件：一系列记录</p><p>记录：一系列数据，有key</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>​顺序文件：顺序存储记录，读取N&#x2F;2</p><p>​索引文件：按键排序建立索引表，logN复杂度</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>单级目录、多级目录、树形目录</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>连续组织方式</p><p>链接组织方式：隐式（只存首地址，下一个盘块在当前盘块中），显式（全存到FCB中）FAT表 </p><h2 id="5-io"><a href="#5-io" class="headerlink" title="5.io"></a>5.io</h2><h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218633.png" alt="image-20230407131713071"></p><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218634.png"></p><h4 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h4><p>​盘面 磁道 扇区</p><p>寻道+旋转+传输</p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218635.png" alt="image-20230407131437644"></p><h5 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h5><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218636.png" alt="image-20230407131552116"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>1.什么是操作系统？操作系统的主要功能是什么？</strong></p><p>操作系统位于计算机硬件和应用软件之间，负责协调和管理硬件资源的分配、控制和调度，提供对硬件的抽象和访问接口，以便应用程序能够运行并与硬件交互。</p><p>进程管理、内存管理、文件系统、输入输出</p><p><strong>2.请大致描述操作系统的启动过程。</strong></p><p>操作系统的启动过程包括硬件自检、引导加载程序加载、内核初始化、用户空间初始化、用户应用程序加载和运行等阶段。</p><ol><li>上电自检（Power-On Self-Test, POST）：当计算机电源被打开时，计算机硬件会进行自我检测，包括检测内存、CPU、硬盘、显示器等硬件设备，以确保它们正常工作。</li><li>BIOS&#x2F;UEFI初始化：计算机硬件自检完成后，BIOS（基本输入&#x2F;输出系统）或UEFI（统一可扩展固件接口）会被加载并初始化，它们是计算机的固件，负责初始化硬件设备、设置启动选项等。</li><li>引导加载程序（Boot Loader）：BIOS&#x2F;UEFI会从预定义的引导设备（通常是硬盘、光盘或网络）中加载引导加载程序，例如GRUB、LILO等，它负责加载操作系统的核心模块到内存中。</li><li>操作系统内核加载：引导加载程序会加载操作系统的内核模块到内存中，并将控制权交给操作系统的内核。</li><li>内核初始化：操作系统内核被加载后，会进行初始化，包括初始化设备驱动程序、建立进程管理、内存管理、文件系统等子系统。</li><li>用户空间初始化：操作系统内核初始化完成后，会创建一个或多个用户空间的进程，这些进程负责提供用户界面和用户应用程序的运行环境。</li><li>用户应用程序加载：用户空间的进程会加载用户应用程序到内存中，并开始执行用户应用程序。</li><li>用户应用程序运行：用户应用程序开始在操作系统的运行环境下执行，通过系统调用和内核交互来请求操作系统提供的服务和资源。</li></ol><p><strong>3.什么是系统调用？系统调用的作用是什么？</strong></p><p>系统调用（System Call）是操作系统提供给用户态程序访问内核态功能和资源的<strong>接口</strong>。它允许用户态程序通过调用特定的系统调用函数来请求操作系统的服务和资源，例如文件操作、网络通信、进程管理、内存管理等。</p><p>当需要执行系统调用时，用户通过中断或异常从用户态切换到内核态，从而执行系统调用</p><p><strong>4.多道程序设计、分时操作系统、实时操作系统是什么</strong></p><ul><li>多道程序：通过进程之间的相互切换，同时运行多个进程</li><li>分时操作系统：通过时间片轮转实现<strong>多用户多程序</strong>并发执行，用户之间的隔离和资源的共享。</li><li>实时操作系统：用于处理实时任务，硬实时（航空、医疗工业）、软实时</li></ul><p><strong>5.什么是中断？如何工作？</strong></p><p>中断（Interrupt）是计算机系统中的一种事件，暂停当前指令，转向执行特定的中断程序</p><p>过程：</p><ol><li>中断请求(外部IO、定时器、出现错误) </li><li>暂停当前保留进程现场 </li><li>根据中断向量表定位中断处理程序入口，移交控制权  </li><li>执行中断处理程序，清除中断标志位</li><li>恢复现场，继续执行原来程序</li></ol><p>作用：中断的存在使得程序支持多任务处理、提高响应，控制硬件设备</p><p><strong>6.什么是守护进程（Daemon Process），它在操作系统中的作用是什么？</strong></p><p>守护进程是一种一直在后台运行的特殊类型的进程，用于提供服务和执行系统管理任务。维护系统的正常运行</p><hr><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><strong>7.什么是进程控制块（PCB）？其主要作用是什么？</strong></p><p>CB保存了进程的基本信息，如进程ID（PID）、进程状态（如就绪、运行、阻塞等）、进程优先级、内存指针、CPU寄存器内容、进程的内存分配信息等，用于对进程进行管理和控制。</p><p><strong>8.操作系统中进程和线程的区别</strong></p><p>进程是指在操作系统中正在运行的一个程序的实例，它包括了程序的代码、数据和运行时的资源。每个进程都有独立的内存空间和系统资源，例如文件句柄、网络连接等。进程之间相互隔离，彼此独立运行，互不干扰。进程之间通过进程间通信（IPC）机制来进行数据交换和通信。</p><p>而线程是进程内的一个独立执行流，也是程序执行的最小单元。同一进程中的多个线程共享进程的内存空间和系统资源，包括文件句柄、网络连接等。线程之间可以通过共享内存来进行通信，因此线程间的通信更加高效。线程的切换开销较小，因此线程可以更快地响应用户请求。</p><p>总结：进程是独立的程序执行实体，拥有独立的内存空间和系统资源；而线程是进程内的执行流，共享进程的内存空间和系统资源，可以更快地进行通信和切换。</p><p>进程：独立、稳定；线程：资源共享(需要手动实现互斥)、响应快</p><p><strong>9.什么是进程通信？进程通信的方式有哪些？</strong></p><table><thead><tr><th align="left">通信方式</th><th align="left">优点</th><th align="left">缺点</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">管道</td><td align="left">简单易用，无需考虑同步问题。半双工，如果空了或者满了就会阻塞</td><td align="left">只能用于具有亲缘关系的进程间通信</td><td align="left">父子进程间通信</td></tr><tr><td align="left">信号</td><td align="left">传递简单信息，可靠性高，响应速度快。一个进程可以发送一个信号给另一个进程</td><td align="left">只能传递整数值，不能传递复杂数据结构</td><td align="left">进程间异步通信</td></tr><tr><td align="left">信号量</td><td align="left">一个计数器，可以用于同步和互斥，可靠性高</td><td align="left">只能用于具有亲缘关系的进程间通信</td><td align="left">进程间同步和互斥</td></tr><tr><td align="left">消息队列</td><td align="left">可以传递复杂数据结构，可靠性高，支持多对多通信</td><td align="left">性能较差，需要内核支持</td><td align="left">进程间异步通信</td></tr><tr><td align="left">共享内存</td><td align="left">传输速度快，可以直接访问共享内存区域，支持多对多通信</td><td align="left">需要考虑同步和互斥问题，可能会出现死锁等问题</td><td align="left">进程间大量数据交换</td></tr><tr><td align="left">套接字</td><td align="left">网络通信，支持不同主机之间的进程通信，支持多种协议和数据格式</td><td align="left">实现较为复杂，性能较差</td><td align="left">不同主机之间的进程通信</td></tr></tbody></table><p><strong>10.细说信号量：</strong></p><p>信号量可以解决资源间的共享和同步问题</p><p>资源共享：</p><p>​S表示资源数目，当多个资源时，AND机制</p><p>​wait：  s–     if s &lt; 0，线程加入等待队列  </p><p>​signal：s++  if  s&lt;&#x3D;0, 唤醒等待队列</p><p>生产者消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义两个信号量，用于控制缓冲区的空闲空间和数据项数量</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semEmpty</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">// 初始值为缓冲区的大小，表示空闲空间的数量</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semFull</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值为 0，表示数据项的数量</span><br><br><span class="hljs-comment">// 生产者进程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 生成一个数据项</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 等待空闲空间，如果没有空闲空间则阻塞</span><br>    wait(semEmpty);<br>    <span class="hljs-comment">// 将数据项放入缓冲区</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加数据项数量</span><br>    signal(semFull);<br>&#125;<br><br><span class="hljs-comment">// 消费者进程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 等待数据项，如果没有数据项则阻塞</span><br>    wait(semFull);<br>    <span class="hljs-comment">// 从缓冲区取出一个数据项</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加空闲空间数量</span><br>    signal(semEmpty);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>11.为什么操作系统需要进行进程调度，有哪些常见的进程调度算法？</strong></p><p>为了充分利用 CPU 资源</p><ul><li><p>先来先服务（First-Come, First-Served, FCFS）：按照进程到达的先后顺序进行调度，即先到达的进程先被执行。</p></li><li><p>最短作业优先（Shortest Job Next, SJN）：选择下一个执行的进程时，选择估计运行时间最短的进程。</p></li><li><p>优先级调度（Priority Scheduling）：为每个进程分配一个优先级，优先级高的进程优先被调度执行。</p></li><li><p>时间片轮转法（Round Robin, RR）：每个进程被分配一个固定的时间片（时间量），当时间片用完时，进程被挂起，下一个进程开始执行，被挂起的进程排队等待下一轮调度。</p></li><li><p>高响应比：1 + 等待时间&#x2F;服务时间  </p></li><li><p>多级反馈队列调度（Multilevel Feedback Queue Scheduling）：多级队列，优先级高的时间短，进程在规定时间未完成则降到下一级</p></li><li><p>实时：</p><ul><li>​最早截止EDF（抢占、非抢占）</li><li>​最低松弛度优先LLF（不得不开始时抢占CPU）</li></ul></li></ul><p><strong>12.什么是死锁？如何避免和检测死锁？</strong></p><p>各个进程或线程因争夺系统资源（如共享资源）而导致相互等待</p><p>互斥条件 请求与保持条件 不可剥夺条件 循环等待条件</p><p>​<strong>处理方法</strong>：</p><ul><li><strong>预防死锁</strong>（一次性分配资源、允许抢占）</li><li><strong>避免死锁</strong>（银行家：在一次分配完后检查是否有安全序列能实现全部运行）</li><li><strong>监测死锁</strong>（资源分配图，分配完有没有环）</li><li><strong>解除死锁</strong>（资源剥夺、回滚进程、终止进程）</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><strong>13.内存管理的几个阶段？</strong></p><ul><li><strong>单一连续分配</strong>（单程序）</li><li><strong>固定分区分配</strong>（区域固定但大小不等，一个程序一个区） 分区表维护状态  存在<strong>内部碎片</strong>  不能共享</li><li><strong>动态分区分配</strong>（根据进程大小分配，空闲表，空闲区由一个双向指针连接起来），存在<strong>外部碎片</strong>（太小没人用）  回收直接合并前后空闲区</li><li><strong>分页管理</strong>（离散）  1页1~8KB</li><li><strong>分段管理</strong>  逻辑上</li></ul><p><strong>14.二级分页管理中，如何实现逻辑地址到物理地址的映射</strong></p><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218637.png" alt="image-20230411175730569"></p><p><strong>15.什么是虚拟内存，概念及其实现原理，虚拟内存与物理内存的映射是怎么实现的？</strong></p><p>概念：</p><ul><li>虚拟内存：每个进程拥有自己的虚拟地址空间，包括代码段、数据段和堆栈段等，进程访问的地址都是虚拟地址，由进程的逻辑地址空间组成。</li><li>物理内存：实际的物理内存模块，用于存储正在执行的进程的数据和指令。</li></ul><p>实现原理：</p><ul><li>分页机制：将进程的虚拟地址空间划分为固定大小的页，同时将物理内存划分为对应大小的页框。每个页框可以存放一个页的数据或指令。</li><li>页表映射：每个进程都有自己的页表，用于记录其虚拟地址空间中每个页与物理内存中页框的映射关系。通过页表，操作系统可以实现虚拟地址到物理地址的映射。</li><li>页面置换：当物理内存不足以容纳所有进程所需的页时，操作系统会使用页面置换算法，将一些不活跃的页面置换到磁盘上，从而释放物理内存空间，用于加载其他进程的页面。</li><li>页面调度：当发生缺页时，抛出缺页中断，操作系统根据进程的访问模式和页的访问频率等信息，通过页面置换算法来决定将哪些页面调入物理内存，从而提高系统的性能。</li></ul><p><strong>16.操作系统中的页面置换算法有哪些</strong></p><ul><li>​最佳置换算法 （理论算法、无法实现）</li><li>​先进先出</li><li>​最久未使用LRU   链表头尾</li><li>​最少使用LFU（页面访问表 +1）   </li><li>​    Clock算法  （第一次置为零不换出，第二次&#x3D;0则 换出）</li></ul><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p><strong>17.文件系统是什么？请讲解文件系统的常见类型及其特点</strong></p><p>文件系统是操作系统中负责管理和组织文件的一部分，它提供了一种逻辑结构，用于在存储介质（如硬盘、闪存等）上存储和组织文件，以便用户可以方便地创建、读取、写入、删除、移动、复制和管理文件。</p><p><strong>18.什么是磁盘调度算法？常见的磁盘调度算法有哪些？</strong></p><ul><li>先来先服务FCFS</li><li>最短寻道时间SSTF</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>CSCAN：单方向电梯</li></ul><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202304191218636.png" alt="image-20230407131552116"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>19.请解释什么是死机和蓝屏，并解释它们在操作系统中的原因和处理方法。</strong></p><ul><li>死机：死机是指计算机在运行时突然停止响应，无法继续执行任何操作，屏幕上的图像和界面也无法更新。死机可能是由于<strong>软件或硬件</strong>故障引起的，例如程序错误、设备驱动问题、内存错误等。死机时，屏幕上的内容通常会被冻结在当前状态，无法进行任何操作。</li><li>蓝屏：蓝屏是指在Windows操作系统中出现严重错误时，屏幕会显示蓝色的错误信息界面，通常包含错误代码和错误信息。蓝屏通常由于<strong>操作系统的关键组件</strong>出现故障或冲突引起，例如驱动程序问题、硬件故障、系统文件损坏等。蓝屏时，计算机会自动崩溃并重启，屏幕上会显示蓝屏错误信息。</li></ul><p>死机无提示信息，而蓝屏有；死机会冻结在当且页面，蓝屏会自动崩溃并重启；</p><p><strong>20.介绍下常见的操作系统</strong></p><p>常见的操作系统类型包括Windows、Linux和macOS。</p><ol><li>Windows：Windows是由微软公司开发的操作系统，广泛应用于个人计算机和企业环境。Windows操作系统以图形用户界面（GUI）为特点，提供了丰富的应用程序生态系统和广泛的硬件兼容性。Windows操作系统版本众多，包括Windows 10、Windows 8、Windows 7等，每个版本都有不同的特点和功能。</li><li>Linux：Linux是一种自由和开放源代码的操作系统，基于UNIX的设计原则和哲学。Linux操作系统以稳定、安全和高度可定制性为特点，被广泛用于服务器、嵌入式系统、移动设备和超级计算机等领域。Linux有众多的发行版，如Ubuntu、CentOS、Debian等，每个发行版有其独特的特点和用途。</li><li>macOS：macOS是由苹果公司开发的操作系统，专门设计用于苹果的Mac计算机。macOS以稳定、安全和用户友好的界面为特点，与苹果的硬件和软件紧密集成，提供了独特的用户体验和生产力工具。macOS有多个版本，如macOS Monterey、Big Sur、Catalina等，每个版本都有新的功能和改进。</li></ol><p>这些操作系统之间的主要区别包括：</p><ul><li>用户界面：Windows以图形用户界面（GUI）为主，macOS也是如此，而Linux则可以有多种用户界面选择，例如GNOME、KDE、XFCE等。</li><li>开放性：Linux是自由和开放源代码的操作系统，可以自由定制和修改，而Windows和macOS都是商业操作系统，不开放源代码。</li><li>应用程序生态系统：Windows和macOS拥有丰富的商业软件和应用程序生态系统，而Linux则以开源软件为主，应用程序生态系统相对较小。</li><li>硬件兼容性：Windows通常具有广泛的硬件兼容性，因为它是市场份额最大的操作系统之一，而macOS只能在苹果硬件上运行，Linux的硬件兼容性则因发行版和驱动支持而异。</li><li>安全性：Linux和macOS在安全性方面通常被认为较高，因为它们基于UNIX的安全设计原则，而Windows在过去一直面临着安全威胁和攻击的挑战。</li><li>社区支持：Linux拥有庞大的开源社区和支持系统，而Windows和macOS则主要依赖于厂商的官方支持。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
