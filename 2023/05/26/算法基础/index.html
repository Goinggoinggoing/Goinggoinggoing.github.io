

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#B1A58E">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="0.特殊leetcode  10^7^ 1234567891011121314151617181920n&lt;&#x3D;12      n!n&lt;&#x3D;30      2^n           dfs+剪枝100~300  n^3            floyd10^3        n^2            dp dij 二分  10^4        n*根号n      块状链表10^5~">
<meta property="og:type" content="article">
<meta property="og:title" content="算法基础">
<meta property="og:url" content="http://example.com/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Xun&#39;s Blog">
<meta property="og:description" content="0.特殊leetcode  10^7^ 1234567891011121314151617181920n&lt;&#x3D;12      n!n&lt;&#x3D;30      2^n           dfs+剪枝100~300  n^3            floyd10^3        n^2            dp dij 二分  10^4        n*根号n      块状链表10^5~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325203241435.png">
<meta property="article:published_time" content="2023-05-26T12:00:00.000Z">
<meta property="article:modified_time" content="2025-03-21T05:09:37.272Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325203241435.png">
  
  
  
  <title>算法基础 - Xun&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GEluhFhlvVVyi1wC9RzB0vSk-MdYXbMMI","app_key":"9ng4wvU8n0568liU440awYcT","server_url":"https://proxy.bytewaver.top/proxy/geluhfhl.api.lncldglobal.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/pink-small.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">算法基础</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-26 20:00" pubdate>
          2023年5月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          181 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法基础</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="0-特殊"><a href="#0-特殊" class="headerlink" title="0.特殊"></a>0.特殊</h2><p>leetcode  10^7^</p>
<figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">n&lt;=</span><span class="hljs-number">12</span><span class="language-xml">      n!</span><br><span class="language-xml"></span><br><span class="language-xml">n&lt;=</span><span class="hljs-number">30</span><span class="language-xml">      </span><span class="hljs-number">2</span><span class="hljs-keyword">^n</span><span class="language-xml">           dfs+剪枝</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">100</span><span class="language-xml">~</span><span class="hljs-number">300</span><span class="language-xml">  n</span><span class="hljs-keyword">^3</span><span class="language-xml">            floyd</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^3</span><span class="language-xml">        n</span><span class="hljs-keyword">^2</span><span class="language-xml">            dp dij 二分  </span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^4</span><span class="language-xml">        n*根号n      块状链表</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span><span class="language-xml">~</span><span class="hljs-number">6</span><span class="language-xml">    nlogn         排序 线段树 树状数组 set/map heap dij+heap spfa 二分 求凸包 求半平面交</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^6</span><span class="language-xml">         n               hash 双指针  kmp ac自动机  </span><br><span class="language-xml">	小常nlogn   sort 树状数组 heap+dij spfa</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^7</span><span class="language-xml">         n                hash 双指针  kmp ac自动机  线性筛质素</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^9</span><span class="language-xml">         根号n         判断质素</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">10</span><span class="hljs-keyword">^18</span><span class="language-xml">        logn          欧几里得  快速幂</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span> map</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> memset(h,-1,sizeof h); memset(dis,0x3f,sizeof dis);</span><br><span class="hljs-comment">// 小于x的第一个元素</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>(), x)-alls.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">// 优先队列</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; q;  <span class="hljs-comment">//大根堆 priority_queue&lt;int&gt; q; </span><br>	priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt;q;  <span class="hljs-comment">//小根堆</span><br>	<span class="hljs-comment">// 自定义比较函数：STL构造时放入 https://www.cnblogs.com/lengbingshy/p/3491192.html</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">mycmp</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span>  <span class="hljs-keyword">return</span> l1-&gt;val&gt;l2-&gt;val</span>;<br>    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,function&lt;<span class="hljs-type">bool</span>(ListNode*, ListNode*)&gt;&gt; <span class="hljs-built_in">pq</span>(mycmp);<br>	<span class="hljs-comment">// 或者</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">comp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a, ListNode* b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; q;<br>	<br><span class="hljs-comment">// 保留小数</span><br>	<span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)<br><span class="hljs-comment">//排序 去重  algorithm</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// vector</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(b)</span> 	vector&lt;<span class="hljs-type">int</span>&gt; a </span>= &#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>&#125;初始化<br>    <br>	a.<span class="hljs-built_in">swap</span>(b)			交换<br>	add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;)  <span class="hljs-comment">//vector中 pair插入:</span><br>        <br><span class="hljs-comment">// 优先队列 栈  top()   pop() push()</span><br><span class="hljs-comment">// 队列        front() pop() push()</span><br>        <br><span class="hljs-comment">//set map multiset multimap 平衡二叉树（红黑树） 动态维护有序序列 增删改查:O(logN)</span><br>	<span class="hljs-built_in">size</span>() <span class="hljs-built_in">empty</span>() <span class="hljs-built_in">clear</span>() <span class="hljs-built_in">begin</span>() <span class="hljs-built_in">end</span>()<br>set 无重复有序 multiset 有重复<br>    <span class="hljs-built_in">insert</span>()<br>    <span class="hljs-built_in">find</span>()<br>    <span class="hljs-built_in">count</span>() <span class="hljs-comment">// 0 1</span><br>    <span class="hljs-built_in">erase</span>(x)删除所有x  k+<span class="hljs-function">logn</span><br><span class="hljs-function">    <span class="hljs-title">erase</span><span class="hljs-params">(迭代器)</span>删除当前</span><br><span class="hljs-function">    <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span> 删除大于等于x最小的  </span><br><span class="hljs-function">    <span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span> 删除大于x中最小的</span><br><span class="hljs-function"></span><br><span class="hljs-function">map multimap</span><br><span class="hljs-function">    <span class="hljs-title">insert</span><span class="hljs-params">(&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;)</span> <span class="hljs-title">erase</span><span class="hljs-params">()</span> 参数pair</span><br><span class="hljs-function">    添加M[&quot;str&quot;]</span>=<span class="hljs-number">1</span> ,如果没有该key，默认值为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">auto</span>遍历时first,second取数，和pair遍历一样<br>    multimap可以用map&lt;x,vector&lt;y&gt; &gt;代替<br><br>unordered_set unordered_map unoerder_multiset unoerder_multimap 哈希表<br>    增删改查<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 不支持 lower_bound upper_bound<br><br><span class="hljs-comment">//二分返回第一个大于等于x的数</span><br>	<span class="hljs-built_in">lower_bound</span>(a,a+n,x)-a;<br>	<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),x)-v.<span class="hljs-built_in">begin</span>();  <br><br><span class="hljs-comment">// 随机数</span><br>	<span class="hljs-built_in">srand</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>	cout &lt;&lt; <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-comment">// 自定义比较函数</span><br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b;&#125;<br>	<span class="hljs-built_in">sort</span>(a,a+n,cmp);<br><span class="hljs-comment">// greater比较</span><br>	<span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure>



<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><h3 id="1-0排序"><a href="#1-0排序" class="headerlink" title="1.0排序"></a>1.0排序</h3><blockquote>
<p>快速排序</p>
</blockquote>
<p>​	选取中点为划分，左边&lt;&#x3D;，右边&gt;&#x3D;。再分别排序两边  空间O(logn)   不稳定 <a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/487415/">边界选择</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span> ,j=r<span class="hljs-number">+1</span> mid=a[l + r &gt;&gt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>    i++;<span class="hljs-keyword">while</span>(a[i]&lt;mid) i ++;<br>    j--;<span class="hljs-keyword">while</span>(a[j]&gt;mid) j --;<br>    <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(a[i], a[j]);<br>&#125;<br><span class="hljs-built_in">quickSort</span>(l, j);        <span class="hljs-comment">// j会停留在&lt;=mid的位置，且j右边一定满足&gt;=mid</span><br><span class="hljs-built_in">quickSort</span>(j<span class="hljs-number">+1</span>, r);<br><br><span class="hljs-comment">// 如果以i-1  i分解 mid要加一  否则死循环  [1, 2]</span><br><span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure>

<p>​	<strong>partition</strong>:  l的左边小于key，r的右边大于key。[l:i)的数等于key</p>
<p>l为下一个放小于key的地方，r为下一个放大于key的地方</p>
<p>最后0<del>l-1小于key ， l</del>r等于key ， r+1到n-1大于key</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>,i=l<br><span class="hljs-keyword">while</span>(i&lt;=r)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]&lt;key)&#123;<br>    	<span class="hljs-built_in">swap</span>(nums[i],nums[l]);<br>    	i++,l++;<span class="hljs-comment">//换过来的数一定等于key，i直接增加</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&gt;key)&#123;<br>    	<span class="hljs-built_in">swap</span>(nums[i],nums[r]);<br>    	r--;   <span class="hljs-comment">// 换过来的数不知道大小，i不增加</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    	i++;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>



<blockquote>
<p>归并排序</p>
</blockquote>
<p>​	先排好中点左边，再排中点右边，然后merge两边,  空间O(n)  稳定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l+r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(l,mid);<br><span class="hljs-built_in">merge_sort</span>(mid<span class="hljs-number">+1</span>,r);<br><span class="hljs-comment">// merge  merge时tmp数组只申请需要的大小，或者全局申请</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>其他</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">冒泡 每次交换出一个最大<br>插入 <br>选择  不稳定<br><br>堆排序 不稳定<br><br>计数排序<br>桶排序  ：桶内排序，桶外计数排序<br></code></pre></td></tr></table></figure>



<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">排序算法	平均时间复杂度	最坏时间复杂度	空间复杂度	稳定性<br><span class="hljs-variable">QuickSort</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>		<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>不稳定<br><span class="hljs-built_in">Merge</span> <span class="hljs-built_in">Sort</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>稳定<br><span class="hljs-variable">Heap</span> <span class="hljs-built_in">Sort</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>不稳定<br><span class="hljs-variable">Timsort</span>		<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>稳定  归并<span class="hljs-operator">+</span>插入<br><span class="hljs-variable">Dual</span><span class="hljs-operator">-</span><span class="hljs-variable">Pivot</span> 	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>		<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">log</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span>不稳定  <span class="hljs-variable">java</span> <span class="hljs-variable">int</span> <span class="hljs-variable">char</span> <span class="hljs-variable">long</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">Insertion</span> 	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>			<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>稳定   每次向有序中插入一个元素 常数小！<br><span class="hljs-variable">Bubble</span> <span class="hljs-built_in">Sort</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>			<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>稳定   冒泡 每次交换出一个最大<br><span class="hljs-built_in">Selection</span> 	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>			<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>不稳定  每次在无序中，选出一个最小的<br><span class="hljs-variable">Counting</span> 	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>稳定  	<span class="hljs-number">0</span><span class="hljs-operator">~</span><span class="hljs-variable">k</span>个桶 统计数量，适用于小范围整数。<br><span class="hljs-variable">Radix</span> 		<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">d</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">d</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>稳定 	按位排序，适用于整数和固定长度字符串。<br><span class="hljs-variable">Bucket</span> 		<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>	<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span>		<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">+</span> <span class="hljs-variable">k</span><span class="hljs-punctuation">)</span>稳定	数据分桶<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">0.1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-operator">,</span> <span class="hljs-number">0.2</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span>后排序，再合并所有桶。<br></code></pre></td></tr></table></figure>

<h4 id="TimSort-的过程："><a href="#TimSort-的过程：" class="headerlink" title="TimSort 的过程："></a><strong>TimSort 的过程：</strong></h4><ol>
<li><strong>分块</strong>: TimSort 首先将数组分成若干个小的子数组，这些子数组称为 <strong>Run</strong>。每个 Run 的大小通常在 32 到 64 之间，具体取决于数组的大小和实现。</li>
<li><strong>对每个 Run 进行排序</strong>: 对每个 Run 使用插入排序进行排序，因为插入排序在小规模数据上效率高。</li>
<li><strong>合并 Run</strong>: 将这些有序的 Run 通过归并排序的方式合并在一起，形成一个更大的有序数组。TimSort 会根据实际情况决定何时合并哪些 Run，以保持整体效率。</li>
</ol>
<h3 id="1-1二分"><a href="#1-1二分" class="headerlink" title="1.1二分"></a>1.1二分</h3><p>分界点右边都满足一种性质，左边都不满足</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">l=<span class="hljs-number">0</span> ,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//寻找满足条件的最左边的数        大于等于aim      不会用到a[r]的值     </span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(a[mid]&gt;=aim)&#123;<br>        r=mid;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//寻找满足条件的最右边的数        小于等于aim      不会用到a[l]的值</span><br> <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    mid=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-comment">//不加一 会死循环</span><br>    <span class="hljs-keyword">if</span>(a[mid]&lt;=aim)&#123;<br>        l=mid;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//浮点数二分，结束条件要多两位</span><br><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">0.00000001</span>)&#123;        <span class="hljs-comment">//多两位</span><br>    <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(mid*mid*mid&lt;=n) l=mid;<br>    <span class="hljs-keyword">else</span> r=mid;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>0.旋转数组找旋转点</p>
<p>1.机器人跳跃 1e5 n a[i]，从起点跳到终点 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">每次跳跃res= res*<span class="hljs-number">2</span>-a[i];   res始终要大于零，求最小的起始res。<br>检测一个数要<span class="hljs-number">1e5</span>，遍历[<span class="hljs-number">1</span>,<span class="hljs-number">1e5</span>]个数超时，二分遍历即可解决<br></code></pre></td></tr></table></figure>

<p>2.分巧克力</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">对于每一种大小的切法，1e5时间能求出是否满足数量<br>二分求出这个大小即可。<br></code></pre></td></tr></table></figure>

<p>3.炸弹问题：矩阵和</p>
<p><strong>4.四平方和 四个数的平方和为x，求出序列最小的  x&lt; 5*1e6</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">求出三个数，就能得出最后一个，但是时间上最多求出两个<br>	枚举前面两个数c d，并存下来 按照sum排序 如果相同就按照c排序<br>		（或者把和扔到hash中，只放入第一次遇到的）<br>	枚举<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span>，查看<span class="hljs-attribute">x</span>-<span class="hljs-selector-tag">a</span>^<span class="hljs-number">2</span>-<span class="hljs-selector-tag">b</span>^<span class="hljs-number">2</span>是否在存下的数中（二分，hash）<br></code></pre></td></tr></table></figure>

<p>5.k倍区间  一个数组中子串为给定数k的倍数，求共有多少个这样的区间  1e5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">两个循环加前缀和 但依旧会超时<br><br>s[r]-s[l]  % k == <span class="hljs-number">0</span> 相当于  s[r]与s[l]余数相同，所以每次是在找余数为固定值的个数<br>cnt[i] 代表当前余数为i的个数（包括s[r]）<br>先计算出s[r]全取的情况下，余数为零的个数，再取算s[l]与s[r]同余的个数<br>遍历右端点<br>    <span class="hljs-keyword">if</span>(s[r]==<span class="hljs-number">0</span>)res ++;<br>	cnt[s[r]]++;<br>    res += (cnt[s[r]]<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure>



<h3 id="1-2高精度"><a href="#1-2高精度" class="headerlink" title="1.2高精度"></a>1.2高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//两个大整数，求和          10^6位</span><br><span class="hljs-comment">//相减                    10^6位</span><br><span class="hljs-comment">//一个大整数乘一个小整数    &lt;10^6位 * 1000000</span><br><span class="hljs-comment">//          除</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//大整数的每一位存到vector中，个位放下标0,输入用字符串,记得-&#x27;0&#x27;</span><br><span class="hljs-comment">//t = a[i] + b[i] + t</span><br></code></pre></td></tr></table></figure>
<ul>
<li>除了加法都要去除前面的零    while(C.size()&gt;1&amp;&amp;C.back()&#x3D;&#x3D;0)C.pop_back();</li>
<li>乘法每一位直接拿小的数乘</li>
<li>除法从高位开始除，最后反转 reverse(C.begin(),C.end());</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 乘法直接一位一位乘, 最后再一次性进位</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a1.size();i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a2.size();j++)&#123;<br>    	res[i+j] += a1.get(i) * a2.get(j);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length-<span class="hljs-number">1</span>;i++)&#123;<br>    res[i+<span class="hljs-number">1</span>] += res[i]/<span class="hljs-number">10</span>;<br>    res[i] %= <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>java中，<code>string</code>到<code>List&lt;Integer&gt;</code>需要-‘0’，而sb.append 可以直接append数字</p>
<h3 id="1-3前缀和-差分"><a href="#1-3前缀和-差分" class="headerlink" title="1.3前缀和  差分"></a>1.3前缀和  差分</h3><p>&#x3D;&#x3D;前缀和&#x3D;&#x3D;：前缀和一个值代表着一个区间的性质</p>
<ol>
<li>普通前缀和  <strong>询问区间</strong></li>
<li>矩阵和        求出每个到0，0点的矩阵的和   <strong>询问矩阵</strong></li>
<li>前缀积 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-product-queries-of-powers/solutions/2453873/yi-ti-duo-jie-bu-chong-ling-shen-bzhan-s-20vb/">2438. 二的幂数组中查询范围内的乘积 - 力扣（LeetCode）</a>  需要结合逆元</li>
</ol>
<p>&#x3D;&#x3D;差分&#x3D;&#x3D;：差分数组一个值的改变影响一个区间</p>
<ol>
<li>差分数组   <strong>多次区间操作后，询问结果</strong></li>
<li>差分矩阵b求和等于a，不用考虑b如何出来的，只需要考虑b如何改变a的<ul>
<li>当b增加时，改变的时全部右下角的数</li>
</ul>
</li>
</ol>
<h3 id="1-4双指针"><a href="#1-4双指针" class="headerlink" title="1.4双指针"></a>1.4双指针</h3><p>双指针<br>快排 归并排序</p>
<p>将i j 两种枚举n^2的情况，优化为O(n);<br>找到i j 之间存在的单调性</p>
<p>将一个英文句子的每个单词输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>连续最长不重复子串</p>
</li>
<li><p>两个升序数组，求和为x的两个数组的下标</p>
</li>
<li><p>判断是否是字串</p>
</li>
</ul>
<h3 id="1-5位运算"><a href="#1-5位运算" class="headerlink" title="1.5位运算"></a>1.5位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) x&amp;-x</span><br><span class="hljs-comment">//lowbit:返回最后一位1以及后面的零 110100 -&gt; 100</span><br><br>n&gt;&gt;k&amp;<span class="hljs-number">1</span><br><span class="hljs-comment">//二进制中第k位是几</span><br></code></pre></td></tr></table></figure>

<ul>
<li>求一个数中二进制1的个数，两种方法都可以</li>
</ul>
<h3 id="1-6离散化"><a href="#1-6离散化" class="headerlink" title="1.6离散化"></a>1.6离散化</h3><p>原来的下标太大了，将大数，转为排序数组的下标</p>
<ul>
<li>操作无限长坐标上的元素后，询问区间和</li>
</ul>
<p>将大的数保存到vector中后，排序，去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<p>将大值和下标映射用<strong>二分查找</strong>或<strong>unordered_map</strong>映射</p>
<p>询问上的点也要先加入到alls中</p>
<p>如果只想将大数映射到小数，也可也不去重，同一个数每次查找时会获取出同一个idx</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sorted 所有的大数 并且已经排序 可能重复</span><br>Arrays.sort(sorted);<br><br>idx = Arrays.binarySearch(sorted, nums[i]);   <span class="hljs-comment">//或者用map</span><br></code></pre></td></tr></table></figure>



<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>int h&#x3D;-1, e[], ne[], idx</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>s[],  t&#x3D;-1</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调增：栈内元素单调递增，遍历到i时，导致某元素出栈，则i是右边第一个比该元素小的，新栈顶为左边第一个比该元素小的。</p>
<ol start="84">
<li>最大矩阵面积</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>q[], t&#x3D;-1, h&#x3D;0;     t进h出   q[++t]&#x3D;x;  h++;</p>
<ul>
<li>单调队列：把最小的始终保存在队头，实现滑动窗口求最小</li>
</ul>
<h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">297</span> 树的序列化与反序列化<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">middle_order</span><span class="hljs-params">(Node Node)</span>:</span><br><span class="hljs-function">	if(Node =</span>= <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);前</span><br>    <span class="hljs-built_in">middle_order</span>(Node-&gt;left);<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);中</span><br>    <span class="hljs-built_in">middle_order</span>(Node-&gt;right);<br>    <span class="hljs-comment">// printf(&quot;%d &quot;, Node-&gt;data);后</span><br><br>非递归实现：颜色标记法<br><span class="hljs-function">def <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[<span class="hljs-type">int</span>]:</span><br><span class="hljs-function">    WHITE, GRAY =</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    res = []<br>    stack = [(WHITE, root)]<br>    <span class="hljs-keyword">while</span> stack:<br>        color, node = stack.<span class="hljs-built_in">pop</span>()<br>        <span class="hljs-keyword">if</span> node is None: <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> color == WHITE:<br>            stack.<span class="hljs-built_in">append</span>((WHITE, node.right)) # 先输出的后入栈<br>            stack.<span class="hljs-built_in">append</span>((GRAY, node))<br>            stack.<span class="hljs-built_in">append</span>((WHITE, node.left))<br>        <span class="hljs-keyword">else</span>:<br>            res.<span class="hljs-built_in">append</span>(node.val)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>



<h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>树：边的个数加+ 1 &#x3D; ∑节点*度 + 1 &#x3D; 节点个数</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Tb4y197Fe">https://www.bilibili.com/video/BV1Tb4y197Fe</a></p>
<p>Binary Search Tree: <strong>BST</strong>   -&gt;退化-&gt;   <strong>AVL</strong> （左右高度差不超过1）&gt;频繁增删&gt;  <strong>RBT</strong></p>
<p>如果失去平衡, 找到第一个失去平衡的点左右旋转使得平衡 LL，RR（直接旋转）  LR（先左旋）</p>
<p> RBT：根是黑色（空结点也是黑色）、红节点不连续、黑节点到达空指针进过的黑点个数相同</p>
<p><strong>B树</strong>（数据库）：一个节最多m-1个值（连续，访问磁盘次数就会更少），m个孩子节点。m为树的阶</p>
<p>​		非叶子节点最少有(m+1)&#x2F;2子树，最多m</p>
<p>​		叶子节点为空节点，都在同一层</p>
<p>​		<strong>查找</strong>：和BST类似       范围查询：中序遍历</p>
<p>​		<strong>插入</strong>：当节点个数多于(m+1)&#x2F;2时，进行分裂</p>
<p>​		<strong>删除</strong>：终端节点：大于(m+1)&#x2F;2-1个节点：直接删</p>
<p>​										等于(m+1)&#x2F;2-1，去兄弟节点借，借不到就合并：上一层挪下来一个</p>
<p>​					非终端：和相邻关键字（前驱、后驱）互换，就变成了终端节点</p>
<p><strong>B+树：</strong></p>
<p>​		n个节点n个子树</p>
<p>​		非叶子节点只能索引，叶子节点才指向记录。</p>
<p>​		叶子节点被串成了一个单链表，可以线性访问，头指针被保存。</p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>p 在 s中所有的起始位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">ne:p当前匹配失败后，j跳转的位置（j<span class="hljs-number">-1</span>的最大匹配长度） ababc ne[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>  ne[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">get</span>()&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">-1</span>;<br>    ne[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||p[i]==p[j])&#123;<br>            i++,j++;<br>            ne[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;m)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==p[j])&#123;<br>            i++,j++;<br>            <span class="hljs-keyword">if</span>(j==n)&#123;<br>                cout&lt;&lt;i-n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                j=ne[j];  <span class="hljs-comment">// 这里不可以从头开始，不然会少很多  如 aba  ababa</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cin&gt;&gt;n&gt;&gt;s&gt;&gt;m&gt;&gt;p;<br><span class="hljs-built_in">get</span>();<br><span class="hljs-built_in">kmp</span>();<br></code></pre></td></tr></table></figure>



<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>字符串出现次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idx;   <span class="hljs-comment">//son 保存下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        <span class="hljs-type">int</span> u=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u])son[p][u]=++idx;<br>        p=son[p][u];<br>    &#125;<br>    cnt[p]++;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回根节点编号 路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x!=p[x])&#123;<br>        p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(fx!=fy)&#123;     <span class="hljs-comment">//在不同的情况下才相加</span><br>        p[fx]=fy;<br>        cnt[fy]+=cnt[fx];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用数列保存，从1开始存 儿子（2<em>u，2</em>u+1）</p>
<p>down: 左右儿子已经是堆，加上直接再构成堆    n&#x2F;2开始down</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=u;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span>&lt;=si&amp;&amp;h[u*<span class="hljs-number">2</span>]&lt;h[t])t=u*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;=si&amp;&amp;h[u*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&lt;h[t])t=u*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">if</span>(u!=t)&#123;<br>        <span class="hljs-built_in">swap</span>(h[u],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span> &amp;&amp; heap[i]&lt;heap[i/<span class="hljs-number">2</span>])&#123;<br>        <span class="hljs-built_in">swap</span>(heap[i],heap[i/<span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">up</span>(i/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 插入到最后一个元素，然后up</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>    now++;<br>    heap[now] = p;<br>    <span class="hljs-built_in">up</span>(now);<br>&#125;<br><span class="hljs-comment">// 最后一个元素放到第一个位置，然后down</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    heap[<span class="hljs-number">1</span>]=heap[now];<br>    now--;<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>无扩容java堆，0开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriorityQueue</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> Object[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyPriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span>&#123;<br>        <span class="hljs-built_in">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity+<span class="hljs-number">1</span>];<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.comparator = comparator;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>&#123;<br>        queue[size] = e;<br>        size ++;<br>        up(size-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span>: (E)queue[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (E)queue[<span class="hljs-number">0</span>];<br>        queue[<span class="hljs-number">0</span>] = queue[size-<span class="hljs-number">1</span>];<br>        size--;<br>        down(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;size &amp;&amp; comparator.compare((E)queue[u], (E)queue[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)&#123;<br>            u = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>&lt;size &amp;&amp; comparator.compare((E)queue[u], (E)queue[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">0</span>)&#123;<br>            u = i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u != i)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue[i];<br>            queue[i] = queue[u];<br>            queue[u] = t;<br>            down(u);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (i-<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>(comparator.compare((E)queue[i], (E)queue[p]) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue[i];<br>            queue[i] = queue[p];<br>            queue[p] = t;<br>            up(p);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>方法1：线性探测表，开两倍地址空间 null&#x3D;0x3f3f3f3f</p>
<p>&#x2F;&#x2F;返回x对应下标,没有x就返回应该放的地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(a[k]!=null&amp;&amp;a[k]!=x)&#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k==N)k=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法2：链地址法，也是存图的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> mod=<span class="hljs-number">100003</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N; <span class="hljs-comment">//保证都映射到正数上</span><br>    e[idx]=x;<br>    ne[idx]=h[k];<br>    h[k]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[k];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        <span class="hljs-keyword">if</span>(e[i]==x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><p>将一段<strong>字符串</strong>用一个<strong>数字</strong>表示，字符串低位为数字高位  左高右低</p>
<p>hash值用ULL保存typedef unsigned long long ULL;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> P=<span class="hljs-number">131</span>;<span class="hljs-comment">//131进制，字符串中下标小的为高位</span><br>ULL p[N];  <span class="hljs-comment">// 进制的i次方</span><br>ULL h[N];  <span class="hljs-comment">// hash值   下标1~i</span><br></code></pre></td></tr></table></figure>

<p>存入时,计算字符串hash</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    h[i]=h[i<span class="hljs-number">-1</span>]*P+s[i];<br>    p[i]=p[i<span class="hljs-number">-1</span>]*P;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计算式，L到R之间的字符串的hash值为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ULL t=h[R]-h[L<span class="hljs-number">-1</span>]*p[R-L<span class="hljs-number">+1</span>];<br></code></pre></td></tr></table></figure>

<p>java：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-palindrome/">214. 最短回文串</a> 前添加字符使得字符串回文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">131</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mul</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, suffix = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-comment">// abcde</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br>    prefix = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) prefix * base + c)%mod); <span class="hljs-comment">//a ab abc  正常字符串写法</span><br>    suffix = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) mul * c + suffix)%); <span class="hljs-comment">//a ba cba</span><br>    mul = (<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>) mul * base) % mod);<br><br>    <span class="hljs-keyword">if</span>(prefix == suffix)&#123;<br>        idx = i;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span>(idx==n-<span class="hljs-number">1</span> || n==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.substring(idx+<span class="hljs-number">1</span>)).reverse().toString() + s;<br></code></pre></td></tr></table></figure>

<h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;$#&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            t.append(s.charAt(i));<br>            t.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        n = t.length();<br>        t.append(<span class="hljs-string">&#x27;!&#x27;</span>);<br><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">iMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rMax = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-comment">// 初始化 f[i]</span><br>            f[i] = i &lt;= rMax ? Math.min(rMax - i + <span class="hljs-number">1</span>, f[<span class="hljs-number">2</span> * iMax - i]) : <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 中心拓展</span><br>            <span class="hljs-keyword">while</span> (t.charAt(i + f[i]) == t.charAt(i - f[i])) &#123;<br>                ++f[i];<br>            &#125;<br>            <span class="hljs-comment">// 动态维护 iMax 和 rMax</span><br>            <span class="hljs-keyword">if</span> (i + f[i] - <span class="hljs-number">1</span> &gt; rMax) &#123;<br>                iMax = i;<br>                rMax = i + f[i] - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 回文串数量</span><br>            ans += f[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 回文串长度</span><br>            ans  = Math.max(ans, f[i] -<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ol start="315">
<li><p>逆序对数量</p>
</li>
<li><p><strong>单点更新</strong> <code>update(x, delta)</code>： 把序列 x 位置的数加上一个值 delta；  logn</p>
</li>
<li><p><strong>前缀和查询</strong> <code>query(x)</code>：查询序列 <code>[1,...x]</code> 区间的区间和，即位置 x 的前缀和。logn</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>建树规则：<strong>c[i] 管理着 从i开始的前lowbit(i)个数的和</strong></p>
<ul>
<li><p>求前 10010010的和 只需要拿出c[10010010] (最后两个数) + [sum(10010000) &#x3D; c[10010000] + c[10000000] ]</p>
</li>
<li><p>当一个数修改后 1010，会影响管理者他的c：c[1010]  c[1100] c[10000] c[100000] …</p>
</li>
<li><p>单点修改+区间查询      （单纯前缀和不能在这两种操作混合时发挥作用）</p>
</li>
<li><p>区间修改+单点查询      维护差分数组   （单纯差分数组在这两种操作混合时发挥作用）</p>
</li>
</ul>
<h2 id="3-图"><a href="#3-图" class="headerlink" title="3.图"></a>3.图</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],ne[N],e[N],w[N];<br><span class="hljs-type">int</span> idx;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    w[idx]=c;<br>    e[idx]=b;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[a];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>    <span class="hljs-type">int</span> j=e[i];<br></code></pre></td></tr></table></figure>



<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs:"></a>dfs:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 需要标记数组st[N],  遍历节点的每个相邻的边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记一下，记录为已经被搜索过了，下面进行搜索过程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            <span class="hljs-built_in">dfs</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br>实践：求树的重心 acwing846<br></code></pre></td></tr></table></figure>



<h3 id="bfs："><a href="#bfs：" class="headerlink" title="bfs："></a>bfs：</h3><p>st[] 和 queue</p>
<p>求距离，先进距离短 先出</p>
<p> d[]保存距离，同时判断是否访问过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>    <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>)&#123;<br>            d[j]=d[x]<span class="hljs-number">+1</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs inform7">无负边 （从顶点角度出发每次取出最近顶点）<br>                                 			                 都需要dis<span class="hljs-comment">[N]</span><br>   dij稠密 	         n*n      二维数组           st<span class="hljs-comment">[N]</span> //判断是否已经求出来了<br>   dij稀疏  堆优化      m*logn     邻接表              优先队列存&lt;PII&gt;  st<span class="hljs-comment">[N]</span><br><br><br>有负边  (从边的角度出发)<br><br>   有负环 bellmanford      n*m               struct存边       backup<span class="hljs-comment">[N]</span>//防止串联更新<br>   无负环 spfa             m -&gt; n*m          邻接表            q  st<span class="hljs-comment">[N]</span>//是否在队列中<br>      判负环：不用设置dis，所有点都加入队列                        +cnt<span class="hljs-comment">[N]</span>  连了多少条边<br><br>floyd 动态规划             n^3                 二维数组<br><br><br>二维数组处理重边g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>=min(g<span class="hljs-comment">[a]</span><span class="hljs-comment">[b]</span>,c); dij初始化可以全为0x3f3f3f3f但floyd不行。<br>邻接表、struct存边不需要额外处理，松弛时自动选择小的边<br><br>存在负边会导致正无穷变小（bellmanford 和 floyd）所以判断改成：dis<span class="hljs-comment">[n]</span>&gt;0x3f3f3f3f /2<br></code></pre></td></tr></table></figure>

<h4 id="dij"><a href="#dij" class="headerlink" title="dij"></a>dij</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">priority_queue</span>&lt;PII,<span class="hljs-built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt; &gt; p;<br>p.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-keyword">while</span>(p.size())&#123;<br>    PII tmp = p.top();<br>    p.pop();<br>    <span class="hljs-keyword">if</span>(st[tmp.second])<span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-type">int</span> x = tmp.second;<br>    st[x] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(dis[j]&gt;dis[x]+w[i])&#123;  <span class="hljs-comment">// 这里及时更新距离，并通过距离剪枝</span><br>            dis[j] = dis[x]+w[i];<br>            p.push(&#123;dis[j],j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="bellmanford"><a href="#bellmanford" class="headerlink" title="bellmanford"></a>bellmanford</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最多k条边,对所有点的出边进行更新</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    <span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis); <span class="hljs-comment">//防止串联更新</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>        <span class="hljs-type">int</span> a=edges[j].a,b=edges[j].b,c=edges[j].c;<br>        dis[b]=<span class="hljs-built_in">min</span>(dis[b],backup[a]+c);<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<p>如果k&#x3D;n时还更新了，就是存在包含点1的负环</p>
<h4 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h4><p>当一个点距离变小后，所有以该点的出边才可能更新。st数组防止重复添加(不用也能过)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>st[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>    <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;<br>            dis[j]=dis[t]+w[i];<br>            <span class="hljs-keyword">if</span>(st[j]==<span class="hljs-number">0</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                st[j]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h4><p>最短路包含边数大于n-1</p>
<p>设置一个虚拟源节点，到所有阶段距离都为0，原图有负环等价于现在的图有负环，</p>
<p>第一次spfa等价于所以开始时所有点都加入</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">普里姆：	 加最近点，有点像dij    n</span><span class="hljs-keyword">^2</span><span class="language-xml"></span><br><span class="language-xml">克鲁斯卡尔： 加最小的边     		E</span><span class="hljs-keyword">^2</span><span class="language-xml">     并查集</span><br></code></pre></td></tr></table></figure>



<h2 id="4-数学"><a href="#4-数学" class="headerlink" title="4.数学"></a>4.数学</h2><h3 id="筛质素"><a href="#筛质素" class="headerlink" title="筛质素"></a>筛质素</h3><p>诶氏筛法 O(nloglogn):小于等于 n 的质数的倒数和大约是 loglogn</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            primes[cnt++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//可以用质数就把所有的合数都筛掉；</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线性筛法 O(n)：每个数只被最小的质素筛 <a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2559/">https://www.acwing.com/solution/content/2559/</a></p>
<p>i&#x3D;15  会筛掉 15* 2 15* 3 ，但15*5不会被15筛，而是被25 * 3筛, 所以primes[j]只到 i 的最小因子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<br>        <span class="hljs-comment">//假设primes[0]为n最小的质因子,i为最大的因数，</span><br>        <span class="hljs-comment">//易知若primes[i]中i&gt;0,则会进入循环后产生多余的标记。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)<br>        &#123;<br>            <span class="hljs-comment">//标记;primes[j]一定是primes[j]*i的最小质因子</span><br>            st[primes[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//表明primes[j]一定是i的最小质因子,没有必要再遍历,primes要小于等于i的最小质因子</span><br>            <span class="hljs-comment">//这样能保证每个数遍历一遍,而没有重复</span><br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p>n 个正整数 ai，请你输出这些数的乘积的约数个数</p>
<p>求出所有质因子p以及个数x：N &#x3D; (p1^x1^)(p2^x2^)(p3^x3^)…(pk^xk^)   </p>
<p>约数个数： (x1+1)(x2+1)(x3+1)…(xk+1)</p>
<p>约数和&#x3D;(1+p1^1^+p1^2^+…+p1^x1^)×(1+p2^1^+p2^2^+…+p2^x2^)…×(1+pk^1^+pk^2^+…+pk^xk^)   每一个括号里取出一个数相乘就得到一个约数，最后求和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><span class="hljs-keyword">while</span> (n -- )<br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; x;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            x /= i;<br>            primes[i] ++ ;<br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>&#125;<br><br>LL res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes)<br>&#123;<br>    LL a = p.first, b = p.second;<br>    LL t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b -- ) t = (t * a + <span class="hljs-number">1</span>) % mod;<br>    res = res * t % mod;<br>&#125;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>

<p>秦九韶算法: 计算多项式朴素方法需要2n乘法（xn-1 * x * a）n次加法，秦九韶只需要n次乘n次加<br>$$<br>f(x) &#x3D; a_nx^n + a_{n-1}x^{n-1} + \cdots + a_1x + a_0&#x3D; (((a_nx + a_{n-1})x + \cdots )x + a_1)x + a_0<br>$$</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">求 m^k mod p，时间复杂度 <span class="hljs-built_in">O</span>(logk)。<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>将递推式写成矩阵形式：斐波那契数列 O（n）-&gt; O（m^3*logn）</p>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/350535">矩阵快速幂 - Virtual Judge (vjudge.net)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">6</span>;                  <span class="hljs-comment">//题目中可能出现的最大大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">6</span>;                  <span class="hljs-comment">//实际常数矩阵的大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">123456789</span>;        <span class="hljs-comment">// const int 和int 作为模数还运算速度不一样</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> t[N][N];          <span class="hljs-comment">//常数矩阵</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> tmp[N][N];         <span class="hljs-comment">//相乘时的temp  辅助</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> b[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>                tmp[i][j]=(tmp[i][j]+a[i][k]*b[k][j])%mod;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>    		a[i][j]=tmp[i][j];<br><br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> result[N][N];                     <span class="hljs-comment">//保存求幂后的值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a[][N],<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(result,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> result);             <span class="hljs-comment">//N是矩阵大小</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) result[i][i]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">multi</span>(result,a,n);              <span class="hljs-comment">//result=result*a;复制直接在multi里面实现了；</span><br>        <span class="hljs-built_in">multi</span>(a,a,N);                       <span class="hljs-comment">//a=a*a</span><br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x&amp;&amp;x!=<span class="hljs-number">-1</span>)&#123;<br>        t[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=t[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=t[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        t[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pow</span>(t,x);<br>        cout&lt;&lt;result[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><ul>
<li>(ab)modp&#x3D;(amodp)∗(bmodp)modp</li>
<li>(a+b)modp&#x3D;((amodp)+(bmodp))modp</li>
<li>(a−b)modp&#x3D;((amodp)−(bmodp)+p)modp</li>
<li><strong>注意(a&#x2F;b)modp≠((amodp)&#x2F;(bmodp))modp 这也是为什么需要求乘法逆元</strong></li>
</ul>
<p>若整数 b，m互质，并且对于任意的整数 a，如果满足 b|a，则存在一个整数 x，使得 a&#x2F;b≡a×x(modm)，则称 x为 b的模 m 乘法逆元，记为 b−1(modm)。</p>
<p>b存在乘法逆元的充要条件是 b与模数 m互质：</p>
<ul>
<li><p>当模数 m为质数时，b^m−2^即为 b 的乘法逆元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = (LL)a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p)<br></code></pre></td></tr></table></figure>
</li>
<li><p>否者用扩展欧几里得</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a, p, x, y);<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) cout &lt;&lt; ((LL)x + p) % p &lt;&lt; endl;<span class="hljs-comment">//保证x是正数</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">a / b ≡ a * x (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>两边同乘b可得 a ≡ a * b * x (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>即 <span class="hljs-number">1</span> ≡ b * x (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>同 b * x ≡ <span class="hljs-number">1</span> (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>由费马小定理可知，当<span class="hljs-built_in">n</span>为质数时 且b <span class="hljs-built_in">n</span> 互质<br>b ^ (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) ≡ <span class="hljs-number">1</span> (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>拆一个b出来可得 b * b ^ (<span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>) ≡ <span class="hljs-number">1</span> (<span class="hljs-built_in">mod</span> <span class="hljs-built_in">n</span>)<br>故当<span class="hljs-built_in">n</span>为质数时，b的乘法逆元 x = b ^ (<span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<p>逆元可拆分：（a!)-1 &#x3D;（a-1! * a)-1 &#x3D; ( a-1! )-1 * ( a )-1</p>
<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/35805_f4228ae4c7-%E7%BB%84%E5%90%88%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="组合数.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>, p = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] fact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N], infact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( k &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>( (k &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> ) res = res * a % p;<br>            a =(<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) a * a % p);<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Integer.valueOf(read.readLine());<br>        fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>            fact[i] =(<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>)fact[i - <span class="hljs-number">1</span>] * i % p);<br>            infact[i] = (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) infact[i - <span class="hljs-number">1</span>] * qmi(i, p - <span class="hljs-number">2</span>, p ) % p);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(t -- &gt; <span class="hljs-number">0</span>)&#123;<br>            String[] ss = read.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(ss[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(ss[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((<span class="hljs-type">long</span>) fact[a] * infact[a - b] % p * infact[b] % p);<br>            System.out.println(res);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/29702/">https://www.acwing.com/solution/content/29702/</a></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">n = <span class="hljs-number">10</span>, <span class="hljs-built_in">p1</span><span class="hljs-number">=2</span>,<span class="hljs-built_in">p2</span><span class="hljs-number">=3</span><br>求<span class="hljs-number">1</span>-<span class="hljs-number">10</span>中能满足能整除<span class="hljs-built_in">p1</span>或<span class="hljs-built_in">p2</span>的个数, 即<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">8</span>，<span class="hljs-number">9</span>，<span class="hljs-number">10</span>,共<span class="hljs-number">7</span>个<br></code></pre></td></tr></table></figure>

<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240330222536954.png" srcset="/img/loading.gif" lazyload alt="image-20240330222536954"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> p[N], n, m;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <span class="hljs-built_in">cin</span> &gt;&gt; p[i];<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;             <span class="hljs-comment">//选中集合对应质数的乘积</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;             <span class="hljs-comment">//选中的集合数量</span><br><br>        <span class="hljs-comment">//枚举当前状态的每一位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>            <span class="hljs-comment">//选中一个集合</span><br>            <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//乘积大于n, 则n/t = 0, 跳出这轮循环</span><br>                <span class="hljs-keyword">if</span>((LL)t * p[j] &gt; n)&#123;    <br>                    t = <span class="hljs-number">-1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                s++;                  <span class="hljs-comment">//有一个1，集合数量+1</span><br>                t *= p[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;  <br><br>        <span class="hljs-keyword">if</span>(s &amp; <span class="hljs-number">1</span>) res += n / t;              <span class="hljs-comment">//选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量</span><br>        <span class="hljs-keyword">else</span> res -= n / t;                      <span class="hljs-comment">//反之则为 -1</span><br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs subunit">n元1次方程组<br><br>初等行列变换：1.某一行乘非零的数   2.交换某2行   3.把某一行的k倍加到另外一行取<br><br>高斯消元：每一次消去每行第一个，把方程边成上三角，再逆推求xn xn<span class="hljs-string">-1</span>...<br><br>完美阶梯型(第一行n个数 第二行n<span class="hljs-string">-1</span>...最后一行1个) 唯一解             r(A)=r(A,b)=n<br>左边没有未知数，右边不为零                    无解                r(A)&lt;r(A,b)<br>方程没有n个                                无穷多组           r(A)=r(A,b)&lt;n<br><br>（矩阵的秩r：矩阵中所有行向量中极大线性代无关组的元素个数。有效方程数量, 阶梯矩阵非零行数）<br>https://www.zhihu.com/question/21605094<br><br>化阶梯型：<br>int r=0,c=0;<br>枚举每一列c 0~n<span class="hljs-string">-1</span><br>	1.选出r~n<span class="hljs-string">-1</span>行中，第c列的数最大的那一行(为零就continue),移到第r行上去（最上面）<br>	2.将该数a[r][c]化成1<br>	3.将r<span class="hljs-string">+1</span>~n<span class="hljs-string">-1</span>行，如果第c列不是零，将第c列化为零<br>	成功消除一列r++<br>r==n 有解  有解逆推 i=n<span class="hljs-string">-1</span> ~0，<br>			j= i<span class="hljs-string">+1</span>~n<span class="hljs-string">-1</span> <br>				a[i][n]-=a[i][j]*a[j][n];<br>r&lt;n <br>	for i in r~n<span class="hljs-string">-1</span><br>		如果存在b不为零，无解 否则无穷解<br></code></pre></td></tr></table></figure>



<h2 id="5-dp"><a href="#5-dp" class="headerlink" title="5.dp"></a>5.dp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>每一个状态为一个集合，分集合思想后，求转移方程是通过大的划分出小的(不重不漏)<br><span class="hljs-number">2.</span>代码实现时，是从小的推导出大的，一定要保证转移方程中小的项已经求出来了。自底向上逐步填充数组<br>	因此有的循环顺序可以交换：背包、整数划分      有的一定不行：哈密顿<br><span class="hljs-number">3.</span>初始化，按题意给出有效的初始值<br>	计数时有效：<span class="hljs-number">1</span>，无效为<span class="hljs-number">0</span><br>	最值时有效：<span class="hljs-number">0</span>  负无穷或正无穷<br></code></pre></td></tr></table></figure>



<h3 id="5-1背包问题"><a href="#5-1背包问题" class="headerlink" title="5.1背包问题"></a>5.1背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">https:<span class="hljs-comment">//blog.csdn.net/yandaoqiusheng/article/details/84782655</span><br><span class="hljs-number">01</span>背包    每种只有一个             <br>完全背包 可以无限重复        <br>    <span class="hljs-number">1000</span> *<span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> 暴力tle，f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-v[i]] +w[i]) 用本层求出来的值优化<br>多重背包 限制单种数量              <br>    <span class="hljs-number">1000</span>* <span class="hljs-number">2000</span>* <span class="hljs-number">2000</span> 暴力tle，二进制优化（像快速幂），打包后<span class="hljs-number">1000</span>* <span class="hljs-number">2000</span>* <span class="hljs-number">12</span>转化为<span class="hljs-number">01</span>背包  <br>分组背包 每一组最多选一个       <br>    <span class="hljs-number">100</span>* <span class="hljs-number">100</span>* <span class="hljs-number">100</span>直接暴力<br>限制总数量                                <br>    额外一个sum[][]记录当前数量<br><br><span class="hljs-number">1.</span>一维数组存储，用上一层的值j就从大到小，用本层的j从小到大<br><br><span class="hljs-number">2.</span>完全背包 和 <span class="hljs-number">01</span>背包 的区别仅在于状态更新时的遍历顺序。（即<span class="hljs-number">01</span>是逆序，完全是顺序）<br><br><span class="hljs-number">3.</span>不超过容量 和 恰好装满 的区别仅在于二者的初始化~<br>- 前者全<span class="hljs-number">0</span>；也就是全有效<br>- 后者，f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>（第一列），其余全为负无穷，一维：除f[<span class="hljs-number">0</span>]为<span class="hljs-number">0</span>外，其余f[j]都是负无穷）<br></code></pre></td></tr></table></figure>



<h3 id="5-2线性dp"><a href="#5-2线性dp" class="headerlink" title="5.2线性dp:"></a>5.2线性dp:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>三角形<br><span class="hljs-number">2.</span>a最长上升子序列 f[i] 以i结尾的长度     优化：f[i]长度为i的序列结尾的数字<br><span class="hljs-number">3.</span>a、b最长公共子序列 f[i][j] a[i],b[j]结尾的最大长度   以a[i],b[j]是否出现四次划分<span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span><br><span class="hljs-number">4.</span>编辑距离       f[i][j]a前i个变成b前j个的最小操作次数	 只操作i的最后一个字母（<span class="hljs-number">3</span>种）<br><span class="hljs-number">5.</span>最短编辑距离 		同上<br><span class="hljs-number">6.</span>石头合并最小代价（最优矩阵相乘）  f[i][j] i到j的代价  最后一次的分界线为分类（因为该区间最后一定是某两个区间合并出来的）<br>	(!!!!!!区间问题：先枚举区间长度，再枚举起点，最后再根据决策计算。)<br>    长度 -&gt; 起点 -&gt; 拆分点<br><br><span class="hljs-number">7.</span>整数划分<span class="hljs-number">1.</span> 转化为体积为<span class="hljs-number">1</span>~n的！恰好 ！为n的完全背包物体 计数问题<br>        	    f[i][j]只取i个数，体积恰好为j的种类<br><br> 	<span class="hljs-number">2.</span> f[i][j] 总和为i，总数为j   分成有无<span class="hljs-number">1</span>两类 f[i][j]=(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i-j][j])%mod;<br><br><span class="hljs-number">8.</span>计数问题<br></code></pre></td></tr></table></figure>


<h3 id="5-3状态dp"><a href="#5-3状态dp" class="headerlink" title="5.3状态dp"></a>5.3状态dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">AcWing <span class="hljs-number">291</span><br>只考虑放水平的方格，列方格自动补全（前提不能有连续奇数个零，不然补全不了）<br>用二进制表示状态，<span class="hljs-number">0</span>表示无<span class="hljs-number">1</span>表示有<br><br>横向放置第i列结尾方格时  <span class="hljs-number">1.</span>满足与第i<span class="hljs-number">-1</span>列不冲突     (j&amp;k)==<span class="hljs-number">0</span><br>		        	 <span class="hljs-number">2.</span>i<span class="hljs-number">-1</span>列剩下的格子，没有连续奇数个格子   st[ j|k ]==<span class="hljs-number">1</span><br>当n不同时，st数组也不同<br><br><span class="hljs-comment">//棋盘为0~m-1列，需要计算到m列</span><br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)     <span class="hljs-comment">//放以i列结尾的方块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; <span class="hljs-number">1</span>&lt;&lt;n ;j++)      <span class="hljs-comment">//i-1列结尾的方块状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt; <span class="hljs-number">1</span>&lt;&lt;n ;k++)     <span class="hljs-comment">//尝试i列结尾的方块状态</span><br>            <span class="hljs-keyword">if</span>((j&amp;k)==<span class="hljs-number">0</span> &amp;&amp; st[j|k])<br>                f[i][k]+=f[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-number">11</span>* <span class="hljs-number">2</span>^<span class="hljs-number">11</span> *<span class="hljs-number">2</span>^<span class="hljs-number">11</span> =<span class="hljs-number">4</span> * <span class="hljs-number">10</span>^<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">acwing <span class="hljs-number">91</span> 最短hamilton哈密顿距离<br><span class="hljs-number">1</span>≤n≤<span class="hljs-number">20</span> <br>用二进制保存进过点的状态 <br><span class="hljs-type">int</span> f[<span class="hljs-number">1</span>&lt;&lt;N][N];<span class="hljs-comment">//i状态 j结尾的最小长度</span><br><span class="hljs-keyword">for</span> 状态<br>	<span class="hljs-keyword">for</span> 终点<br>		<span class="hljs-keyword">for</span> 倒数第二个点<br></code></pre></td></tr></table></figure>



<h3 id="5-4记忆化搜索"><a href="#5-4记忆化搜索" class="headerlink" title="5.4记忆化搜索"></a>5.4记忆化搜索</h3><p>dfs的同时，返回前记录下当前状态值。</p>
<p>没有上司的舞会、最长滑雪长度 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>(需要注意什么情况下是无解 什么条件是还没求 什么时候是中止)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x])<span class="hljs-keyword">return</span> f[x];<br>    <span class="hljs-comment">// 中止条件 </span><br>    ... 求解f[x]的最优解res<br>    f[x] = res;<br>    <span class="hljs-keyword">return</span> f[x];<br></code></pre></td></tr></table></figure>



<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">322</span>Coin Change：给定无数个定值硬币，最少数量凑出amount。<br>	dp：恰好、完全背包<br>	记忆化搜索：凑<span class="hljs-attribute">x</span>需要的个数 me<span class="hljs-selector-attr">[x]</span>, 画出求解树,存在重叠，需要记忆优化<br><br>矩阵左上角到右下角传纸条，穿两次路径和最大<br><br>栈的出栈入栈序列<br></code></pre></td></tr></table></figure>



<h2 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6.贪心"></a>6.贪心</h2><p>0.合并区间</p>
<p>1.区间选点使得每个区间至少一个点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">右端点排序，每次更新最右边的点<br></code></pre></td></tr></table></figure>

<p>2.安排课表，使得上的课最多[区间不重叠]</p>
<p>3.区间分组，组内互不相交      优先队列+左端点排序</p>
<p>4.选择区间覆盖指定区间。     左端点+贪心</p>
<p>5.排序</p>
<p>6.牛的最大忍耐度最小     对两头牛交换，会导致结果变大还是变小</p>
<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="Hot-100"><a href="#Hot-100" class="headerlink" title="Hot 100"></a>Hot 100</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1 两数之和 hash  双指针<br>4  二分<br>5 最长回文 dp || 马拉车<br>10 正则表达式匹配 ！ dp  处理边界以及情况列举<br>11 盛水容器  每次移动是丢弃了一些状态 <br>15 三数和为零 hash+set去重  |  排序+双指针 注意去重 <br>19 一次遍历删除链表第n个元素  快慢指针<br>23 合并k个有序列表  分治！类似归并、维护优先队列<br>31 下一个排序 找规律<br>33 旋转过的有序数组 二分寻找一个数<br>34 二分模板<br>39 组合总和 dfs   引用更快，但需要回溯回状态<br>42 接雨水<br><span class="hljs-code">	求出每个i能够接到的雨水数</span><br><span class="hljs-code">	单调栈</span><br><span class="hljs-code">46 全排列</span><br><span class="hljs-code">48 旋转矩阵</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">49.</span> 字母异位词分组 输入vector<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span></span> 将所含字母相同放入一个vector中输出<br><span class="hljs-code">	1.map&lt;string,[s1,s2]&gt; string为排序后 s1,s2为原来</span><br><span class="hljs-code">	2.将字母映射一个质素double a[26]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125;;</span><br><span class="hljs-code">		将string转为质素相乘，其他与1一样，少一个排序时间</span><br><span class="hljs-code">		小心溢出，用long long后取余(余数要大)或者用double</span><br><span class="hljs-code">	3.如果是string需要完全相同，可以字符串哈希映射为一个数字</span><br><span class="hljs-code">	4.统计个数后，map&lt;string,[s1,s2]&gt; string是每一个元素的个数 &#x27;a:x b:y&#x27;</span><br><span class="hljs-code"></span><br>53* 最大子数组和 字串的最大连续和  【dp】  二分分治维护区间关系，可以求解任意[l，r]区间最大值  -&gt; 线段树<br><span class="hljs-code">	后续题目：2321. 拼接数组的最大分数  或者转为状态dp </span><br><span class="hljs-code"></span><br>55 从数组第一个位置能否跳到最后一位置，数组上值为最大跳跃距离  dp优化成【贪心】<br><br>56 区间合并 【贪心】<br><br><span class="hljs-bullet">62.</span> 【dp】或者 记忆化搜索 或者 排列组合<br><br>63 【dp】可以优化空间到<br><br>64 【dp】可以直接原数组上dp<br><br>70 【dp】或找规律<br><br>72 最短编辑距离 【dp】    边界条件(如何初始化方便)<br><br>75 将数组分为0 1 2 【partition】 L:下一个放0的位置   R：下一个放2   有等号<br><br>76 【滑动窗口】求最小覆盖串<br><span class="hljs-code">	滑动窗口的套路</span><br><span class="hljs-code">	先找到一个可行解，再优化这个可行解。</span><br><span class="hljs-code">	优化到不能优化，产生出一个可能的最优解。</span><br><span class="hljs-code">	继续找新的可行解，再优化这个可行解。</span><br><span class="hljs-code"></span><br><span class="hljs-code">	直接用数组代替map映射需要的字母的数量，用额外count记下还需要匹配多少个，免去遍历过程</span><br><span class="hljs-code"></span><br>78  求无重复数组的子集   直接每层选出一个，下一层接着这个数选，有重复的话剪枝，排序后只拿第一个<br><br>79  普通回溯，记得找到后【提前结束】寻找，不然超时<br><br>84  柱状图中最大的矩形 暴力：以i为高度两边扩散；     【单调栈】<br><br>85  最大矩形 0和1的矩阵，求最大矩形面积 多个84题<br><br>96  n个节点二叉搜索数的个数    暴力超时，dp分解求解   卡特兰数<br><br>98 	验证二叉搜索树  中序遍历为上升序列，巧用pre保存前一个点   or  dfs<br><br>101 对称二叉树  dfs or bfs<br><br>102	二叉树层次遍历  需要知道层次，一次性处理一行<br><br>104 二叉树的最大深度 dfs<br><br>105	前序中序得到树		dfs<br><br>114 将树转为链表：右节点转为下一个节点  dfs    解法很巧妙，自己用的最朴素的返回链后头尾节点<br><br><span class="hljs-bullet">121.</span> 买卖股票的最佳时机 直接求<br><br><span class="hljs-bullet">124.</span> 二叉树中的最大路径和  注意dfs的返回值的含义！<br><br>128 最长连续序列  数组中的数值，连续的最长序列长度<br><span class="hljs-code">	1.暴力：计算以每一个数为开头的长度n  2.优化：只计算区间起点的长度 3.并查集  4.dp</span><br><span class="hljs-code"></span><br>136 只出现一次的数字  异或<br><br><span class="hljs-bullet">139.</span> 单词拆分  给wordDict 拼出s，可重复使用<br><span class="hljs-code">	1.暴力 超时  2.hash优化字符串比较+记忆化（存在重复 所以想到）  3.dp</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">142.</span> 环形链表 II  并返回入环点<br><br><span class="hljs-bullet">148.</span> 排序链表 1.归并排序 logn空间  2.O1不会<br><br><span class="hljs-bullet">152.</span> 乘积最大子数组 dp<br><br><span class="hljs-bullet">155.</span> 最小栈 栈，但能获取到最小值<br><br><span class="hljs-bullet">160.</span> 相交链表 求相交点 1.hash 2.求多出来的长度 3.相互连接起来<br><br><span class="hljs-bullet">169.</span> 多数元素 删除不同的两个数 还是多数元素<br><br><span class="hljs-bullet">198.</span> 打家劫舍<br><br><span class="hljs-bullet">200.</span> 岛屿数量 DFS||BFS<br><br><span class="hljs-bullet">206.</span> 反转链表<br><br><span class="hljs-bullet">207.</span> 课程表 图是否有环  拓扑图 ||  DFS搜索看是否回来<br><br><span class="hljs-bullet">208.</span> 实现 Trie (前缀树) <br><br><span class="hljs-bullet">215.</span> 数组中的第K个最大元素<br><br><span class="hljs-bullet">221.</span> 最大正方形  dp || 85. 直接用长方形来解答的，没用答案的正方形性质<br><br><span class="hljs-bullet">235.</span> 二叉搜索树的最近公共祖先  非搜索树236也可也解，递归，函数返回结果为是否包含p或q<br><br><span class="hljs-bullet">238.</span> 除自身以外数组的乘积  不用除法、On时间 On空间  前缀和<br><br><span class="hljs-bullet">240.</span> 搜索二维矩阵 II  在搜索矩阵中高效找一个数<br><br><span class="hljs-bullet">279.</span> 完全平方数  dp | 记忆化<br><br><span class="hljs-bullet">283.</span> 移动零<br><br><span class="hljs-bullet">287.</span> 寻找重复数 有一个数出现两次及以上  二分 | 位运算 | 快慢指针<br><br><span class="hljs-bullet">297.</span> 二叉树的序列化与反序列化 解析时删除元素<br><br><span class="hljs-bullet">300.</span> 最长递增子序列<br><br><span class="hljs-bullet">301.</span> 删除无效的括号  可能的方案？<br><br><span class="hljs-bullet">309.</span> 买卖股票的最佳时机含冷冻期  dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">3</span>]<br><br>312<span class="hljs-emphasis">*. 戳气球 区间dp 以区间最后一个气球为准</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">322. 零钱兑换  dp  见分类刷题-dp</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">337. 打家劫舍 III  树上 记忆化搜索  可以不要考虑两种情直接求</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">338. 比特位计数 dp</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">347. 前 K 个高频元素 堆</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">394. 字符串解码 递归</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">399. 除法求值 构建为图  List<span class="language-xml">&lt;List&lt;Pair&lt;Integer, Double&gt;</span>&gt;&gt; edges  最外层是点，存List<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Pair</span>&gt;</span></span>代表点的每条出边</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">406. 根据身高重建队列 贪心排序 + 暴力找位置 or  树状数组+二分 （想知道1~x区间和，同时也会增加1，二分找区间和&gt;=k+1的地方  logn *</span> logn）<br><br><span class="hljs-bullet">416.</span> 分割等和子集 选择一些数和等于sum/2 dp 注意顺序，数组在内部循环会导致错误（元素重复使用）  零钱兑换是需要重复使用<br><br><span class="hljs-bullet">437.</span> 路径总和 III 暴力  || 前缀和+hash<br><br><span class="hljs-bullet">438.</span> 找到字符串中所有字母异位词 双指针<br><br><span class="hljs-bullet">448.</span> 找到所有数组中消失的数字  交换到应该的位置 |  +n标记<br><br><span class="hljs-bullet">494.</span> 目标和 添加正负号和为target  dfs -&gt; 记忆化 -&gt; dp  || 转为数组中选取元素，之和等于 target 416.<br><br><span class="hljs-bullet">538.</span> 把二叉搜索树转换为累加树 反中序遍历<br><br><span class="hljs-bullet">543.</span> 二叉树的直径  二叉树任意两个点的最大距离 dfs  定义好dfs的返回值的意义！ 同 二叉树中的最大路径和<br><br><span class="hljs-bullet">560.</span> 和为 K 的子数组 数量  暴力 | 前缀和 + hash（不关心具体下标，只关心等于 k 的前缀和之差出现的次数c）  遍历右维护左<br><br><span class="hljs-bullet">581.</span> 最短无序连续子数组 将数组部分排序后有序 nlogn排序-二分  找规律技巧<br><br><span class="hljs-bullet">617.</span> 合并二叉树 dfs<br><br><span class="hljs-bullet">621.</span> 任务调度器 模拟题<br><br><span class="hljs-bullet">647.</span> 回文子串 中心点暴力<br><br>739 每日温度 下一个更大的温度 单调栈<br></code></pre></td></tr></table></figure>



<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-number">24</span> 两两交换链表节点  		递归<br><span class="hljs-number">26</span> 删除有序<span class="hljs-built_in">vector</span>重复项     双指针	<br><br><span class="hljs-number">172</span> 阶层中零的个数<br><span class="hljs-number">202</span> 将一个数每一位求平方和，判断最后是否收敛到<span class="hljs-number">1</span>  <span class="hljs-number">19</span>-&gt;<span class="hljs-number">82</span>-&gt;<span class="hljs-number">68</span>-&gt;<span class="hljs-number">100</span>-&gt;<span class="hljs-number">1</span>  <br>	判断是否存在循环：快慢指针、hash<br>o<br></code></pre></td></tr></table></figure>



<p>卡特兰数：n对括号正确匹配数目 (22)，n个节点二叉搜索树(96)，出栈次序，矩阵相乘<br>C0 &#x3D; 0   Cn+1 &#x3D; 2(2n+1) &#x2F; (n+2) * Cn</p>
<p>$$<br>C0 &#x3D; 0      ~~~~~~~~~<br>Cn+1&#x3D;<br>\frac{2(2n+1)}{n+2}Cn<br>$$</p>
<h2 id="分类刷题"><a href="#分类刷题" class="headerlink" title="分类刷题"></a>分类刷题</h2><p><a target="_blank" rel="noopener" href="https://github.com/doocs/leetcode">doocs&#x2F;leetcode: 😏 LeetCode solutions</a></p>
<h3 id="0-找规律"><a href="#0-找规律" class="headerlink" title="0.找规律"></a>0.找规律</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>   每一个i可以的最大高度</li>
<li>438 异位词比较 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>    滑动窗口；字符比较：排序hash、计数后拼接hash、26个桶比较</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组的个数</a>  hash+前缀和</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a>  数组向后移动k位  最大公约数 | 反转数组</li>
<li></li>
</ul>
<h3 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1. 基础算法"></a>1. 基础算法</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">在排序数组中查找元素的第一个和最后一个位置 - 二分查找<br>准时到达的列车最小时速 - 二分查找  		对速度进行二分<br>找到需要补充粉笔的学生编号 - 二分查找<br>可移除字符的最大数目 - 二分查找<br><br>排序数组 - 快速排序、归并排序<br><br>字符串相加 - 高精度加法<br>字符串相乘 - 高精度乘法<br><br>区域和检索 - 数组不可变 - 前缀和<br>二维区域和检索 - 矩阵不可变 - 二维前缀和<br>区间加法 - 前缀和、差分<br>用邮票贴满网格图 - 二维前缀和、二维差分<br><br><br>位<span class="hljs-number"> 1 </span>的个数 - 位运算、lowbit<br>合并区间 - 区间合并<br></code></pre></td></tr></table></figure>



<h4 id="枚举右，维护左"><a href="#枚举右，维护左" class="headerlink" title="枚举右，维护左"></a>枚举右，维护左</h4><p>哈希表维护左边全部<strong>（找等值关系）</strong>, 或者单变量维护最值(买卖股票1)  （<strong>找最值关系</strong>）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">2874. 有序三元组中的最大值 II - 力扣（LeetCode）</a>  max ((nums[i] - nums[j]) * nums[k])，  枚举j或者k</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-nice-pairs-in-an-array/">1814. 统计一个数组中好对子的数目</a></li>
</ul>
<p>前缀和+维护左</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/submissions/">437. 路径总和 III - 力扣（LeetCode）</a>   + 回溯</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-good-subarray-sum/">3026. 最大好子数组和 - 力扣（LeetCode）</a> 子数组满足|nums[l] - nums[r]| &#x3D;&#x3D; k，给出sum子数组最大值</li>
</ul>
<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SqopEo/">分享丨【题单】二分算法（二分答案&#x2F;最小化最大值&#x2F;最大化最小值&#x2F;第K小） - 力扣（LeetCode）</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/">3296. 移山所需的最少秒数 - 力扣（LeetCode）</a> 双二分、堆</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-removable-characters/">1898. 可移除字符的最大数目</a></li>
</ul>
<h3 id="2-数据结构-1"><a href="#2-数据结构-1" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">设计链表 <span class="hljs-operator">-</span> 单链表、指针引用、数组实现<br>下一个更大元素 <span class="hljs-built_in">I</span> <span class="hljs-operator">-</span> 单调栈<br>每日温度 <span class="hljs-operator">-</span> 单调栈<br>子数组的最小值之和 <span class="hljs-operator">-</span> 单调栈<br>最大宽度坡 <span class="hljs-operator">-</span> 单调栈<br>最多能完成排序的块 <span class="hljs-variable">II</span> <span class="hljs-operator">-</span> 单调栈   ×<br>子数组范围和 <span class="hljs-operator">-</span> 单调栈<br>子数组最小乘积的最大值 <span class="hljs-operator">-</span> 单调栈<br>滑动窗口最大值 <span class="hljs-operator">-</span> 单调队列<br>满足不等式的最大值 <span class="hljs-operator">-</span> 单调队列 ×<br>和至少为 <span class="hljs-built_in">K</span> 的最短子数组 <span class="hljs-operator">-</span> 单调队列   尝试单调栈<span class="hljs-operator">-&gt;</span>无单调性？  前缀和<span class="hljs-operator">+</span>单调队列<br>带限制的子序列和 <span class="hljs-operator">-</span> 动态规划、单调队列优化<br>单词规律 <span class="hljs-variable">II</span> <span class="hljs-operator">-</span> 哈希表、回溯 ×<br>最短回文串 <span class="hljs-operator">-</span> 字符串哈希<br>回文对 <span class="hljs-operator">-</span> 字符串哈希<br>最长重复子串 <span class="hljs-operator">-</span> 字符串哈希、二分查找<br>不同的循环子字符串 <span class="hljs-operator">-</span> 字符串哈希<br></code></pre></td></tr></table></figure>



<h4 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h4><p>查找满足某要求的字串、子序列；<strong>解题时看到字串子序列：先考虑所有以i结尾的串，在考虑j的单调</strong></p>
<p>（此外还有一种二分的解法 nlogn：每一个right结尾时，二分寻找left的最优）</p>
<p><strong>基本思想</strong>：随着 i的增大，满足 某表达式 的j 值是单调的。</p>
<p>​        1.我遍历了全部以i结尾的串。确保不遗漏<br>​        2.暴力：j需要for一次 -&gt; 如果以i结尾的<code>j~i</code>窗口是一个可行解，i往后移，<strong>j不能回头</strong>。该单调性可以优化掉O(n^2^)</p>
<p><strong>步骤</strong></p>
<ol>
<li>左右指针ji控制窗口，遍历右指针i向右边移动，以获取所有的答案（理解为以i结尾的所有串）</li>
<li>目前ji是可行解</li>
<li>当前窗口<code>i++</code>，不是可行解或最优解（窗口大小,字符数量）</li>
<li><code>j++</code>，直到可行</li>
<li>更新res</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 朴素 N^2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (check(i, j)) &#123;<br>            <span class="hljs-comment">// 具体问题的逻辑 res = max(res, j-i+1)</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双指针 N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑 res = max(res, j-i+1)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="基础："><a href="#基础：" class="headerlink" title="基础："></a><strong>基础：</strong></h5><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小且sum大于k的子数组</a>：<code>j~i</code>以i结尾长度最小且大于k，<code>j ~ i+1</code> 一定大于但可能不是最短； 除了双指针还可以二分j</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-product-less-than-k/">乘积小于 K 的子数组</a>：有多少个子串乘积后严格小于k。<code>j~i &lt; k</code>，<code>j ~ i+1</code>不一定&lt;k, 但j一定要往后走<ol>
<li>拓展：字串加减乘除(不能有负数:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">反例</a>) 满足 大于小于某个值:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小且sum大于k的子数组</a></li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/">3097. 或值至少为 K 的最短子数组 II</a> 将求和改成了或，需要记录每一位上的数量</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>：<code>j~i</code>以i结尾无重复且最长，<code>j ~ i+1</code>  不一定无重复，但j一定是往后移动缩小窗口，使得无重复<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/description/">长度为 K 的无重复字符子串</a> 的个数 多一个长度缩小</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>：s2是否存在的某个子串刚好包含s1全部字符  ；新加进来的不能多+直接长度判断是否满足</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a> 同上，需要找出所有的  </li>
<li>**<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>**：s中字串能包含t全部字符，且最小（可以多，所以不能用长度判断 要多一个need记录）。<code>j~i</code>覆盖且最小，<code>j ~ i+1</code>  覆盖但不一定最小，但j一定是往后移动缩小窗口，使得更小；用一个变量记录下一共要多少个字符、一个hash记录每个字符需要多少（也可也直接用长为26字母遍历check）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">统计定界子数组的数目</a> 满足最大为min 最小为max的子数组的数量<ol>
<li>维护两个指针，i是以i结尾的子数组。</li>
<li>当i不越界时，数量关系取决于最后一个min 和 max的下标</li>
<li>当i越界时，两指针都跳到i+1</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/">最大连续1的个数 III</a>：最多存在k个0，求数组连续1的个数</li>
</ol>
<h5 id="相向："><a href="#相向：" class="headerlink" title="相向："></a><strong>相向：</strong></h5><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>  三数和为0，并且去重 ； 排序去重 然后双指针（有序）找值，当然也可也hash维护找（空间消耗）</li>
<li><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a>两个升序数组，求和为x的两个数组的下标<ul>
<li>一个i指针一直往大了走，说明窗口是变大的，那么j的移动方向就是使得窗口值变小</li>
<li>因此推断<code>i=0  -&gt; n</code> ;  <code>j=m-1 -&gt; 0</code>  <ul>
<li>if  <code>v(i,j)&gt;x</code>，j一直移动变小，直到满足&lt;&#x3D;x       （<code>v(i,j)&gt;x</code>，那么<code>v(i+1,j)&gt;x</code>，不会遗漏）</li>
<li>如果ij小于x，x变大，并且j</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器 - 力扣（LeetCode）</a></li>
</ol>
<h5 id="恰好型"><a href="#恰好型" class="headerlink" title="恰好型"></a>恰好型</h5><p>恰好为k，拆分成&gt;&#x3D;k 以及 &gt;&#x3D;k+1</p>
<h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><ul>
<li><p>想知道每个元素前后第一个比它大(或小)的元素；  当新来元素很大时，前面比他小的都找到下一个更大了 于是出栈，所以栈中是一个递减的序列</p>
</li>
<li><p><code>pre ~ i ~ next</code>时(两边只包含一个) i 都是最大，就可以知道所有子数组中，i 当了<code>(k-i)(i-j)</code>次老大</p>
</li>
<li><p>经常要求所有子数组的个数或者子数组求和，需要注意越界问题</p>
</li>
</ul>
<p>求下一个更大：暴力：每个元素都可能要遍历后面的所有；优化：维护一个栈，当目前元素比栈顶更大时，栈顶就找到了下一个更大。一直pop，最后栈顶是i的前一个更大</p>
<p>模板1：当前元素必须进栈，进栈后影响栈内元素  可以见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-subarray-ranges/">https://leetcode.cn/problems/sum-of-subarray-ranges/</a><br>这里pre next 一个是严格一个不是，可以保证子数组不重不漏！ <strong>如果都想要严格或者非严格就再求一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt;= nums[i]) &#123;<br>        nextBig[stack.top()] = i; <span class="hljs-comment">// 栈顶的下一个非严格大是i，出栈时记录   下面是严格大，去掉等号要反过来</span><br>        stack.pop();<br>    &#125;<br>    preBig[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();  <span class="hljs-comment">// 当前i的前一个严格大是栈顶</span><br>    stack.push(i);<br>&#125;<br><span class="hljs-comment">// 不能忘了最后栈内的</span><br><span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>    nextBig[stack.pop()] = n;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模板2：当前元素可能不进栈，进栈后会影响后面未进栈的。左边小的可以让后面大的都不进栈，相当于从右到左模板1的弹出过程,用的比较少，看题目具体情况（最大宽度坡）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (stack.isEmpty() || nums[stack.peek() &gt; nums[i]]) &#123;<br>    	stack.push(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>模板1从左到右和从右到左得到结果不一样</li>
<li>从左到右模板2的结果和从右到左模板1并反序，栈内元素会一样</li>
</ul>
<p>例题：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></p>
</li>
<li><p>求所有子数组中最小值，并求和  907</p>
<p>​	<strong>方法一</strong>:  dp[i] 以i结尾的所有子数组，最小和：<code>a[i]</code>能影响到上一个比a[i]小数a[j] <strong>单调栈</strong>，dp[i] &#x3D; dp[j] + (i-j)*a[i]  如果这一步不dp记录下来，就会导致超时</p>
<p>​	<strong>方法二</strong>：每个元素 <code>nums[i]</code> 作为最小值出现在了多少个子数组中：pre j、next k <code>(k-i)(i-j)</code>。<strong>单调栈！</strong></p>
<p>​	<strong>方法三</strong>：排序后，从最小数的下标开始  <code>Arrays.sort(B, (i, j) -&gt; ((Integer) A[i]).compareTo(A[j]));</code></p>
</li>
<li><p>最大宽度坡  满足 <code>A[i] &lt;= A[j]</code> 的最大 <code>j - i</code> 值</p>
<p>​	需要从左往右建立一个特殊的栈，小的元素会导致后面大的元素直接不进栈，建立后从右往左找规律求结果</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">最多能完成排序的块 II</a> 排序子数组使得整体有序</p>
<p>​	1、找规律 max nums[0:i-1] &lt; min nums[i:n-1]   和单调栈无关</p>
<p>​	2、和排序的对比字符数</p>
<p>​	3、单调栈</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-subarray-ranges/">子数组范围和</a>  </p>
<p>​	求全部子数组(max-min)，并求和，同2，但多一个最pre nextMax。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray-min-product/">子数组最小乘积的最大值</a></p>
<p>​	求全部子数组中，<code>min(a) * sum(a)</code>最大的。mina 还是用单调栈，注意这里是越宽越好，所以pre next都用非严格的两次去求(单次同时求出非严格需要跳跃 <a target="_blank" rel="noopener" href="https://leetcode.cn/submissions/detail/427726444/">代码</a>)。（其实一个非严格一个严格也可以，因为第一个元素的nextBig会包裹相同元素，1111相当于以第一个1为代表）。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a>  模板</p>
</li>
</ol>
<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>​	为什么要引入队列？有的题目前后都要弹出！！元素满足单调性</p>
<p>理解：通过单调性来移出不优的元素，例如在“和至少为 K 的最短子数组”，对于每个点作为左节点<code>j</code>，如果来了一个新值<code>j‘</code>，并且更小，那么左边的旧值<code>j</code>就永远不需要看了；作为左节点<code>j</code>如果<code>j~i</code>满足条件，那么右边的<code>j~i&#39;</code>就不用再看了</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/[">可以获取最值的队列</a>  可以在队尾插入，队头取出；并且O1最大值</p>
<ol>
<li>维护全局一个最大值，但该元素出队列后找不到下一个最大值  ×</li>
<li>维护有效最大值列表，使得最大出列后还能找到第二大：<ol>
<li>有效的特点：当队尾来了一个很大的数，最大值列表中的小值都可以被忽略了，所以是一个递减的</li>
<li>队头也可也删除元素，当普通队列的元素和最大值队列队头相同时，最大值队列需要出队</li>
</ol>
</li>
<li>类似题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">可以获取最小值的栈</a>  同样是维护一个最小值列表</li>
</ol>
<p>[滑动窗口最大值](<a target="_blank" rel="noopener" href="https://github.com/doocs/leetcode/blob/main/solution/0200-0299/0239.Sliding">https://github.com/doocs/leetcode/blob/main/solution/0200-0299/0239.Sliding</a> Window Maximum&#x2F;README.md)</p>
<p>​	求滑动窗口的最大值，当新来元素很大时，前面比他小的都可以忽略了，所以窗口中是一个递减的序列，最大值就在peekLast  （此外还可以维护一个优先队列（堆） <code>O(logn)</code>取出最值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队尾超出窗口大小 pop</span><br><span class="hljs-keyword">while</span>(deque.peekLast().index&lt;i-k+<span class="hljs-number">1</span>)&#123;<br>    deque.pollLast();<br>&#125;<br><br><span class="hljs-comment">// 队头出pop， 并且新元素入队</span><br><span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst().value&lt;nums[i])&#123;<br>    deque.pollFirst();<br>&#125;<br>deque.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(nums[i], i));<br><span class="hljs-comment">// 根据队列最大值计算相关值</span><br>res[i] = deque.peekLast().value;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a> ：如果全是正数，那么用双指针可以把空间复杂度也降低到O1</p>
<ol>
<li><p>使用<code>前缀和的差</code>来计算子数组的和；</p>
</li>
<li><p>使用一种数据结构，将<code>当前前缀和i</code>与<code>最前面的前缀和j</code>作差，如果满足&gt;&#x3D;k的条件，那么<code>j</code>在之后就可以不用看了。【因为即使后面也有满足条件的，长度也会更长，所以需要将j从前面弹出】；</p>
</li>
<li><p>第2步完成了之后，当前的i也要放入数据结构，那么如果数据结构中有<code>前缀和j</code>比<code>前缀和i</code>大，j也可以不用看了。【因为即使后面有满足条件的，与i作差肯定也满足条件，并且长度更短，所以需要将大于等于i的从后面弹出】。</p>
<p>​	前面后面都要弹出，压入的元素满足单调性，所以使用单调队列。</p>
<p>数组存在负数，所以不能用二分查找i结尾的起点在哪。</p>
<p>第二次做：其实是找满足条件的<code>j~i</code>，不能暴力遍历就找规律：对于左起点j以及右终点i，如果<code>j~i</code>当前满足了，那j不需要再去找后面的i了；i以后作为左起点 对于左起点，如果当前比左边的数小，那么左边的数都不可能再作为左起点了</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/constrained-subsequence-sum/">带限制的子序列和</a>  求<code>max ( sum[子序列] )</code> ， 且子序列中的最大下标间隔不能超过k</p>
<ol>
<li><code>dp[i]</code> 代表以i结尾的子序列的最大和，保证不遗漏</li>
<li><code>dp[i] = max(dp [i-k] ~ dp[i-1])</code>  如果遍历k的话，超时；分析目前是想得到前k个元素的最大值</li>
<li>维护一个窗口大小为k的单调队列！</li>
</ol>
<h4 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h4><ul>
<li><p>单点更新，区间查询</p>
</li>
<li><p>值不断变化，<strong>动态数组查找小于（大于）x的和 或 个数</strong></p>
<ul>
<li>或者是给出要查找第x大的数，给出这个数字；多一个二分查找过程 2653</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/">3072. 将元素分配到两个数组中 II - 力扣（LeetCode）</a></p>
</li>
<li><p>严格单调递减的子序列右多少个； 树状数组+离散化； 求所有小于当前数x的i  dp[i]的和</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-subarray-beauty/description/">2653. 滑动子数组的美丽值 - 力扣（LeetCode）</a>     动态数组查找第x大的数字，二分  ；数据范围小这题可以直接计数</p>
</li>
</ul>
<h3 id="3-搜索"><a href="#3-搜索" class="headerlink" title="3.搜索"></a>3.搜索</h3><p>BFS：有很多结果，需要最优的，所以需要BFS同时尝试所有的，并且最先遇到的就是最优解<br>DFS：存在问题，只需要一个；把一种可能的情况尝试到底</p>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>BFS</strong>：状态转换 + <strong>最短路&#x2F;最小步数&#x2F;最小操作</strong>；空间范围有限</p>
<ul>
<li>有一个全局的visit代表是否访问过，<strong>用来保证不走回头路</strong>，可以用距离(使用距离的话，入队的点就不用额外保存距离)</li>
<li><strong>入队时</strong>标记而不是出队时标记，防止同一个节点入队两次</li>
<li>尽量只将有意义的节点入队，同时入队时判断结束条件最好：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">grid[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 入队时标记</span><br>deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;n-<span class="hljs-number">1</span>, m-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>    <span class="hljs-type">int</span>[] tmp = deque.pollFirst();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> tmp[<span class="hljs-number">0</span>], y = tmp[<span class="hljs-number">1</span>], dis = tmp[<span class="hljs-number">2</span>];<br>    <br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> dis; <span class="hljs-comment">// 出队时判断全集最优 结束搜索</span><br><br>    <span class="hljs-type">int</span> []dx = &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> []dy = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">xx</span> <span class="hljs-operator">=</span> x + dx[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yy</span> <span class="hljs-operator">=</span> y + dy[i];<br>        <span class="hljs-keyword">if</span>(xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&lt;m&amp;&amp;grid[xx][yy]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 入队的条件</span><br>            grid[xx][yy] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 入队标记</span><br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;xx, yy, dis+<span class="hljs-number">1</span>&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br>https:<span class="hljs-comment">//leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/submissions/505710677/</span><br></code></pre></td></tr></table></figure>

<p>优化：<strong>双向DFS</strong>，可以节约百倍空间复杂度[模板](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/submissions/505775766/">1091. 二进制矩阵中的最短路径 - 力扣（LeetCode）</a>) <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/open-the-lock/submissions/505756847/">模板code</a>  </p>
<p>1+2+4+8+16+32+64+128+256+512  -&gt;    1+2+4+8+16  + (相遇)  16+8+4+2+1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">queue1、queue2 为两个方向的队列<br>dis1、dis2 为两个方向的距离数组，记录每个节点距离起点的<br><br>更新时优先更新小的，并且一次更新一层<br>二者相遇时即为结果<br><br>    <span class="hljs-keyword">while</span>(!deque1.isEmpty() &amp;&amp; !deque2.isEmpty())&#123;<br>        <span class="hljs-type">int</span> res=-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 优先扩展size小的 缩小搜索空间</span><br>        <span class="hljs-keyword">if</span>(deque1.size()&lt;deque2.size())&#123;<br>            res = update(deque1, dis1, dis2);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res = update(deque2, dis2, dis1);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(res!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span>-<span class="hljs-number">1</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Deque&lt;Integer&gt; deque, <span class="hljs-type">int</span> []dis, <span class="hljs-type">int</span> []other)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> deque.size();<br>        <span class="hljs-keyword">while</span>(num-- != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> deque.pollFirst();<br><br>            <span class="hljs-comment">// 相遇为终结</span><br>            <span class="hljs-keyword">if</span>(other[x] != -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> dis[x] + other[x];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-comment">// 具体业务</span><br>                <span class="hljs-keyword">if</span>(...&amp;&amp;dis[now]==-<span class="hljs-number">1</span>)&#123;<br>                	deque.addLast(now);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">图像渲染- <span class="hljs-keyword">BFS、DFS、Flood </span>Fill 算法、连通性模型<br>岛屿数量 - <span class="hljs-keyword">BFS、DFS、Flood </span>Fill 算法<br><span class="hljs-number">01</span> 矩阵 - 多源 <span class="hljs-keyword">BFS </span>   					 注意只能多源<span class="hljs-keyword">BFS！！DFS实现失败 </span>  还可以dp，但没看<br>地图中的最高点 - 多源 <span class="hljs-keyword">BFS </span>和上面一模一样<br>进击的骑士 - <span class="hljs-keyword">BFS、最短路模型 </span>  			暴力或者双向<span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span>二进制矩阵中的最短路径 - <span class="hljs-keyword">BFS、最短路模型 </span>    模板  如果入队没有标记而是出队标记 会超时<br>迷宫中离入口最近的出口 - <span class="hljs-keyword">BFS、最短路模型 </span>    模板<br><br>网格中的最短路径 - <span class="hljs-keyword">BFS、最短路模型 </span>          从左上到右下最短路，可以删除k个障碍；这里即便访问过，后来的也可也访问：入队额外记录剩余删除个数，如果比全局的更多（后来的距离一定更大，想要继续走就必须要剩余更多删除），就可以入队<br><br>打开转盘锁 - 最小步数模型、双向 <span class="hljs-keyword">BFS、A* </span>IDA*  四位旋转到目标数  看上去题目复杂，但搜索空间只有<span class="hljs-number">1</span>e5 直接暴力 dfs第一次遇到的是最优的，set去重。  双向<span class="hljs-keyword">BFS优化模板</span><br><span class="hljs-keyword"></span><br>单词接龙 - 最小步数模型、双向 <span class="hljs-keyword">BFS </span>  同上 仔细分析搜索空间其实不是特别大  最多也就<span class="hljs-number">5</span>k个词<br>转化数字的最小运算数 - 最小步数模型、双向 <span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span>滑动谜题 - <span class="hljs-keyword">BFS、最小步数模型、A* </span>算法<br>访问所有节点的最短路径 - <span class="hljs-keyword">BFS、最小步数模型、A* </span>算法<br>为高尔夫比赛砍树 - <span class="hljs-keyword">BFS、A* </span>算法<br>使网格图至少有一条有效路径的最小代价 - 双端队列 <span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span>到达角落需要移除障碍物的最小数目 - 双端队列 <span class="hljs-keyword">BFS</span><br><span class="hljs-keyword"></span><br></code></pre></td></tr></table></figure>



<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a><strong>DFS</strong></h4><ul>
<li><p>存在问题，剪枝：搜索到了就直接<code>return true</code>   <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">单词搜索</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/matchsticks-to-square/">火柴拼正方形</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">划分为k个相等的子集</a></p>
</li>
<li><p>最优问题，剪枝：</p>
<ul>
<li><p>最大值：遍历全部 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-gold/"> 黄金矿工</a></p>
</li>
<li><p>最小值：维护一个全局最小，当前值大于就剪枝 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fair-distribution-of-cookies/">公平分发饼干</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">完成所有工作的最短时间</a></p>
<p>  全排列问题需要记录数字是否使用  used<br>  组合问题需要按照搜索顺序  使用begin  如果可重复begin下次还是i 不可重复i+1；<br>  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mG4y1A7Gu">https://www.bilibili.com/video/BV1mG4y1A7Gu</a><br>  枚举选哪个<br>  当前选或不选<br>      组合问题两种写法 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/submissions/566429278/">https://leetcode.cn/problems/combinations/submissions/566429278/</a><br>  划分为 k 个相等的子集 从组成边角度，每一条边是组合问题begin标记，边与边之间需要用used标记</p>
</li>
<li><p>分配时，如果效果一样的化可以剪枝</p>
</li>
</ul>
</li>
</ul>
<p>​		进入时修改状态，回溯后改回状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当前状态保存在传参中 now 和 idx</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []matchsticks, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> now, <span class="hljs-type">int</span> start)</span>&#123;<br>	<span class="hljs-comment">// 结束条件</span><br>    <span class="hljs-keyword">if</span>(idx == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(now == target) <span class="hljs-keyword">return</span> dfs(matchsticks, target, idx+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;matchsticks.length;i++)&#123;<br>        <span class="hljs-comment">// 遍历选择列表 过滤不满足的</span><br>        <span class="hljs-keyword">if</span>(i&gt;start &amp;&amp; matchsticks[i] == matchsticks[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(matchsticks[i]==-<span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(matchsticks[i] + now &gt; target) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 修改选择状态 并加入下一次</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> matchsticks[i];<br>        matchsticks[i] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 存在类问题提前返回，如果是最优问题需要用最优值剪枝</span><br>        <span class="hljs-keyword">if</span> (dfs(matchsticks, target, idx, now + t, i+<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        matchsticks[i] = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>记忆化搜索</strong>： 自顶向下，并记录。可以改写dp</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">迷宫 - DFS、连通性模型、Flood Fill 算法<br>单词搜索 - DFS、搜索顺序、回溯<br>黄金矿工 - DFS、搜索顺序、回溯<br>火柴拼正方形 - DFS、回溯、剪枝 n=<span class="hljs-number">15</span>          数组组合成一个正方形，暴力遍历 <br>	<span class="hljs-number">1.</span>从组成边的角度出发：(<span class="hljs-number">2</span>^n)^k used标记 在组成某一条边时，是组合问题而不是排列！所以需要起始idx<br>	<span class="hljs-number">2.</span>从使用每一个数字出发： 每个数字可以放<span class="hljs-number">4</span>个位置 <span class="hljs-number">4</span>^n 剪枝：优先遍历大的数字，这样遍历空间更小 edge一样剪纸<br>	<span class="hljs-number">3.</span>状态压缩 + 动态规划<br>	<br>划分为 k 个相等的子集 - DFS、回溯、剪枝  k&lt;=<span class="hljs-number">16</span>    同上, 数组从划分<span class="hljs-number">4</span>个子数组改为k个<br>	<span class="hljs-number">1.</span>从组成子集角度 n!   对于每一个子集，是组合问题，需要使用<span class="hljs-keyword">begin</span>控制搜索<br>	<span class="hljs-number">2.</span>从使用每一个数字：k^n   超时！  加上edge[i+<span class="hljs-number">1</span>] == edge[i]优化可以过<br><br>公平分发饼干 - DFS、回溯、剪枝  n=k=<span class="hljs-number">8</span>   数组划分为k个，求划分使得最小化：max(sum(子数组)) 同下<br>	<span class="hljs-number">1.</span>无法从组成子集角度 <br>	<span class="hljs-number">2.</span>分配每一个数字即可, n=<span class="hljs-number">8</span>不需要剪枝<br><br>完成所有工作的最短时间 - DFS、回溯、剪枝  n=k=<span class="hljs-number">12</span>   数组划分为k个，求划分使得最小化：max(sum(子数组))<br>	<span class="hljs-number">1.</span>从分配每一个任务角度：k^n   超时！   剪枝：维护一个全局最优  降序排列<br>		剪枝：默认dfs第一次会把任务全给<span class="hljs-number">0</span>号工人，其实是最差情况，我们希望分配平均一点<br>			 优化<span class="hljs-number">1</span>：先用优先队列贪心求取出一个res，缩小dfs范围<br>			 优化<span class="hljs-number">2</span>：edge[i+<span class="hljs-number">1</span>] == edge[i]时 二者等价  直接跳过<br>			 优化<span class="hljs-number">3.</span> 优先分配给未分配的工人（和<span class="hljs-number">2</span>一样）; 因为未分配都一样，所以就分配给未分配的第一个人<br>		     			可以快速获得一个全局最优，并且去重。原来第一个任务分配给所有人，现在只给<span class="hljs-number">1</span><br>			 优化<span class="hljs-number">4.</span> 对分配排序，每次取出最小的：问题<span class="hljs-number">1</span> 直接排序下一层影响这一层，使用idx<br>								           问题<span class="hljs-number">2</span> 每次都排序复杂度太高了，排序行不通<br>		     <br>	<span class="hljs-number">2.</span> 状态压缩 dp<br>	<span class="hljs-number">3.</span> 二分+转为存在问题<br>	<br>组合总和 组合出target  可重复使用，不考虑顺序   记录下list&lt;&gt;now 进入时<span class="hljs-keyword">add</span> 回溯时remove<br>	全排列问题需要记录数字是否使用  used<br>	组合问题需要按照搜索顺序  使用<span class="hljs-keyword">begin</span>  如果可重复<span class="hljs-keyword">begin</span>下次还是i 不可重复i+<span class="hljs-number">1</span><br>	<br>	[<span class="hljs-number">40.</span> 组合总和 II] 需要去重  <span class="hljs-keyword">set</span>直接去重超时  改成排序后一次处理同一种数<br><br><br>	<br>	划分为k个相等的子集 问题的组成每个子集角度，整体需要used标记，单个子集是组合问题需要<span class="hljs-keyword">begin</span>标记<br><br>矩阵中的最长递增路径 - DFS、记忆化搜索      模板<br>网格图中递增路径的数目 - DFS、记忆化搜索    模板  上面是最大长度，这里是求和<br>翻转游戏 II - DFS、状态压缩、记忆化搜索 你和朋友轮流将 连续 的两个 &quot;++&quot; 反转成 &quot;--&quot; 是否存在必胜<br>	代码特别优雅，使用位运算实现字符串的改变<br>	String nextState = state.substring(<span class="hljs-number">0</span>, i) + &quot;--&quot; + state.substring(i + <span class="hljs-number">2</span>);<br>	<br>    // 优化<br>    <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) == <span class="hljs-number">0</span> || (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>))) == <span class="hljs-number">0</span>) &#123;<br>    	<span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dfs(mask ^ (<span class="hljs-number">1</span> &lt;&lt; i) ^ (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>)))) &#123;<br>    	<span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <br>    <br>统计所有可行路径 - DFS、记忆化搜索    <br>	模板，记录从 dp[i][fuel]  从 i并且有fuel燃料 到finish 有多少解法 sum dfs(j, fuel-<span class="hljs-keyword">cost</span>(i-&gt;j))<br>	需要注意边界条件，如果i==finish，那么ans += <span class="hljs-number">1</span> 当前立即结束代表一种解法<br>	<br>	改写成dp！！！  fuel 有大小关系所以在外层，注意dp的初始化<br>	<br>切披萨的方案数 - DFS、记忆化搜索+二维前缀和<br></code></pre></td></tr></table></figure>



<h3 id="4-DP"><a href="#4-DP" class="headerlink" title="4.DP"></a>4.DP</h3><p>dp有两种</p>
<ul>
<li>一种是当前状态由哪些状态转移来的(一般idx从n开始,方便改写dp，以及前缀和优化转移过程 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/submissions/568578185/">3251. 单调数组对的数目 </a>)</li>
<li>一种是当前状态可以转移出哪些状态 （买卖股票、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/submissions/568472363/">3251. 单调数组对的数目 II - 力扣（LeetCode）</a>，一般idx从0开始）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tXLS3i/">分享丨【题单】动态规划（入门&#x2F;背包&#x2F;状态机&#x2F;划分&#x2F;区间&#x2F;状压&#x2F;数位&#x2F;树形&#x2F;数据结构优化） - 力扣（LeetCode）</a></p>
<ol>
<li><p>01背包</p>
<ul>
<li><p>dp：</p>
<ul>
<li>从使用每一个物品出发 0或1个  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">目标和</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">将一个数字表示成幂的和的方案数</a> </li>
<li>保证从小的转移过来时， 二维循环可以交换</li>
</ul>
</li>
<li><p>记忆化：当前物品有选和不选两种情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dfs(now+nums[idx], idx+<span class="hljs-number">1</span>);<br>dfs(now, idx+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>完全背包</p>
<ul>
<li><p>dp：</p>
<ul>
<li>从使用每一个物品出发，x个	<code>dp[i][j] = 最优 dp[i-1][j-x * [w]]</code>  -&gt; 优化为当前层取值   -&gt;  优化为1维</li>
<li>从组成的数出发，可重复使用的物品循环在内。 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a>  ； <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a> dp只有一维（不考虑顺序可从完全背包出发， 但组合总数考虑了所有不可以）</li>
</ul>
</li>
<li><p>记忆化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">从使用每一个物品出发  选了但idx不变<br>dfs(idx-<span class="hljs-number">1</span>, target);<br>dfs(idx, target-coins[idx]);<br><br><br>从组成的数出发<br><span class="hljs-keyword">for</span> i in n:<br>	dfs(target-nums[i]);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>找到所有可能的解决方案一般要dfs <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs inform7">杨辉三角 - 线性 DP、数字三角形模型<br>最小路径和 - 线性 DP、数字三角形模型<br><br>摘樱桃 - 线性 DP、数字三角形模型  ×<br><br>摘樱桃 II - 线性 DP、数字三角形模型<br><br>最长递增子序列 - 线性 DP、最长上升子序列模型<br>	暴力：查找前面所有的<br>	优化：如果当前长度为5，并且结尾字符比以前的长度为5的结尾字符小，那么以前的就被忽略了，有点像单调栈<br>			所以每一个长度只需要保存一个结尾字符最小的就行了。<br>			长度越长结尾字符肯定越大，用二分查找哪一个长度的字符刚好比现在小<br><br>无重叠区间 - 线性 DP、最长上升子序列模型、贪心优化<br>	dp：以当前区间结尾的 无重复区间数，和上面一样可以用二分优化<br><br>删列造序 III - 线性 DP、最长上升子序列模型<br><br>俄罗斯套娃信封问题 - 线性 DP、最长上升子序列模型、贪心优化<br><br>堆叠长方体的最大高度 - 排序、线性 DP、最长上升子序列模型<br>无矛盾的最佳球队 - 排序、线性 DP、最长上升子序列模型<br><br><br>最长公共子序列 - 线性 DP、最长公共子序列模型<br>两个字符串的最小 ASCII 删除和 - 线性 DP、最长公共子序列模型<br>两个字符串的删除操作 - 线性 DP、最长公共子序列模型<br><br>目标和 - 0-1 背包问题<br>	数组前面添加+ 或 -， 最后凑出目标的方案数<br>	方法1：dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>  前i个数凑出j-1000的方案个数<br>			init: dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1000]</span> = 1; return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[target+1000]</span>;<br>	方法2：负号和为x。sum - 2x = target。 数组中凑出(sum-target)/2的方案数<br>		   dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 前i个数和为j的方案数(可以不选) <br>		   	 init: dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;  return dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[target]</span><br>	方案3：dfs暴力 2^n^		   <br><br>		   <br>分割等和子集 - 0-1 背包问题  是否存在使得划分两个集合sum相等  计算方案会溢出<br><br>最后一块石头的重量 II - 0-1 背包问题  分成两堆 sum差值最小<br><br>零钱兑换 - 完全背包问题 给出零钱面值数组(可重复)，凑出target的最小数量<br>	1.完全背包 f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 前i种零钱凑出j<br>	2.普通背包问题 f<span class="hljs-comment">[i]</span> 凑出i的硬币数量。从n种状态种选出最优<br>	3.记忆化搜索 从上到下 定义什么时候终止 什么状态为求出来了 求出来中什么状态无解  同样有两种<br><br>组合总和 Ⅳ - 完全背包问题  数组中凑出target方案数  <br>	不考虑顺序是完全背包问题  <br>	考虑顺序为f<span class="hljs-comment">[i]</span>凑出i的方案数，从n种状态种选出最优<br><br><br>从栈中取出 K 个硬币的最大面值和 - 分组背包问题<br><br>数字 1 的个数 - 数位 DP、记忆化搜索<br><br>统计各位数字都不同的数字个数 - 数位 DP、记忆化搜索、状态压缩<br><br>不含连续 1 的非负整数 - 数位 DP、记忆化搜索<br><br>旋转数字 - 数位 DP、记忆化搜索<br>最大为 N 的数字组合 - 数位 DP、记忆化搜索<br>统计特殊整数 - 数位 DP、记忆化搜索<br><br>买卖股票的最佳时机 <br>	II  无限制次数 ，记忆化idx flag<br>	III IIII 限制次数，记忆化idx left flag，map记忆化比数组慢快10倍<br>	冷冻期 idx state(无 持有 冷冻)<br></code></pre></td></tr></table></figure>



<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-number">139</span>. 单词拆分 使用给定<span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> 拼接出<span class="hljs-selector-tag">s</span>，能不能拼接出来<br><span class="hljs-number">2707</span>. 字符串中的额外字符 同上，但目标是剩余字符最少  <span class="hljs-selector-tag">dp</span><span class="hljs-selector-attr">[i]</span>: <span class="hljs-number">0</span>~<span class="hljs-selector-tag">i</span>  暴力<span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">trie</span> || 字符串<span class="hljs-selector-tag">hash</span>优化查找字符串<br></code></pre></td></tr></table></figure>



<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a>  凑出target<ul>
<li>考虑顺序，不可以用完全背包</li>
<li>dfs(x)  从最后一个数转移</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组 - 力扣（LeetCode）</a>   保持两种最优状态</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-texts/">2266. 统计打字方案数 - 力扣（LeetCode）</a>  分解子问题</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-th-character-in-string-game-ii/description/">3307. 找出第 K 个字符 II - 力扣（LeetCode）</a>  分解子问题</li>
</ul>
<h4 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/description/">118. 杨辉三角 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/description/">64. 最小路径和 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/">329. 矩阵中的最长递增路径 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/description/">2328. 网格图中递增路径的数目 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-falling-path-sum-ii/">1289. 下降路径最小和 II - 力扣（LeetCode）</a>  n^3   -&gt; 维护最优和次优状态 </li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/description/">741. 摘樱桃 - 力扣（LeetCode）</a></li>
</ul>
<h4 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h4><h5 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h5><p>一些物品 选或者不选；<code>dp[i][j] = Math.max(dp[i][j], dp[i-1][j-nums[i-1]]);</code> -&gt; 优化为逆序1维</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">目标和</a>  选或者不选，凑出目标的方案数 <code>dfs(target, nums.length-1);</code>  前idx个数 凑出的方案</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a>   能否凑出  <code>dfs(target, nums.length-1);</code>  前idx个数 能否凑出target</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a>  凑出的最大长度 <code>dfs(target, nums.length-1);</code>  前idx个数 凑出target最大长度</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">将一个数字表示成幂的和的方案数</a>  <code>dfs(target, nums.length-1)</code> 前idx个数 凑出target的方案</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">取或者不取<br>前idx个数，拼接出target <span class="hljs-comment">// 也可也从0开始，dfs含义为idx~n-1个数的结果</span><br>dfs(nums, idx-<span class="hljs-number">1</span>, target);<br>dfs(nums, idx-<span class="hljs-number">1</span>, target-nums.get(idx));<br><br>递归终点 -<span class="hljs-number">1</span>  <br>    方案数  有效 <span class="hljs-number">1</span>  无效<span class="hljs-number">0</span><br>    最值 有效<span class="hljs-number">0</span> 无效inf<br>    能否 有效<span class="hljs-number">1</span> 无效<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>



<h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><ul>
<li>从使用每一个物品出发，x个	<code>dp[i][j] = 最优 dp[i-1][j-x * [w]]</code>  -&gt; 优化为当前层取值   -&gt;  优化为1维</li>
<li>从组成的数出发，可重复使用的物品循环在内。</li>
</ul>
<p>不考虑顺序，完全背包</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>  </p>
<ul>
<li><p>前i种零钱凑出j；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">记忆化，前idx个元素，凑出amount的最少数量<br><br>dfs(coins, idx-<span class="hljs-number">1</span>, amount);<br><span class="hljs-number">1</span> + dfs(coins, idx, amount-coins[idx]); <span class="hljs-comment">// 选了但idx不变</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>也可也从普通dp问题：f[i] 凑出i的硬币数量。从n种状态种选出最优</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    t = Math.min(t, dfs(coins, amount - coins[i]));<br>&#125;<br>t++;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></p>
</li>
</ul>
<p>考虑顺序，从使用的最后一个数出发, 因为考虑顺序，不可以用完全背包解决</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a></li>
</ul>
<h4 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h4><ul>
<li>记忆化从idx&#x3D;0或者n-1开始记忆化都可以，本质都一样（只是看数组的方向变了）</li>
<li><strong>当前结束状态</strong>和<strong>当前进入状态</strong> 有较大区别，1比较通用，2有时比较好理解<ol>
<li>当前结束状态（通常n-1开始） 更方便改写dp（前缀和优化 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/description/">3251</a> 、空间优化、二分优化） ，需要逆向思考<strong>状态转移方程</strong></li>
<li>进入状态（0开始 ） 更方便理解 （最长子序列、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/description/">3098</a> 、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-special-subsequences/submissions/570562800/">1955. 012数组个数</a>） ，从最初始的状态 <strong>按照题目逻辑</strong> 转移到后续状态</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/submissions/570468057/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/submissions/570522662/">3251. 单调数组对的数目 II - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/submissions/570561616/">1911. 最大子序列交替和 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-special-subsequences/submissions/570562800/">1955. 012数组个数</a> </li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/description/">1911. 最大子序列交替和 - 力扣（LeetCode）</a></li>
</ul>
</li>
</ul>
<p>相邻相关 最长上升子序列  需要多保存一个相邻关系（可以理解为状态）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/submissions/562282284/">300. 最长递增子序列 - 力扣（LeetCode）</a><ul>
<li>暴力记忆化时 <code>dfs(idx, pre)</code>，用hashmap会超时  在使用idx~n-1，且pre情况下的最长长度</li>
<li>或者<code>dfs(idx, next)</code> 在使用0~idx, 且next情况下的最长长度</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/description/">3098. 求出所有子序列的能量和 - 力扣（LeetCode）</a>  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19t421g7Pd">https://www.bilibili.com/video/BV19t421g7Pd</a><ul>
<li><code>dfs(idx, pre, minnow, lennow)  n * n * n^2 * k</code>  在使用0~idx，且pre情况下的值</li>
<li>选或不选、枚举选哪个 都可以</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/description/">3251. 单调数组对的数目 II - 力扣（LeetCode）</a> 拆分成一个递增一个递减数组  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cf421v7Ky">bili</a><ul>
<li>需要保存上一个数是什么，有点像状态dp  <code>dfs(idx, pre1)</code> 在下一个数取了pre1的情况下, 0~idx的方案数</li>
<li>不好改写dp，换第二种记忆化（当前值）<code>dfs(idx, j)</code> 在idx取了j的情况下 0~idx的方案数</li>
<li>改写成dp后，前缀和优化</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-special-subsequences/submissions/570562800/">1955. 012数组个数</a> <ul>
<li><code>dfs(nums, 0, 0)</code>  从idx&#x3D;0开始，初始state&#x3D;0表示不包含0, 从初始状态转移到其他状态</li>
<li><code>dfs(nums, n-1, 2)</code>   前n-1个数，且由（state&#x3D;0 0；state&#x3D;1 01； state&#x3D;2 012）组成的子序列   更难获得状态转移方程</li>
</ul>
</li>
<li>一个字符串，每次可以将char+1，求<strong>最小</strong>操作使得任意两个相邻的字符不同 <ul>
<li><code>dfs(idx, pre)</code>0~idx且下一个是pre需要的操作次数</li>
<li>同样不好改dp，  修改为  <code>dfs(idx, now)</code>0~idx且当前为now字符的情况下，的最值</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DIfwTtXarjktN5BYMWMgUQ">9月22日字节跳动校招机试题目+题解+在线测试 (qq.com)</a></li>
</ul>
</li>
</ul>
<p><code>dp[i][j] 为s[:i] 和t[:j] 的结果</code>， 转移考虑最后一个i j</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a>  <code>dfs(i, j)</code>  前i和前j</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/">712. 两个字符串的最小ASCII删除和 - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a>  <code>dfs(i, j)</code>  前i和前j</li>
<li>两个数组取出k个相乘，值最大  </li>
<li><code>dfs(i, j, k)</code> arr1前i个和arr2前j个，还剩下k个；这题中j和k相等</li>
<li>dp，注意溢出，key选择string可以，List作为key会超时</li>
</ul>
<h4 id="状态dp"><a href="#状态dp" class="headerlink" title="状态dp"></a>状态dp</h4><ul>
<li>买卖股票  从右往左思考且是结束的状态，更方便改写dp ；之前自己写是从左往右+进入状态<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a>  无限制次数 ，记忆化<code>dfs(idx, flag)</code>  0~idx -1, 第idx天结束状态为flag</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a>   <code>dfs(idx, state(无 持有 冷冻))</code></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/submissions/570470696/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a>  限制次数  <code>dfs(idx, state(无 持有), left)</code></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/description/">1911. 最大子序列交替和 - 力扣（LeetCode）</a>  <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 的最大值 <ul>
<li>进入状态 <code>dfs(idx, state)</code>  idx ~ n       且 state&#x3D;0 下一个数为+、  1 下一个为-</li>
<li>最终状态  <code>dfs(idx, state)</code>  前idx个数 且 state&#x3D;0 偶数个数、  1 奇数个数</li>
<li>对比：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/submissions/570561616/">1911. 最大子序列交替和 - 力扣（LeetCode）</a></li>
</ul>
</li>
</ul>
<h2 id="题单刷"><a href="#题单刷" class="headerlink" title="题单刷"></a>题单刷</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/RvFUtj/">分享｜如何科学刷题？ - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/mOr1u6/">分享丨【题单】常用数据结构（前缀和&#x2F;差分&#x2F;栈&#x2F;队列&#x2F;堆&#x2F;字典树&#x2F;并查集&#x2F;树状数组&#x2F;线段树） - 力扣（LeetCode）</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="周赛补题"><a href="#周赛补题" class="headerlink" title="周赛补题"></a>周赛补题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/">3097. 或值至少为 K 的最短子数组 II</a>：长度最小且或后大于k的子数组；和求sum很相似</p>
<ul>
<li><strong>暴力</strong>：以每一个i结尾，往前找left超时；<strong>双指针优化</strong>，但和求和不同，求和left移动直接减就行，这里需要记录下每一位1的个数</li>
<li>还是暴力每一个结尾i，但以i结尾能筹出来的或最多32个，也就是i -&gt; i+1的转换为O32的，而不是On的，这和求和不同</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/">3098. 求出所有子序列的能量和</a>：</p>
<ul>
<li>子序列<ul>
<li>相邻无关 01背包</li>
<li>相邻相关 最长上升子序列  多一个相邻关系</li>
</ul>
</li>
<li>排序后，dfs  -&gt; 记忆化优化  50^5  但有一些系数的减小（变量有大小关系，相当于在求组合数，组合数下面有阶乘系数）</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">给你一个长度为 <span class="hljs-built_in">n</span> &lt; <span class="hljs-number">50</span> 的整数数组 nums 和一个 正 整数 k 。<br><br>一个子序列的 能量 定义为子序列中 任意 两个元素的差值绝对值的 最小值 。<br><br>请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。<br><br>由于答案可能会很大，将答案对 <span class="hljs-number">109</span> + <span class="hljs-number">7</span> 取余 后返回。<br><br><br>dfs(idx, pre, minnow, lennow)  <span class="hljs-built_in">n</span> * <span class="hljs-built_in">n</span> * <span class="hljs-built_in">n</span>^<span class="hljs-number">2</span> * k<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-walk-in-weighted-graph/">100244. 带权图里旅途的最小代价</a>: 图中两点距离为 &amp; 值，求x y之间的最小距离，可以重复访问</p>
<ul>
<li><strong>and是越多越小</strong>，所以尽量访问x和y之间全部的边，因此一个连通块为一个结果</li>
<li>并查集 or  dfs</li>
<li>初始化数组太大会超时，n或者只大max一点</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-multiplication-score/description/">3290. 最高乘法得分 - 力扣（LeetCode）</a></p>
<ul>
<li>dp，注意溢出，key选择string可以，List作为key会超时</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-i/description/">3291. 形成目标字符串需要的最少字符串数 I - 力扣（LeetCode）</a></p>
<ul>
<li>记忆化搜索 dfs(i)代表从i~n-1需要多少个字符，但由于每次需要尝试n次，n^2复杂度</li>
<li>改成跳跃游戏；如何求每一个idx可以到达的最长长度？ 二分长度 + 字符串hash（字符串普通hash是On的，字符串hash是O1比较）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-410/problems/find-the-count-of-monotonic-pairs-ii/">Q4. 单调数组对的数目 II</a>：将数组nums[] 拆分成一个递增的 一个递减的</p>
<ul>
<li>经典子序列题，记忆化解决  可以从当前状态可以推出哪些，也可也从转移，转移才可以改写dp优化</li>
<li>改写成dp后，前缀和优化</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-th-character-in-string-game-ii/description/">3307. 找出第 K 个字符 II - 力扣（LeetCode）</a></p>
<ul>
<li>拆分成子问题</li>
</ul>
<h3 id="非递归快排"><a href="#非递归快排" class="headerlink" title="非递归快排"></a>非递归快排</h3><p>用栈模拟递归保存排序区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort_no_Recursion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] q)</span>&#123;<br>        ArrayDeque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        st.push(<span class="hljs-number">0</span>);<br>        st.push(q.length-<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-type">int</span> l, r, x, i, j;<br>        <span class="hljs-keyword">while</span>(st.size() != <span class="hljs-number">0</span>)&#123;<br>            <br>            r = st.pop();<br>            l = st.pop();<br>            <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">continue</span>;<br>            <br>            x = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>        <br>            i = l-<span class="hljs-number">1</span>; j = r+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>                i++; <span class="hljs-keyword">while</span>(q[i] &lt; x) i++;<br>                j--; <span class="hljs-keyword">while</span>(q[j] &gt; x) j--;<br>                <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q[i];<br>                    q[i] = q[j];<br>                    q[j] = t;<br>                &#125;<br>            &#125;<br>            <br>            st.push(l);<br>            st.push(j);<br>            <br>            st.push(j+<span class="hljs-number">1</span>);<br>            st.push(r);<br>            <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="非递归中序"><a href="#非递归中序" class="headerlink" title="非递归中序"></a>非递归中序</h3><p>染色来标记是否是第一次遇到，先序可以不用染色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;Node&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Node&gt;();<br><br>    deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(root, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">while</span>(deque.size() &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> deque.pollLast();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tmp.root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> tmp.flag;<br>        <span class="hljs-keyword">if</span>(r == <span class="hljs-literal">null</span>)<span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;<br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(r.right, <span class="hljs-number">0</span>));<br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(r, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 放最上面就是后续  最下面就是先序</span><br>            deque.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(r.left, <span class="hljs-number">0</span>));<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res.add(r.val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a>: 矩阵快速幂</p>
<h3 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 预处理字符串，插入特殊字符以便处理偶数长度回文</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 转换后的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// p[i]表示以i为中心的回文半径</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前最右的回文的中心和右边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大的回文长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCenter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大回文中心</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 如果i在当前最右回文的范围内，使用之前的对称性加速</span><br>            <span class="hljs-keyword">if</span> (i &lt; right) &#123;<br>                p[i] = Math.min(right - i, p[<span class="hljs-number">2</span> * center - i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 尝试扩展以i为中心的回文串</span><br>            <span class="hljs-keyword">while</span> (i - p[i] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; i + p[i] + <span class="hljs-number">1</span> &lt; n &amp;&amp; str.charAt(i - p[i] - <span class="hljs-number">1</span>) == str.charAt(i + p[i] + <span class="hljs-number">1</span>)) &#123;<br>                p[i]++;<br>            &#125;<br><br>            <span class="hljs-comment">// 更新右边界和中心</span><br>            <span class="hljs-keyword">if</span> (i + p[i] &gt; right) &#123;<br>                center = i;<br>                right = i + p[i];<br>            &#125;<br><br>            <span class="hljs-comment">// 更新最大回文长度和中心</span><br>            <span class="hljs-keyword">if</span> (p[i] &gt; maxLen) &#123;<br>                maxLen = p[i];<br>                maxCenter = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 从原始字符串中提取最长回文子串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> (maxCenter - maxLen) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 起始位置 (注意去掉#号)</span><br>        <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h4 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>String[] line = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br><br>n = Integer.parseInt(line[<span class="hljs-number">0</span>]);<br>m = Integer.parseInt(line[<span class="hljs-number">1</span>]);<br><br><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out));<br>out.println();<br>out.flush();<br></code></pre></td></tr></table></figure>

<p><code>stringbuilder</code>删除的时候，从后往前删防止影响，传入整数自动转为字符串</p>
<p><code>new Integer(&#39;0&#39;)</code>  得到的是ASCII， char可以自动转integer，反过来不行 <code>new Character((char) 48)</code></p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">set去重<br>Set&lt;List&lt;Integer&gt;&gt;  使用里面元素的equal  默认ArrayList 是一个一个对比 但<span class="hljs-type">int</span>[]是比较地址<br><br><span class="hljs-type">char</span>加上一个<span class="hljs-type">int</span>需要强转 <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + j);<br><br><br>数组初始化，此外对应<span class="hljs-type">int</span>，里面默认值为<span class="hljs-number">0</span>，如果是object，还需要额外<span class="hljs-keyword">new</span>  <span class="hljs-title class_">left</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][<span class="hljs-number">2</span>];  <span class="hljs-comment">// 26 行 2 列的二维数组</span><br>	System.out.println(left[<span class="hljs-number">0</span>].length);  <span class="hljs-comment">// 输出 2</span><br><br>    <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][]; <span class="hljs-comment">// 锯齿数组</span><br>    System.out.println(left[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 输出 null，因为还没有为第 0 行分配列</span><br>    left[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 手动为第 0 行分配 2 列</span><br>    left[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];  <span class="hljs-comment">// 手动为第 1 行分配 3 列</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">数组    .length  <br>String  .length()<br>List    .size()<br><br><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][]; <span class="hljs-comment">// 3行的二维数组，但每行的列数不定  内存不连续</span><br><br><br>Arrays:<br>    sort(a);     <span class="hljs-comment">// 对于非基本类 第二个参数可以传入比较方法，见 后面</span><br>	binarySearch(a, key);  binarySearch(a, start, end, key);   不包括end<br>		Collections.binarySearch(list, key);<br>	fill(a, value);<br>	a2 = copyOf(a1, a1.length);<br>	toString() <span class="hljs-comment">// 打印</span><br>        <br>	Arrays.stream(a).sum();<br>	Arrays.stream(a).max().getAsInt();<br><br>	object[]转List： <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(ints))<br>        反过来 ints = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][]) <span class="hljs-comment">//这里是二维的 list中存放 &lt;int[]&gt; 带参方法 56.</span><br>	<span class="hljs-type">int</span>[] 转List ：  <br>         Arrays.stream(a).boxed().collect(Collectors.toList());    <span class="hljs-comment">//需要装箱</span><br>		integerList.stream().mapToInt(Integer::intValue).toArray();<br><br>隐式强转可以小转大，大转小需要显式并且不能溢出<br><br>    <br>java 包含声明和创建<br>    变量的声明通常在栈内存中完成<br>    创建通常为<span class="hljs-keyword">new</span>在堆中完成，返回堆内存地址<br>    <br>Object[] arr:申明数组类型变量时，为其分配了（<span class="hljs-number">32</span>位）引用空间 栈中，由于未赋值，因此并不指向任何对象<br>    <br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>]  堆中创建一个长度为<span class="hljs-number">10</span>的Object 类型数组对象(也是对象)，分配了<span class="hljs-number">10</span>个连续的内存空间，各自占用（<span class="hljs-number">32</span>位的）Object用空间，但现在默认指向<span class="hljs-literal">null</span><br>    <br>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() 在堆中为 Object 类型的对象分配一段内存空间，将引用存储在arr[i]<br></code></pre></td></tr></table></figure>



<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>重写排序，<code>Array.sorts(a)</code> 排序数组同理。注意int不能重写，需要逆序就先排序再反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList：<br>    方法一：直接传一个函数，原理还是下面 FunctionalInterface<br>    	    nums.sort( (x, y) -&gt; x - y ); <span class="hljs-comment">// integer</span><br>            nums.sort(persons, (p1, p2) -&gt; p2.getAge() - p1.getAge());  <span class="hljs-comment">// 方便 </span><br>		   nums.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 数组</span><br>	方法二：传一个Comparator类对象，比较时调用Comparator.compare<br>            nums.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                    <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>                &#125;<br>            &#125;)<br>    方法三：类重写接口方法<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyClass&gt;&#123;<br>			<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyClass other)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.priority, other.priority);<br>            &#125;<br>		&#125;<br><br><br><br>或者对于List<br>Collections.sort(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">栈 底层数组，适合两端插入删除；LinkedList是链表<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();  或 Stack<br>	.isEmpty() .peek() .pop() .push(num)<br>	<br>队列  在栈中pop push都是从First操作，因此我代码也在first加入，但严格来说队列是队尾插入<br>	.addFirst  .addLast<br>	.peekFirst .peekLast<br>	.pollFirst .pollLast<br>    <br>map 遍历 <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) map.forEach((key, value) -&gt; sout)<br>    <br>优先队列 PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <span class="hljs-comment">// 自己的类同sort方法 默认小根堆</span><br>		<span class="hljs-comment">// (a, b) -&gt; a.getValue() - b.getValue() 小根堆</span><br>	pq.offer(<span class="hljs-number">3</span>); add()<br> 	pq.peek();<br>	pq.poll();<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">console</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(T... input)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (T i: input) &#123;<br>            sb.append(i.toString());<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        System.out.println(sb.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="重写hashmap"><a href="#重写hashmap" class="headerlink" title="重写hashmap"></a>重写hashmap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    TreeNode t;<br>    <span class="hljs-type">int</span> state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(TreeNode t, <span class="hljs-type">int</span> state)</span>&#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (Node) o;<br>        <span class="hljs-keyword">return</span> t == x.t &amp;&amp; state == x.state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(t, state);  <span class="hljs-comment">// 使用 Objects.hash() 生成基于 t 和 state 的哈希值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="randomfile"><a href="#randomfile" class="headerlink" title="randomfile"></a>randomfile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">randomAccess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(filepath, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = ...<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.write(buffer);<br><br>randomAccess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(filepath, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[pageSize]<br>randomAccess.seek(pageSize * pageNumber);<br>randomAccess.read(buffer);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapPage</span>((HeapPageId) pid, buffer);<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/12/java%E5%B9%B6%E5%8F%91/" title="java并发">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java并发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/26/dl/GNN-base/" title="图网络入门">
                        <span class="hidden-mobile">图网络入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comment.bytewaver.top/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10,"reaction":true},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
