

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#B1A58E">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="这篇文章是Java多线程编程的学习大纲，涵盖了多线程编程的核心概念和高级特性。主要内容包括线程基础知识（创建、状态、中断、守护线程等）、线程同步机制（synchronized关键字、Monitor对象、锁优化、wait&#x2F;notify机制）、并发问题（死锁、活锁、饥饿）、可重入锁（ReentrantLock及其特性）、Java内存模型（可见性、有序性、volatile关键字）、原子操作（CAS、At">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="http://example.com/2023/06/12/java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Xun&#39;s Blog">
<meta property="og:description" content="这篇文章是Java多线程编程的学习大纲，涵盖了多线程编程的核心概念和高级特性。主要内容包括线程基础知识（创建、状态、中断、守护线程等）、线程同步机制（synchronized关键字、Monitor对象、锁优化、wait&#x2F;notify机制）、并发问题（死锁、活锁、饥饿）、可重入锁（ReentrantLock及其特性）、Java内存模型（可见性、有序性、volatile关键字）、原子操作（CAS、At">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325202842856.png">
<meta property="article:published_time" content="2023-06-12T12:00:00.000Z">
<meta property="article:modified_time" content="2025-04-11T03:47:38.081Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/image-20240325202842856.png">
  
  
  
  <title>java并发 - Xun&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GEluhFhlvVVyi1wC9RzB0vSk-MdYXbMMI","app_key":"9ng4wvU8n0568liU440awYcT","server_url":"https://proxy.bytewaver.top/proxy/geluhfhl.api.lncldglobal.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/pink-small.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">java并发</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-12 20:00" pubdate>
          2023年6月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          131 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">java并发</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p><strong>GPT摘要</strong></p>
<p>这篇文章是Java多线程编程的学习大纲，涵盖了多线程编程的核心概念和高级特性。主要内容包括线程基础知识（创建、状态、中断、守护线程等）、线程同步机制（synchronized关键字、Monitor对象、锁优化、wait&#x2F;notify机制）、并发问题（死锁、活锁、饥饿）、可重入锁（ReentrantLock及其特性）、Java内存模型（可见性、有序性、volatile关键字）、原子操作（CAS、AtomicInteger等原子类）、线程池（创建、任务提交、拒绝策略、各种预定义线程池）、并发工具类（AQS、读写锁、StampedLock、Semaphore、CountDownLatch、CyclicBarrier）等。文本还提到了一些同步模式设计模式（保护性暂停、生产者&#x2F;消费者模式、顺序控制模式）以及不可变设计和享元模式在并发编程中的应用。整体来看，这是一份较为全面的Java并发编程知识体系，涵盖了从基础概念到高级特性的多个层面，适合系统学习Java多线程编程。</p>
</blockquote>
<p>效率提升：</p>
<ul>
<li>异步，防止阻塞IO</li>
<li>充分发挥多核CPU</li>
</ul>
<h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol>
<li>重写thread的run方法</li>
<li>创建runnable 抽象出来任务</li>
<li>FutureTask 带返回值  线程间通信</li>
</ol>
<p>核心Thread是创建一个线程，其中run方法或者Runnable只是代表具体的任务。如果main线程中调用Runnable.run该任务就是main执行的</p>
<p>extends Thread 并重写run方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 要执行的任务</span><br> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure>

<p>Runnable :当成参数传给thread，run方法默认会检查Runnable如果有就执行Runnable.run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// lambda:单个抽象方法的接口</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 线程的任务逻辑</span><br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure>

<p>FutureTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Callable</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 继承Runnable</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> task.get(); <span class="hljs-comment">// 阻塞等待返回结果</span><br>            System.out.println(s);<br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//重写线程任务类方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>tasklist    jps</code>   <code>taskkill</code></p>
<p><code>top -H -p pid           jstack</code>  查看进程中线程信息</p>
<p>每一个线程都有一个独立的栈，栈内每个函数都会有栈帧。main线程中的三个函数：</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808190.png" srcset="/img/loading.gif" lazyload alt="image-20230607100221439"></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>切换当前执行的线程</p>
<ul>
<li>CPU时间片</li>
<li>垃圾回收</li>
<li>更高优先权</li>
<li>线程主动调用sleep、yield、wait、 join、 park、 synchronized、 lock</li>
</ul>
<p>如何保存上下文信息？</p>
<ul>
<li>线程内程序计数器 记录运行到哪里</li>
<li>栈帧记录变量信息</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void <strong>start</strong>()</td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td>public void <strong>run</strong>()</td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td>public void getName()</td>
<td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td>public static void <strong>sleep</strong>(long time)</td>
<td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td>public static native void <strong>yield</strong>()</td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td>public final void <strong>setPriority</strong>(int priority)</td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td>public void interrupt()</td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td>public final void <strong>join</strong>()</td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td>public final void join(long millis)</td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td>public final native boolean isAlive()</td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td>public final void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ul>
<li><strong>操作系统层面</strong>：新建 就绪 运行 阻塞(io) 终止</li>
<li><strong>java层面</strong>：其中Runnable包含 就绪 运行 阻塞(io)</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808191.png" srcset="/img/loading.gif" lazyload alt="image-20230607112856036"></p>
<table>
<thead>
<tr>
<th>程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>NEW（新建）</td>
<td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td>
</tr>
<tr>
<td>Runnable（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td>
</tr>
<tr>
<td>Blocked（阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态 <code>synchronized</code>      <strong>EntryList</strong></td>
</tr>
<tr>
<td>Waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态. <code>wait</code>(WaitSet) <code>join</code>(原理wait) <code>park</code></td>
</tr>
<tr>
<td>Timed Waiting （限期等待）</td>
<td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。常用方法有 <code>Thread.sleep(time) 、wait(time)  </code> <code>join(time)</code> <code>parkUntil(time)</code></td>
</tr>
<tr>
<td>Teminated（结束）</td>
<td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">     */</span><br>    NEW,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">     * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">     * be waiting for other resources from the operating system</span><br><span class="hljs-comment">     * such as processor.</span><br><span class="hljs-comment">     */</span><br>    RUNNABLE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">     * to enter a synchronized block/method or</span><br><span class="hljs-comment">     * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">     */</span><br>    BLOCKED,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread.</span><br><span class="hljs-comment">     * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">     * following methods:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">     * perform a particular action.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">     * on an object is waiting for another thread to call</span><br><span class="hljs-comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">     * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">     */</span><br>    WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">     * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">     * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">     * &lt;ul&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">     * &lt;/ul&gt;</span><br><span class="hljs-comment">     */</span><br>    TIMED_WAITING,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread state for a terminated thread.</span><br><span class="hljs-comment">     * The thread has completed execution.</span><br><span class="hljs-comment">     */</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul>
<li><code>public void interrupt()</code>：打断这个线程，异常处理机制</li>
<li><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong></li>
<li><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</li>
</ul>
<ol>
<li><p>线程处于<strong>阻塞</strong>状态：如果线程当前处于阻塞状态，如调用了 <code>Thread.sleep()</code>、<code>Object.wait()</code>、<code>join</code> <code>BlockingQueue.take()</code> 等阻塞方法，调用 <code>interrupt()</code> 方法会中断线程的阻塞状态，抛出 <code>InterruptedException</code> 异常，打断标记。因为线程都不在运行，所以需要抛异常来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    t1.interrupt();<br>    System.out.println(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>线程处于<strong>非阻塞</strong>状态：如果线程当前处于非阻塞状态，调用 <code>interrupt()</code> 方法会将线程的中断状态设置为 <code>true</code>，但不会中断线程的执行。可以通过检查中断状态来决定是否终止线程的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主线程休眠 2 秒后中断子线程</span><br>Thread.sleep(<span class="hljs-number">2000</span>);<br>myThread.interrupt();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            <span class="hljs-comment">// 线程执行的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;Thread is running.&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Thread interrupted. Exiting...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="两阶段终止"><a href="#两阶段终止" class="headerlink" title="两阶段终止"></a>两阶段终止</h5><p>功能：记录系统的利用率，但需要能停止下来。<br>如果在sleep时被打断，则手动标记一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInterrupt</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    current.interrupt();<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作 </span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="打断park"><a href="#打断park" class="headerlink" title="打断park"></a>打断park</h5><p>park阻塞线程类似于一直sleep，但被打断不会清空标记。需要标记为假时才生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;park...&quot;</span>);<br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="hljs-comment">//打断状态：true</span><br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><ul>
<li><code>public final void join()</code>等待该线程执行完成，原理上可以使用信号量PV</li>
<li><code>join(long millis)</code> 最大等待时间</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>当其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<p><code>t1.setDaemon(true);</code></p>
<ul>
<li>垃圾回收器线程就是一种守护线程 </li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
<h2 id="共享模型之并发"><a href="#共享模型之并发" class="headerlink" title="共享模型之并发"></a>共享模型之并发</h2><p>访问共享变量时，代码的原子性（互斥）以及并发协调（同步）</p>
<ul>
<li>共享问题</li>
<li>synchronized</li>
<li>线程安全分析 </li>
<li>Monitor </li>
<li>wait&#x2F;notify </li>
<li>线程状态转换 </li>
<li>活跃性 </li>
<li>Lock 加以改进</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 共享资源</span><br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter++;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        counter--;<br>     &#125;<br> &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<ul>
<li>阻塞：synchronized、lock</li>
<li>非阻塞：原子变量</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>对象锁，同一时刻只有一个线程获取到针对该对象的锁，获取失败进入等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>	临界区<br>&#125;<br><br>大括号相当于 获取锁 + 释放锁。  对象相当于locked<br>    没有获取到时会阻塞释放资源 相当于Futex <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (xchg(&amp;locked, <span class="hljs-number">1</span>)) ; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; xchg(&amp;locked, <span class="hljs-number">0</span>); &#125;<br></code></pre></td></tr></table></figure>

<p>加在成员方法上，锁<strong>对象</strong>  <code>synchronized(this)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块</span><br>&#125;<br><br>同一类中的多个函数，如果<span class="hljs-keyword">synchronized</span>了 也不能并行，因为对象被锁了而不是函数被锁了<br></code></pre></td></tr></table></figure>

<p>加在静态方法上，锁<strong>类对象</strong>  <code>synchronized(MyClass.class)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步的静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>局部变量理论是线程安全的（每个栈都有栈帧），成员变量和静态变量不是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>但如果方法是public并且在子类中被修改了，就可能出错，所以private 或者 final的修饰符是有必要的，满足开<strong>闭</strong>原则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadSafe</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h4><p>线程安全的类： 单一方法是安全的，组合不一定（想要安全还要额外上锁）</p>
<ul>
<li>java.lang.String、 java.lang.Integer  不可变对象</li>
<li>java.lang.StringBuffer</li>
<li>java.lang.Float</li>
<li>java.lang.Boolean</li>
<li>java.util.Vector</li>
<li>java.util.Hashtable</li>
<li>java.util.concurrent.ConcurrentHashMap</li>
</ul>
<p>非线程安全的类：</p>
<ul>
<li>java.lang.StringBuilder</li>
<li>java.util.ArrayList</li>
<li>java.util.LinkedList</li>
<li>java.util.HashMap</li>
<li>java.util.HashSet</li>
</ul>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>MyServlet只有一个，共享的。所以userService也是一个共享的。count不是安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>     userService.update(...);<br>     &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>     <span class="hljs-comment">// 记录调用次数</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>     	<span class="hljs-comment">// ...</span><br>     	count++;<br> 	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>单例中的成员变量都是共享的。  改成环绕通知中的局部变量就解决了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>     <span class="hljs-comment">// 是否安全？</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br><br>     <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>         start = System.nanoTime();<br>     &#125;<br><br>     <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>         System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>dao中的数据库连接，不能共享否则被别人close了，所以每个查询都要在局部变量中获取一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>	 <span class="hljs-comment">// 是否安全</span><br> 	<span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> 	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>         conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>         <span class="hljs-comment">// ...</span><br>         conn.close();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转账 锁住类对象，简单的解决办法但效率不高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Account.class)&#123;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.money &gt; amount) &#123;<br>                <span class="hljs-built_in">this</span>.setMoney(<span class="hljs-built_in">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>        	&#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808192.png" srcset="/img/loading.gif" lazyload alt="image-20230609132432143" style="zoom: 80%;" />

<p>Mark Word</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808194.png" srcset="/img/loading.gif" lazyload alt="image-20230609132408757"></p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor是JVM中提供的一个对象，负责管理某个对象的锁。我们的对象通过MarkWord中的指针指向monitor对象（一对一）  c++实现的</p>
<ul>
<li>获取成功为Owner</li>
<li>失败加入EntryList（还可以先进行<strong>自旋</strong>几次，如果还失败才加入，减少上下文切换   自适应）；</li>
<li>在thread-2释放时唤醒一个（线程的阻塞和唤醒操作是在<strong>Java虚拟机内部</strong>进行的，而不涉及到底层操作系统的系统调用）</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808195.png" srcset="/img/loading.gif" lazyload alt="image-20230609133445269"></p>
<h4 id="字节码角度"><a href="#字节码角度" class="headerlink" title="字节码角度"></a>字节码角度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) <br>&#123;<br>	count++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了正常处理外，19~23为异常处理，也会释放锁</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808196.png" srcset="/img/loading.gif" lazyload alt="image-20230609134409660"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>优化：轻量级、偏向锁</p>
<ul>
<li><strong>轻量级锁</strong>：在竞争比较少的情况下，每次上锁太麻烦了；房门上挂书包  <strong>对使用者透明</strong></li>
<li><strong>偏向锁</strong>：直接在房门上课上名字，专属于谁</li>
</ul>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p><strong>锁记录</strong>：线程中负责记录 该线程锁住了哪些对象</p>
<ul>
<li><p>加锁：如果对象没被锁(01)，通过<strong>CAS</strong>让对象头保留锁记录地址，锁记录保存原对象头信息</p>
<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808197.png" srcset="/img/loading.gif" lazyload alt="image-20230610113617600" style="zoom:67%;" />
</li>
<li><p>加锁失败：如果对象已经被锁了(00)，<strong>锁膨胀</strong>：申请一个monitor，对象头指向monitor，加入entrylist</p>
</li>
<li><p>解锁：CAS再交换回来，如果发现对象被重量级锁锁住了，就进入重量级锁解锁流程</p>
</li>
</ul>
<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808198.png" srcset="/img/loading.gif" lazyload alt="image-20230610114230079" style="zoom:67%;" />

<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁问题：自己调用时，还需要指向<strong>CAS</strong>操作（这次一定会失败），偏向锁优化掉这个操作</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808199.png" srcset="/img/loading.gif" lazyload alt="image-20230610123937238"></p>
<ul>
<li><p>把线程的ID放入MarkWord，以后轻量级锁前先查看线程ID是否是自己，自己就不用CAS了</p>
</li>
<li><p>如果threadID不是自己，升级为轻量级锁，解锁后变成normal</p>
<ul>
<li>（如果超过20次，会发生批量重新偏向，全部直接偏向t2）</li>
<li>（如果超过40次，直接所有新建对象不可偏向）</li>
</ul>
</li>
<li><p>偏向锁释放时，并不会清空threadID</p>
</li>
</ul>
<img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808200.png" srcset="/img/loading.gif" lazyload alt="image-20230610124244401" style="zoom: 80%;" />

<ul>
<li>初始时默认状态就是该状态，但程序加载会有延时</li>
<li>可以手动禁用，或者hashCode()时会禁用（因为放不下，而在轻量级锁记录 重量级monitor会记录hash）</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁压根不会发生冲突，则直接被优化掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     <span class="hljs-keyword">synchronized</span> (o) &#123;<br>     	x++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait &#x2F; notify"></a>wait &#x2F; notify</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>等价于万能条件变量法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>        lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>        System.out.println(<span class="hljs-string">&quot;Thread A is resumed&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread B is performing some task&quot;</span>);<br>        lock.notify();  <span class="hljs-comment">// 唤醒等待的线程A</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808201.png" srcset="/img/loading.gif" lazyload alt="image-20230610133052012"></p>
<ul>
<li><p>在获取锁后，发现不满足情况，<code>lock.wait()</code>释放锁并进入<code>WaitSet</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex_lock(&amp;lk);<br><span class="hljs-keyword">if</span> (!cond) cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 睡眠前释放锁；在唤醒后，会重新尝试获取锁</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在被Owner <code>lock.notify</code>后，重新进入<code>EntryList</code>。<code>notifyAll()</code>唤醒全部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cond_signal(&amp;cv);<br>broadcast(&amp;cv);<br></code></pre></td></tr></table></figure>
</li>
<li><p>和<strong>操作系统不同点</strong>就是这里锁lk和唤醒信号cv都是lock对象</p>
</li>
</ul>
<p>同样可能会存在错误叫醒的情况，while + 广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>     <span class="hljs-keyword">while</span>(!cond) &#123;<br>     	lock.wait();<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>	lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait sleep区别"></a>wait sleep区别</h4><ul>
<li>wait 是Object方法；sleep是Thread方法</li>
<li>wait必须要先获取锁并且再释放锁，sleep不用且不会释放锁</li>
</ul>
<h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><ul>
<li>一个线程等待另外一个线程结果</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>但如果是一直产生：消息队列（见生产者&#x2F;消费者）</li>
</ul>
<p>如果用join实现，必须要下载线程结束，并且变量要设置为全局的</p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>     <span class="hljs-keyword">private</span> Object response;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件不满足则等待</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                	lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                	e.printStackTrace();<br>            	&#125;<br>        	&#125;<br>        	<span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件满足，通知等待线程</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            lock.notifyAll();<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 子线程执行下载 耗时</span><br>        List&lt;String&gt; response = download();<br>        log.debug(<span class="hljs-string">&quot;download complete...&quot;</span>);<br>        guardedObject.complete(response);<br>        <br>    &#125;).start();<br><br>    <span class="hljs-comment">// 主线程阻塞等待</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> guardedObject.get();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="带超时"><a href="#带超时" class="headerlink" title="带超时"></a><strong>带超时</strong></h5><p>直接wait(time) break不行，因为存在虚假唤醒。记录等待时间防止多等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 1) 记录最初时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 2) 已经经历的时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">timePassed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> millis - timePassed;<br>            log.debug(<span class="hljs-string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);<br>            <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;break...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.wait(waitTime);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span><br>            timePassed = System.currentTimeMillis() - begin;<br>            log.debug(<span class="hljs-string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, timePassed, response == <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="扩展多个"><a href="#扩展多个" class="headerlink" title="扩展多个"></a>扩展多个</h5><p>多加一个中间者，实现多对多，但其中每一对还是一一对应的。解耦产生和消费；  PRC框架</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808202.png" srcset="/img/loading.gif" lazyload alt="image-20230610155101901"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Join原理"><a href="#Join原理" class="headerlink" title="Join原理"></a>Join原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">线程对象也是对象<br>A线程调用B.join()时，会先获取锁<span class="hljs-keyword">synchronized</span> 然后执行B.wait(delay);<br>	B线程运行结束后，调用notifyAll唤醒所有等待<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span>&#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h4><ul>
<li>生产者消费者不需要一一对应</li>
<li>JDK中的阻塞队列原理</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808203.png" srcset="/img/loading.gif" lazyload alt="image-20230610155149434"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            <span class="hljs-keyword">return</span> queue.getFirst();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Message m)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.notifyAll();<br>            queue.add(m);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h3><p>wait状态，有点像<strong>值最大为1的信号量</strong>  但是是以<strong>线程</strong>为单位   不需要获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    LockSupport.park(); <span class="hljs-comment">// 暂停自己</span><br>    log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>LockSupport.unpark(t1); <span class="hljs-comment">// 恢复某个线程运行，可以在线程暂停前使用</span><br></code></pre></td></tr></table></figure>



<ul>
<li>不需要monitor，唤醒比较精确</li>
<li>可以先恢复再暂停</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每个线程一个parker对象</p>
<p>其中有一个_counter(干粮数量)&#x3D;0或者1</p>
<ul>
<li>unpark：<code>_counter++  if(线程在等待) &#123;唤醒， _counter=0&#125;</code></li>
<li>park：<code>_counter--   if ( _counter&lt;0)  &#123;wait , _counter=0&#125;</code></li>
</ul>
<h3 id="细粒度锁"><a href="#细粒度锁" class="headerlink" title="细粒度锁"></a>细粒度锁</h3><p>睡觉和学习应该能并发，所以需要将锁细粒度化，而不是直接锁住this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在一个线程需要获取多把锁时就可能导致</p>
<h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">jps <span class="hljs-comment">// 输出java进程 pid</span><br><br>jconsole <span class="hljs-comment">// 切换到线程，然后检测死锁</span><br>jstack pid  <span class="hljs-comment">// 显示进程运行信息  可以检测死锁  但只能检测java自己的  imple-db项目中锁是用map定义的就无法检测</span><br><br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361d378</span> (object <span class="hljs-number">0x000000076b5bf1c0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> waiting to lock monitor <span class="hljs-number">0x000000000361e768</span> (object <span class="hljs-number">0x000000076b5bf1d0</span>, a java.lang.Object),<br> which is held by <span class="hljs-string">&quot;Thread-1&quot;</span><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">1</span>(TestDeadLock.java:<span class="hljs-number">28</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">883049899.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br> at thread.TestDeadLock.lambda$main$<span class="hljs-number">0</span>(TestDeadLock.java:<span class="hljs-number">15</span>)<br> - waiting to lock &lt;<span class="hljs-number">0x000000076b5bf1d0</span>&gt; (a java.lang.Object)<br> - locked &lt;<span class="hljs-number">0x000000076b5bf1c0</span>&gt; (a java.lang.Object)<br> at thread.TestDeadLock$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">495053715.</span>run(Unknown Source)<br> at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure>



<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。开发中可以增加随机时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望减到 0 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count--;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 期望超过 20 退出循环</span><br>    <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>        sleep(<span class="hljs-number">0.2</span>);<br>        count++;<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>



<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>某个线程始终不能运行，如设置了线程优先级，优先级低的可能难以运行</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul>
<li>可中断</li>
<li>可以设置超时时间     </li>
<li>可以设置为公平锁     先到先得而不是随机</li>
<li>支持多个条件变量     相当于不同条件变量进入不同<code>WaitSet</code>    现在就完全相当于万能条件变量法 等价于synchronized+wait notifyall 升级</li>
</ul>
<p>都可以重入</p>
<p>java实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h4><p>等待锁的过程中可以被叫醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    lock.lockInterruptibly();  <span class="hljs-comment">// 如果别人获取了锁，我在等待过程可以被打断</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>    log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br>lock.lock();<br>t1.start();<br>sleep(<span class="hljs-number">1</span>);<br>t1.interrupt();<br></code></pre></td></tr></table></figure>

<h4 id="可超时"><a href="#可超时" class="headerlink" title="可超时"></a>可超时</h4><p>避免无限制的等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!lock.tryLock()) &#123; <span class="hljs-comment">// 查看当前状态下是否能够获取锁 立即返回true false</span><br>    log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br><br>lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS) <span class="hljs-comment">// 尝试1s</span><br></code></pre></td></tr></table></figure>

<h5 id="解决哲学家"><a href="#解决哲学家" class="headerlink" title="解决哲学家"></a>解决哲学家</h5><p>获取锁时，如果右手获取不到，需要立马不等并且左手要解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 尝试获得左手筷子</span><br><span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试获得右手筷子</span><br>        <span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                eat();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                right.unlock();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        left.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>会降低并发度 默认为false   <code>lock = new ReentrantLock(true);</code></p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>之前等待队列只有一个，直接是lock对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Thread A is waiting&quot;</span>);<br>    lock.wait();  <span class="hljs-comment">// 线程A等待</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在lock基础上，创建一个condition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 创建一个condition</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionMet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (!conditionMet) &#123;<br>            condition.await(); <span class="hljs-comment">// 在该condition上等待 进入该队列</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Condition is met. Resuming execution.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        conditionMet = <span class="hljs-literal">true</span>;<br>        condition.signal(); <span class="hljs-comment">// signalAll()</span><br>        System.out.println(<span class="hljs-string">&quot;Condition is signaled.&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h3><h4 id="线程执行顺序"><a href="#线程执行顺序" class="headerlink" title="线程执行顺序"></a>线程执行顺序</h4><ul>
<li>wait notify：  还需要一个额外变量标记代表cond</li>
<li>park unpark  非常简洁</li>
</ul>
<h4 id="打印指定形状"><a href="#打印指定形状" class="headerlink" title="打印指定形状"></a>打印指定形状</h4><p>例如打印abcabc   和打印🐟一个原理</p>
<ol>
<li><p>直接万能条件变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag, String str)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.flag != waitFlag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.print(str);<br>        flag = nextFlag;<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>ReentrantLock + condition  每个线程都有等待的cond以及唤醒的cond 感觉没有必要 不如直接上面whlie+notifyAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> &#123;<br>    <span class="hljs-built_in">this</span>.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        current.await();<br>        log.debug(str);<br>        next.signal();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


</li>
<li><p>park unpark：每次unpark下一个想打印的线程，需要一个数组以获得下一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LockSupport.park();<br>System.out.print(str);<br>LockSupport.unpark(nextThread());<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>分析多线程访问共享资源时，哪些代码片段属于临界区 </p>
<p>使用 synchronized 互斥解决临界区的线程安全问题 </p>
<ul>
<li>掌握 synchronized 锁对象语法 </li>
<li>掌握 synchronzied 加载成员方法this 和静态方法语法 this.getClass()</li>
<li>掌握 wait&#x2F;notify 同步方法</li>
</ul>
<p>使用 lock 互斥解决临界区的线程安全问题 </p>
<ul>
<li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量   </li>
<li>相当于synchronzied 的<strong>升级</strong></li>
</ul>
<p>学会分析变量的线程安全性、掌握常见<strong>线程安全类</strong>的使用</p>
<p> 了解线程活跃性问题：死锁、活锁、饥饿 </p>
<p><strong>应用方面</strong> </p>
<ul>
<li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li>
<li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果</li>
</ul>
<p><strong>原理方面</strong> </p>
<ul>
<li>monitor、synchronized 、wait&#x2F;notify 原理 </li>
<li>synchronized 进阶原理   轻量级  偏向锁  锁消除</li>
<li>park &amp; unpark 原理</li>
</ul>
<p><strong>模式方面</strong> </p>
<ul>
<li>同步模式之保护性暂停 </li>
<li>异步模式之生产者消费者 </li>
<li>同步模式之顺序控制</li>
</ul>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>通过volatile解决由于缓存引发的可见性问题，以及重排序引发的有序性问题</p>
<p>JMM java memory model</p>
<ul>
<li>原子性</li>
<li>可见性  不受缓存影响</li>
<li>有序性  不受cpu指令并行优化影响</li>
</ul>
<p>JMM的主要内容包括：</p>
<ol>
<li>主内存（Main Memory）：主内存是所有线程共享的内存区域，用于存储共享变量。主内存中的数据对所有线程可见。</li>
<li>工作内存（Working Memory）：每个线程都有自己的工作内存，用于存储线程执行时需要使用的数据。工作内存中包含了主内存中的部分数据副本。</li>
<li>内存间交互操作：JMM定义了一组规则，用于线程在主内存和工作内存之间进行数据交互。这些操作包括读取、写入和同步操作。</li>
<li>顺序一致性（Sequential Consistency）：JMM保证线程的执行结果与顺序一致的执行结果相同。即，对于一个线程来说，它的操作将按照程序中的顺序执行，并且对其他线程可见。</li>
<li>可见性（Visibility）：JMM保证一个线程对共享变量的修改对其他线程是可见的。这意味着一个线程对变量的修改，将会在之后的操作中对其他线程可见。</li>
<li>原子性（Atomicity）：JMM提供了一些原子性的保证。例如，对<code>volatile</code>变量的读写具有原子性，单个读写操作不会被线程中断。</li>
<li>重排序（Reordering）：JMM允许编译器和处理器对指令进行优化和重排序，但要求保持程序的顺序一致性和线程的可见性。</li>
</ol>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>实际上停不下来，为什么？</li>
<li>while中如果有sout，就可以停下来了 为什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1</span>);<br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t会在下一次循环中停下来</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程中存储了<code>run = true;</code> 的副本</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808204.png" srcset="/img/loading.gif" lazyload alt="image-20230612163339523"></p>
<ul>
<li><strong>volatile</strong>：强制到主存中读取，修饰成员变量和静态成员变量。不能保证原子性，一个i++ 一个i– 还是会错，适合一个写其他读的情况 (轻量级的同步机制)</li>
<li><strong>synchronized</strong>：也可以实现必须去主存读取，但复杂度高。可以实现原子性(代码块内也可能重排序）<ul>
<li>进入时从主存读取最新</li>
<li>退出时将修改刷新到主存</li>
</ul>
</li>
</ul>
<h4 id="改进两阶段"><a href="#改进两阶段" class="headerlink" title="改进两阶段"></a>改进两阶段</h4><p>使用volatile标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTVolatile</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作</span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt(); <span class="hljs-comment">// 立即打断 不用等待sleep</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="balking"><a href="#balking" class="headerlink" title="balking"></a>balking</h4><p>监控线程只有一个，但如果有人多次start()其实会调用多个。balking<strong>避免重复执行某个操作</strong>  任务调度</p>
<ul>
<li>加一个volatile变量if判断 ？   不行 不能保证原子</li>
<li>加synchronized  可以实现，但每次都要synchronized同步比较慢（如用这个实现单例）</li>
<li>缩小synchronized 范围。  为什么不直接用单例 单例是保证只有一个实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting; <span class="hljs-comment">// 如果只在synchronized内读写可以不加volatile</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808205.png" srcset="/img/loading.gif" lazyload alt="image-20230612172143500" style="zoom:67%;" />

<p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和组合来实现指令级并行，单线程下正确，但多线程下有问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// 指令2</span><br>System.out.println( a + b );<br><span class="hljs-comment">// 不能重排的例子</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 指令1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">5</span>; <span class="hljs-comment">// 指令2</span><br></code></pre></td></tr></table></figure>

<h4 id="指令重排序问题"><a href="#指令重排序问题" class="headerlink" title="指令重排序问题"></a>指令重排序问题</h4><p>1 4为正常输出 但可能出现0(概率比较低)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123; <br>    num = <span class="hljs-number">2</span>; <span class="hljs-comment">// 这两条可能被交换位置  或者num = 2并没有被写入主存中</span><br>    ready = <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>对变量ready添加volatile会禁用重排序</p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障 </li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可见性：<ul>
<li>遇到写屏障（sfence），对所有共享变量的改动，都同步到主存当中</li>
<li>遇到读屏障（lfence），去主存加载最新数据</li>
</ul>
</li>
<li>有序性：<ul>
<li>指令不能跨越屏障</li>
</ul>
</li>
</ul>
<h3 id="double-check-locking"><a href="#double-check-locking" class="headerlink" title="double-check-locking"></a>double-check-locking</h3><p>普通写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>double</p>
<ul>
<li><p>需要把同步的范围缩小，只在第一次加锁</p>
</li>
<li><p>并且通过volatile保证读取最新值保证<strong>可见性</strong>，并且<strong>有序性</strong>防止指令重排导致 还没初始化完毕的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 的过程<br>    <span class="hljs-number">17</span> 表示创建对象，将对象引用入栈 <span class="hljs-comment">// new Singleton</span><br>    <span class="hljs-number">20</span> 表示复制一份对象引用 <span class="hljs-comment">// 引用地址</span><br>    <span class="hljs-number">21</span> 表示利用一个对象引用，调用构造方法<br>    <span class="hljs-number">24</span> 表示利用一个对象引用，赋值给 <span class="hljs-keyword">static</span> INSTANCE  <span class="hljs-comment">// 可能先执行  需要加volatile写屏障</span><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?</span><br>    <span class="hljs-comment">// volatile会在synchronized读取，synchronized外面需要volatile保证从内存读取</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗  EntryList都会进到这里</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2 </span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="可见性进阶"><a href="#可见性进阶" class="headerlink" title="可见性进阶"></a>可见性进阶</h3><ol>
<li>synchronized中的变量</li>
<li>volatile修饰的变量</li>
<li>在线程开始前修改变量（可以理解为创建副本）</li>
<li>t1.join() 后，可以看到t1中的修改</li>
<li>t1打断t2， t2.interrupt();  t2可以看到t1的写</li>
<li>对变量默认值的写，其他线程可见</li>
<li>具有传递性 ，在写屏障前的全部修改都可见 y &#x3D; 10 x &#x3D; 1  (x是volatile)</li>
</ol>
<h3 id="单例习题"><a href="#单例习题" class="headerlink" title="单例习题"></a>单例习题</h3><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final 防止被修改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?  不能</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?  jvm实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 避免反序列化</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的      </span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题    jvm避免</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例        不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例    不会</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式      饿汉式  static 静态成员变量</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做  构造方法</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123; <br> INSTANCE; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>类加载实现懒汉式单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 问题1：属于懒汉式还是饿汉式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyHolder</span> &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-comment">// 问题2：在创建时是否有并发问题  不会 JVM保证只有一个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="无锁并发"><a href="#无锁并发" class="headerlink" title="无锁并发"></a>无锁并发</h2><ul>
<li>本章内容</li>
<li>CAS 与 volatile </li>
<li>原子整数 </li>
<li>原子引用 </li>
<li>原子累加器 </li>
<li>Unsafe</li>
</ul>
<ol>
<li>CAS可以实现锁，0代表空闲1代表占用，下一章连接池中使用atomic数组实现多个连接池的锁</li>
<li>reentrantlock底层其实还是CAS，外带一个等待队列（park实现等待） 见原理部分</li>
</ol>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取当前值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> atomicInteger.get();<br><br><span class="hljs-comment">// 设置新的值</span><br>atomicInteger.set(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 获取当前值，并设置新的值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> atomicInteger.getAndSet(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 比较当前值是否等于期望值，如果等于则设置新的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> atomicInteger.compareAndSet(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br><span class="hljs-comment">// public final native boolean compareAndSwapInt(Object this, long offset, int old, int new);</span><br><br><span class="hljs-comment">// 获取当前值，并将其加1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> atomicInteger.getAndIncrement();<br><br><span class="hljs-comment">// 获取当前值，并将其减1</span><br>newValue = atomicInteger.getAndDecrement();<br><br><span class="hljs-comment">// 获取当前值，并将其加上delta</span><br>newValue = atomicInteger.getAndAdd(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 将当前值加1，并返回新的值</span><br>newValue = atomicInteger.incrementAndGet();<br><br><span class="hljs-comment">// 将当前值减1，并返回新的值</span><br>newValue = atomicInteger.decrementAndGet();<br><br><span class="hljs-comment">// 将当前值加上delta，并返回新的值</span><br>newValue = atomicInteger.addAndGet(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CAS修改过程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>    <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>    <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;  <span class="hljs-comment">//compareAndSwapInt(this, offset, prev, next)</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 包括getAndIncrement也是这个原理 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object <span class="hljs-built_in">this</span>, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> var4=<span class="hljs-number">1</span>)</span> &#123;<br>    <span class="hljs-type">int</span> old;<br>    <span class="hljs-keyword">do</span> &#123;<br>        old = <span class="hljs-built_in">this</span>.getIntVolatile(<span class="hljs-built_in">this</span>, offset);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(<span class="hljs-built_in">this</span>, offset, old, old + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>Compare And Swap</code>：先比较是否是旧值，旧值没被修改才swap（乐观锁） </p>
<p>核心一个函数：this和offset用于确定地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object <span class="hljs-built_in">this</span>, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> old, <span class="hljs-type">int</span> new)</span>;<br></code></pre></td></tr></table></figure>

<p>底层：<code>lock cmpxchg</code> 指令（X86 架构）</p>
<p>变量存储在一个<strong>volatile</strong>值中，因为每次都要保证可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure>



<p><strong>效率高</strong>：不需要 锁的获取 以及 线程的上下文下切换，但需要更高的cpu资源，受限cpu内核数</p>
<h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><ul>
<li>AtomicBoolean </li>
<li>AtomicInteger </li>
<li>AtomicLong</li>
</ul>
<p>操作 原理都是while中尝试<code>compareAndSwapInt</code></p>
<ul>
<li>getAndIncrement();  incrementAndGet</li>
<li>getAndAdd(10);</li>
<li>getAndUpdate(p -&gt; p * 2);</li>
</ul>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul>
<li>AtomicReference </li>
<li>AtomicMarkableReference </li>
<li>AtomicStampedReference</li>
</ul>
<p>对象不是基本类型，提供CAS对对象进行操作，compare比较的是地址</p>
<h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>保证多线程环境下取钱操作正常，并且不需要加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AtomicReference&lt;Double&gt; balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-number">0.0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>    Double oldValue;<br>    Double newValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = balance.get();<br>        newValue = oldValue - amount;<br>    &#125; <span class="hljs-keyword">while</span> (!balance.compareAndSet(oldValue, newValue));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h4><p>有人修改了值，但又改回来了，如何察觉到被修改了呢？</p>
<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>添加版本号，每次操作版本号+1，除了值要匹配，版本号也要匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取值 A</span><br><span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br><span class="hljs-comment">// 获取版本号</span><br><span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br><br><br>ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><p>不关心换了几次，只关心有没有换。用一个bool 来判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicMarkableReference&lt;T&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark=<span class="hljs-literal">true</span>);<br><br><span class="hljs-type">T</span> <span class="hljs-variable">currentRef</span> <span class="hljs-operator">=</span> ref.getReference();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">currentMark</span> <span class="hljs-operator">=</span> ref.isMarked();<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(expectedRef, newRef, expectedMark, newMark);<br><br><span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> counter.get(mark);<br>counter.compareAndSet(value, value + <span class="hljs-number">1</span>, mark[<span class="hljs-number">0</span>], !mark[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>



<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul>
<li>AtomicIntegerArray </li>
<li>AtomicLongArray </li>
<li>AtomicReferenceArray</li>
</ul>
<p>前面的是保证引用的对象不变，现在需要保护引用对象的内部不被改变，例如数组对象的内容没有修改（多个引用对象），底层就是偏移量不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment"> 参数2，获取数组长度的方法</span><br><span class="hljs-comment"> 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment"> 参数4，打印数组的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">    Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">    Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">    BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">    Consumer&lt;T&gt; printConsumer )</span> &#123;<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                putConsumer.accept(array, j%length);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>    printConsumer.accept(array);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br> ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br> (array)-&gt;array.length,<br> (array, index) -&gt; array[index]++,<br> array-&gt; System.out.println(Arrays.toString(array))<br>);<br><br>demo(<br> ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br> (array) -&gt; array.length(),<br> (array, index) -&gt; array.getAndIncrement(index),<br> array -&gt; System.out.println(array)<br>);<br></code></pre></td></tr></table></figure>



<h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul>
<li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段 </li>
<li>AtomicIntegerFieldUpdater </li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>某个对象内部的字段，保证原子操作。必须volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span>AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="hljs-string">&quot;field&quot;</span>);<br>    <span class="hljs-type">Test5</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test5</span>();<br>    fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>更高级的自增</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(), adder -&gt; adder.increment());<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> adderSupplier.get();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                action.accept(adder);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start());<br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start)/<span class="hljs-number">1000_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁   CAS实现</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure>



<h5 id="sun-misc-Contended"><a href="#sun-misc-Contended" class="headerlink" title="@sun.misc.Contended"></a>@sun.misc.Contended</h5><p>防止cell伪共享</p>
<p>缓存行64 byte，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value）  一个缓存行可能有多个Cell，注解添加128B的pad防止在同一个缓存行</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808206.png" srcset="/img/loading.gif" lazyload alt="image-20230630145548007"></p>
<table>
<thead>
<tr>
<th>从 cpu 到</th>
<th>大约需要的时钟周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1 cycle (4GHz 的 CPU 约为0.25ns)</td>
</tr>
<tr>
<td>L1</td>
<td>3~4 cycle</td>
</tr>
<tr>
<td>L2</td>
<td>10~20 cycle</td>
</tr>
<tr>
<td>L3</td>
<td>40~45 cycle</td>
</tr>
<tr>
<td>内存</td>
<td>120~240 cycle</td>
</tr>
</tbody></table>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>会操作内存，比较危险</p>
<p>获取unsafe</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Unsafe.getUnsafe();  被CallerSensitive修饰，能在引导类加载器加载的类中访问 抛出 SecurityException <br><br><span class="hljs-comment">// 反射获取</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) unsafeField.get(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>操作field</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br><br><span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br><span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>unsafe.compareAndSwapInt(teacher, idOffset, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br>System.out.println(teacher);<br></code></pre></td></tr></table></figure>

<h4 id="模拟原子整数"><a href="#模拟原子整数" class="headerlink" title="模拟原子整数"></a>模拟原子整数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicData</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> DATA_OFFSET;<br>    <span class="hljs-keyword">static</span> &#123;<br>        unsafe = UnsafeAccessor.getUnsafe();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span><br>            DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="hljs-string">&quot;data&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrease</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> oldValue;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span><br>            oldValue = data;<br>            <span class="hljs-comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span><br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><h3 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>); <span class="hljs-comment">// 不是线程安全的 多个线程调用会出错</span><br><br><span class="hljs-keyword">synchronized</span> (sdf)&#123;  <span class="hljs-comment">// 可以解决 但太慢了</span><br>    sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>内部属性不可变实现安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br></code></pre></td></tr></table></figure>



<h3 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 保护性拷贝，防止内容被修改</span><br><span class="hljs-built_in">this</span>.value = Arrays.copyOf(value, value.length); <br><span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br></code></pre></td></tr></table></figure>

<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>minimizes memory usage by sharing</p>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的<br>valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对<br>象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="String-串池"><a href="#String-串池" class="headerlink" title="String 串池"></a>String 串池</h4><h4 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h4><h3 id="模拟连接池！"><a href="#模拟连接池！" class="headerlink" title="模拟连接池！"></a>模拟连接池！</h3><p>有多个连接，所以需要array标记使用状态：AtomicArray</p>
<p>AtomicIntegerArray来标记连接状态，并且是线程安全的，注意需要使用cas修改标记<br>在所有的连接都占用时，wait等待以节约cpu</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-comment">// 实现略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上实现没有考虑：</p>
<ul>
<li>连接的动态增长与收缩</li>
<li>连接保活（可用性检测）</li>
<li>等待超时处理</li>
<li>分布式 hash</li>
</ul>
<p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache<br>commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p>
<p>tomcat jdbc连接池比较简单易读</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>线程池 ThreadPollExecutor Fork&#x2F;Join</li>
<li>JUC   Lock Semaphore CountdownLatch CyclicBarrier…</li>
<li>第三方</li>
</ul>
<h3 id="自己线程池"><a href="#自己线程池" class="headerlink" title="自己线程池"></a>自己线程池</h3><p>无救急线程</p>
<p>高并发下，并不是越大越好，而是需要充分发挥已有线程的潜力</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808207.png" srcset="/img/loading.gif" lazyload alt="image-20230702093206100"></p>
<ul>
<li>需要一个线程set</li>
<li>当一个线程结束后，查看有没有BlockingQueue有没有任务，有就run（实现复用）</li>
</ul>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>实现保存暂时没有执行的任务列表，任务队列相当于<a href="###%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85/%E6%B6%88%E8%B4%B9%E8%80%85">生产者消费者模型</a>,但使用lock实现</p>
<ul>
<li><p>获取一个任务take</p>
<ul>
<li>为了实现如果等一段时间内还没有任务结束线程（不是一直死等），需要添加超时的等待<code>take -&gt; poll(timeout, unit)</code></li>
</ul>
</li>
<li><p>添加一个任务put</p>
<ul>
<li><p>等待任务队列也不是无穷大，有一个capcity</p>
</li>
<li><p>当满了以后，有<strong>不同的策略</strong></p>
<ol>
<li><p><code>put</code> 死等，阻塞主线程 fullWaitSet.await()</p>
</li>
<li><p><code>offer(task, timeout, unit)</code> 带超时等待</p>
</li>
<li><p>添加一个拒绝策略，策略模式</p>
<ul>
<li><p>具体实现的策略可以是死等、超时…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">(queue, task)-&gt;&#123;<br>    <span class="hljs-comment">// 1. 死等</span><br>    queue.put(task);<br>    <span class="hljs-comment">// 2) 带超时等待</span><br>    queue.offer(task, <span class="hljs-number">1500</span>, TimeUnit.MILLISECONDS);<br>    <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>    log.debug(<span class="hljs-string">&quot;放弃&#123;&#125;&quot;</span>, task);<br>    <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;任务执行失败 &quot;</span> + task);<br>    <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>    task.run();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 1. 任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-comment">// 2. 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 3. 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 4. 消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 5. 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br>    <span class="hljs-comment">// 带超时阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 timeout 统一转换为 纳秒</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 返回值是剩余时间</span><br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<span class="hljs-comment">//自动返回剩余时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 带超时时间阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断队列是否满</span><br>            <span class="hljs-keyword">if</span>(queue.size() == capcity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有空闲</span><br>                log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务队列</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><span class="hljs-comment">// 线程集合</span><br><span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">// 核心线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br><span class="hljs-comment">// 等待队列满了时，拒绝策略</span><br><span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br></code></pre></td></tr></table></figure>



<h5 id="创建任务："><a href="#创建任务：" class="headerlink" title="创建任务："></a>创建任务：</h5><ul>
<li><p>任务数量小于coreSize时，创建一个Worker并加入线程集合中</p>
</li>
<li><p>否则加入taskQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>    <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>    <span class="hljs-keyword">synchronized</span> (workers) &#123; <span class="hljs-comment">// 保证线程安全</span><br>        <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>            <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>            log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>            workers.add(worker);<br>            worker.start();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// taskQueue.put(task);</span><br>            <span class="hljs-comment">// 1) 死等</span><br>            <span class="hljs-comment">// 2) 带超时等待</span><br>            <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>            <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>            <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>            taskQueue.tryPut(rejectPolicy, task);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="执行与任务完成："><a href="#执行与任务完成：" class="headerlink" title="执行与任务完成："></a>执行与任务完成：</h5><ul>
<li><p>当任务完成后，Worker需要从taskQueue取出下一个任务，实现Worker的复用</p>
<ul>
<li>一直等待 或者 等一段时间后结束线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable task;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>        <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>        <span class="hljs-comment">// while(task != null || (task = taskQueue.take()) != null) &#123;  // 会一直等awiati</span><br>        <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                task.run();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>            workers.remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> threadpoolself;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">// 获取任务时的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>        <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// taskQueue.put(task);</span><br>                <span class="hljs-comment">// 1) 死等</span><br>                <span class="hljs-comment">// 2) 带超时等待</span><br>                <span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br>                <span class="hljs-comment">// 4) 让调用者抛出异常</span><br>                <span class="hljs-comment">// 5) 让调用者自己执行任务</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, <span class="hljs-type">int</span> queueCapcity,</span><br><span class="hljs-params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>            <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>            <span class="hljs-comment">// while(task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808208.png" srcset="/img/loading.gif" lazyload alt="image-20230702105624890"></p>
<p> int 的高 3 位来表示线程池状态，低 29 位表示线程数量，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>高3位</th>
<th>新任务</th>
<th>处理阻塞队列任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不会接收新任务，但会处理阻塞队列剩余任务shutdown</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>会中断正在执行的任务，并抛弃阻塞队列任务shutdownNow</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td></td>
<td></td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td></td>
<td></td>
<td>终结状态</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数目 (最多保留的线程数)</li>
<li>maximumPoolSize 最大线程数目   减去核心线程就是救急线程数量，多出来的会被销毁</li>
<li>keepAliveTime 生存时间 - 针对救急线程</li>
<li>unit 时间单位 - 针对救急线程</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li>
<li>handler 拒绝策略</li>
</ul>
<p><strong>当阻塞队列满时，会先创建救济线程，再考虑拒绝策略</strong></p>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808209.png" srcset="/img/loading.gif" lazyload alt="image-20230702111206853"></p>
<ul>
<li><p>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p>
</li>
<li><p>CallerRunsPolicy 让调用者运行任务</p>
</li>
<li><p>DiscardPolicy 放弃本次任务</p>
</li>
<li><p>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</p>
</li>
<li><p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方<br>便定位问题</p>
</li>
<li><p>Netty 的实现，是创建一个新线程来执行任务</p>
</li>
<li><p>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</p>
</li>
<li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p>
</li>
</ul>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
<li>任务量已知，任务耗时</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>
<li>适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
<p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p>
<p><code>FinalizableDelegatedExecutorService</code>限制了一些方法的暴露</p>
<h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;   futer.get()获取结果（原理保护性暂停模式） 有异常返回异常<br><br><span class="hljs-comment">// 提交 tasks 中所有任务, 会等最后一个完成</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException;<br><br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure>



<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非阻塞</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br>- 会将队列中的任务返回<br>- 并用 interrupt 的方式中断正在执行的任务<br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> <br><br><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事</span><br>情，可以利用此方法等待<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure>

<h4 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h4><p>分工模式，不同的任务采用不同的线程池。如点餐线程池和做饭线程池</p>
<p>如果同一个线程池中，可能会没有做饭的导致点餐的一直在等待，导致饥饿。但jconsole死锁检测不到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">waiterPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cookPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>waiterPool.execute(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>    Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>        <span class="hljs-keyword">return</span> cooking();<br>    &#125;);<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h5 id="线程池数量"><a href="#线程池数量" class="headerlink" title="线程池数量"></a>线程池数量</h5><ul>
<li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p>
</li>
<li><p>过大会导致更多的线程上下文切换，占用更多内存</p>
</li>
<li><p><strong>CPU 密集</strong>型运算</p>
<p>​	通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因<br>导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p>
</li>
<li><p><strong>I&#x2F;O 密集型</strong>运算</p>
<p>​	CPU 容易闲下来（IO RPC），你可以利用多线程提高它的利用率。    时间占比可以用工具估算</p>
<p>​	线程数 &#x3D; 核数 * 期望 CPU 利用率(1.0) * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p>
</li>
</ul>
<h4 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h4><p>如何实现一些延时的任务，或者反复执行</p>
<h5 id="Timmer"><a href="#Timmer" class="headerlink" title="Timmer"></a>Timmer</h5><p>同一时间只能有一个任务在执行，出现异常后续不可以执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span><br>    <span class="hljs-comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span><br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><p>延时任务或者重复执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 添加两个任务，希望它们都在 1s 后执行</span><br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务1，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">2000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>executor.schedule(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;任务2，执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br><br><span class="hljs-comment">// 延时2s后 每隔1s反复执行，延时包括执行时间，任务开始间隔时间 = max（执行时间，等待时间）</span><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 延时从上一个任务结束开始算  任务开始间隔时间 = 执行时间+等待时间</span><br>executor.scheduleWithFixedDelay(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>



<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><p>方法1：主动捉异常</p>
</li>
<li><p>方法2：使用submit中的 Future，f.get()会返回异常信息</p>
</li>
</ul>
<h3 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808210.png" srcset="/img/loading.gif" lazyload alt="image-20230703111719298"></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor implement Runnable），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<h4 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h4><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同<br>    如果总线程数达到 maximumPoolSize<br>        这时不会立刻抛 RejectedExecutionException 异常<br>        而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    submittedCount.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> (TaskQueue)<span class="hljs-built_in">super</span>.getQueue();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;<br>                    submittedCount.decrementAndGet();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>                submittedCount.decrementAndGet();<br>                Thread.interrupted();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(x);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            submittedCount.decrementAndGet();<br>            <span class="hljs-keyword">throw</span> rx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Connector 配置</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808211.png" srcset="/img/loading.gif" lazyload alt="image-20230703112719086"></p>
<p>Executor 线程配置，优先级高于上面的配置</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808212.png" srcset="/img/loading.gif" lazyload alt="image-20230703112911572"></p>
<p>此外，对救急线程的激活逻辑做了修改，先创建救急线程而不是加入队列</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808213.png" srcset="/img/loading.gif" lazyload alt="image-20230703113021772"></p>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>大任务拆分为算法上相同的小任务，小任务分配到不同线程从而并行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>    System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(<span class="hljs-number">5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">AddTask1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork(); <span class="hljs-comment">// 启动另一个线程执行该任务</span><br>        <br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>拆分优化：拆分成 begin-mid，mid+1-end 能提高并行度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask3</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-built_in">this</span>.begin = begin;<br>    <span class="hljs-built_in">this</span>.end = end;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<p>特点：</p>
<ul>
<li>用 <strong>state</strong>  volatile属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取<br>锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br>    <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span><br>&#125;<br><br><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要实现以下方法： 不同的实现代表不同锁类型    AQS其他方法会调用下面的方法,详情见ReentrantLock</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808214.png" srcset="/img/loading.gif" lazyload alt="image-20230704100702089" style="zoom:50%;" />

<p>入队需要把当前Node变成tail，CAS操作防止并发影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 原来的 tail</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail;<br><span class="hljs-comment">// 用 cas 在原来 tail 的基础上改为 node</span><br>&#125; <span class="hljs-keyword">while</span>(tail.compareAndSet(prev, node))<br></code></pre></td></tr></table></figure>

<p>某个线程释放锁后，会唤醒Head的下一个，并尝试tryAcquire；成功后设置当前节点为head，并且出队列，失败继续等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 释放锁</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <span class="hljs-comment">// 修改state 自己定义的方法</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>        unparkSuccessor(h);  <span class="hljs-comment">// unpark下一个thread，优先叫醒head下一个；只是unpark，后面还要获取锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 老二被叫醒 尝试获取锁，成功了才被删除</span><br>    setHead(node);<br>    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    failed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> interrupted;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="自定义非重入锁"><a href="#自定义非重入锁" class="headerlink" title="自定义非重入锁"></a>自定义非重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span> (acquires == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">if</span>(acquires == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列，可打断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试一次，不成功返回，不进入队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 尝试，不成功，进入等待队列，有时限</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 生成条件变量</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808215.png" srcset="/img/loading.gif" lazyload alt="image-20230703151551509"></p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>当前线程在获取失败后会park</p>
<p>有一个Node链表连接所有线程（有一个虚假head），前一个负责unpark后一个</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808216.png" srcset="/img/loading.gif" lazyload alt="image-20230703154753396"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="hljs-comment">// add加入到链表中</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 老二被叫醒 尝试获取锁</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="hljs-comment">// pre的state设置为-1</span><br>                parkAndCheckInterrupt()) <span class="hljs-comment">// park 并返回等待过程中有没有被打断</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ul>
<li>设置state</li>
<li>unpark队列中离head最近的Thread</li>
</ul>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808217.png" srcset="/img/loading.gif" lazyload alt="image-20230703155757360"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;  <span class="hljs-comment">// 修改state 自己定义的方法</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);  <span class="hljs-comment">// unpark下一个thread，优先叫醒head下一个；只是unpark，后面还要获取锁</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>state：代表计数，获取时++，释放时–</p>
<h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><p>获取锁时会进入park，如果被打断就立马抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>(); <span class="hljs-comment">// 被打断后 立马抛出异常</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 如果被打断 返回true</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="公平性原理"><a href="#公平性原理" class="headerlink" title="公平性原理"></a>公平性原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">tryAcquire<br>    <span class="hljs-title function_">if</span> <span class="hljs-params">(!hasQueuedPredecessors()</span> &amp;&amp;  <span class="hljs-comment">// 添加这一句  队列中等待有时，新来的不可以tryAcquire</span><br>        compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h4><p>每一个ConditionObject有一个Node等待队列，nextWaiter串起来，firstWaiter为第一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br>    <span class="hljs-comment">/** First node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">/** Last node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br><br>await<br>    <span class="hljs-comment">// 添加一个节点，CONDITION 并加入到Waiter队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br><br>    <span class="hljs-comment">// 释放掉当前lock上的锁，并唤醒等待队列</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br><br>    <span class="hljs-comment">// park自己</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br><br>signal<br>    从ConditionObject.firstWaiter转移到等待列表<br></code></pre></td></tr></table></figure>

<p>await</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808218.png" srcset="/img/loading.gif" lazyload alt="image-20230703173859988"></p>
<p>signal</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808219.png" srcset="/img/loading.gif" lazyload alt="image-20230703173947214"></p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>让<code>读-读</code>并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br><span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataContainer</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>dataContainer.read();<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>dataContainer.write();<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<ul>
<li>写锁才有条件变量</li>
<li>不支持升级但支持降级</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedData</span> &#123;<br>    Object data;<br>    <span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// 获取写锁前必须释放读锁</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>                        cacheValid = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span><br>                rwl.readLock().lock();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                rwl.writeLock().unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 自己用完数据, 释放读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            use(data);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwl.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="读写锁实现缓存一致性"><a href="#读写锁实现缓存一致性" class="headerlink" title="读写锁实现缓存一致性"></a><strong>读写锁实现缓存一致性</strong></h4><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑<br>    适合读多写少，如果写操作比较频繁，以上实现性能低<br>    没有考虑缓存容量<br>    没有考虑缓存过期<br>    只适合单机<br>    并发性还是低，目前只会用一把锁<br>    更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）<br>乐观锁实现：用 CAS 去更新</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位，Node链表还是只有一个</p>
<p><img src="https://proxy.bytewaver.top/proxy/raw.githubusercontent.com/Goinggoinggoing/image/main/blogimg/202307041808220.png" srcset="/img/loading.gif" lazyload alt="image-20230704112731294"></p>
<p>没有仔细读源码</p>
<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(stamp);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();  <span class="hljs-comment">// 无锁</span><br>sleep(readTime); <br><span class="hljs-comment">// 验戳 如果有人修改了，那么会失败</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br>    <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>semaphore.acquire();<br>semaphore.release();<br></code></pre></td></tr></table></figure>



<h4 id="优化连接池"><a href="#优化连接池" class="headerlink" title="优化连接池"></a>优化连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(poolSize);<br><br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// t1, t2, t3</span><br>    <span class="hljs-comment">// 获取许可</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire(); <span class="hljs-comment">// 没有许可的线程，在此等待</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>        <span class="hljs-comment">// 获取空闲连接</span><br>        <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                <span class="hljs-keyword">return</span> connections[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不会执行到这里</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 6. 归还连接</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>            states.set(i, <span class="hljs-number">0</span>);<br>            log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>            semaphore.release();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>原理：state记录数量，cas操作。减完小于零时进入队列 <code>doAcquireSharedInterruptibly</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>释放，检查唤醒后面的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>    doReleaseShared();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">         * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">         * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">         * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">         * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">         * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">         * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">         * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">         * fails, if so rechecking.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>用来进行线程同步协作，等待所有线程完成倒计时。<br>其中构造参数用来初始化等待计数值<code>new CountDownLatch(3)</code>，<code>await()</code> 用来等待计数归零，<code>countDown()</code> 用来让计数减一</p>
<p>原理可以看源码，非常短countDown：state–   await：state不等于零就加入队列</p>
<p>可以用来实现等待线程完成，为什么不用join？线程池！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;);<br>    service.submit(()-&gt;&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            latch.await();<br>            log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 应用：</p>
<ul>
<li>等待线程完成，如用户加载</li>
<li>等待远程调用完成</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>人满发车，可重复使用，state变成0后，会修改为init</p>
<p>await： state–  不为零就加入队列；为零就唤醒所有人，并重置state</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>); <br><br>t1: cb.await(); <span class="hljs-comment">// 当个数不足时，等</span><br>t2: cb.await(); <span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span><br><br><span class="hljs-comment">// 发车后执行的操作</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, ()-&gt;&#123;<br>    <span class="hljs-string">&quot;发车了&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>注意线程池数量要和CyclicBarrier一样，否则可能出现同时两次都是task1的await触发</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/" class="print-no-link">#并发</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法基础">
                        <span class="hidden-mobile">算法基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comment.bytewaver.top/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10,"reaction":true},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
